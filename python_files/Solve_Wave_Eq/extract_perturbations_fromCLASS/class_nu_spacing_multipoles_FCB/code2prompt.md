Project Path: class_nu_spacing_multipoles

Source Tree:

```txt
class_nu_spacing_multipoles
├── include
│   ├── arrays.h
│   ├── background.h
│   ├── class.h
│   ├── common.h
│   ├── dei_rkck.h
│   ├── distortions.h
│   ├── evolver_ndf15.h
│   ├── evolver_rkck.h
│   ├── fourier.h
│   ├── growTable.h
│   ├── harmonic.h
│   ├── hermite3_interpolation_csource.h
│   ├── hermite4_interpolation_csource.h
│   ├── hermite6_interpolation_csource.h
│   ├── hyperspherical.h
│   ├── input.h
│   ├── lensing.h
│   ├── macros_precision.h
│   ├── output.h
│   ├── parallel.h
│   ├── parser.h
│   ├── perturbations.h
│   ├── precisions.h
│   ├── primordial.h
│   ├── quadrature.h
│   ├── sparse.h
│   ├── svnversion.h
│   ├── thermodynamics.h
│   ├── transfer.h
│   └── trigonometric_integrals.h
└── source
    ├── background.c
    ├── distortions.c
    ├── fourier.c
    ├── harmonic.c
    ├── input.c
    ├── lensing.c
    ├── output.c
    ├── perturbations.c
    ├── primordial.c
    ├── thermodynamics.c
    └── transfer.c

```

`include/arrays.h`:

```h
/**
 * definitions for module thermodynamics.c
 */

#ifndef __ARRAYS__
#define __ARRAYS__

#include "common.h"

#define _SPLINE_NATURAL_ 0 /**< natural spline: ddy0=ddyn=0 */
#define _SPLINE_EST_DERIV_ 1 /**< spline with estimation of first derivative on both edges */
#define array_spline_eval(y,ddy,inf,sup,h,a,b) ((a)*(y)[inf]+(b)*(y)[sup] + (((a)*(a)*(a)-(a))* (ddy)[inf] + ((b)*(b)*(b)-(b))* (ddy)[sup])*(h)*(h)/6.)

/**
 * Boilerplate for C++
 */
#ifdef __cplusplus
extern "C" {
#endif

  int array_derive(
		   double * array,
		   int n_columns,
		   int n_lines,
		   int index_x,   /** from 0 to (n_columns-1) */
		   int index_y,
		   int index_dydx,
		   ErrorMsg errmsg);

  int array_derive_spline(
			  double * x_array,
			  int n_lines,
			  double * array,
			  double * array_splined,
			  int n_columns,
			  int index_y,
			  int index_dydx,
			  ErrorMsg errmsg);

  int array_derive_spline_table_line_to_line(
				       double * x_array,
				       int n_lines,
				       double * array,
				       int n_columns,
				       int index_y,
				       int index_ddy,
				       int index_dy,
				       ErrorMsg errmsg);

  int array_derive1_order2_table_line_to_line(
				       double * x_array,
				       int n_lines,
				       double * array,
				       int n_columns,
				       int index_y,
				       int index_dy,
				       ErrorMsg errmsg);

  int array_derive2_order2_table_line_to_line(
				       double * x_array,
				       int n_lines,
				       double * array,
				       int n_columns,
				       int index_y,
				       int index_dy,
				       int index_ddy,
				       ErrorMsg errmsg);

  int array_derive_two(
		   double * array,
		   int n_columns,
		   int n_lines,
		   int index_x,   /** from 0 to (n_columns-1) */
		   int index_y,
		   int index_dydx,
		   int index_ddydxdx,
		   ErrorMsg errmsg);



  int array_spline(
		   double * array,
		   int n_columns,
		   int n_lines,
		   int index_x,   /** from 0 to (n_columns-1) */
		   int index_y,
		   int index_ddydx2,
		   short spline_mode,
		   ErrorMsg errmsg);

  int array_spline_table_line_to_line(
				      double * x, /* vector of size x_size */
				      int x_size,
				      double * array,
				      int n_columns,
				      int index_y,
				      int index_ddydx2,
				      short spline_mode,
				      ErrorMsg errmsg);

  int array_spline_table_columns(
		       double * x,
		       int x_size,
		       double * y_array,
		       int y_size,
		       double * ddy_array,
		       short spline_mode,
		       ErrorMsg errmsg);

  int array_spline_table_columns2(
		       double * x,
		       int x_size,
		       double * y_array,
		       int y_size,
		       double * ddy_array,
		       short spline_mode,
		       ErrorMsg errmsg);

  int array_spline_table_lines(
		       double * x,
		       int x_size,
		       double * y_array,
		       int y_size,
		       double * ddy_array,
		       short spline_mode,
		       ErrorMsg errmsg
		       );

  int array_logspline_table_lines(
				  double * x,
				  int x_size,
				  double * y_array,
				  int y_size,
				  double * ddlny_array,
				  short spline_mode,
				  ErrorMsg errmsg
				  );

  int array_spline_table_one_column(
				    double * x, /* vector of size x_size */
				    int x_size,
				    double * y_array, /* array of size x_size*y_size with elements
							 y_array[index_y*x_size+index_x] */
				    int y_size,
				    int index_y,
				    double * ddy_array, /* array of size x_size*y_size */
				    short spline_mode,
				    ErrorMsg errmsg
				    );

  int array_logspline_table_one_column(
				    double * x, /* vector of size x_size */
				    int x_size,
				    int x_stop,
				    double * y_array, /* array of size x_size*y_size with elements
							 y_array[index_y*x_size+index_x] */
				    int y_size,
				    int index_y,
				    double * ddlogy_array, /* array of size x_size*y_size */
				    short spline_mode,
				    ErrorMsg errmsg
				    );

  int array_integrate_all_spline(
				 double * array,
				 int n_columns,
				 int n_lines,
				 int index_x,
				 int index_y,
				 int index_ddy,
				 double * result,
				 ErrorMsg errmsg
				 );

int array_integrate_all_spline_table_line_to_line(
                  double * x_array,
                  int n_lines,
                  double * array,
                  int n_columns,
                  int index_y,
                  int index_ddy,
                  double * result,
                  ErrorMsg errmsg);

int array_integrate_all_trapzd_or_spline(
		   double * array,
		   int n_columns,
		   int n_lines,
           int index_start_spline,
		   int index_x,   /** from 0 to (n_columns-1) */
		   int index_y,
		   int index_ddy,
		   double * result,
		   ErrorMsg errmsg);

  int array_integrate_spline_table_line_to_line(
						double * x_array,
						int n_lines,
						double * array,
						int n_columns,
						int index_y,
						int index_ddy,
						int index_inty,
						ErrorMsg errmsg);

  int array_integrate(
		      double * array,
		      int n_columns,
		      int n_lines,
		      int index_x,   /** from 0 to (n_columns-1) */
		      int index_y,
		      int index_int_y_dx,
		      ErrorMsg errmsg);

  int array_integrate_all(
		      double * array,
		      int n_columns,
		      int n_lines,
		      int index_x,   /** from 0 to (n_columns-1) */
		      int index_y,
		      double * result);

  int array_integrate_ratio(
			    double * array,
			    int n_columns,
			    int n_lines,
			    int index_x,   /** from 0 to (n_columns-1) */
			    int index_y1,
			    int index_y2,
			    int index_int_y1_over_y2_dx,
			    ErrorMsg errmsg);

  int array_interpolate(
			double * array,
			int n_columns,
			int n_lines,
			int index_x,   /** from 0 to (n_columns-1) */
			double x,
			int * last_index,
			double * result,
			int result_size,
			ErrorMsg errmsg); /** from 1 to n_columns */

  int array_interpolate_spline(
			       double * __restrict__ x_array,
			       int n_lines,
			       double * __restrict__ array,
			       double * __restrict__ array_splined,
			       int n_columns,
			       double x,
			       int * __restrict__ last_index,
			       double * __restrict__ result,
			       int result_size, /** from 1 to n_columns */
			       ErrorMsg errmsg);

  int array_search_bisect(
                       int n_lines,
                       double * __restrict__ array,
                       double c,
                       int * __restrict__ last_index,
                       ErrorMsg errmsg);

  int array_interpolate_linear(
			       double * x_array,
			       int n_lines,
			       double * array,
			       int n_columns,
			       double x,
			       int * last_index,
			       double * result,
			       int result_size, /** from 1 to n_columns */
			       ErrorMsg errmsg);

  int array_interpolate_spline_transposed(double * array,
                                          int x_size,
                                          int y_size,
                                          int index_x,
                                          int index_y,
                                          int index_ddy,
                                          double x,
                                          int * last_index,
                                          double * result,
                                          ErrorMsg errmsg);

  int array_interpolate_growing_closeby(
					double * array,
					int n_columns,
					int n_lines,
					int index_x,   /** from 0 to (n_columns-1) */
					double x,
					int * last_index,
					double * result,
					int result_size,
					ErrorMsg errmsg);

  int array_interpolate_one_growing_closeby(
                                            double * array,
                                            int n_columns,
                                            int n_lines,
                                            int index_x,   /** from 0 to (n_columns-1) */
                                            double x,
                                            int * last_index,
                                            int index_y,
                                            double * result,
                                            ErrorMsg errmsg);

  int array_interpolate_spline_growing_closeby(
					       double * x_array,
					       int n_lines,
					       double * array,
					       double * array_splined,
					       int n_columns,
					       double x,
					       int * last_index,
					       double * result,
					       int result_size, /** from 1 to n_columns */
					       ErrorMsg errmsg);

  int array_interpolate_spline_growing_hunt(
					       double * x_array,
					       int n_lines,
					       double * array,
					       double * array_splined,
					       int n_columns,
					       double x,
					       int * last_index,
					       double * result,
					       int result_size, /** from 1 to n_columns */
					       ErrorMsg errmsg);

  int array_spline_hunt(double* x_array,
                        int x_size,
                        double x,
                        int* last,
                        double* h,
                        double* a,
                        double* b,
                        ErrorMsg errmsg);

  int array_interpolate_two(
			    double * array_x,
			    int n_columns_x,
			    int index_x,   /** from 0 to (n_columns_x-1) */
			    double * array_y,
			    int n_columns_y,
			    int n_lines,  /** must be the same for array_x and array_y */
			    double x,
			    double * result,
			    int result_size, /** from 1 to n_columns_y */
			    ErrorMsg errmsg);

  int array_interpolate_two_bis(
				double * array_x,
				int n_columns_x,
				int index_x,   /** from 0 to (n_columns_x-1) */
				double * array_y,
				int n_columns_y,
				int n_lines,  /** must be the same for array_x and array_y */
				double x,
				double * result,
				int result_size, /** from 1 to n_columns_y */
				ErrorMsg errmsg);

  int array_interpolate_spline_one_column(
					  double * x_array,
					  int x_size,
					  double * y_array, /* array of size x_size*y_size with elements
							       y_array[index_y*x_size+index_x] */
					  int y_size,
					  int index_y,
					  double * ddy_array, /* array of size x_size*y_size */
					  double x,   /* input */
					  double * y, /* output */
					  ErrorMsg errmsg
					  );

  int array_interpolate_extrapolate_spline_one_column(
					  double * x_array,
					  int x_size,
					  double * y_array, /* array of size x_size*y_size with elements
							       y_array[index_y*x_size+index_x] */
					  int y_size,
					  int index_y,
					  double * ddy_array, /* array of size x_size*y_size */
					  double x,   /* input */
					  double * y, /* output */
					  ErrorMsg errmsg
					  );

  int array_interpolate_extrapolate_logspline_loglinear_one_column(
								   double * x_array,
								   int x_size,
								   int x_stop,
								   double * y_array, /* array of size x_size*y_size with elements
											y_array[index_y*x_size+index_x] */
								   int y_size,
								   int index_y,
								   double * ddlogy_array, /* array of size x_size*y_size */
								   double x,   /* input */
								   double * y, /* output */
								   ErrorMsg errmsg
								   );

  int array_interpolate_two_arrays_one_column(
					      double * array_x, /* assumed to be a vector (i.e. one column array) */
					      double * array_y,
					      int n_columns_y,
					      int index_y, /* between 0 and (n_columns_y-1) */
					      int n_lines,  /** must be the same for array_x and array_y */
					      double x,
					      double * result,
					      ErrorMsg errmsg);

  int array_interpolate_equal(
			    double * array,
			    int n_colums,
			    int n_lines,
			    double x,
			    double x_min,
			    double x_max,
			    double * result,
			    ErrorMsg errmsg);

  int array_interpolate_cubic_equal(
				    double x0,
				    double dx,
				    double *yarray,
				    int Nx,
				  double x,
				    double * result,
				    ErrorMsg errmsg);

  int array_interpolate_parabola(double x1,
				 double x2,
				 double x3,
				 double x,
				 double y1,
				 double y2,
				 double y3,
				 double * y,
				 double * dy,
				 double * ddy,
				 ErrorMsg errmsg);

  int array_smooth(double * array,
		   int n_columns,
		   int n_lines,
		   int index, /** from 0 to (n_columns-1) */
		   int radius,
		   ErrorMsg errmsg);

  int array_trapezoidal_weights(double * __restrict__ x,
                                int n,
                                double * __restrict__ w_trapz,
                                ErrorMsg errmsg);

  int array_trapezoidal_mweights(double * __restrict__ x,
                                int n,
                                double * __restrict__ w_trapz,
                                ErrorMsg errmsg);

  int array_trapezoidal_integral(double * __restrict__ integrand,
                                 int n,
                                 double * __restrict__ w_trapz,
                                 double * __restrict__ I,
                                 ErrorMsg errmsg);

  int array_trapezoidal_convolution(double * __restrict__ integrand1,
                                    double * __restrict__ integrand2,
                                    int n,
                                    double * __restrict__ w_trapz,
                                    double * __restrict__ I,
                                    ErrorMsg errmsg);

  int array_extrapolate_quadratic(double* x,
                                  double* y,
                                  double xnew,
                                  int x_size,
                                  double* ynew,
                                  double* dynew,
                                  ErrorMsg errmsg);

  int simpson_integration(
                          int nptz,
                          double* int_f,
                          double h,
                          double * F,
                          ErrorMsg errmsg);

  int array_hunt_descending(
                            double * array,
                            int size,
                            double value,
                            int * index,
                            ErrorMsg errmsg);

  int array_hunt_ascending(
                           double * array,
                           int size,
                           double value,
                           int * index,
                           ErrorMsg errmsg);

#ifdef __cplusplus
}
#endif

#endif

```

`include/background.h`:

```h
/** @file background.h Documented includes for background module */

#ifndef __BACKGROUND__
#define __BACKGROUND__

#include "common.h"
#include "quadrature.h"
#include "growTable.h"
#include "arrays.h"
#include "dei_rkck.h"
#include "parser.h"

/** list of possible parametrisations of the DE equation of state */

enum equation_of_state {CLP,EDE};


/** list of possible parametrizations of the varying fundamental constants */

enum varconst_dependence {varconst_none,varconst_instant};

/** list of formats for the vector of background quantities */

enum vecback_format {short_info, normal_info, long_info};

/** list of interpolation methods: search location in table either
    by bisection (inter_normal), or step by step starting from given
    index (inter_closeby) */

enum interpolation_method {inter_normal, inter_closeby};

/**
 * background structure containing all the background information that
 * other modules need to know.
 *
 * Once initialized by the backgound_init(), contains all necessary
 * information on the background evolution (except thermodynamics),
 * and in particular, a table of all background quantities as a
 * function of time and scale factor, used for interpolation in other
 * modules.
 */

struct background
{
  /** @name - input parameters initialized by user in input module
   *  (all other quantities are computed in this module, given these parameters
   *   and the content of the 'precision' structure)
   *
   * The background cosmological parameters listed here form a parameter
   * basis which is directly usable by the background module. Nothing
   * prevents from defining the input cosmological parameters
   * differently, and to pre-process them into this format, using the input
   * module (this might require iterative calls of background_init()
   * e.g. for dark energy or decaying dark matter). */

  //@{

  double H0; /**< \f$ H_0 \f$: Hubble parameter (in fact, [\f$H_0/c\f$]) in \f$ Mpc^{-1} \f$ */
  double h;  /**< reduced Hubble parameter */

  double Omega0_g; /**< \f$ \Omega_{0 \gamma} \f$: photons */
  double T_cmb;    /**< \f$ T_{cmb} \f$: current CMB temperature in Kelvins */

  double Omega0_b; /**< \f$ \Omega_{0 b} \f$: baryons */

  double Omega0_ur; /**< \f$ \Omega_{0 \nu r} \f$: ultra-relativistic neutrinos */

  double Omega0_cdm;      /**< \f$ \Omega_{0 cdm} \f$: cold dark matter */

  double Omega0_idm; /**< \f$ \Omega_{0 idm} \f$: interacting dark matter with photons, baryons, and idr */


  double Omega0_idr; /**< \f$ \Omega_{0 idr} \f$: interacting dark radiation */
  double T_idr;      /**< \f$ T_{idr} \f$: current temperature of interacting dark radiation in Kelvins */

  double Omega0_dcdmdr;   /**< \f$ \Omega_{0 dcdm}+\Omega_{0 dr} \f$: decaying cold dark matter (dcdm) decaying to dark radiation (dr) */
  double Omega_ini_dcdm;  /**< \f$ \Omega_{ini,dcdm} \f$: rescaled initial value for dcdm density (see 1407.2418 for definitions) */
  double Gamma_dcdm;      /**< \f$ \Gamma_{dcdm} \f$: decay constant for decaying cold dark matter */
  double tau_dcdm;

  int N_ncdm;                            /**< Number of distinguishable ncdm species */
  /* the following parameters help to define tabulated ncdm p-s-d passed in file */
  char * ncdm_psd_files;                 /**< list of filenames for tabulated p-s-d */
  int * got_files;                       /**< list of flags for each species, set to true if p-s-d is passed through file */
  /* the following parameters help to define the analytical ncdm phase space distributions (p-s-d) */
  double * ncdm_psd_parameters;          /**< list of parameters for specifying/modifying ncdm p.s.d.'s, to be customized for given model
                                            (could be e.g. mixing angles) */
  double * M_ncdm;                       /**< vector of masses of non-cold relic: dimensionless ratios m_ncdm/T_ncdm */
  double * m_ncdm_in_eV;                 /**< list of ncdm masses in eV (inferred from M_ncdm and other parameters above) */
  double * Omega0_ncdm, Omega0_ncdm_tot; /**< Omega0_ncdm for each species and for the total Omega0_ncdm */
  double * T_ncdm,T_ncdm_default;        /**< list of 1st parameters in p-s-d of non-cold relics: relative temperature
                                            T_ncdm1/T_gamma; and its default value */
  double * ksi_ncdm, ksi_ncdm_default;   /**< list of 2nd parameters in p-s-d of non-cold relics: relative chemical potential
                                            ksi_ncdm1/T_ncdm1; and its default value */
  double * deg_ncdm, deg_ncdm_default;    /**< vector of degeneracy parameters in factor of p-s-d: 1 for one family of neutrinos
                                             (= one neutrino plus its anti-neutrino, total g*=1+1=2, so deg = 0.5 g*); and its
                                             default value */
  int * ncdm_input_q_size; /**< Vector of numbers of q bins */
  double * ncdm_qmax;      /**< Vector of maximum value of q */

  double Omega0_k;         /**< \f$ \Omega_{0_k} \f$: curvature contribution */
  int nu_spacing;          /* the spacing of integer $\nu$ in closed universe. */

  double Omega0_lambda;    /**< \f$ \Omega_{0_\Lambda} \f$: cosmological constant */
  double Omega0_fld;       /**< \f$ \Omega_{0 de} \f$: fluid */
  double Omega0_scf;       /**< \f$ \Omega_{0 scf} \f$: scalar field */
  short use_ppf; /**< flag switching on PPF perturbation equations instead of true fluid equations for perturbations. It could have been defined inside
                    perturbation structure, but we leave it here in such way to have all fld parameters grouped. */
  double c_gamma_over_c_fld; /**< ppf parameter defined in eq. (16) of 0808.3125 [astro-ph] */
  enum equation_of_state fluid_equation_of_state; /**< parametrisation scheme for fluid equation of state */
  double w0_fld;   /**< \f$ w0_{DE} \f$: current fluid equation of state parameter */
  double wa_fld;   /**< \f$ wa_{DE} \f$: fluid equation of state parameter derivative */
  double cs2_fld;  /**< \f$ c^2_{s~DE} \f$: sound speed of the fluid in the frame comoving with the fluid (so, this is
                      not [delta p/delta rho] in the synchronous or newtonian gauge!) */
  double Omega_EDE;        /**< \f$ wa_{DE} \f$: Early Dark Energy density parameter */
  double * scf_parameters; /**< list of parameters describing the scalar field potential */
  short attractor_ic_scf;  /**< whether the scalar field has attractor initial conditions */
  int scf_tuning_index;    /**< index in scf_parameters used for tuning */
  double phi_ini_scf;      /**< \f$ \phi(t_0) \f$: scalar field initial value */
  double phi_prime_ini_scf;/**< \f$ d\phi(t_0)/d\tau \f$: scalar field initial derivative wrt conformal time */
  int scf_parameters_size; /**< size of scf_parameters */
  double varconst_alpha; /**< finestructure constant for varying fundamental constants */
  double varconst_me; /**< electron mass for varying fundamental constants */
  enum varconst_dependence varconst_dep; /**< dependence of the varying fundamental constants as a function of time */
  double varconst_transition_redshift; /**< redshift of transition between varied fundamental constants and normal fundamental constants in the 'varconst_instant' case*/

  //@}


  /** @name - related parameters */

  //@{

  double age; /**< age in Gyears */
  double conformal_age; /**< conformal age in Mpc */
  double K; /**< \f$ K \f$: Curvature parameter \f$ K=-\Omega0_k*a_{today}^2*H_0^2\f$; */
  int sgnK; /**< K/|K|: -1, 0 or 1 */
  double Neff; /**< so-called "effective neutrino number", computed at earliest time in interpolation table */
  double Omega0_dcdm; /**< \f$ \Omega_{0 dcdm} \f$: decaying cold dark matter */
  double Omega0_dr; /**< \f$ \Omega_{0 dr} \f$: decay radiation */
  double Omega0_m;  /**< total non-relativistic matter today */
  double Omega0_r;  /**< total ultra-relativistic radiation today */
  double Omega0_de; /**< total dark energy density today, currently defined as 1 - Omega0_m - Omega0_r - Omega0_k */
  double Omega0_nfsm; /**< total non-free-streaming matter, that is, cdm, baryons and wdm */
  double a_eq;      /**< scale factor at radiation/matter equality */
  double H_eq;      /**< Hubble rate at radiation/matter equality [Mpc^-1] */
  double z_eq;      /**< redshift at radiation/matter equality */
  double tau_eq;    /**< conformal time at radiation/matter equality [Mpc] */

  //@}


  /** @name - all indices for the vector of background (=bg) quantities stored in table */

  //@{

  int index_bg_a;             /**< scale factor (in fact (a/a_0), see
                                 normalisation conventions explained
                                 at beginning of background.c) */
  int index_bg_H;             /**< Hubble parameter in \f$Mpc^{-1}\f$ */
  int index_bg_H_prime;       /**< its derivative w.r.t. conformal time */

  /* end of vector in short format, now quantities in normal format */

  int index_bg_rho_g;         /**< photon density */
  int index_bg_rho_b;         /**< baryon density */
  int index_bg_rho_cdm;       /**< cdm density */
  int index_bg_rho_idm;       /**< idm density */
  int index_bg_rho_lambda;    /**< cosmological constant density */
  int index_bg_rho_fld;       /**< fluid density */
  int index_bg_w_fld;         /**< fluid equation of state */
  int index_bg_rho_idr;       /**< density of interacting dark radiation */
  int index_bg_rho_ur;        /**< relativistic neutrinos/relics density */
  int index_bg_rho_dcdm;      /**< dcdm density */
  int index_bg_rho_dr;        /**< dr density */

  int index_bg_phi_scf;       /**< scalar field value */
  int index_bg_phi_prime_scf; /**< scalar field derivative wrt conformal time */
  int index_bg_V_scf;         /**< scalar field potential V */
  int index_bg_dV_scf;        /**< scalar field potential derivative V' */
  int index_bg_ddV_scf;       /**< scalar field potential second derivative V'' */
  int index_bg_rho_scf;       /**< scalar field energy density */
  int index_bg_p_scf;         /**< scalar field pressure */
  int index_bg_p_prime_scf;         /**< scalar field pressure */

  int index_bg_rho_ncdm1;     /**< density of first ncdm species (others contiguous) */
  int index_bg_p_ncdm1;       /**< pressure of first ncdm species (others contiguous) */
  int index_bg_pseudo_p_ncdm1;/**< another statistical momentum useful in ncdma approximation */

  int index_bg_rho_tot;       /**< Total density */
  int index_bg_p_tot;         /**< Total pressure */
  int index_bg_p_tot_prime;   /**< Conf. time derivative of total pressure */

  int index_bg_Omega_r;       /**< relativistic density fraction (\f$ \Omega_{\gamma} + \Omega_{\nu r} \f$) */

  /* end of vector in normal format, now quantities in long format */

  int index_bg_rho_crit;      /**< critical density */
  int index_bg_Omega_m;       /**< non-relativistic density fraction (\f$ \Omega_b + \Omega_cdm + \Omega_{\nu nr} \f$) */
  int index_bg_conf_distance; /**< conformal distance (from us) in Mpc */
  int index_bg_ang_distance;  /**< angular diameter distance in Mpc */
  int index_bg_lum_distance;  /**< luminosity distance in Mpc */
  int index_bg_time;          /**< proper (cosmological) time in Mpc */
  int index_bg_rs;            /**< comoving sound horizon in Mpc */

  int index_bg_D;             /**< scale independent growth factor D(a) for CDM perturbations */
  int index_bg_f;             /**< corresponding velocity growth factor [dlnD]/[dln a] */

  int index_bg_varc_alpha;    /**< value of fine structure constant in varying fundamental constants */
  int index_bg_varc_me;      /**< value of effective electron mass in varying fundamental constants */

  int bg_size_short;  /**< size of background vector in the "short format" */
  int bg_size_normal; /**< size of background vector in the "normal format" */
  int bg_size;        /**< size of background vector in the "long format" */

  //@}


  /** @name - background interpolation tables */

  //@{

  int bt_size;               /**< number of lines (i.e. time-steps) in the four following array */
  double * loga_table;       /**< vector loga_table[index_loga] with values of log(a) (in fact \f$ log(a/a0) \f$, logarithm of relative scale factor compared to today) */
  double * tau_table;        /**< vector tau_table[index_loga] with values of conformal time \f$ \tau \f$ (in fact \f$ a_0 c tau \f$, see normalisation conventions explained at beginning of background.c) */
  double * z_table;          /**< vector z_table[index_loga] with values of \f$ z \f$ (redshift) */
  double * background_table; /**< table background_table[index_tau*pba->bg_size+pba->index_bg] with all other quantities (array of size bg_size*bt_size) **/

  //@}


  /** @name - table of their second derivatives, used for spline interpolation */

  //@{

  double * d2tau_dz2_table; /**< vector d2tau_dz2_table[index_loga] with values of \f$ d^2 \tau / dz^2 \f$ (conformal time) */
  double * d2z_dtau2_table; /**< vector d2z_dtau2_table[index_loga] with values of \f$ d^2 z / d\tau^2 \f$ (conformal time) */
  double * d2background_dloga2_table; /**< table d2background_dtau2_table[index_loga*pba->bg_size+pba->index_bg] with values of \f$ d^2 b_i / d\log(a)^2 \f$ */

  //@}


  /** @name - all indices for the vector of background quantities to be integrated (=bi)
   *
   * Most background quantities can be immediately inferred from the
   * scale factor. Only few of them require an integration with
   * respect to conformal time (in the minimal case, only one quantity needs to
   * be integrated with time: the scale factor, using the Friedmann
   * equation). These indices refer to the vector of
   * quantities to be integrated with time.
   * {B} quantities are needed by background_functions() while {C} quantities are not.
   */

  //@{

  int index_bi_rho_dcdm;/**< {B} dcdm density */
  int index_bi_rho_dr;  /**< {B} dr density */
  int index_bi_rho_fld; /**< {B} fluid density */
  int index_bi_phi_scf;       /**< {B} scalar field value */
  int index_bi_phi_prime_scf; /**< {B} scalar field derivative wrt conformal time */

  int index_bi_time;    /**< {C} proper (cosmological) time in Mpc */
  int index_bi_rs;      /**< {C} sound horizon */
  int index_bi_tau;     /**< {C} conformal time in Mpc */
  int index_bi_D;       /**< {C} scale independent growth factor D(a) for CDM perturbations. */
  int index_bi_D_prime; /**< {C} D satisfies \f$ [D''(\tau)=-aHD'(\tau)+3/2 a^2 \rho_M D(\tau) \f$ */

  int bi_B_size;        /**< Number of {B} parameters */
  int bi_size;          /**< Number of {B}+{C} parameters */

  //@}

  /** @name - flags describing the absence or presence of cosmological
      ingredients
      *
      * having one of these flag set to zero allows to skip the
      * corresponding contributions, instead of adding null contributions.
      */


  //@{

  short has_cdm;       /**< presence of cold dark matter? */
  short has_idm;       /**< presence of interacting dark matter with photons, baryons, and idr */
  short has_dcdm;      /**< presence of decaying cold dark matter? */
  short has_dr;        /**< presence of relativistic decay radiation? */
  short has_scf;       /**< presence of a scalar field? */
  short has_ncdm;      /**< presence of non-cold dark matter? */
  short has_lambda;    /**< presence of cosmological constant? */
  short has_fld;       /**< presence of fluid with constant w and cs2? */
  short has_ur;        /**< presence of ultra-relativistic neutrinos/relics? */
  short has_idr;       /**< presence of interacting dark radiation? */
  short has_curvature; /**< presence of global spatial curvature? */
  short has_varconst;  /**< presence of varying fundamental constants? */

  //@}


  /**
   *@name - arrays related to sampling and integration of ncdm phase space distributions
   */

  //@{

  int * ncdm_quadrature_strategy; /**< Vector of integers according to quadrature strategy. */
  double ** q_ncdm_bg;  /**< Pointers to vectors of background sampling in q */
  double ** w_ncdm_bg;  /**< Pointers to vectors of corresponding quadrature weights w */
  double ** q_ncdm;     /**< Pointers to vectors of perturbation sampling in q */
  double ** w_ncdm;     /**< Pointers to vectors of corresponding quadrature weights w */
  double ** dlnf0_dlnq_ncdm; /**< Pointers to vectors of logarithmic derivatives of p-s-d */
  int * q_size_ncdm_bg; /**< Size of the q_ncdm_bg arrays */
  int * q_size_ncdm;    /**< Size of the q_ncdm arrays */
  double * factor_ncdm; /**< List of normalization factors for calculating energy density etc.*/

  //@}

  /** @name - technical parameters */

  //@{

  short shooting_failed;  /**< flag is set to true if shooting failed. */
  ErrorMsg shooting_error; /**< Error message from shooting failed. */

  short background_verbose; /**< flag regulating the amount of information sent to standard output (none if set to zero) */

  ErrorMsg error_message; /**< zone for writing error messages */

  short is_allocated; /**< flag is set to true if allocated */
  //@}
};


/**
 * temporary parameters and workspace passed to the background_derivs function
 */

struct background_parameters_and_workspace {

  /* structures containing fixed input parameters (indices, ...) */
  struct background * pba;

  /* workspace */
  double * pvecback;

};

/**
 * temporary parameters and workspace passed to phase space distribution function
 */

struct background_parameters_for_distributions {

  /* structures containing fixed input parameters (indices, ...) */
  struct background * pba;

  /* Additional parameters */

  /* Index of current distribution function */
  int n_ncdm;

  /* Used for interpolating in file of tabulated p-s-d: */
  int tablesize;
  double *q;
  double *f0;
  double *d2f0;
  int last_index;

};

/**************************************************************/
/* @cond INCLUDE_WITH_DOXYGEN */
/*
 * Boilerplate for C++
 */
#ifdef __cplusplus
extern "C" {
#endif

  int background_at_z(
                      struct background *pba,
                      double a_rel,
                      enum vecback_format return_format,
                      enum interpolation_method inter_mode,
                      int * last_index,
                      double * pvecback
                      );

  int background_at_tau(
                        struct background *pba,
                        double tau,
                        enum vecback_format return_format,
                        enum interpolation_method inter_mode,
                        int * last_index,
                        double * pvecback
                        );

  int background_tau_of_z(
                          struct background *pba,
                          double z,
                          double * tau
                          );

  int background_z_of_tau(
                          struct background *pba,
                          double tau,
                          double * z
                          );

  int background_functions(
                           struct background *pba,
                           double a_rel,
                           double * pvecback_B,
                           enum vecback_format return_format,
                           double * pvecback
                           );

  int background_w_fld(
                       struct background * pba,
                       double a,
                       double * w_fld,
                       double * dw_over_da_fld,
                       double * integral_fld);

  int background_varconst_of_z(
                               struct background* pba,
                               double z,
                               double* alpha,
                               double* me
                               );

  int background_init(
                      struct precision *ppr,
                      struct background *pba
                      );

  int background_free(
                      struct background *pba
                      );

  int background_free_noinput(
                              struct background *pba
                              );

  int background_free_input(
                            struct background *pba
                            );

  int background_indices(
                         struct background *pba
                         );

  int background_ncdm_distribution(
                                   void *pba,
                                   double q,
                                   double * f0
                                   );

  int background_ncdm_test_function(
                                    void *pba,
                                    double q,
                                    double * test
                                    );

  int background_ncdm_init(
                           struct precision *ppr,
                           struct background *pba
                           );

  int background_ncdm_momenta(
                              double * qvec,
                              double * wvec,
                              int qsize,
                              double M,
                              double factor,
                              double z,
                              double * n,
                              double * rho,
                              double * p,
                              double * drho_dM,
                              double * pseudo_p
                              );

  int background_ncdm_M_from_Omega(
                                   struct precision *ppr,
                                   struct background *pba,
                                   int species
                                   );

  int background_checks(
                        struct precision * ppr,
                        struct background *pba
                        );

  int background_solve(
                       struct precision *ppr,
                       struct background *pba
                       );

  int background_initial_conditions(
                                    struct precision *ppr,
                                    struct background *pba,
                                    double * pvecback,
                                    double * pvecback_integration,
                                    double * loga_ini
                                    );

  int background_find_equality(
                               struct precision *ppr,
                               struct background *pba
                               );


  int background_output_titles(struct background * pba,
                               char titles[_MAXTITLESTRINGLENGTH_]
                               );

  int background_output_data(
                             struct background *pba,
                             int number_of_titles,
                             double *data);

  int background_derivs(
                        double loga,
                        double * y,
                        double * dy,
                        void * parameters_and_workspace,
                        ErrorMsg error_message
                        );

  int background_sources(
                         double loga,
                         double * y,
                         double * dy,
                         int index_loga,
                         void * parameters_and_workspace,
                         ErrorMsg error_message
                         );

  int background_timescale(
                           double loga,
                           void * parameters_and_workspace,
                           double * timescale,
                           ErrorMsg error_message
                           );

  int background_output_budget(
                               struct background* pba
                               );

  /** Scalar field potential and its derivatives **/
  double V_scf(
               struct background *pba,
               double phi
               );

  double dV_scf(
                struct background *pba,
                double phi
                );

  double ddV_scf(
                 struct background *pba,
                 double phi
                 );

  /** Coupling between scalar field and matter **/
  double Q_scf(
               struct background *pba,
               double phi,
               double phi_prime
               );

#ifdef __cplusplus
}
#endif

/**************************************************************/

/**
 * @name Some conversion factors and fundamental constants needed by background module:
 */

//@{

#define _Mpc_over_m_ 3.085677581282e22  /**< conversion factor from meters to megaparsecs */
/* remark: CAMB uses 3.085678e22: good to know if you want to compare  with high accuracy */

#define _Gyr_over_Mpc_ 3.06601394e2 /**< conversion factor from megaparsecs to gigayears
                                       (c=1 units, Julian years of 365.25 days) */
#define _c_ 2.99792458e8            /**< c in m/s */
#define _G_ 6.67428e-11             /**< Newton constant in m^3/Kg/s^2 */
#define _eV_ 1.602176487e-19        /**< 1 eV expressed in J */

/* parameters entering in Stefan-Boltzmann constant sigma_B */
#define _k_B_ 1.3806504e-23
#define _h_P_ 6.62606896e-34
/* remark: sigma_B = 2 pi^5 k_B^4 / (15h^3c^2) = 5.670400e-8
   = Stefan-Boltzmann constant in W/m^2/K^4 = Kg/K^4/s^3 */

//@}

/**
 * @name Some limits on possible background parameters
 */

//@{

#define _h_BIG_ 1.5            /**< maximal \f$ h \f$ */
#define _h_SMALL_ 0.3         /**< minimal \f$ h \f$ */
#define _omegab_BIG_ 0.039    /**< maximal \f$ omega_b \f$ */
#define _omegab_SMALL_ 0.005  /**< minimal \f$ omega_b \f$ */

//@}

/**
 * @name Some limits imposed in other parts of the module:
 */

//@{

#define _SCALE_BACK_ 0.1  /**< logarithmic step used when searching
                             for an initial scale factor at which ncdm
                             are still relativistic */

#define _PSD_DERIVATIVE_EXP_MIN_ -30 /**< for ncdm, for accurate computation of dlnf0/dlnq, q step is varied in range specified by these parameters */
#define _PSD_DERIVATIVE_EXP_MAX_ 2  /**< for ncdm, for accurate computation of dlnf0/dlnq, q step is varied in range specified by these parameters */

#define _zeta3_ 1.2020569031595942853997381615114499907649862923404988817922 /**< for quandrature test function */
#define _zeta5_ 1.0369277551433699263313654864570341680570809195019128119741 /**< for quandrature test function */

//@}


#endif
/* @endcond */

```

`include/class.h`:

```h
#ifndef __CLASS__
#define __CLASS__

/* standard libraries */
#include "stdio.h"
#include "stdlib.h"
#include "math.h"
#include "string.h"
#include "float.h"
#ifdef _OPENMP
#include "omp.h"
#endif

/* tools for class */
#include "quadrature.h"
#include "growTable.h"
#include "arrays.h"
#include "dei_rkck.h"
#include "parser.h"

/* class modules */
#include "common.h"
#include "input.h"
#include "background.h"
#include "thermodynamics.h"
#include "perturbations.h"
#include "primordial.h"
#include "fourier.h"
#include "transfer.h"
#include "harmonic.h"
#include "distortions.h"
#include "lensing.h"
#include "output.h"

#endif

```

`include/common.h`:

```h
/** @file common.h Generic libraries, parameters and functions used in the whole code. */

#include "stdio.h"
#include "stdlib.h"
#include "math.h"
#include "string.h"
#include "float.h"
#include "svnversion.h"
#include <stdarg.h>

#ifdef _OPENMP
#include "omp.h"
#endif

#ifndef __COMMON__
#define __COMMON__

#define _VERSION_ "v3.2.5"

/* @cond INCLUDE_WITH_DOXYGEN */

#define _TRUE_ 1 /**< integer associated to true statement */
#define _FALSE_ 0 /**< integer associated to false statement */

#define _SUCCESS_ 0 /**< integer returned after successful call of a function */
#define _FAILURE_ 1 /**< integer returned after failure in a function */

#define _ERRORMSGSIZE_ 2048 /**< generic error messages are cut beyond this number of characters */
typedef char ErrorMsg[_ERRORMSGSIZE_]; /**< Generic error messages (there is such a field in each structure) */

#define _FILENAMESIZE_ 256 /**< size of the string read in each line of the file (extra characters not taken into account) */
typedef char FileName[_FILENAMESIZE_];

#define _SUFFIXNAMESIZE_ 4 /**< maximum size of the short string appended to file names to account for initial conditions, etc. */

#define _PI_ 3.1415926535897932384626433832795e0 /**< The number pi */

#define _PIHALF_ 1.57079632679489661923132169164e0 /**< pi divided by 2 */

#define _TWOPI_ 6.283185307179586476925286766559e0 /**< 2 times pi */

#define _SQRT2_ 1.41421356237309504880168872421e0 /** < square root of 2. */

#define _SQRT6_ 2.4494897427831780981972840747059e0 /**< square root of 6. */

#define _SQRT_PI_ 1.77245385090551602729816748334e0 /**< square root of pi. */

#define _E_ 2.718281828459045235360287471352662497757247093699959574966967627724076630353547594571382178525166427427466391932003059921817413596629043572900334295260595630738132328627943490763233829880753195251019011573834187930702154089149934884167509244761460668082264800168477411853742345442437107539077744992069551702761838606261331384583000752044933826560297606737113200709328709127443747047230696977209310141692836819025515108657463772111252389784425056953696 /**< exponential of one */

#define _MAX_IT_ 10000/**< default maximum number of iterations in conditional loops (to avoid infinite loops) */

#define _QUADRATURE_MAX_ 250 /**< maximum allowed number of abssices in quadrature integral estimation */

#define _QUADRATURE_MAX_BG_ 800 /**< maximum allowed number of abssices in quadrature integral estimation */

#define _TOLVAR_ 100. /**< The minimum allowed variation is the machine precision times this number */

#define _HUGE_ 1.e99

#define _EPSILON_ 1.e-10

#define _OUTPUTPRECISION_ 12 /**< Number of significant digits in some output files */

#define _COLUMNWIDTH_ 24 /**< Must be at least _OUTPUTPRECISION_+8 for guaranteed fixed width columns */

#define _MAXTITLESTRINGLENGTH_ 8000 /**< Maximum number of characters in title strings */

#define _DELIMITER_ "\t" /**< character used for delimiting titles in the title strings */

#ifndef __CLASSDIR__
#define __CLASSDIR__ "." /**< The directory of CLASS. This is set to the absolute path to the CLASS directory so this is just a failsafe. */
#endif

#define MIN(a,b) (((a)<(b)) ? (a) : (b) ) /**< the usual "min" function */
#define MAX(a,b) (((a)<(b)) ? (b) : (a) ) /**< the usual "max" function */
#define SIGN(a) (((a)>0) ? 1. : -1. )
#define NRSIGN(a,b) ((b) >= 0.0 ? fabs(a) : -fabs(a))
#define index_symmetric_matrix(i1,i2,N) (((i1)<=(i2)) ? ((i2)+N*(i1)-((i1)*((i1)+1))/2) : ((i1)+N*(i2)-((i2)*((i2)+1))/2)) /**< assigns an index from 0 to [N(N+1)/2-1] to the coefficients M_{i1,i2} of an N*N symmetric matrix; useful for converting a symmetric matrix to a vector, without losing or double-counting any information */

/* @endcond */


#ifdef __cplusplus
extern "C" {
#endif
    /* needed because of weird openmp bug on macosx lion... */
    void class_protect_sprintf(char* dest, char* tpl, ...);
    void class_protect_fprintf(FILE* dest, char* tpl, ...);
    void* class_protect_memcpy(void* dest, void* from, size_t sz);

    /* some general functions */
    int get_number_of_titles(char * titlestring);
    int file_exists(const char *fname);
    int compare_doubles(const void * a,
                        const void * b);
    int string_begins_with(char* thestring, char beginchar);
#ifdef __cplusplus
}
#endif

/* general CLASS macros */

//This macro receives additional 'do {' and '} while(0)' to safeguard
//in single-line if else clauses without '{' and '}'
//Also, careful: Since sprintf(NULL,0,x) returns the size of characters
//that are inside of the string x, then the buffer needs to be
//actually one character longer to hold also the null character '\0'
#define class_sprintf(string, format...) do {                                                                       \
  int _buffer_size_sprintf = snprintf(NULL, 0, format);                                                          \
  snprintf(string, _buffer_size_sprintf+1, format);                                                                \
} while (0)

#define class_build_error_string(dest,tmpl,...) {                                                                \
  ErrorMsg FMsg;                                                                                                 \
  class_protect_sprintf(FMsg,tmpl,__VA_ARGS__);                                                                  \
  class_protect_sprintf(dest,"%s(L:%d) :%s",__func__,__LINE__,FMsg);                                             \
}

// Error reporting macros

// Call
#define class_call_message(err_out,extra,err_mess)   \
  class_build_error_string(err_out,"error in %s;\n=>%s",extra,err_mess);

/* macro for calling function and returning error if it failed */
#define class_call_except(function, error_message_from_function, error_message_output,list_of_commands) {        \
  if (function == _FAILURE_) {                                                                                   \
    class_call_message(error_message_output,#function,error_message_from_function);                              \
    list_of_commands;                                                                                            \
    return _FAILURE_;                                                                                            \
  }                                                                                                              \
}

/* macro for trying to call function */
#define class_call_try(function, error_message_from_function, error_message_output,list_of_commands) { \
  if (function == _FAILURE_) {                                                                                   \
    class_call_message(error_message_output,#function,error_message_from_function);                              \
    list_of_commands;                                                                                            \
  }                                                                                                              \
}

/* macro for calling function and returning error if it failed */
#define class_call(function, error_message_from_function, error_message_output)                                  \
  class_call_except(function, error_message_from_function,error_message_output,)

/* same in parallel region  -- UNUSED NOW */
/*#define class_call_parallel(function, error_message_from_function, error_message_output) {                       \
  if (abort_now == _FALSE_) {                                                                                        \
    if (function == _FAILURE_) {                                                                                 \
      class_call_message(error_message_output,#function,error_message_from_function);                            \
      abort_now=_TRUE_;                                                                                              \
    }                                                                                                            \
  }                                                                                                              \
}*/




// Alloc
#define class_alloc_message(err_out,extra,sz)                                                                    \
  class_build_error_string(err_out,"could not allocate %s with size %d",extra,sz);

/* macro for allocating memory and returning error if it failed */
#define class_alloc(pointer, size, error_message_output)  {                                                      \
  pointer=(__typeof__(pointer))malloc(size);                                                                                          \
  if (pointer == NULL) {                                                                                         \
    int size_int;                                                                                                \
    size_int = size;                                                                                             \
    class_alloc_message(error_message_output,#pointer, size_int);                                                \
    return _FAILURE_;                                                                                            \
  }                                                                                                              \
}


/* same inside parallel structure -- UNUSED NOW
#define class_alloc_parallel(pointer, size, error_message_output)  {                                             \
  pointer=NULL;                                                                                                  \
  if (abort_now == _FALSE_) {                                                                                        \
    pointer=(__typeof__(pointer))malloc(size);                                                                                        \
    if (pointer == NULL) {                                                                                       \
      int size_int;                                                                                              \
      size_int = size;                                                                                           \
      class_alloc_message(error_message_output,#pointer, size_int);                                              \
      abort_now=_TRUE_;                                                                                              \
    }                                                                                                            \
  }                                                                                                              \
}*/

/* macro for allocating memory, initializing it with zeros/ and returning error if it failed */
#define class_calloc(pointer, init,size, error_message_output)  {                                                \
  pointer=(__typeof__(pointer))calloc(init,size);                                                                                     \
  if (pointer == NULL) {                                                                                         \
    int size_int;                                                                                                \
    size_int = size;                                                                                             \
    class_alloc_message(error_message_output,#pointer, size_int);                                                \
    return _FAILURE_;                                                                                            \
  }                                                                                                              \
}

/* macro for re-allocating memory, returning error if it failed */
#define class_realloc(pointer, size, error_message_output)  {                                          \
    pointer=(__typeof__(pointer))realloc(pointer,size);                                                                               \
  if (pointer == NULL) {                                                                                         \
    int size_int;                                                                                                \
    size_int = size;                                                                                             \
    class_alloc_message(error_message_output,#pointer, size_int);                                                \
    return _FAILURE_;                                                                                            \
  }                                                                                                              \
}

// Testing

#define class_test_message(err_out,extra,args...) {                                                              \
  ErrorMsg Optional_arguments;                                                                                   \
  class_protect_sprintf(Optional_arguments,args);                                                                \
  class_build_error_string(err_out,"condition (%s) is true; %s",extra,Optional_arguments);                       \
}

/* macro for testing condition and returning error if condition is true;
   args is a variable list of optional arguments, e.g.: args="x=%d",x
   args cannot be empty, if there is nothing to pass use args="" */
#define class_test_except(condition, error_message_output,list_of_commands, args...) {                           \
  if (condition) {                                                                                               \
    class_test_message(error_message_output,#condition, args);                                                   \
    list_of_commands;                                                                                            \
    return _FAILURE_;                                                                                            \
  }                                                                                                              \
}

#define class_test(condition, error_message_output, args...) {                                                   \
  if (condition) {                                                                                               \
    class_test_message(error_message_output,#condition, args);                                                   \
    return _FAILURE_;                                                                                            \
  }                                                                                                              \
}

/* UNUSED NOW
#define class_test_parallel(condition, error_message_output, args...) {                                          \
  if (abort_now == _FALSE_) {                                                                                        \
    if (condition) {                                                                                             \
      class_test_message(error_message_output,#condition, args);                                                 \
      abort_now=_TRUE_;                                                                                              \
    }                                                                                                            \
  }                                                                     \
}*/

/* macro for returning error message;
   args is a variable list of optional arguments, e.g.: args="x=%d",x
   args cannot be empty, if there is nothing to pass use args="" */
#define class_stop(error_message_output,args...) {                                                               \
  ErrorMsg Optional_arguments;                                                                                   \
  class_protect_sprintf(Optional_arguments,args);                                                                \
  class_build_error_string(error_message_output,"error; %s",Optional_arguments);                                 \
  return _FAILURE_;                                                                                              \
}

// IO
/* macro for opening file and returning error if it failed */
#define class_open(pointer, filename,	mode, error_output) {                                                      \
  pointer=fopen(filename,mode);                                                                                  \
  if (pointer == NULL) {                                                                                         \
    class_build_error_string(error_output,"could not open %s with name %s and mode %s",#pointer,filename,#mode); \
    return _FAILURE_;                                                                                            \
  }                                                                                                              \
}

/* macro for defining indices (usually one, sometimes a block) */
#define class_define_index(index,                                       \
                           condition,                                   \
                           running_index,                               \
                           number_of_indices) {                         \
    if (condition) {                                                    \
      index = running_index;                                            \
      running_index += number_of_indices;                               \
    }                                                                   \
  }

/* macros for writing formatted output */
#define class_fprintf_double(file,                                      \
                             output,                                    \
                             condition){                                \
    if (condition == _TRUE_)                                            \
      fprintf(file,"%*.*e ",_COLUMNWIDTH_,_OUTPUTPRECISION_,output);    \
  }

#define class_fprintf_double_or_default(file,                           \
                                        output,                         \
                                        condition,                      \
                                        defaultvalue){                  \
    if (condition == _TRUE_)                                            \
      fprintf(file,"%*.*e ",_COLUMNWIDTH_,_OUTPUTPRECISION_,output);    \
    else                                                                \
      fprintf(file,"%*.*e ",_COLUMNWIDTH_,_OUTPUTPRECISION_,defaultvalue);    \
}

#define class_fprintf_int(file,                                         \
                          output,                                       \
                          condition){                                   \
    if (condition == _TRUE_)                                            \
      fprintf(file,"%*d%*s ",                                           \
              MAX(0,_COLUMNWIDTH_-_OUTPUTPRECISION_-5),                 \
              output, _OUTPUTPRECISION_+5," ");                          \
  }

#define class_fprintf_columntitle(file,                                 \
                                  title,                                \
                                  condition,                            \
                                  colnum){                              \
    if (condition == _TRUE_)                                            \
      fprintf(file,"%*s%2d:%-*s ",                                      \
              MAX(0,MIN(_COLUMNWIDTH_-_OUTPUTPRECISION_-6-3,_COLUMNWIDTH_-((int) strlen(title))-3)), \
              "",colnum++,_OUTPUTPRECISION_+6,title);                   \
  }

#define class_store_columntitle(titlestring,                            \
				title,					\
				condition){				\
    if (condition == _TRUE_){                                           \
      strcat(titlestring,title);                                        \
      strcat(titlestring,_DELIMITER_);                                  \
    }                                                                   \
  }
//,_MAXTITLESTRINGLENGTH_-strlen(titlestring)-1);

#define class_store_double(storage,					\
			   value,					\
			   condition,                                   \
                           dataindex){                                  \
    if (condition == _TRUE_)                                            \
      storage[dataindex++] = value;                                     \
  }

#define class_store_double_or_default(storage,                          \
                                      value,                            \
                                      condition,                        \
                                      dataindex,                        \
                                      defaultvalue){                    \
    if (condition == _TRUE_)                                            \
      storage[dataindex++] = value;                                     \
    else                                                                \
      storage[dataindex++] = defaultvalue;                              \
}

//The name for this macro can be at most 30 characters total
#define class_print_species(name,type) \
printf("-> %-30s Omega = %-15g , omega = %-15g\n",name,pba->Omega0_##type,pba->Omega0_##type*pba->h*pba->h);

//Generic evolver prototype
#define EVOLVER_PROTOTYPE \
    int (*)(double, double *, double *, void *, ErrorMsg), \
    double, double, double *, int *, \
    int, void *, double, double, \
    int (*)(double, void *, double *, ErrorMsg), \
    double, double *, int, \
    int (*)(double, double *, double *, int, void *, ErrorMsg), \
    int (*)(double, double *, double *, void *, ErrorMsg), \
    ErrorMsg

/* Forward-Declare the structs of CLASS */
struct background;
struct thermodynamics;
struct perturbations;
struct transfer;
struct primordial;
struct harmonic;
struct fourier;
struct lensing;
struct distortions;
struct output;

/** parameters related to the precision of the code and to the method of calculation */

/**
 * list of evolver types for integrating perturbations over time
 */
enum evolver_type {
  rk, /* Runge-Kutta integrator */
  ndf15 /* stiff integrator */
};

/**
 * List of ways in which matter power spectrum P(k) can be defined.
 * The standard definition is the first one (delta_m_squared) but
 * alternative definitions can be useful in some projects.
 *
 */
enum pk_def {
  delta_m_squared, /**< normal definition (delta_m includes all non-relativistic species at late times) */
  delta_tot_squared, /**< delta_tot includes all species contributions to (delta rho), and only non-relativistic contributions to rho */
  delta_bc_squared, /**< delta_bc includes contribution of baryons and cdm only to (delta rho) and to rho */
  delta_tot_from_poisson_squared /**< use delta_tot inferred from gravitational potential through Poisson equation */
};
/**
 * Different ways to present output files
 */

enum file_format {class_format,camb_format};

/**
 * All precision parameters.
 *
 * Includes integrations
 * steps, flags telling how the computation is to be performed, etc.
 */
struct precision
{
  /**
   * Define (allocate) all precision parameters (these very concise
   * lines declare all precision parameters thanks to the macros
   * defined in macros_precision.h)
   */

  #define __ALLOCATE_PRECISION_PARAMETER__
  #include "precisions.h"
  #undef __ALLOCATE_PRECISION_PARAMETER__

  /** @name - general precision parameters */

  //@{

  double smallest_allowed_variation; /**< machine-dependent, assigned automatically by the code */

  //@}

  /** @name - zone for writing error messages */

  //@{

  ErrorMsg error_message;  /**< zone for writing error messages */

  //@}

};


#endif

```

`include/dei_rkck.h`:

```h
#ifndef __DEI__
#define __DEI__

#include "common.h"

struct generic_integrator_workspace
{

  int n;

  double * yscal;
  double * y;
  double * dydx;

  double * yerr;
  double * ytempo;

  double * ak2;
  double * ak3;
  double * ak4;
  double * ak5;
  double * ak6;
  double * ytemp;

  double stepmin;

  /**
    * zone for writing error messages
    */
  ErrorMsg error_message;

};

/**************************************************************/

/**
 * Boilerplate for C++
 */
#ifdef __cplusplus
extern "C" {
#endif

  int initialize_generic_integrator(
				    int n_dim,
				    struct generic_integrator_workspace * pgi
				    );

  int cleanup_generic_integrator(struct generic_integrator_workspace * pgi);

  int generic_integrator(int (*derivs)(double x,
				       double y[],
				       double yprime[],
				       void * parameters_and_workspace,
				       ErrorMsg error_message),
			 double x1,
			 double x2,
			 double ystart[],
			 void * parameters_and_workspace_for_derivs,
			 double eps,
			 double hmin,
			 struct generic_integrator_workspace * pgi);

  int rkqs(double *x,
	   double htry,
	   double eps,
	   double *hdid,
	   double *hnext,
	   int (*derivs)(double, double [], double [], void *, ErrorMsg),
	   void * parameters_and_workspace_for_derivs,
	   struct generic_integrator_workspace * pgi);

  int rkck(double x,
	   double h,
	   int (*derivs)(double, double [], double [], void *, ErrorMsg),
	   void * parameters_and_workspace_for_derivs,
	   struct generic_integrator_workspace * pgi);

#ifdef __cplusplus
}
#endif

/**************************************************************/

#define dsign(a,b) ( (b) > 0. ? (a) : (-(a)) )

#define _MAXSTP_ 100000
#define _TINY_ 1.0e-30
#define _SAFETY_ 0.9
#define _PGROW_ -0.2
#define _PSHRNK_ -0.25
#define _ERRCON_ 1.89e-4

#define _RKCK_a2_ 0.2
#define _RKCK_a3_ 0.3
#define _RKCK_a4_ 0.6
#define _RKCK_a5_ 1.0
#define _RKCK_a6_ 0.875
#define _RKCK_b21_ 0.2
#define _RKCK_b31_ 3.0/40.0
#define _RKCK_b32_ 9.0/40.0
#define _RKCK_b41_ 0.3
#define _RKCK_b42_ -0.9
#define _RKCK_b43_ 1.2
#define _RKCK_b51_ -11.0/54.0
#define _RKCK_b52_ 2.5
#define _RKCK_b53_ -70.0/27.0
#define _RKCK_b54_ 35.0/27.0
#define _RKCK_b61_ 1631.0/55296.0
#define _RKCK_b62_ 175.0/512.0
#define _RKCK_b63_ 575.0/13824.0
#define _RKCK_b64_ 44275.0/110592.0
#define _RKCK_b65_ 253.0/4096.0
#define _RKCK_c1_ 37.0/378.0
#define _RKCK_c3_ 250.0/621.0
#define _RKCK_c4_ 125.0/594.0
#define _RKCK_c6_ 512.0/1771.0
#define _RKCK_dc5_ -277.00/14336.0
#define _RKCK_dc1_ (37.0/378.0-2825.0/27648.)
#define _RKCK_dc3_ (250.0/621.0-18575.0/48384.0)
#define _RKCK_dc4_ (125.0/594.0-13525.0/55296.0)
#define _RKCK_dc6_ (512.0/1771.0-0.25)

#endif

```

`include/distortions.h`:

```h
/** @file distortions.h Documented module on spectral distortions
 * Matteo Lucca, 31.10.2018
 * Nils Schoeneberg, 18.02.2019
 */

#ifndef __DISTORTIONS__
#define __DISTORTIONS__

#include "arrays.h"
#include "background.h"
#include "thermodynamics.h"
#include "perturbations.h"
#include "primordial.h"
#include "noninjection.h"

#define _MAX_DETECTOR_NAME_LENGTH_ 100
typedef char DetectorName[_MAX_DETECTOR_NAME_LENGTH_];
typedef char DetectorFileName[_FILENAMESIZE_+_MAX_DETECTOR_NAME_LENGTH_+256];

/** List of possible branching ratio approximations */

enum br_approx {bra_sharp_sharp,bra_sharp_soft,bra_soft_soft,bra_soft_soft_cons,bra_exact};

/** List of possible schemes to compute relativistic contribution from
    reionization and structure formatio */

enum reio_approx {sd_reio_Nozawa, sd_reio_Chluba};

/**
 * distorsions structure, containing all the distortion-related parameters and
 * evolution that other modules need to know.
 */

struct distortions
{
  /** @name - input parameters initialized by user in input module
   *   (all other quantities are computed in this module, given these
   *   parameters and the content of the 'precision', 'background',
   *   'thermodynamics' and 'primordial' structures) */

  //@{

  int sd_branching_approx;                      /**< Which approximation to use for the branching ratios? */

  int sd_PCA_size;                              /**< Number of PCA components for the calculation of residual distortions */

  DetectorFileName sd_detector_file_name;       /**< Name of detector list file */

  DetectorName sd_detector_name;                /**< Name of detector */
  double sd_detector_nu_min;                    /**< Minimum frequency of chosen detector */
  double sd_detector_nu_max;                    /**< Maximum frequency of chosen detector */
  double sd_detector_nu_delta;                  /**< Bin size of chosen detector */
  int sd_detector_bin_number;                   /**< Number of frequency bins of chosen detector */
  double sd_detector_delta_Ic;                  /**< Sensitivity of the chosen detector */

  enum reio_approx sd_reio_type;                /**< Calculation method for Sunyaev Zeldovich contributions from re-ionization */

  double sd_add_y;                              /**< Possible additional y contribution (manually) to the SD signal */
  double sd_add_mu;                             /**< Possible additional mu contribution (manually) to the SD signal */

  //@}

  /** @name - Public tables and parameters */

  //@{

  /* Parameters related to redshift (z) sampling */
  double z_muy;                              /**< Redshift of the transition of mu to y era */
  double z_th;                               /**< Redshift of the transition from thermal shift to mu era */

  double z_min;                              /**< Minimum redshift */
  double z_max;                              /**< Maximum redshift */
  int z_size;                                /**< Lenght of redshift array */
  double z_delta;                            /**< Redshift intervals */
  double * z;                                /**< Redshift list z[index_z] = list of values */

  double * z_weights;                        /**< Weights for integration over z */

  /* Can be specified if no noisefile */
  double x_min;                              /**< Minimum dimentionless frequency */
  double x_max;                              /**< Maximum dimentionless frequency */
  double x_delta;                            /**< dimentionless frequency intervals */

  /* Will always be specified */
  int x_size;                                /**< Lenght of dimentionless frequency array */
  double * x;                                /**< Dimensionless frequency x[index_x] = list of values */
  double * x_weights;                        /**< Weights for integration over x */

  /* Unit conversions */
  double x_to_nu;                            /**< Conversion factor nu[GHz] = x_to_nu * x */
  double DI_units;                           /**< Conversion from unitless DI to DI[10^26 W m^-2 Hz^-1 sr^-1] */

  /* File names for the PCA */
  char sd_detector_noise_file[2*_FILENAMESIZE_+_MAX_DETECTOR_NAME_LENGTH_+256];              /**< Full path of detector noise file */
  DetectorFileName sd_PCA_file_generator;               /**< Full path of PCA generator file */
  DetectorFileName sd_detector_list_file;               /**< Full path of detector list file */


  /* Tables storing branching ratios, distortions amplitudes and spectral distoritons for all types of distortios */
  double ** br_table;              /**< Branching ratios br_table[index_type][index_z] */
  double * sd_parameter_table;     /**< Spectral Distortion parameters (g,mu,y,r) sd_parameter_table[index_type] */
  double ** sd_shape_table;        /**< Spectral Distortion shapes (G,M,Y,R) sd_shape_table[index_type][index_x] */
  double ** sd_table;              /**< Spectral Distortion Intensities (final deltaI seperated by component) sd_table[index_type][index_x] */

  /* indices for the type of distortion */
  int index_type_g;                /**< temperature shift/g type distortion */
  int index_type_mu;               /**< mu type distortion */
  int index_type_y;                /**< y type distortion */
  int index_type_PCA;              /**< PCA type distortion (first index) */
  int type_size;                   /**< Number of total components for the type array */

  /* Total distortion amplitude for residual distortions */
  double epsilon;

  /* Total heating function */
  double * dQrho_dz_tot;

  /* Total heating rate */
  double Drho_over_rho;

  /* Total spectral distortion */
  double * DI;                               /**< DI[index_x] = list of values */

  /* Variables to read, allocate and interpolate external file branching_ratios_exact.dat */
  double * br_exact_z;                       /**< Redshift array for reading from file br_exact_z[index_z] */
  int br_exact_Nz;                           /**< Number of redshift values for reading from file */

  double * f_g_exact;                        /**< temperature shift/g distortion branching ratio f_g_exact[index_z] */
  double * ddf_g_exact;                      /**< second derivative of the above ddf_g_exact[index_z] */
  double * f_y_exact;                        /**< y distortion branching ratio f_y_exact[index_z] */
  double * ddf_y_exact;                      /**< second derivative of the above ddf_y_exact[index_z] */
  double * f_mu_exact;                       /**< mu distortion shape branching ratio f_mu_exact[index_z] */
  double * ddf_mu_exact;                     /**< second derivative of the above ddf_mu_exact[index_z] */

  double * E_vec;                            /**< PCA component E branching ratio for reading from file E_vec[index_e*br_exact_Nz+index_z] with index_e=[1..8] */
  double * ddE_vec;                          /**< second derivative of the above ddE_vec[index_e*br_exact_Nz+index_z] */
  int E_vec_size;                            /**< number of PCA component E branching ratios */

  /* Variable to read, allocate and interpolate external file PCA_distortions_schape.dat */
  double * PCA_nu;                           /**< Frquency array for reading from file PCA_nu[index_nu] */
  int PCA_Nnu;                               /**< Number of frequency values for reading from file */

  double * PCA_G_T;                          /**< temperature shift/g distortion shape PCA_G_T[index_nu] */
  double * ddPCA_G_T;                        /**< second derivative of the above ddPCA_G_T[index_nu] */
  double * PCA_Y_SZ;                         /**< y distortion shape PCA_Y_SZ[index_nu] */
  double * ddPCA_Y_SZ;                       /**< second derivative of the above ddPCA_Y_SZ[index_nu] */
  double * PCA_M_mu;                         /**< mu distortion shape PCA_M_mu[index_nu] */
  double * ddPCA_M_mu;                       /**< second derivative of the above ddPCA_M_mu[index_nu] */

  double * S_vec;                            /**< PCA component S shape for reading from file S_vec[index_s*S_vec_size+index_x] with index_s=[1..8] */
  double * ddS_vec;                          /**< second derivative of the above ddS_vec[index_s*S_vec_size+index_x] */
  int S_vec_size;                            /**< number of PCA component S spectral shapes */


  double * delta_Ic_array;                   /**< delta_Ic[index_x] for detectors with given sensitivity in each bin */

  //@}


  /** @name - Flags and technical parameters */

  //@{

  int has_distortions;                      /**< do we need to compute spectral distortions? */

  int has_user_defined_detector;            /**< does the user specify their own detector? */
  int has_user_defined_name;                /**< does the user specify the name of their detector? */

  int has_detector_file;                    /**< do we have a file for the detector specification? */

  int has_SZ_effect;                        /**< do we include the SZ effect? */

  int include_only_exotic;                  /**< shall we only take exotic injection contributions? */
  int include_g_distortion;                 /**< shall we include the g distortion in the total distortion ?  */

  int has_noninjected;                      /**< do we have terms that are not injected (like dissipation of acoustic waves)? */

  struct noninjection ni;                   /**< noninjection file structure */

  short distortions_verbose;                /**< flag regulating the amount of information sent to standard output (none if set to zero) */

  ErrorMsg error_message;    /**< zone for writing error messages */

  short is_allocated; /**< flag is set to true if allocated */

  //@}

};

/*************************************************************************************************************/
/* @cond INCLUDE_WITH_DOXYGEN */
/*
 * Boilerplate for C++
 */
#ifdef __cplusplus
extern "C" {
#endif

  /* Main functions */
  int distortions_init(struct precision * ppr,
                       struct background * pba,
                       struct thermodynamics * pth,
                       struct perturbations * ppt,
                       struct primordial * ppm,
                       struct distortions * psd);

  int distortions_constants(struct precision* ppr,
                            struct background * pba,
                            struct thermodynamics * pth,
                            struct distortions * psd);

  int distortions_free(struct distortions * psd);

  /* PCA decomposition (branching ratios and spectral shapes) for unknown detector */
  int distortions_generate_detector(struct precision * ppr,
                                    struct distortions * psd);

  int distortions_set_detector(struct precision * ppr,
                               struct distortions* psd);

  int distortions_read_detector_noisefile(struct precision * ppr,
                                          struct distortions * psd);

  /* Indices and lists */
  int distortions_indices(struct distortions * psd);

  int distortions_get_xz_lists(struct precision * ppr,
                               struct background* pba,
                               struct thermodynamics* pth,
                               struct distortions* psd);

  /* The main computation methods */
  int distortions_compute_branching_ratios(struct precision * ppr,
                                           struct distortions* psd);

  int distortions_compute_heating_rate(struct precision* ppr,
                                       struct background* pba,
                                       struct thermodynamics * pth,
                                       struct perturbations * ppt,
                                       struct primordial * ppm,
                                       struct distortions * psd);

  int distortions_compute_spectral_shapes(struct precision * ppr,
                                          struct background * pba,
                                          struct thermodynamics * pth,
                                          struct distortions * psd);

  /* Additional sources of distortions due to recombination and LSS formation */
  int distortions_add_effects_reio(struct background * pba,
                                   struct thermodynamics * pth,
                                   struct distortions * psd,
                                   double T_e,
                                   double Dtau,
                                   double beta,
                                   double beta_z,
                                   double x,
                                   double * y_reio,
                                   double * DI);

  /* PCA decomposition (branching ratios and spectral shapes) for known detector */
  int distortions_read_br_data(struct precision * ppr,
                               struct distortions * psd);
  int distortions_spline_br_data(struct distortions* psd);
  int distortions_interpolate_br_data(struct distortions* psd,
                                      double z,
                                      double* f_g,
                                      double* f_y,
                                      double* f_mu,
                                      double* E,
                                      int * last_index);
  int distortions_free_br_data(struct distortions * psd);

  int distortions_read_sd_data(struct precision * ppr,
                               struct distortions * psd);
  int distortions_spline_sd_data(struct distortions* psd);
  int distortions_interpolate_sd_data(struct distortions* psd,
                                      double nu,
                                      double * G_T,
                                      double * Y_SZ,
                                      double * M_mu,
                                      double * S,
                                      int * index);
  int distortions_free_sd_data(struct distortions * psd);

  /* Output */
  int distortions_output_heat_titles(struct distortions * psd, char titles[_MAXTITLESTRINGLENGTH_]);
  int distortions_output_heat_data(struct distortions * psd,
                                   int number_of_titles,
                                   double * data);

  int distortions_output_sd_titles(struct distortions * psd, char titles[_MAXTITLESTRINGLENGTH_]);
  int distortions_output_sd_data(struct distortions * psd,
                                 int number_of_titles,
                                 double * data);

#ifdef __cplusplus
}
#endif

/**************************************************************/


#endif
/* @endcond */

```

`include/evolver_ndf15.h`:

```h
#ifndef __EVO__
#define __EVO__
#include "common.h"
// #include "perturbations.h"
#include "sparse.h"
#define TINY 1e-50
/**************************************************************/

struct jacobian{
/*Stuff for normal method: */
	double **dfdy;
	double *jacvec; /*Stores experience gained from subsequent calls */
	double **LU;
	double *LUw;
	int *luidx;
	/*Sparse stuff:*/
	int use_sparse;
	int sparse_stuff_initialized;
	int max_nonzero;     /*Maximal number of non-zero entries to be considered sparse */
	int repeated_pattern;
	int trust_sparse; /* Number of times a pattern is repeated (actually included) before we trust it. */
	int has_grouping;
	int has_pattern;
	int new_jacobian; /* True if sp_ludcmp has not been run on the current jacobian. */
	int cnzmax;
	int *col_group; /* Column grouping. Groups go from 0 to max_group*/
	int *col_wi; /* Workarray for column grouping*/
	int max_group; /*Number of columngroups -1 */
	sp_mat *spJ; /* Stores the matrix we want to decompose */
	double *xjac; /*Stores the values of the sparse jacobian. (Same pattern as spJ) */
	sp_num *Numerical; /*Stores the LU decomposition.*/
	int *Cp; /* Stores the column pointers of the spJ+spJ' sparsity pattern. */
	int *Ci; /* Stores the row indices of the  spJ+spJ' sparsity pattern. */
};

struct numjac_workspace{
	/* Allocate vectors and matrices: */
	double *yscale;
	double *del;
	double * Difmax;
	double * absFdelRm;
	double * absFvalue;
	double * absFvalueRm;
	double * Fscale;
	double * ffdel;
	double * yydel;
	double * tmp;

	double **ydel_Fdel;

	int * logj;
	int * Rowmax;
};

/**
 * Boilerplate for C++
 */
#ifdef __cplusplus
extern "C" {
#endif

  int initialize_jacobian(struct jacobian *jac, int neq, ErrorMsg error_message);
  int uninitialize_jacobian(struct jacobian *jac);
  int initialize_numjac_workspace(struct numjac_workspace * nj_ws,int neq, ErrorMsg error_message);
  int uninitialize_numjac_workspace(struct numjac_workspace * nj_ws);
  int calc_C(struct jacobian *jac);
  int interp_from_dif(double tinterp,double tnew,double *ynew,double h,double **dif,int k, double *yinterp,
		      double *ypinterp, double *yppinterp, int* index, int neq, int output);
  int new_linearisation(struct jacobian *jac,double hinvGak,int neq, ErrorMsg error_message);
  int adjust_stepsize(double **dif, double abshdivabshlast, int neq,int k);
  void eqvec(double *datavec,double *emptyvec, int n);
  int lubksb(double **a, int n, int *indx, double b[]);
  int ludcmp(double **a, int n, int *indx, double *d, double *vv);
  int fzero_Newton(int (*func)(double *x,
                               int x_size,
                               void *param,
                               double *F,
                               ErrorMsg error_message),
                   double *x_inout,
                   double *dxdF,
                   int x_size,
                   double tolx,
                   double tolF,
                   void *param,
                   int *fevals,
                   ErrorMsg error_message);

  int numjac(int (*derivs)(double x,double * y,double * dy,void * parameters_and_workspace,ErrorMsg error_message),
	     double t, double *y, double *fval, struct jacobian *jac, struct numjac_workspace *nj_ws,
	     double thresh, int neq, int *nfe,
	     void * parameters_and_workspace_for_derivs, ErrorMsg error_message);


int evolver_ndf15(
	int (*derivs)(double x,double * y,double * dy,
		void * parameters_and_workspace, ErrorMsg error_message),
	double x_ini,
	double x_final,
	double * y_inout,
 	int * used_in_output,
	int neq,
	void * parameters_and_workspace_for_derivs,
	double rtol,
	double minimum_variation,
	int (*timescale_and_approximation)(double x,
					   void * parameters_and_workspace,
					   double * timescales,
					   ErrorMsg error_message),
	double timestep_over_timescale,
	double * t_vec,
	int t_res,
	int (*output)(double x,double y[],double dy[],int index_x,void * parameters_and_workspace,
		ErrorMsg error_message),
	int (*print_variables)(double x, double y[], double dy[], void *parameters_and_workspace,
		ErrorMsg error_message),
	ErrorMsg error_message);


#ifdef __cplusplus
}
#endif

/**************************************************************/

#endif

```

`include/evolver_rkck.h`:

```h
#ifndef __EVO_RK__
#define __EVO_RK__

#include "dei_rkck.h"

/**************************************************************/

/**
 * Boilerplate for C++
 */
#ifdef __cplusplus
extern "C" {
#endif

  int evolver_rk(int (*derivs)(double x,
				    double * y,
				    double * dy,
				    void * parameters_and_workspace,
				    ErrorMsg error_message),
		      double x_ini,
		      double x_end,
		      double * y,
		      int * used_in_output,
		      int y_size,
		      void * parameters_and_workspace_for_derivs,
		      double tolerance,
		      double minimum_variation,
		      int (*evaluate_timescale)(double x,
						void * parameters_and_workspace,
						double * timescale,
						ErrorMsg error_message),
		      double timestep_over_timescale,
		      double * x_sampling,
		      int x_size,
		      int (*output)(double x,
				    double y[],
				    double dy[],
				    int index_x,
				    void * parameters_and_workspace,
				    ErrorMsg error_message),
		      int (*print_variables)(double x,
					     double y[],
					     double dy[],
					     void * parameters_and_workspace,
					     ErrorMsg error_message),
		      ErrorMsg error_message);

#ifdef __cplusplus
}
#endif

/**************************************************************/

#endif

```

`include/fourier.h`:

```h
/** @file fourier.h Documented includes for trg module */

#include "primordial.h"
#include "trigonometric_integrals.h"

#ifndef __FOURIER__
#define __FOURIER__

#define _M_EV_TOO_BIG_FOR_HALOFIT_ 10. /**< above which value of non-CDM mass (in eV) do we stop trusting halofit? */

#define _M_SUN_ 1.98847e30 /**< Solar mass in Kg */

#define _MAX_NUM_EXTRAPOLATION_ 100000

enum non_linear_method {nl_none,nl_halofit,nl_HMcode};
enum pk_outputs {pk_linear,pk_nonlinear};

enum source_extrapolation {extrap_zero,extrap_only_max,extrap_only_max_units,extrap_max_scaled,extrap_hmcode,extrap_user_defined};

enum halofit_integral_type {halofit_integral_one, halofit_integral_two, halofit_integral_three};

enum hmcode_baryonic_feedback_model {nl_emu_dmonly, nl_owls_dmonly, nl_owls_ref, nl_owls_agn, nl_owls_dblim, nl_user_defined};
enum out_sigmas {out_sigma,out_sigma_prime,out_sigma_disp};

/**
 * Structure containing all information on non-linear spectra.
 *
 * Once initialized by fourier_init(), contains a table for all two points correlation functions
 * and for all the ai,bj functions (containing the three points correlation functions), for each
 * time and wave-number.
 */

struct fourier {

  /** @name - input parameters initialized by user in input module
      (all other quantities are computed in this module, given these
      parameters and the content of the 'precision', 'background',
      'thermo', 'primordial' and 'spectra' structures) */

  //@{

  enum non_linear_method method; /**< method for computing non-linear corrections (none, Halogit, etc.) */

  enum source_extrapolation extrapolation_method; /**< method for analytical extrapolation of sources beyond pre-computed range */

  enum hmcode_baryonic_feedback_model feedback; /** to choose between different baryonic feedback models
                                                    in hmcode (dmonly, gas cooling, Agn or supernova feedback) */
  double c_min;      /** for HMcode: minimum concentration in Bullock 2001 mass-concentration relation */
  double eta_0;      /** for HMcode: halo bloating parameter */
  double z_infinity; /** for HMcode: z value at which Dark Energy correction is evaluated needs to be at early times (default */

  short has_pk_eq;  /**< flag: in case wa_fld is defined and non-zero, should we use the pk_eq method? */

  //@}

  /** @name - information on number of modes and pairs of initial conditions */

  //@{

  int index_md_scalars; /**< set equal to phr->index_md_scalars
                           (useful since this module only deals with
                           scalars) */
  int ic_size;         /**< for a given mode, ic_size[index_md] = number of initial conditions included in computation */
  int ic_ic_size;      /**< for a given mode, ic_ic_size[index_md] = number of pairs of (index_ic1, index_ic2) with index_ic2 >= index_ic1; this number is just N(N+1)/2  where N = ic_size[index_md] */
  short * is_non_zero; /**< for a given mode, is_non_zero[index_md][index_ic1_ic2] is set to true if the pair of initial conditions (index_ic1, index_ic2) are statistically correlated, or to false if they are uncorrelated */

  //@}

  /** @name - information on the type of power spectra (_cb, _m...) */

  //@{

  short has_pk_m;  /**< do we want spectra for total matter? */
  short has_pk_cb; /**< do we want spectra for cdm+baryons? */

  int index_pk_m;  /**< index of pk for matter (defined only when has_pk_m is TRUE) */
  int index_pk_cb; /**< index of pk for cold dark matter plus baryons (defined only when has_pk_cb is TRUE */

  /* and two redundent but useful indices: */

  int index_pk_total;      /**< always equal to index_pk_m
                              (always defined, useful e.g. for weak lensing spectrum) */
  int index_pk_cluster;    /**< equal to index_pk_cb if it exists, otherwise to index_pk_m
                              (always defined, useful e.g. for galaxy clustering spectrum) */

  int pk_size;     /**< k_size = total number of pk */

  //@}

  /** @name - arrays for the Fourier power spectra P(k,tau) */

  //@{

  short has_pk_matter; /**< do we need matter Fourier spectrum? */

  int k_size;      /**< k_size = total number of k values */
  int k_size_pk;   /**< k_size = number of k values for P(k,z) and T(k,z) output) */
  double * k;      /**< k[index_k] = list of k values */
  double * ln_k;   /**< ln_k[index_k] = list of log(k) values */

  double * ln_tau;     /**< log(tau) array, only needed if user wants
                          some output at z>0, instead of only z=0.  This
                          array only covers late times, used for the
                          output of P(k) or T(k), and matching the
                          condition z(tau) < z_max_pk */

  int ln_tau_size;     /**< total number of values in this array */

  double ** ln_pk_ic_l;   /**< Matter power spectrum (linear).
                             Depends on indices index_pk, index_ic1_ic2, index_k, index_tau as:
                             ln_pk_ic_l[index_pk][(index_tau * pfo->k_size + index_k)* pfo->ic_ic_size + index_ic1_ic2]
                             where index-pk labels P(k) types (m = total matter, cb = baryons+CDM),
                             while index_ic1_ic2 labels ordered pairs (index_ic1, index_ic2) (since
                             the primordial spectrum is symmetric in (index_ic1, index_ic2)).
                             - for diagonal elements (index_ic1 = index_ic2) this arrays contains
                             ln[P(k)] where P(k) is positive by construction.
                             - for non-diagonal elements this arrays contains the k-dependent
                             cosine of the correlation angle, namely
                             P(k)_(index_ic1, index_ic2)/sqrt[P(k)_index_ic1 P(k)_index_ic2]
                             This choice is convenient since the sign of the non-diagonal cross-correlation
                             could be negative. For fully correlated or anti-correlated initial conditions,
                             this non-diagonal element is independent on k, and equal to +1 or -1.
                          */

  double ** ddln_pk_ic_l; /**< second derivative of above array with respect to log(tau), for spline interpolation. So:
                             - for index_ic1 = index_ic, we spline ln[P(k)] vs. ln(k), which is
                             good since this function is usually smooth.
                             - for non-diagonal coefficients, we spline
                             P(k)_(index_ic1, index_ic2)/sqrt[P(k)_index_ic1 P(k)_index_ic2]
                             vs. ln(k), which is fine since this quantity is often assumed to be
                             constant (e.g for fully correlated/anticorrelated initial conditions)
                             or nearly constant, and with arbitrary sign.
                          */

  double ** ln_pk_l;   /**< Total matter power spectrum summed over initial conditions (linear).
                          Only depends on indices index_pk,index_k, index_tau as:
                          ln_pk[index_pk][index_tau * pfo->k_size + index_k]
                       */

  double ** ddln_pk_l; /**< second derivative of above array with respect to log(tau), for spline interpolation. */

  double ** ln_pk_nl;   /**< Total matter power spectrum summed over initial conditions (nonlinear).
                           Only depends on indices index_pk,index_k, index_tau as:
                           ln_pk[index_pk][index_tau * pfo->k_size + index_k]
                        */

  double ** ddln_pk_nl; /**< second derivative of above array with respect to log(tau), for spline interpolation. */

  double * sigma8;   /**< sigma8[index_pk] */

  //@}

  /** @name - table non-linear corrections for matter density, sqrt(P_NL(k,z)/P_NL(k,z)) */

  //@{

  int k_size_extra;/** total number of k values of extrapolated k array (high k)*/

  int tau_size;    /**< tau_size = number of values */
  double * tau;    /**< tau[index_tau] = list of time values, covering
                      all the values of the perturbation module */

  double ** nl_corr_density;   /**< nl_corr_density[index_pk][index_tau * ppt->k_size + index_k] */
  double ** k_nl;              /**< wavenumber at which non-linear corrections become important,
                                  defined differently by different non_linear_method's */
  int index_tau_min_nl;        /**< index of smallest value of tau at which nonlinear corrections have been computed
                                  (so, for tau<tau_min_nl, the array nl_corr_density only contains some factors 1 */

  //@}

  /** @name - parameters for the pk_eq method */

  //@{

  int index_pk_eq_w;                /**< index of w in table pk_eq_w_and_Omega */
  int index_pk_eq_Omega_m;          /**< index of Omega_m in table pk_eq_w_and_Omega */
  int pk_eq_size;                   /**< number of indices in table pk_eq_w_and_Omega */

  int pk_eq_tau_size;               /**< number of times (and raws in table pk_eq_w_and_Omega) */

  double * pk_eq_tau;               /**< table of time values */
  double * pk_eq_w_and_Omega;       /**< table of background quantites */
  double * pk_eq_ddw_and_ddOmega;   /**< table of second derivatives */

  //@}

  /** @name - technical parameters */

  //@{

  short fourier_verbose;  	/**< amount of information written in standard output */

  ErrorMsg error_message; 	/**< zone for writing error messages */

  short is_allocated; /**< flag is set to true if allocated */

  //@}
};

/**
 * Structure containing variables used only internally in fourier module by various functions.
 *
 */

struct fourier_workspace {

  /** @name - quantitites used by HMcode */

  //@{

  double * rtab; /** List of R values */
  double * stab; /** List of Sigma Values */
  double * ddstab; /** Splined sigma */

  double * growtable;
  double * ztable;
  double * tautable;

  double ** sigma_8;
  double ** sigma_disp;
  double ** sigma_disp_100;
  double ** sigma_prime;

  double dark_energy_correction; /** this is the ratio [g_wcdm(z_infinity)/g_lcdm(z_infinity)]^1.5
                                  * (power comes from Dolag et al. (2004) correction)
                                  * it is 1, if has_fld == _FALSE_ */

  //@}

};

/********************************************************************************/

/* @cond INCLUDE_WITH_DOXYGEN */
/*
 * Boilerplate for C++
 */
#ifdef __cplusplus
extern "C" {
#endif

  /* external functions (meant to be called from other modules) */

  int fourier_pk_at_z(
                      struct background * pba,
                      struct fourier *pfo,
                      enum linear_or_logarithmic mode,
                      enum pk_outputs pk_output,
                      double z,
                      int index_pk,
                      double * out_pk,
                      double * out_pk_ic
                      );

  int fourier_pks_at_z(
                       struct background * pba,
                       struct fourier *pfo,
                       enum linear_or_logarithmic mode,
                       enum pk_outputs pk_output,
                       double z,
                       double * out_pk,
                       double * out_pk_ic,
                       double * out_pk_cb,
                       double * out_pk_cb_ic
                       );

  int fourier_pk_at_k_and_z(
                            struct background * pba,
                            struct primordial * ppm,
                            struct fourier *pfo,
                            enum pk_outputs pk_output,
                            double k,
                            double z,
                            int index_pk,
                            double * out_pk,
                            double * out_pk_ic
                            );

  int fourier_pks_at_k_and_z(
                             struct background * pba,
                             struct primordial * ppm,
                             struct fourier *pfo,
                             enum pk_outputs pk_output,
                             double k,
                             double z,
                             double * out_pk,
                             double * out_pk_ic,
                             double * out_pk_cb,
                             double * out_pk_cb_ic
                             );

  int fourier_pks_at_kvec_and_zvec(
                                   struct background * pba,
                                   struct fourier * pfo,
                                   enum pk_outputs pk_output,
                                   double * kvec,
                                   int kvec_size,
                                   double * zvec,
                                   int zvec_size,
                                   double * out_pk,
                                   double * out_pk_cb
                                   );

  int fourier_sigmas_at_z(
                          struct precision * ppr,
                          struct background * pba,
                          struct fourier * pfo,
                          double R,
                          double z,
                          int index_pk,
                          enum out_sigmas sigma_output,
                          double * result
                          );

  int fourier_pk_tilt_at_k_and_z(
                                 struct background * pba,
                                 struct primordial * ppm,
                                 struct fourier * pfo,
                                 enum pk_outputs pk_output,
                                 double k,
                                 double z,
                                 int index_pk,
                                 double * pk_tilt
                                 );

  int fourier_k_nl_at_z(
                        struct background *pba,
                        struct fourier * pfo,
                        double z,
                        double * k_nl,
                        double * k_nl_cb
                        );

  /* internal functions */

  int fourier_init(
                   struct precision *ppr,
                   struct background *pba,
                   struct thermodynamics *pth,
                   struct perturbations *ppt,
                   struct primordial *ppm,
                   struct fourier *pfo
                   );

  int fourier_free(
                   struct fourier *pfo
                   );

  int fourier_indices(
                      struct precision *ppr,
                      struct background *pba,
                      struct perturbations * ppt,
                      struct primordial * ppm,
                      struct fourier * pfo
                      );

  int fourier_get_k_list(
                         struct precision *ppr,
                         struct primordial *ppm,
                         struct perturbations * ppt,
                         struct fourier * pfo
                         );

  int fourier_get_tau_list(
                           struct perturbations * ppt,
                           struct fourier * pfo
                           );

  int fourier_get_source(
                         struct background * pba,
                         struct perturbations * ppt,
                         struct fourier * pfo,
                         int index_k,
                         int index_ic,
                         int index_tp,
                         int index_tau,
                         double ** sources,
                         double * source);

  int fourier_pk_linear(
                        struct background *pba,
                        struct perturbations *ppt,
                        struct primordial *ppm,
                        struct fourier *pfo,
                        int index_pk,
                        int index_tau,
                        int k_size,
                        double * lnpk,
                        double * lnpk_ic
                        );

  int fourier_sigmas(
                     struct fourier * pfo,
                     double R,
                     double *lnpk_l,
                     double *ddlnpk_l,
                     int k_size,
                     double k_per_decade,
                     enum out_sigmas sigma_output,
                     double * result
                     );

  int fourier_sigma_at_z(
                         struct background * pba,
                         struct fourier * pfo,
                         double R,
                         double z,
                         int index_pk,
                         double k_per_decade,
                         double * result
                         );

  int fourier_halofit(
                      struct precision *ppr,
                      struct background *pba,
                      struct perturbations *ppt,
                      struct primordial *ppm,
                      struct fourier *pfo,
                      int index_pk,
                      double tau,
                      double *pk_nl,
                      double *lnpk_l,
                      double *ddlnpk_l,
                      double *k_nl,
                      short * halofit_found_k_max
                      );

  int fourier_halofit_integrate(
                                struct fourier *pfo,
                                double * integrand_array,
                                int integrand_size,
                                int ia_size,
                                int index_ia_k,
                                int index_ia_pk,
                                int index_ia_sum,
                                int index_ia_ddsum,
                                double R,
                                enum halofit_integral_type type,
                                double * sum
                                );

  int fourier_hmcode(
                     struct precision *ppr,
                     struct background *pba,
                     struct perturbations *ppt,
                     struct primordial *ppm,
                     struct fourier *pfo,
                     int index_pk,
                     int index_tau,
                     double tau,
                     double *pk_nl,
                     double **lnpk_l,
                     double **ddlnpk_l,
                     double *k_nl,
                     short * halofit_found_k_max,
                     struct fourier_workspace * pnw
                     );

  int fourier_hmcode_workspace_init(
                                    struct precision *ppr,
                                    struct background *pba,
                                    struct fourier *pfo,
                                    struct fourier_workspace * pnw
                                    );

  int fourier_hmcode_workspace_free(
                                    struct fourier *pfo,
                                    struct fourier_workspace * pnw
                                    );

  int fourier_hmcode_dark_energy_correction(
                                            struct precision *ppr,
                                            struct background *pba,
                                            struct fourier *pfo,
                                            struct fourier_workspace * pnw
                                            );

  int fourier_hmcode_baryonic_feedback(
                                       struct fourier *pfo
                                       );


  int fourier_hmcode_fill_sigtab(
                                 struct precision *ppr,
                                 struct background * pba,
                                 struct perturbations *ppt,
                                 struct primordial * ppm,
                                 struct fourier * pfo,
                                 int index_tau,
                                 double *lnpk_l,
                                 double *ddlnpk_l,
                                 struct fourier_workspace * pnw
                                 );

  int fourier_hmcode_fill_growtab(
                                  struct precision *ppr,
                                  struct background * pba,
                                  struct fourier * pfo,
                                  struct fourier_workspace * pnw
                                  );

  int fourier_hmcode_growint(
                             struct precision *ppr,
                             struct background * pba,
                             struct fourier * pfo,
                             double a,
                             double w,
                             double wa,
                             double * growth
                             );

  int fourier_hmcode_window_nfw(
                                struct fourier * pfo,
                                double k,
                                double rv,
                                double c,
                                double *window_nfw
                                );

  int fourier_hmcode_halomassfunction(
                                      double nu,
                                      double *hmf
                                      );

  int fourier_hmcode_sigma8_at_z(
                                 struct background *pba,
                                 struct fourier * pfo,
                                 double z,
                                 double * sigma_8,
                                 double * sigma_8_cb,
                                 struct fourier_workspace * pnw
                                 );

  int fourier_hmcode_sigmadisp_at_z(
                                    struct background *pba,
                                    struct fourier * pfo,
                                    double z,
                                    double * sigma_disp,
                                    double * sigma_disp_cb,
                                    struct fourier_workspace * pnw
                                    );

  int fourier_hmcode_sigmadisp100_at_z(
                                       struct background *pba,
                                       struct fourier * pfo,
                                       double z,
                                       double * sigma_disp_100,
                                       double * sigma_disp_100_cb,
                                       struct fourier_workspace * pnw
                                       );

  int fourier_hmcode_sigmaprime_at_z(
                                     struct background *pba,
                                     struct fourier * pfo,
                                     double z,
                                     double * sigma_prime,
                                     double * sigma_prime_cb,
                                     struct fourier_workspace * pnw
                                     );

#ifdef __cplusplus
}
#endif

#endif
/* @endcond */

```

`include/growTable.h`:

```h
/***
 * A table that  grows automatically.
 */

#ifndef __GROWTABLE__
#define __GROWTABLE__

#include "common.h"

#define _GT_INITSIZE_ 4096 /**< Init size of a growTable (in bytes)*/
#define _GT_FACTOR_ 2      /**< inflating factor when current max size is reached */
#define _GT_END_ -1        /**< flag meaning the end of the current data in the growTable */

/**
 * growTable structure.
 */
typedef struct {
  void* buffer; /**< stack of data */
  long sz;      /**< total size */
  long csz;     /**< real size */
  int freeze;   /**< if set to _TRUE_ no data can be added */

  ErrorMsg error_message; /**< error message slot */
} growTable;

/** Boilerplate for C++ */
#ifdef __cplusplus
extern "C" {
#endif

int gt_init(growTable*);

int gt_add(growTable*, long idx, void* data, long sz);
int gt_retrieve(growTable *,long idx, long sz, void* data);
int gt_retrieveAll(growTable *,void* data);

int gt_getSize(growTable*, long *idx);

int gt_getPtr(growTable*, void** ptr);

int gt_free(growTable*);

/** Boilerplate for C++ */
#ifdef __cplusplus
}
#endif
#endif

```

`include/harmonic.h`:

```h
/** @file harmonic.h Documented includes for harmonic module */

#ifndef __HARMONIC__
#define __HARMONIC__

#include "transfer.h"

/**
 * Structure containing everything about anisotropy and Fourier power spectra that other modules need to know.
 *
 * Once initialized by harmonic_init(), contains a table of all
 * \f$ C_l\f$'s and P(k) as a function of multipole/wavenumber,
 * mode (scalar/tensor...), type (for \f$ C_l\f$'s: TT, TE...),
 * and pairs of initial conditions (adiabatic, isocurvatures...).
 */

struct harmonic {

  /** @name - input parameters initialized by user in input module
      (all other quantities are computed in this module, given these parameters
      and the content of the 'background', 'perturbs', 'transfers' and
      'primordial' structures) */

  //@{

  int non_diag; /**< sets the number of cross-correlation spectra
                   that you want to calculate: 0 means only
                   auto-correlation, 1 means only adjacent bins,
                   and number of bins minus one means all
                   correlations */

  //@}

  /** @name - information on number of modes and pairs of initial conditions */

  //@{

  int md_size;           /**< number of modes (scalar, tensor, ...) included in computation */
  int index_md_scalars; /**< index for scalar modes */

  int * ic_size;         /**< for a given mode, ic_size[index_md] = number of initial conditions included in computation */
  int * ic_ic_size;      /**< for a given mode, ic_ic_size[index_md] = number of pairs of (index_ic1, index_ic2) with index_ic2 >= index_ic1; this number is just N(N+1)/2  where N = ic_size[index_md] */
  short ** is_non_zero; /**< for a given mode, is_non_zero[index_md][index_ic1_ic2] is set to true if the pair of initial conditions (index_ic1, index_ic2) are statistically correlated, or to false if they are uncorrelated */

  //@}

  /** @name - information on number of type of C_l's (TT, TE...) */

  //@{

  int has_tt; /**< do we want \f$ C_l^{TT}\f$? (T = temperature) */
  int has_ee; /**< do we want \f$ C_l^{EE}\f$? (E = E-polarization) */
  int has_te; /**< do we want \f$ C_l^{TE}\f$? */
  int has_bb; /**< do we want \f$ C_l^{BB}\f$? (B = B-polarization) */
  int has_pp; /**< do we want \f$ C_l^{\phi\phi}\f$? (\f$ \phi \f$ = CMB lensing potential) */
  int has_tp; /**< do we want \f$ C_l^{T\phi}\f$? */
  int has_ep; /**< do we want \f$ C_l^{E\phi}\f$? */
  int has_dd; /**< do we want \f$ C_l^{dd}\f$? (d = density) */
  int has_td; /**< do we want \f$ C_l^{Td}\f$? */
  int has_pd; /**< do we want \f$ C_l^{\phi d}\f$? */
  int has_ll; /**< do we want \f$ C_l^{ll}\f$? (l = galaxy lensing potential) */
  int has_tl; /**< do we want \f$ C_l^{Tl}\f$? */
  int has_dl; /**< do we want \f$ C_l^{dl}\f$? */

  int index_ct_tt; /**< index for type \f$ C_l^{TT} \f$*/
  int index_ct_ee; /**< index for type \f$ C_l^{EE} \f$*/
  int index_ct_te; /**< index for type \f$ C_l^{TE} \f$*/
  int index_ct_bb; /**< index for type \f$ C_l^{BB} \f$*/
  int index_ct_pp; /**< index for type \f$ C_l^{\phi\phi} \f$*/
  int index_ct_tp; /**< index for type \f$ C_l^{T\phi} \f$*/
  int index_ct_ep; /**< index for type \f$ C_l^{E\phi} \f$*/
  int index_ct_dd; /**< first index for type \f$ C_l^{dd} \f$((d_size*d_size-(d_size-non_diag)*(d_size-non_diag-1)/2) values) */
  int index_ct_td; /**< first index for type \f$ C_l^{Td} \f$(d_size values) */
  int index_ct_pd; /**< first index for type \f$ C_l^{pd} \f$(d_size values) */
  int index_ct_ll; /**< first index for type \f$ C_l^{ll} \f$((d_size*d_size-(d_size-non_diag)*(d_size-non_diag-1)/2) values) */
  int index_ct_tl; /**< first index for type \f$ C_l^{Tl} \f$(d_size values) */
  int index_ct_dl; /**< first index for type \f$ C_l^{dl} \f$(d_size values) */

  int d_size;      /**< number of bins for which density Cl's are computed */

  int ct_size; /**< number of \f$ C_l \f$ types requested */

  //@}

  /** @name - table of pre-computed C_l values, and related quantities */

  //@{

  int * l_size;   /**< number of multipole values for each requested mode, l_size[index_md] */

  int l_size_max; /**< greatest of all l_size[index_md] */

  double * l;    /**< list of multipole values l[index_l] */


  int ** l_max_ct;    /**< last multipole (given as an input) at which
                         we want to output \f$ C_l\f$'s for a given mode and type;
                         l[index_md][l_size[index_md]-1] can be larger
                         than l_max[index_md], in order to ensure a
                         better interpolation with no boundary effects */

  int * l_max;    /**< last multipole (given as an input) at which
                     we want to output \f$ C_l\f$'s for a given mode (maximized over types);
                     l[index_md][l_size[index_md]-1] can be larger
                     than l_max[index_md], in order to ensure a
                     better interpolation with no boundary effects */

  int l_max_tot; /**< last multipole (given as an input) at which
                    we want to output \f$ C_l\f$'s (maximized over modes and types);
                    l[index_md][l_size[index_md]-1] can be larger
                    than l_max[index_md], in order to ensure a
                    better interpolation with no boundary effects */

  double ** cl;   /**< table of anisotropy spectra for each mode, multipole, pair of initial conditions and types, cl[index_md][(index_l * phr->ic_ic_size[index_md] + index_ic1_ic2) * phr->ct_size + index_ct] */
  double ** ddcl; /**< second derivatives of previous table with respect to l, in view of spline interpolation */

  //@}

  /** @name - technical parameters */

  //@{

  struct fourier * pfo; /**< a pointer to the fourier structure is
                           stored in the harmonic structure. This odd,
                           unusual and unelegant feature has been
                           introduced in v2.8 in order to keep in use
                           some deprecated functions harmonic_pk_...()
                           that are now pointing at new function
                           fourier_pk_...(). In the future, if the
                           deprecated functions are removed, it will
                           be possible to remove also this pointer. */

  short harmonic_verbose; /**< flag regulating the amount of information sent to standard output (none if set to zero) */

  ErrorMsg error_message; /**< zone for writing error messages */

  short is_allocated; /**< flag is set to true if allocated */

  //@}
};

/*************************************************************************************************************/
/* @cond INCLUDE_WITH_DOXYGEN */
/*
 * Boilerplate for C++
 */
#ifdef __cplusplus
extern "C" {
#endif

  /* external functions (meant to be called from other modules) */

  int harmonic_cl_at_l(
                       struct harmonic * phr,
                       double l,
                       double * cl,
                       double ** cl_md,
                       double ** cl_md_ic
                       );

  /* internal functions */

  int harmonic_init(
                    struct precision * ppr,
                    struct background * pba,
                    struct perturbations * ppt,
                    struct primordial * ppm,
                    struct fourier *pfo,
                    struct transfer * ptr,
                    struct harmonic * phr
                    );

  int harmonic_free(
                    struct harmonic * phr
                    );

  int harmonic_indices(
                       struct background * pba,
                       struct perturbations * ppt,
                       struct transfer * ptr,
                       struct primordial * ppm,
                       struct harmonic * phr
                       );

  int harmonic_cls(
                   struct precision * ppr,
                   struct background * pba,
                   struct perturbations * ppt,
                   struct transfer * ptr,
                   struct primordial * ppm,
                   struct harmonic * phr
                   );

  int harmonic_compute_cl(
                          struct precision * ppr,
                          struct background * pba,
                          struct perturbations * ppt,
                          struct transfer * ptr,
                          struct primordial * ppm,
                          struct harmonic * phr,
                          int index_md,
                          int index_ic1,
                          int index_ic2,
                          int index_l,
                          int cl_integrand_num_columns,
                          double * cl_integrand,
                          double * cl_integrand_limber,
                          double * primordial_pk,
                          double * transfer_ic1,
                          double * transfer_ic2
                          );

  int harmonic_k_and_tau(
                         struct background * pba,
                         struct perturbations * ppt,
                         struct fourier *pfo,
                         struct harmonic * phr
                         );

  /* deprecated functions (since v2.8) */

  int harmonic_pk_at_z(
                       struct background * pba,
                       struct harmonic * phr,
                       enum linear_or_logarithmic mode,
                       double z,
                       double * output_tot,
                       double * output_ic,
                       double * output_cb_tot,
                       double * output_cb_ic
                       );

  int harmonic_pk_at_k_and_z(
                             struct background * pba,
                             struct primordial * ppm,
                             struct harmonic * phr,
                             double k,
                             double z,
                             double * pk,
                             double * pk_ic,
                             double * pk_cb,
                             double * pk_cb_ic
                             );

  int harmonic_pk_nl_at_z(
                          struct background * pba,
                          struct harmonic * phr,
                          enum linear_or_logarithmic mode,
                          double z,
                          double * output_tot,
                          double * output_cb_tot
                          );

  int harmonic_pk_nl_at_k_and_z(
                                struct background * pba,
                                struct primordial * ppm,
                                struct harmonic * phr,
                                double k,
                                double z,
                                double * pk_tot,
                                double * pk_cb_tot
                                );

  int harmonic_fast_pk_at_kvec_and_zvec(
                                        struct background * pba,
                                        struct harmonic * phr,
                                        double * kvec,
                                        int kvec_size,
                                        double * zvec,
                                        int zvec_size,
                                        double * pk_tot_out,
                                        double * pk_cb_tot_out,
                                        int nonlinear);

  int harmonic_sigma(
                     struct background * pba,
                     struct primordial * ppm,
                     struct harmonic * phr,
                     double R,
                     double z,
                     double *sigma
                     );

  int harmonic_sigma_cb(
                        struct background * pba,
                        struct primordial * ppm,
                        struct harmonic * phr,
                        double R,
                        double z,
                        double *sigma_cb
                        );

  /* deprecated functions (since v2.1) */

  int harmonic_tk_at_z(
                       struct background * pba,
                       struct harmonic * phr,
                       double z,
                       double * output
                       );

  int harmonic_tk_at_k_and_z(
                             struct background * pba,
                             struct harmonic * phr,
                             double k,
                             double z,
                             double * output
                             );

  /* end deprecated functions */

#ifdef __cplusplus
}
#endif

#endif
/* @endcond */

```

`include/hermite3_interpolation_csource.h`:

```h
/** Hermite interpolation of order 3 for Phi, dPhi, and d2Phi. When xinterp
    is sorted (increasing), computations can be reused. On the other hand,
    for a randomly called value, the routine is not much slower than a
    routine optimised for this case. The more sorted the vector, the faster
    the execution time. For closed case, the interpolation structure only
    covers [safety;pi/2-safety]. The calling routine should respect this.
    if sinK and cosK are not NULL, we will also interpolate them.
*/

int l = pHIS->l[lnum];
#if defined (HERMITE_DO_PHI)|| defined (HERMITE_DO_D2PHI)
double ym=0;
#endif
double yp=0, dyp=0, x;
double z[2]={0.,0.};
#ifdef HERMITE_DO_PHI
double a[3]={0.,0.};
#endif
#ifdef HERMITE_DO_DPHI
double b[3]={0.,0.};
#endif
#ifdef HERMITE_DO_D2PHI
double c[3]={0.,0.};
double d2ym = 0, d3yp=0;
double cotKm=0,sinKm=0;
double sinKm2;
#endif
#if defined (HERMITE_DO_DPHI) || defined (HERMITE_DO_D2PHI)
double dym=0;
double d2yp=0;
double cotKp=0,sinKp=0;
double sinKp2;
double *sinK = pHIS->sinK;
double *cotK = pHIS->cotK;
int K = pHIS->K;
double lxlp1 = l*(l+1.0);
double beta = pHIS->beta;
double beta2 = beta*beta;
#endif
double *xvec;
double xmin, xmax, deltax;
double left_border, right_border, next_border;
int j, nx, current_border_idx=0;
double *Phi_l, *dPhi_l;
int phisign = 1, dphisign = 1;

/** Set logical flags. The compiler should probably generate 2^3-1=7
    different functions, according to these flags. If not, maybe I should
    do it.
*/

xvec = pHIS->x;
deltax = pHIS->delta_x;
nx = pHIS->x_size;
Phi_l = pHIS->phi+lnum*nx;
dPhi_l = pHIS->dphi+lnum*nx;

xmin = xvec[0];
xmax = xvec[nx-1];

left_border = xmax;
right_border = xmin;
next_border = xmin;

for (j=0; j<nxi; j++){
  x = xinterp[j];
  //take advantage of periodicity of functions in closed case
  if (pHIS->K==1)
    ClosedModY(l, (int)(pHIS->beta+0.2), &x, &phisign, &dphisign);
  //Loop over output values
  if ((x<xmin)||(x>xmax)){
    //Outside interpolation region, set to zero.
#ifdef HERMITE_DO_PHI
    Phi[j] = 0.0;
#endif
#ifdef HERMITE_DO_DPHI
    dPhi[j] = 0.0;
#endif
#ifdef HERMITE_DO_D2PHI
    d2Phi[j] = 0.0;
#endif
    continue;
  }
  if ((x>right_border)||(x<left_border)){
    if ((x>next_border)||(x<left_border)){
      current_border_idx = ((int) ((x-xmin)/deltax))+1;
      current_border_idx = MAX(1,current_border_idx);
      current_border_idx = MIN(nx-1,current_border_idx);
      //printf("Current border index at jump: %d\n",current_border_idx);
      //max operation takes care of case x = xmin,
      //min operation takes care of case x = xmax.
      //Calculate left derivatives:
#if defined (HERMITE_DO_PHI) || defined (HERMITE_DO_D2PHI)
      ym = Phi_l[current_border_idx-1];
#endif
#if defined HERMITE_DO_DPHI || defined HERMITE_DO_D2PHI
      dym = dPhi_l[current_border_idx-1];
#endif
#ifdef HERMITE_DO_D2PHI
      cotKm = cotK[current_border_idx-1];
      sinKm = sinK[current_border_idx-1];
      sinKm2 = sinKm*sinKm;
      d2ym = -2*dym*cotKm+ym*(lxlp1/sinKm2-beta2+K);
#endif
    }
    else{
      //x>current_border but not next border: I have moved to next block.
      current_border_idx++;
      //printf("Current border index at else: %d\n",current_border_idx);
      //Copy former right derivatives to left derivatives.
#if defined (HERMITE_DO_PHI) || defined (HERMITE_DO_D2PHI)
      ym = yp;
#endif
#if defined HERMITE_DO_DPHI || defined HERMITE_DO_D2PHI
      dym = dyp;
#endif
#ifdef HERMITE_DO_D2PHI
      d2ym = d2yp;
      sinKm = sinKp;
      cotKm = cotKp;
#endif
    }
    left_border = xvec[MAX(0,current_border_idx-1)];
    right_border = xvec[current_border_idx];
    next_border = xvec[MIN(nx-1,current_border_idx+1)];
    //Evaluate right derivatives and calculate coefficients:
    yp = Phi_l[current_border_idx];
    dyp = dPhi_l[current_border_idx];
#if defined HERMITE_DO_DPHI || defined HERMITE_DO_D2PHI
    cotKp = cotK[current_border_idx];
    sinKp = sinK[current_border_idx];
    sinKp2 = sinKp*sinKp;
    d2yp = -2*dyp*cotKp+yp*(lxlp1/sinKp2-beta2+K);
#endif
#ifdef HERMITE_DO_D2PHI
    d3yp = -2*cotKp*d2yp-2*yp*lxlp1*cotKp/sinKp2+
      dyp*(K-beta2+(2+lxlp1)/sinKp2);
#endif

#ifdef HERMITE_DO_PHI
    a[0] = -dyp*deltax-2*ym+2*yp;
    a[1] = dyp*deltax+ym-yp;
#endif
#ifdef HERMITE_DO_DPHI
    b[0] = -d2yp*deltax-2*dym+2*dyp;
    b[1] = d2yp*deltax+dym-dyp;
#endif
#ifdef HERMITE_DO_D2PHI
    c[0] = -d3yp*deltax-2*d2ym+2*d2yp;
    c[1] = d3yp*deltax+d2ym-d2yp;
#endif
  }
  //Evaluate polynomial:
  z[0] = (x-left_border)/deltax;
  z[1] = z[0]*z[0];
#ifdef HERMITE_DO_PHI
  Phi[j] = (ym+a[0]*z[0]+a[1]*z[1])*phisign;
#endif
#ifdef HERMITE_DO_DPHI
  dPhi[j] = (dym+b[0]*z[0]+b[1]*z[1])*dphisign;
#endif
#ifdef HERMITE_DO_D2PHI
  d2Phi[j] = (d2ym+c[0]*z[0]+c[1]*z[1])*phisign;
#endif
 }


```

`include/hermite4_interpolation_csource.h`:

```h
/** Hermite interpolation of order 4 for Phi, dPhi, and d2Phi. When xinterp
    is sorted (increasing), computations can be reused. On the other hand,
    for a randomly called value, the routine is not much slower than a
    routine optimised for this case. The more sorted the vector, the faster
    the execution time. For closed case, the interpolation structure only
    covers [safety;pi/2-safety]. The calling routine should respect this.
    if sinK and cosK are not NULL, we will also interpolate them.
*/

int l = pHIS->l[lnum];
double ym=0, yp=0, dym=0, dyp=0, x;
double z[3]={0.,0.,0.};
#ifdef HERMITE_DO_PHI
double a[3]={0.,0.,0.};
#endif
#ifdef HERMITE_DO_DPHI
double b[3]={0.,0.,0.};
#endif
#ifdef HERMITE_DO_D2PHI
double c[3]={0.,0.,0.};
double d3ym=0, d3yp=0;
#endif
#if defined (HERMITE_DO_DPHI) || defined (HERMITE_DO_D2PHI)
double *sinK = pHIS->sinK;
double *cotK = pHIS->cotK;
double cotKm=0,cotKp=0,sinKm=0,sinKp=0;
double sinKm2, sinKp2;
double d2ym = 0, d2yp=0;
int K = pHIS->K;
double lxlp1 = l*(l+1.0);
double beta = pHIS->beta;
double beta2 = beta*beta;
#endif
double *xvec;
double xmin, xmax, deltax;
double left_border, right_border, next_border;
int j, nx, current_border_idx=0;
double *Phi_l, *dPhi_l;
int phisign = 1, dphisign = 1;

/** Set logical flags. The compiler should probably generate 2^3-1=7
    different functions, according to these flags. If not, maybe I should
    do it.
*/

xvec = pHIS->x;
deltax = pHIS->delta_x;
nx = pHIS->x_size;
Phi_l = pHIS->phi+lnum*nx;
dPhi_l = pHIS->dphi+lnum*nx;

xmin = xvec[0];
xmax = xvec[nx-1];

left_border = xmax;
right_border = xmin;
next_border = xmin;

for (j=0; j<nxi; j++){
  x = xinterp[j];
  //take advantage of periodicity of functions in closed case
  if (pHIS->K==1)
    ClosedModY(l, (int)(pHIS->beta+0.2), &x, &phisign, &dphisign);
  //Loop over output values
  if ((x<xmin)||(x>xmax)){
    //Outside interpolation region, set to zero.
#ifdef HERMITE_DO_PHI
    Phi[j] = 0.0;
#endif
#ifdef HERMITE_DO_DPHI
    dPhi[j] = 0.0;
#endif
#ifdef HERMITE_DO_D2PHI
    d2Phi[j] = 0.0;
#endif
    continue;
  }
  if ((x>right_border)||(x<left_border)){
    if ((x>next_border)||(x<left_border)){
      current_border_idx = ((int) ((x-xmin)/deltax))+1;
      current_border_idx = MAX(1,current_border_idx);
      current_border_idx = MIN(nx-1,current_border_idx);
      //printf("Current border index at jump: %d\n",current_border_idx);
      //max operation takes care of case x = xmin,
      //min operation takes care of case x = xmax.
      //Calculate left derivatives:
      ym = Phi_l[current_border_idx-1];
      dym = dPhi_l[current_border_idx-1];
#if defined HERMITE_DO_DPHI || defined HERMITE_DO_D2PHI
      cotKm = cotK[current_border_idx-1];
      sinKm = sinK[current_border_idx-1];
      sinKm2 = sinKm*sinKm;
      d2ym = -2*dym*cotKm+ym*(lxlp1/sinKm2-beta2+K);
#endif
#ifdef HERMITE_DO_D2PHI
      d3ym = -2*cotKm*d2ym-2*ym*lxlp1*cotKm/sinKm2+
        dym*(K-beta2+(2+lxlp1)/sinKm2);
#endif
    }
    else{
      //x>current_border but not next border: I have moved to next block.
      current_border_idx++;
      //printf("Current border index at else: %d\n",current_border_idx);
      //Copy former right derivatives to left derivatives.
      ym = yp;
      dym = dyp;
#if defined HERMITE_DO_DPHI || defined HERMITE_DO_D2PHI
      d2ym = d2yp;
      sinKm = sinKp;
      cotKm = cotKp;
#endif
#ifdef HERMITE_DO_D2PHI
      d3ym = d3yp;
#endif
    }
    left_border = xvec[MAX(0,current_border_idx-1)];
    right_border = xvec[current_border_idx];
    next_border = xvec[MIN(nx-1,current_border_idx+1)];
    //Evaluate right derivatives and calculate coefficients:
    yp = Phi_l[current_border_idx];
    dyp = dPhi_l[current_border_idx];
#if defined HERMITE_DO_DPHI || defined HERMITE_DO_D2PHI
    cotKp = cotK[current_border_idx];
    sinKp = sinK[current_border_idx];
    sinKp2 = sinKp*sinKp;
    d2yp = -2*dyp*cotKp+yp*(lxlp1/sinKp2-beta2+K);
#endif
#ifdef HERMITE_DO_D2PHI
    d3yp = -2*cotKp*d2yp-2*yp*lxlp1*cotKp/sinKp2+
      dyp*(K-beta2+(2+lxlp1)/sinKp2);
#endif

#ifdef HERMITE_DO_PHI
    a[0] = dym*deltax;
    a[1] = -2*dym*deltax-dyp*deltax-3*ym+3*yp;
    a[2] = dym*deltax+dyp*deltax+2*ym-2*yp;
#endif
#ifdef HERMITE_DO_DPHI
    b[0] = d2ym*deltax;
    b[1] = -2*d2ym*deltax-d2yp*deltax-3*dym+3*dyp;
    b[2] = d2ym*deltax+d2yp*deltax+2*dym-2*dyp;
#endif
#ifdef HERMITE_DO_D2PHI
    c[0] = d3ym*deltax;
    c[1] = -2*d3ym*deltax-d3yp*deltax-3*d2ym+3*d2yp;
    c[2] = d3ym*deltax+d3yp*deltax+2*d2ym-2*d2yp;
#endif
  }
  //Evaluate polynomial:
  z[0] = (x-left_border)/deltax;
  z[1] = z[0]*z[0];
  z[2] = z[1]*z[0];
#ifdef HERMITE_DO_PHI
  Phi[j] = (ym+a[0]*z[0]+a[1]*z[1]+a[2]*z[2])*phisign;
#endif
#ifdef HERMITE_DO_DPHI
  dPhi[j] = (dym+b[0]*z[0]+b[1]*z[1]+b[2]*z[2])*dphisign;
#endif
#ifdef HERMITE_DO_D2PHI
  d2Phi[j] = (d2ym+c[0]*z[0]+c[1]*z[1]+c[2]*z[2])*phisign;
#endif
 }


```

`include/hermite6_interpolation_csource.h`:

```h
/** Hermite interpolation of order 6 for Phi, dPhi, and d2Phi. When xinterp
    is sorted (increasing), computations can be reused. On the other hand,
    for a randomly called value, the routine is not much slower than a
    routine optimised for this case. The more sorted the vector, the faster
    the execution time. For closed case, the interpolation structure only
    covers [safety;pi/2-safety]. The calling routine should respect this.
    if sinK and cosK are not NULL, we will also interpolate them.
*/

double ym=0, yp=0, dym=0, dyp=0, d2ym=0, d2yp=0, x, z, z2, z3, z4, z5;
double cotKm=0,cotKp=0,sinKm=0,sinKp=0, sinKm2, sinKp2;
#ifdef HERMITE_DO_PHI
double a1=0, a2=0, a3=0, a4=0, a5=0;
#endif
#ifdef HERMITE_DO_DPHI
double b1=0, b2=0, b3=0, b4=0, b5=0;
#endif
#ifdef HERMITE_DO_D2PHI
double c1=0, c2=0, c3=0, c4=0, c5=0;
double d4ym=0, d4yp=0;
#endif
#if defined (HERMITE_DO_DPHI) || defined (HERMITE_DO_D2PHI)
double d3ym = 0, d3yp=0;
#endif
double beta, beta2, *xvec, *sinK, *cotK;
double xmin, xmax, deltax, deltax2, lxlp1;
double left_border, right_border, next_border;
int K, l, j, nx, current_border_idx=0;
double *Phi_l, *dPhi_l;
int phisign = 1, dphisign = 1;

/** Set logical flags. The compiler should probably generate 2^3-1=7
    different functions, according to these flags. If not, maybe I should
    do it.
*/

xvec = pHIS->x;
sinK = pHIS->sinK;
cotK = pHIS->cotK;
beta = pHIS->beta;
beta2 = beta*beta;
deltax = pHIS->delta_x;
deltax2 = deltax*deltax;
K = pHIS->K;
nx = pHIS->x_size;
Phi_l = pHIS->phi+lnum*nx;
dPhi_l = pHIS->dphi+lnum*nx;
l = pHIS->l[lnum];
lxlp1 = l*(l+1.0);
xmin = xvec[0];
xmax = xvec[nx-1];

left_border = xmax;
right_border = xmin;
next_border = xmin;

for (j=0; j<nxi; j++){
  x = xinterp[j];
  //take advantage of periodicity of functions in closed case
  if (pHIS->K==1)
    ClosedModY(pHIS->l[lnum], (int)(pHIS->beta+0.2), &x, &phisign, &dphisign);
  //Loop over output values
  if ((x<xmin)||(x>xmax)){
    //Outside interpolation region, set to zero.
#ifdef HERMITE_DO_PHI
    Phi[j] = 0.0;
#endif
#ifdef HERMITE_DO_DPHI
    dPhi[j] = 0.0;
#endif
#ifdef HERMITE_DO_D2PHI
    d2Phi[j] = 0.0;
#endif
    continue;
  }
  if ((x>right_border)||(x<left_border)){
    if ((x>next_border)||(x<left_border)){
      current_border_idx = ((int) ((x-xmin)/deltax))+1;
      current_border_idx = MAX(1,current_border_idx);
      current_border_idx = MIN(nx-1,current_border_idx);
      //printf("Current border index at jump: %d\n",current_border_idx);
      //max operation takes care of case x = xmin,
      //min operation takes care of case x = xmax.
      //Calculate left derivatives:
      cotKm = cotK[current_border_idx-1];
      sinKm = sinK[current_border_idx-1];
      sinKm2 = sinKm*sinKm;
      ym = Phi_l[current_border_idx-1];
      dym = dPhi_l[current_border_idx-1];
      d2ym = -2*dym*cotKm+ym*(lxlp1/sinKm2-beta2+K);
#if defined HERMITE_DO_DPHI || defined HERMITE_DO_D2PHI
      d3ym = -2*cotKm*d2ym-2*ym*lxlp1*cotKm/sinKm2+
        dym*(K-beta2+(2+lxlp1)/sinKm2);
#endif
#ifdef HERMITE_DO_D2PHI
      d4ym = -2*cotKm*d3ym + d2ym*(K-beta2+(4+lxlp1)/sinKm2)+
        dym*(-4*(1+lxlp1)*cotKm/sinKm2)+
        ym*(2*lxlp1/sinKm2*(2*cotKm*cotKm+1/sinKm2));
#endif
    }
    else{
      //x>current_border but not next border: I have moved to next block.
      current_border_idx++;
      //printf("Current border index at else: %d\n",current_border_idx);
      //Copy former right derivatives to left derivatives.
      ym = yp;
      dym = dyp;
      d2ym = d2yp;
#if defined HERMITE_DO_DPHI || defined HERMITE_DO_D2PHI
      d3ym = d3yp;
#endif
#ifdef HERMITE_DO_D2PHI
      d4ym = d4yp;
#endif
      sinKm = sinKp;
      cotKm = cotKp;
    }
    left_border = xvec[MAX(0,current_border_idx-1)];
    right_border = xvec[current_border_idx];
    next_border = xvec[MIN(nx-1,current_border_idx+1)];
    //Evaluate right derivatives and calculate coefficients:
    cotKp = cotK[current_border_idx];
    sinKp = sinK[current_border_idx];
    sinKp2 = sinKp*sinKp;
    yp = Phi_l[current_border_idx];
    dyp = dPhi_l[current_border_idx];
    d2yp = -2*dyp*cotKp+yp*(lxlp1/sinKp2-beta2+K);
#if defined HERMITE_DO_DPHI || defined HERMITE_DO_D2PHI
    d3yp = -2*cotKp*d2yp-2*yp*lxlp1*cotKp/sinKp2+
      dyp*(K-beta2+(2+lxlp1)/sinKp2);
#endif
#ifdef HERMITE_DO_D2PHI
    d4yp = -2*cotKp*d3yp + d2yp*(K-beta2+(4+lxlp1)/sinKp2)+
      dyp*(-4*(1+lxlp1)*cotKp/sinKp2)+
      yp*(2*lxlp1/sinKp2*(2*cotKp*cotKp+1/sinKp2));
#endif

#ifdef HERMITE_DO_PHI
    a1 = dym*deltax;
    a2 = 0.5*d2ym*deltax2;
    a3 = (-1.5*d2ym+0.5*d2yp)*deltax2-(6*dym+4*dyp)*deltax-10*(ym-yp);
    a4 = (1.5*d2ym-d2yp)*deltax2+(8*dym+7*dyp)*deltax+15*(ym-yp);
    a5 = (-0.5*d2ym+0.5*d2yp)*deltax2-3*(dym+dyp)*deltax-6*(ym-yp);
#endif
#ifdef HERMITE_DO_DPHI
    b1 = d2ym*deltax;
    b2 = 0.5*d3ym*deltax2;
    b3 = (-1.5*d3ym+0.5*d3yp)*deltax2-(6*d2ym+4*d2yp)*deltax-10*(dym-dyp);
    b4 = (1.5*d3ym-d3yp)*deltax2+(8*d2ym+7*d2yp)*deltax+15*(dym-dyp);
    b5 = (-0.5*d3ym+0.5*d3yp)*deltax2-3*(d2ym+d2yp)*deltax-6*(dym-dyp);
#endif
#ifdef HERMITE_DO_D2PHI
    c1 = d3ym*deltax;
    c2 = 0.5*d4ym*deltax2;
    c3 = (-1.5*d4ym+0.5*d4yp)*deltax2-(6*d3ym+4*d3yp)*deltax-10*(d2ym-d2yp);
    c4 = (1.5*d4ym-d4yp)*deltax2+(8*d3ym+7*d3yp)*deltax+15*(d2ym-d2yp);
    c5 = (-0.5*d4ym+0.5*d4yp)*deltax2-3*(d3ym+d3yp)*deltax-6*(d2ym-d2yp);
#endif
  }
  //Evaluate polynomial:
  z = (x-left_border)/deltax;
  z2 = z*z;
  z3 = z2*z;
  z4 = z2*z2;
  z5 = z2*z3;
#ifdef HERMITE_DO_PHI
    Phi[j] = (ym+a1*z+a2*z2+a3*z3+a4*z4+a5*z5)*phisign;
#endif
#ifdef HERMITE_DO_DPHI
    dPhi[j] = (dym+b1*z+b2*z2+b3*z3+b4*z4+b5*z5)*dphisign;
#endif
#ifdef HERMITE_DO_D2PHI
    d2Phi[j] = (d2ym+c1*z+c2*z2+c3*z3+c4*z4+c5*z5)*phisign;
#endif
 }


```

`include/hyperspherical.h`:

```h
/**
 * definitions for module hyperspherical.c
 */

#ifndef __HYPERSPHERICAL__
#define __HYPERSPHERICAL__

#include "common.h"
#define _HYPER_OVERFLOW_ 1e200
#define _ONE_OVER_HYPER_OVERFLOW_ 1e-200
#define _HYPER_SAFETY_ 1e-5
#define _TRIG_PRECISSION_ 1e-7
#define _HYPER_BLOCK_ 8
#define _HYPER_CHUNK_ 16
#define _TWO_OVER_THREE_ 0.666666666666666666666666666667e0
#define _HIS_BYTE_ALIGNMENT_ 16

typedef struct HypersphericalInterpolationStructure{
  int K;                 //Sign of the curvature, (0,-1,1)
  double beta;
  double delta_x;         //x-spacing. (xvec is uniformly spaced)
  int trig_order;        //Order of the interpolation formula for SinK and CosK.
  int l_size;                //Number of l values
  int *l;             //Vector of l values stored
  double * chi_at_phimin;     // vector x_min[index-l] below which neglect Bessels
  int x_size;                //Number of x-values
  double *x;          //Pointer to x-values
  double *sinK;          //Vector of sin_K(xvec)
  double *cotK;          //Vector of cot_K(xvec)
  double *phi;        //array of size nl*nx. [y_{l1}(x1) t_{l1}(x2)...]
  double *dphi;       //Same as phivec, but containing derivatives.
} HyperInterpStruct;

struct WKB_parameters{
   int K;
   int l;
   double beta;
   double phiminabs;
};

/**
 * Boilerplate for C++
 */
#ifdef __cplusplus
extern "C" {
#endif
  int hyperspherical_HIS_create(int K,
                                double beta,
                                int nl,
                                int *lvec,
                                double xmin,
                                double xmax,
                                double sampling,
                                int l_WKB,
                                double phiminabs,
                                HyperInterpStruct *pHIS,
                                ErrorMsg error_message);

  int hyperspherical_HIS_free(HyperInterpStruct *pHIS, ErrorMsg error_message);
  int hyperspherical_forwards_recurrence(int K,
                                         int lmax,
                                         double beta,
                                         double x,
                                         double sinK,
                                         double cotK,
                                         double *sqrtK,
                                         double *one_over_sqrtK,
                                         double *PhiL);
int hyperspherical_forwards_recurrence_chunk(int K,
                                             int lmax,
                                             double beta,
                                             double * __restrict__ x,
                                             double * __restrict__ sinK,
                                             double * __restrict__ cotK,
                                             int chunk,
                                             double * __restrict__ sqrtK,
                                             double * __restrict__ one_over_sqrtK,
                                             double * __restrict__ PhiL);
  int hyperspherical_backwards_recurrence(int K,
                                          int lmax,
                                          double beta,
                                          double x,
                                          double sinK,
                                          double cotK,
                                          double *sqrtK,
                                          double *one_over_sqrtK,
                                          double *PhiL);

  int hyperspherical_backwards_recurrence_chunk(int K,
                                                int lmax,
                                                double beta,
                                                double * __restrict__ x,
                                                double * __restrict__ sinK,
                                                double * __restrict__ cotK,
                                                int chunk,
                                                double * __restrict__ sqrtK,
                                                double * __restrict__ one_over_sqrtK,
                                                double * __restrict__ PhiL);
  int hyperspherical_get_xmin(HyperInterpStruct *pHIS,
                              double xtol,
                              double phiminabs,
                              double *xmin);

  int hyperspherical_WKB(int K,int l,double beta,double y, double *Phi);
  int hyperspherical_WKB_vec(int l,
                             double beta,
                             double *sinK_vec,
                             int size_sinK_vec,
                             double *Phi);
  int ClosedModY(int l, int beta, double *y, int * phisign, int * dphisign);
  int get_CF1(int K,int l,double beta, double cotK, double *CF, int *isign);
  int CF1_from_Gegenbauer(int l, int beta, double sinK, double cotK, double *CF);
  double airy_cheb_approx(double z);
  double coef1(double z);
  double coef2(double z);
  double coef3(double z);
  double coef4(double z);
  double cheb(double x, int n, const double A[]);
  double get_value_at_small_phi(int K,int l,double beta,double Phi);

  double PhiWKB_minus_phiminabs(double x, void *param);

  int hyperspherical_get_xmin_from_Airy(int K,
                                        int l,
                                        double beta,
                                        double xtol,
                                        double phiminabs,
                                        double *xmin,
                                        int *fevals
                                        );

  int fzero_ridder(double (*func)(double, void *),
                   double x1,
                   double x2,
                   double xtol,
                   void *param,
                   double *Fx1,
                   double *Fx2,
                   double *xzero,
                   int *fevals
                   );

  int HypersphericalExplicit(int K,int l, double beta,double x, double *Phi);

  int hyperspherical_get_xmin_from_approx(int K,
                                          int l,
                                          double nu,
                                          double ignore1,
                                          double phiminabs,
                                          double *xmin,
                                          int *ignore2);

  size_t hyperspherical_HIS_size(int nl, int nx);
  int hyperspherical_update_pointers(HyperInterpStruct *pHIS_local,
                                     void * HIS_storage_shared);

  int hyperspherical_Hermite_interpolation_vector(HyperInterpStruct *pHIS,
                                                  int nxi,
                                                  int lnum,
                                                  double *xinterp,
                                                  double *Phi,
                                                  double *dPhi,
                                                  double *d2Phi);

  int hyperspherical_Hermite3_interpolation_vector_Phi(HyperInterpStruct *pHIS,int nxi,int lnum,double *xinterp,double *Phi, ErrorMsg error_message);
  int hyperspherical_Hermite3_interpolation_vector_dPhi(HyperInterpStruct *pHIS,int nxi,int lnum,double *xinterp,double *dPhi, ErrorMsg error_message);
  int hyperspherical_Hermite3_interpolation_vector_d2Phi(HyperInterpStruct *pHIS,int nxi,int lnum,double *xinterp,double *d2Phi, ErrorMsg error_message);
  int hyperspherical_Hermite3_interpolation_vector_PhidPhi(HyperInterpStruct *pHIS,int nxi,int lnum,double *xinterp,double *Phi,double *dPhi, ErrorMsg error_message);
  int hyperspherical_Hermite3_interpolation_vector_Phid2Phi(HyperInterpStruct *pHIS,int nxi,int lnum,double *xinterp,double *Phi,double *d2Phi, ErrorMsg error_message);
  int hyperspherical_Hermite3_interpolation_vector_dPhid2Phi(HyperInterpStruct *pHIS,int nxi,int lnum,double *xinterp,double *dPhi,double *d2Phi, ErrorMsg error_message);
  int hyperspherical_Hermite3_interpolation_vector_PhidPhid2Phi(HyperInterpStruct *pHIS,int nxi,int lnum,double *xinterp,double *Phi,double *dPhi,double *d2Phi, ErrorMsg error_message);
  int hyperspherical_Hermite4_interpolation_vector_Phi(HyperInterpStruct *pHIS,int nxi,int lnum,double *xinterp,double *Phi, ErrorMsg error_message);
  int hyperspherical_Hermite4_interpolation_vector_dPhi(HyperInterpStruct *pHIS,int nxi,int lnum,double *xinterp,double *dPhi, ErrorMsg error_message);
  int hyperspherical_Hermite4_interpolation_vector_d2Phi(HyperInterpStruct *pHIS,int nxi,int lnum,double *xinterp,double *d2Phi, ErrorMsg error_message);
  int hyperspherical_Hermite4_interpolation_vector_PhidPhi(HyperInterpStruct *pHIS,int nxi,int lnum,double *xinterp,double *Phi,double *dPhi, ErrorMsg error_message);
  int hyperspherical_Hermite4_interpolation_vector_Phid2Phi(HyperInterpStruct *pHIS,int nxi,int lnum,double *xinterp,double *Phi,double *d2Phi, ErrorMsg error_message);
  int hyperspherical_Hermite4_interpolation_vector_dPhid2Phi(HyperInterpStruct *pHIS,int nxi,int lnum,double *xinterp,double *dPhi,double *d2Phi, ErrorMsg error_message);
  int hyperspherical_Hermite4_interpolation_vector_PhidPhid2Phi(HyperInterpStruct *pHIS,int nxi,int lnum,double *xinterp,double *Phi,double *dPhi,double *d2Phi, ErrorMsg error_message);
  int hyperspherical_Hermite6_interpolation_vector_Phi(HyperInterpStruct *pHIS,int nxi,int lnum,double *xinterp,double *Phi, ErrorMsg error_message);
  int hyperspherical_Hermite6_interpolation_vector_dPhi(HyperInterpStruct *pHIS,int nxi,int lnum,double *xinterp,double *dPhi, ErrorMsg error_message);
  int hyperspherical_Hermite6_interpolation_vector_d2Phi(HyperInterpStruct *pHIS,int nxi,int lnum,double *xinterp,double *d2Phi, ErrorMsg error_message);
  int hyperspherical_Hermite6_interpolation_vector_PhidPhi(HyperInterpStruct *pHIS,int nxi,int lnum,double *xinterp,double *Phi,double *dPhi, ErrorMsg error_message);
  int hyperspherical_Hermite6_interpolation_vector_Phid2Phi(HyperInterpStruct *pHIS,int nxi,int lnum,double *xinterp,double *Phi,double *d2Phi, ErrorMsg error_message);
  int hyperspherical_Hermite6_interpolation_vector_dPhid2Phi(HyperInterpStruct *pHIS,int nxi,int lnum,double *xinterp,double *dPhi,double *d2Phi, ErrorMsg error_message);
  int hyperspherical_Hermite6_interpolation_vector_PhidPhid2Phi(HyperInterpStruct *pHIS,int nxi,int lnum,double *xinterp,double *Phi,double *dPhi,double *d2Phi, ErrorMsg error_message);


#ifdef __cplusplus
}
#endif

#endif

```

`include/input.h`:

```h
/** @file input.h Documented includes for input module */

#ifndef __INPUT__
#define __INPUT__

#include "common.h"
#include "parser.h"

#define _N_FILEROOT_ 100 /* Number of files that will be not overwritten for a given root */

/* macro for reading parameter values with routines from the parser */

#define class_read_double(name,destination)                                     \
  do {                                                                          \
    double param_temp; int flag_temp;                                           \
    class_call(parser_read_double(pfc,name,&param_temp,&flag_temp,errmsg),      \
               errmsg,                                                          \
               errmsg);                                                         \
    if (flag_temp == _TRUE_){                                                   \
      destination = param_temp;                                                 \
    }                                                                           \
  } while(0);


#define class_read_int(name,destination)                                        \
  do {                                                                          \
    int int_temp,flag_temp;                                                     \
    class_call(parser_read_int(pfc,name,&int_temp,&flag_temp,errmsg),           \
               errmsg,                                                          \
               errmsg);                                                         \
    if (flag_temp == _TRUE_){                                                   \
      destination = int_temp;                                                   \
    }                                                                           \
  } while(0);

#define class_read_string(name,destination)                                     \
  do {                                                                          \
    char string_temp[_ARGUMENT_LENGTH_MAX_]; int flag_temp;                     \
    class_call(parser_read_string(pfc,name,&string_temp,&flag_temp,errmsg),     \
               errmsg,                                                          \
               errmsg);                                                         \
    if (flag_temp == _TRUE_){                                                   \
      strcpy(destination,string_temp);                                          \
    }                                                                           \
  } while(0);

#define class_read_flag(name,destination)                                       \
  do {                                                                          \
    char string_temp[_ARGUMENT_LENGTH_MAX_]; int flag_temp;                     \
    class_call(parser_read_string(pfc,name,&string_temp,&flag_temp,errmsg),     \
               errmsg,                                                          \
               errmsg);                                                         \
    if (flag_temp == _TRUE_){                                                   \
      if (string_begins_with(string_temp,'y')                                   \
         || string_begins_with(string_temp,'Y') ){                              \
        destination = _TRUE_;                                                   \
      }                                                                         \
      else if (string_begins_with(string_temp,'n')                              \
         || string_begins_with(string_temp,'N') ){                              \
        destination = _FALSE_;                                                  \
      }                                                                         \
      else {                                                                    \
        class_stop(errmsg,"incomprehensible input '%s' for the field '%s'.",    \
                   string_temp, name);                                          \
      }                                                                         \
    }                                                                           \
  } while(0);

#define class_read_flag_or_deprecated(name,oldname,destination)                 \
  do {                                                                          \
    char string_temp[_ARGUMENT_LENGTH_MAX_]; int flag_temp;                     \
    class_call(parser_read_string(pfc,name,&string_temp,&flag_temp,errmsg),     \
               errmsg,                                                          \
               errmsg);                                                         \
    /* Compatibility code BEGIN */                                              \
    if (flag_temp == _FALSE_){                                                   \
      class_call(parser_read_string(pfc,oldname,&string_temp,&flag_temp,errmsg),\
                 errmsg,                                                        \
                 errmsg);                                                       \
    }                                                                           \
    /* Compatibility code END */                                                \
    if (flag_temp == _TRUE_){                                                   \
      if (string_begins_with(string_temp,'y')                                   \
         || string_begins_with(string_temp,'Y') ){                              \
        destination = _TRUE_;                                                   \
      }                                                                         \
      else if (string_begins_with(string_temp,'n')                              \
         || string_begins_with(string_temp,'N') ){                              \
        destination = _FALSE_;                                                  \
      }                                                                         \
      else {                                                                    \
        class_stop(errmsg,"incomprehensible input '%s' for the field '%s'.",    \
                   string_temp, name);                                          \
      }                                                                         \
    }                                                                           \
  } while(0);

#define class_read_double_one_of_two(name1,name2,destination)                   \
  do {                                                                          \
    int flag_temp1,flag_temp2;                                                  \
    double param_temp1,param_temp2;                                             \
    class_call(parser_read_double(pfc,name1,&param_temp1,&flag_temp1,errmsg),   \
               errmsg,                                                          \
               errmsg);                                                         \
    class_call(parser_read_double(pfc,name2,&param_temp2,&flag_temp2,errmsg),   \
               errmsg,                                                          \
               errmsg);                                                         \
    class_test((flag_temp1 == _TRUE_) && (flag_temp2 == _TRUE_),                \
               errmsg,                                                          \
               "You can only enter one of '%s' or '%s'.",                       \
               name1,name2);                                                    \
    if (flag_temp1 == _TRUE_){                                                  \
      destination = param_temp1;                                                \
    }                                                                           \
    if (flag_temp2 == _TRUE_){                                                  \
      destination = param_temp2;                                                \
    }                                                                           \
  } while(0);

#define class_at_least_two_of_three(a,b,c)                                      \
  (((a) == _TRUE_) && ((b) == _TRUE_)) ||                                       \
  (((a) == _TRUE_) && ((c) == _TRUE_)) ||                                       \
  (((b) == _TRUE_) && ((c) == _TRUE_))

#define class_none_of_three(a,b,c)                                              \
  ((a) == _FALSE_) && ((b) == _FALSE_) && ((c) == _FALSE_)

#define class_read_list_of_doubles_or_default(name,destination,val_default,siz) \
  do {                                                                          \
    int flag_temp,entries_read_temp;                                            \
    class_call(parser_read_list_of_doubles(pfc,name,                            \
                                           &entries_read_temp,                  \
                                           &(destination),                      \
                                           &flag_temp,                          \
                                           errmsg),                             \
               errmsg,                                                          \
               errmsg);                                                         \
    if (flag_temp == _TRUE_){                                                   \
      class_test(entries_read_temp != siz, errmsg,                              \
                 "Number of entries of '%s' (%d) does not match expected number (%d).", \
                 name, entries_read_temp, siz);                                 \
    }else{                                                                      \
      class_alloc(destination,siz*sizeof(double),errmsg);                       \
      for (n=0; n<siz; n++){destination[n] = val_default;}                       \
    }                                                                           \
  } while(0);

#define class_read_list_of_integers_or_default(name,destination,val_default,siz)\
  do {                                                                          \
    int flag_temp,entries_read_temp;                                            \
    class_call(parser_read_list_of_integers(pfc,name,                           \
                                            &entries_read_temp,                 \
                                            &(destination),                     \
                                            &flag_temp,                         \
                                            errmsg),                            \
               errmsg,                                                          \
               errmsg);                                                         \
    if (flag_temp == _TRUE_){                                                   \
      class_test(entries_read_temp != siz, errmsg,                              \
                 "Number of entries of '%s' (%d) does not match expected number (%d).", \
                 name, entries_read_temp, siz);                                 \
    }else{                                                                      \
      class_alloc(destination,siz*sizeof(int),errmsg);                          \
      for (n=0; n<siz; n++){destination[n] = val_default;}                       \
    }                                                                           \
  } while(0);

#define class_read_list_of_doubles(name,destination,siz)                        \
  do {                                                                          \
    int flag_temp,entries_read_temp;                                            \
    class_call(parser_read_list_of_doubles(pfc,name,                            \
                                           &entries_read_temp,                  \
                                           &(destination),                      \
                                           &flag_temp,                          \
                                           errmsg),                             \
               errmsg,                                                          \
               errmsg);                                                         \
    class_test(flag_temp == _FALSE_, errmsg,                                    \
               "Entry '%s' is required but not found!", name)                   \
    class_test(entries_read_temp != siz, errmsg,                                \
               "Number of entries of '%s' (%d) does not match expected number (%d).", \
               name,entries_read_temp, siz);                                    \
  } while(0);

#define class_read_list_of_integers(name,destination,siz)                       \
  do {                                                                          \
    int flag_temp,entries_read_temp;                                            \
    class_call(parser_read_list_of_integers(pfc,name,                           \
                                            &entries_read_temp,                 \
                                            &(destination),                     \
                                            &flag_temp,                         \
                                            errmsg),                            \
               errmsg,                                                          \
               errmsg);                                                         \
    class_test(flag_temp == _FALSE_, errmsg,                                    \
               "Entry '%s' is required but not found!", name)                   \
    class_test(entries_read_temp != siz, errmsg,                                \
               "Number of entries of '%s' (%d) does not match expected number (%d).", \
               name,entries_read_temp, siz);                                    \
  } while(0);

/**
 * For shooting method: definition of the possible targets
 */

enum target_names {theta_s, theta_s_100, Neff, Omega_dcdmdr, omega_dcdmdr, Omega_scf, Omega_ini_dcdm, omega_ini_dcdm, sigma8, S8};
/* Important: Keep this number equal to the number of target_names (except sigma8, S8), and keep sigma8, S8 at the very end */
#define _NUM_TARGETS_ 8

/* Until which class stage is being computed? Pretty much fixed list, don't change. */
enum computation_stage {cs_background, cs_thermodynamics, cs_perturbations, cs_primordial, cs_nonlinear, cs_transfer, cs_spectra};

/**
 * Structure for all temporary parameters for background fzero function
 */

struct fzerofun_workspace {
  int * unknown_parameters_index;
  struct file_content fc;
  enum target_names * target_name;
  double * target_value;
  int target_size;
  enum computation_stage required_computation_stage;
};

/**************************************************************/
/* @cond INCLUDE_WITH_DOXYGEN */
/*
 * Boilerplate for C++
 */
#ifdef __cplusplus
extern "C" {
#endif

  /* Main functions */

  int input_init(int argc,
                 char **argv,
                 struct precision * ppr,
                 struct background * pba,
                 struct thermodynamics * pth,
                 struct perturbations * ppt,
                 struct transfer * ptr,
                 struct primordial * ppm,
                 struct harmonic * phr,
                 struct fourier * pfo,
                 struct lensing *ple,
                 struct distortions *psd,
                 struct output *pop,
                 ErrorMsg errmsg);

  /* Note that the input module does not require an input_free() */

  int input_find_file(int argc,
                      char ** argv,
                      struct file_content * fc,
                      ErrorMsg errmsg);

  int input_set_root(char* input_file,
                     struct file_content** ppfc_input,
                     struct file_content* pfc_setroot,
                     ErrorMsg errmsg);

  int input_read_from_file(struct file_content * pfc,
                           struct precision * ppr,
                           struct background *pba,
                           struct thermodynamics *pth,
                           struct perturbations *ppt,
                           struct transfer *ptr,
                           struct primordial *ppm,
                           struct harmonic *phr,
                           struct fourier *pfo,
                           struct lensing *ple,
                           struct distortions *psd,
                           struct output *pop,
                           ErrorMsg errmsg);

  /* Functions related to shooting */

  int input_shooting(struct file_content * pfc,
                     struct precision * ppr,
                     struct background * pba,
                     struct thermodynamics * pth,
                     struct perturbations * ppt,
                     struct transfer * ptr,
                     struct primordial * ppm,
                     struct harmonic * phr,
                     struct fourier * pfo,
                     struct lensing *ple,
                     struct distortions *psd,
                     struct output *pop,
                     int input_verbose,
                     int * has_shooting,
                     ErrorMsg errmsg);

  int input_needs_shooting_for_target(struct file_content * pfc,
                                      enum target_names target_name,
                                      double target_value,
                                      int * aux_flag,
                                      ErrorMsg errmsg);

  int input_find_root(double * xzero,
                      int * fevals,
                      double tol_x_rel,
                      struct fzerofun_workspace * pfzw,
                      ErrorMsg errmsg);

  int input_fzerofun_1d(double input,
                        void * fzerofun_workspace,
                        double * output,
                        ErrorMsg error_message);

  int input_fzero_ridder(int (*func)(double x,
                                     void * param,
                                     double * y,
                                     ErrorMsg error_message),
                         double x1,
                         double x2,
                         double xtol,
                         void * param,
                         double * Fx1,
                         double * Fx2,
                         double * xzero,
                         int * fevals,
                         ErrorMsg error_message);

  int input_get_guess(double * xguess,
                      double * dxdy,
                      struct fzerofun_workspace * pfzw,
                      ErrorMsg errmsg);

  int input_try_unknown_parameters(double * unknown_parameter,
                                   int unknown_parameters_size,
                                   void * pfzw,
                                   double * output,
                                   ErrorMsg errmsg);

  /* Read from precision.h */

  int input_read_precisions(struct file_content * pfc,
                            struct precision * ppr,
                            struct background * pba,
                            struct thermodynamics * pth,
                            struct perturbations * ppt,
                            struct transfer * ptr,
                            struct primordial * ppm,
                            struct harmonic * phr,
                            struct fourier * pfo,
                            struct lensing * ple,
                            struct distortions *psd,
                            struct output * pop,
                            ErrorMsg errmsg);

  /* Read from .ini file */

  int input_read_parameters(struct file_content * pfc,
                            struct precision * ppr,
                            struct background * pba,
                            struct thermodynamics * pth,
                            struct perturbations * ppt,
                            struct transfer * ptr,
                            struct primordial * ppm,
                            struct harmonic * phr,
                            struct fourier * pfo,
                            struct lensing * ple,
                            struct distortions *psd,
                            struct output * pop,
                            ErrorMsg errmsg);

  int input_read_parameters_general(struct file_content * pfc,
                                    struct background * pba,
                                    struct thermodynamics * pth,
                                    struct perturbations * ppt,
                                    struct distortions * psd,
                                    ErrorMsg errmsg);

  int input_read_parameters_species(struct file_content * pfc,
                                    struct precision * ppr,
                                    struct background * pba,
                                    struct thermodynamics * pth,
                                    struct perturbations * ppt,
                                    int input_verbose,
                                    ErrorMsg errmsg);

  int input_read_parameters_injection(struct file_content * pfc,
                                      struct precision * ppr,
                                      struct thermodynamics * pth,
                                      ErrorMsg errmsg);

  int input_read_parameters_nonlinear(struct file_content * pfc,
                                      struct precision * ppr,
                                      struct background * pba,
                                      struct thermodynamics * pth,
                                      struct perturbations * ppt,
                                      struct fourier * pfo,
                                      int input_verbose,
                                      ErrorMsg errmsg);

  int input_prepare_pk_eq(struct precision * ppr,
                          struct background * pba,
                          struct thermodynamics * pth,
                          struct fourier * pfo,
                          int input_verbose,
                          ErrorMsg errmsg);

  int input_read_parameters_primordial(struct file_content * pfc,
                                       struct perturbations * ppt,
                                       struct primordial * ppm,
                                       ErrorMsg errmsg);

  int input_read_parameters_spectra(struct file_content * pfc,
                                    struct precision * ppr,
                                    struct background * pba,
                                    struct primordial * ppm,
                                    struct perturbations * ppt,
                                    struct transfer * ptr,
                                    struct harmonic * phr,
                                    struct output * pop,
                                    ErrorMsg errmsg);

  int input_read_parameters_lensing(struct file_content * pfc,
                                    struct precision * ppr,
                                    struct perturbations * ppt,
                                    struct transfer * ptr,
                                    struct lensing * ple,
                                    ErrorMsg errmsg);

  int input_read_parameters_distortions(struct file_content * pfc,
                                        struct precision * ppr,
                                        struct distortions * psd,
                                        ErrorMsg errmsg);

  int input_read_parameters_additional(struct file_content * pfc,
                                       struct precision * ppr,
                                       struct background * pba,
                                       struct thermodynamics * pth,
                                       ErrorMsg errmsg);

  int input_read_parameters_output(struct file_content * pfc,
                                   struct background * pba,
                                   struct thermodynamics * pth,
                                   struct perturbations * ppt,
                                   struct transfer * ptr,
                                   struct primordial * ppm,
                                   struct harmonic * phr,
                                   struct fourier * pfo,
                                   struct lensing *ple,
                                   struct distortions *psd,
                                   struct output *pop,
                                   ErrorMsg errmsg);

  int input_write_info(struct file_content * pfc,
                       struct output * pop,
                       ErrorMsg errmsg);

  /* Set default parameters */

  int input_default_params(struct background *pba,
                           struct thermodynamics *pth,
                           struct perturbations *ppt,
                           struct transfer *ptr,
                           struct primordial *ppm,
                           struct harmonic *phr,
                           struct fourier *pfo,
                           struct lensing *ple,
                           struct distortions *psd,
                           struct output *pop);

  /* get version number */

  int class_version( char * version);

#ifdef __cplusplus
}
#endif

/**************************************************************/

#endif
/* @endcond */

```

`include/lensing.h`:

```h
/** @file lensing.h Documented includes for harmonic module */

#ifndef __LENSING__
#define __LENSING__

#include "harmonic.h"

/**
 * Structure containing everything about lensed spectra that other modules need to know.
 *
 * Once initialized by lensing_init(), contains a table of all lensed
 * \f$ C_l\f$'s for the all modes (scalar/tensor), all types (TT, TE...),
 * and all pairs of initial conditions (adiabatic, isocurvatures...).
 * FOR THE MOMENT, ASSUME ONLY SCALAR & ADIABATIC
 */

struct lensing {

  /** @name - input parameters initialized by user in input module
   *  (all other quantities are computed in this module, given these
   *  parameters and the content of the 'precision', 'background' and
   *  'thermodynamics' structures) */

  //@{

  short has_lensed_cls; /**< do we need to compute lensed \f$ C_l\f$'s at all ? */

  //@}

  /** @name - information on number of type of C_l's (TT, TE...) */

  //@{

  int has_tt; /**< do we want lensed \f$ C_l^{TT}\f$? (T = temperature) */
  int has_ee; /**< do we want lensed \f$ C_l^{EE}\f$? (E = E-polarization) */
  int has_te; /**< do we want lensed \f$ C_l^{TE}\f$? */
  int has_bb; /**< do we want \f$ C_l^{BB}\f$? (B = B-polarization) */
  int has_pp; /**< do we want \f$ C_l^{\phi\phi}\f$? (\f$ \phi \f$ = CMB lensing potential) */
  int has_tp; /**< do we want \f$ C_l^{T\phi}\f$? */
  int has_dd; /**< do we want \f$ C_l^{dd}\f$? (d = matter density) */
  int has_td; /**< do we want \f$ C_l^{Td}\f$? */
  int has_ll; /**< do we want \f$ C_l^{ll}\f$? (l = lensing potential) */
  int has_tl; /**< do we want \f$ C_l^{Tl}\f$? */

  int index_lt_tt; /**< index for type \f$ C_l^{TT} \f$*/
  int index_lt_ee; /**< index for type \f$ C_l^{EE} \f$*/
  int index_lt_te; /**< index for type \f$ C_l^{TE} \f$*/
  int index_lt_bb; /**< index for type \f$ C_l^{BB} \f$*/
  int index_lt_pp; /**< index for type \f$ C_l^{\phi\phi} \f$*/
  int index_lt_tp; /**< index for type \f$ C_l^{T\phi} \f$*/
  int index_lt_dd; /**< index for type \f$ C_l^{dd} \f$*/
  int index_lt_td; /**< index for type \f$ C_l^{Td} \f$*/
  int index_lt_ll; /**< index for type \f$ C_l^{dd} \f$*/
  int index_lt_tl; /**< index for type \f$ C_l^{Td} \f$*/

  int lt_size; /**< number of \f$ C_l\f$ types requested */

  //@}

  /** @name - table of pre-computed C_l values, and related quantities */

  //@{

  int l_unlensed_max;    /**< last multipole in all calculations (same as in harmonic module)*/

  int l_lensed_max;    /**< last multipole at which lensed spectra are computed */

  /* interpolable version: */

  int l_size;       /**< number of l values */

  int * l_max_lt;    /**< last multipole (given as an input) at which
                        we want to output \f$ C_l \f$'s for a given mode and type */

  double * l;       /**< table of multipole values l[index_l] */
  double * cl_lens; /**< table of anisotropy spectra for each
                       multipole and types,
                       cl[index_l * ple->lt_size + index_lt] */

  double * ddcl_lens; /**< second derivatives for interpolation */

  //@}

  /** @name - technical parameters */

  //@{

  short lensing_verbose; /**< flag regulating the amount of information sent to standard output (none if set to zero) */

  ErrorMsg error_message; /**< zone for writing error messages */

  short is_allocated; /**< flag is set to true if allocated */

  //@}
};

/*************************************************************************************************************/
/* @cond INCLUDE_WITH_DOXYGEN */
/*
 * Boilerplate for C++
 */
#ifdef __cplusplus
extern "C" {
#endif

  int lensing_cl_at_l(
                      struct lensing * ple,
                      int l,
                      double * cl_lensed
                      );

  int lensing_init(
                   struct precision * ppr,
                   struct perturbations * ppt,
                   struct harmonic * phr,
                   struct fourier * pfo,
                   struct lensing * ple
                   );

  int lensing_free(
                   struct lensing * ple
                   );

  int lensing_indices(
                      struct precision * ppr,
                      struct harmonic * phr,
                      struct lensing * ple
                      );

  int lensing_lensed_cl_tt(
                           double *ksi,
                           double **d00,
                           double *w8,
                           int nmu,
                           struct lensing * ple
                           );

  int lensing_lensed_cl_te(
                           double *ksiX,
                           double **d20,
                           double *w8,
                           int nmu,
                           struct lensing * ple
                           );

  int lensing_lensed_cl_ee_bb(
                              double *ksip,
                              double *ksim,
                              double **d22,
                              double **d2m2,
                              double *w8,
                              int nmu,
                              struct lensing * ple
                              );
  int lensing_addback_cl_tt(
                            struct lensing *ple,
                            double *cl_tt
                            );

  int lensing_addback_cl_te(
                            struct lensing *ple,
                            double *cl_te
                            );

  int lensing_addback_cl_ee_bb(
                               struct lensing *ple,
                               double *cl_ee,
                               double *cl_bb
                               );


  int lensing_X000(
                   double * mu,
                   int num_mu,
                   int lmax,
                   double * sigma2,
                   double ** X000
                   );

  int lensing_Xp000(
                    double * mu,
                    int num_mu,
                    int lmax,
                    double * sigma2,
                    double ** Xp000
                    );

  int lensing_X220(
                   double * mu,
                   int num_mu,
                   int lmax,
                   double * sigma2,
                   double ** X220
                   );

  int lensing_X022(
                   double * mu,
                   int num_mu,
                   int lmax,
                   double * sigma2,
                   double ** X022
                   );

  int lensing_Xp022(
                    double * mu,
                    int num_mu,
                    int lmax,
                    double * sigma2,
                    double ** Xp022
                    );

  int lensing_X121(
                   double * mu,
                   int num_mu,
                   int lmax,
                   double * sigma2,
                   double ** X121
                   );

  int lensing_X132(
                   double * mu,
                   int num_mu,
                   int lmax,
                   double * sigma2,
                   double ** X132
                   );

  int lensing_X242(
                   double * mu,
                   int num_mu,
                   int lmax,
                   double * sigma2,
                   double ** X242
                   );

  int lensing_d00(
                  double * mu,
                  int num_mu,
                  int lmax,
                  double ** d00
                  );

  int lensing_d11(
                  double * mu,
                  int num_mu,
                  int lmax,
                  double ** d11
                  );

  int lensing_d1m1(
                   double * mu,
                   int num_mu,
                   int lmax,
                   double ** d1m1
                   );

  int lensing_d2m2(
                   double * mu,
                   int num_mu,
                   int lmax,
                   double ** d2m2
                   );

  int lensing_d22(
                  double * mu,
                  int num_mu,
                  int lmax,
                  double ** d22
                  );

  int lensing_d20(
                  double * mu,
                  int num_mu,
                  int lmax,
                  double ** d20
                  );

  int lensing_d31(
                  double * mu,
                  int num_mu,
                  int lmax,
                  double ** d3m1
                  );

  int lensing_d3m1(
                   double * mu,
                   int num_mu,
                   int lmax,
                   double ** d3m1
                   );

  int lensing_d3m3(
                   double * mu,
                   int num_mu,
                   int lmax,
                   double ** d3m3
                   );

  int lensing_d40(
                  double * mu,
                  int num_mu,
                  int lmax,
                  double ** d40
                  );

  int lensing_d4m2(
                   double * mu,
                   int num_mu,
                   int lmax,
                   double ** d4m2
                   );

  int lensing_d4m4(
                   double * mu,
                   int num_mu,
                   int lmax,
                   double ** d4m4
                   );

#ifdef __cplusplus
}
#endif

#endif
/* @endcond */

```

`include/macros_precision.h`:

```h
/**
 * This file should not be modified
 * */

#ifdef __ASSIGN_DEFAULT_PRECISION__      
#define class_precision_parameter(NAME,TYPE,DEF_VALUE)          \
ppr->NAME = DEF_VALUE;                       
#endif                                        
#ifdef __ALLOCATE_PRECISION_PARAMETER__      
#define class_precision_parameter(NAME,TYPE,DEF_VALUE)          \
TYPE NAME;                                    
#endif
#ifdef __PARSE_PRECISION_PARAMETER__
#define class_precision_parameter(NAME,TYPE,DEF_VALUE)          \
class_read_ ## TYPE(#NAME,ppr->NAME);
#endif


#ifdef __ASSIGN_DEFAULT_PRECISION__      
#define class_string_parameter(NAME,DIR,STRING)   \
sprintf(ppr->NAME,__CLASSDIR__);                  \
strcat(ppr->NAME,DIR);
#endif                                        
#ifdef __ALLOCATE_PRECISION_PARAMETER__      
#define class_string_parameter(NAME,DIR,STRING)    \
FileName NAME;                                    
#endif
#ifdef __PARSE_PRECISION_PARAMETER__
#define class_string_parameter(NAME,DIR,STRING)     \
class_read_string(STRING,ppr->NAME);
#endif


#ifdef __ASSIGN_DEFAULT_PRECISION__      
#define class_type_parameter(NAME,READ_TP,REAL_TP,DEF_VAL) \
ppr->NAME = DEF_VAL;                       
#endif                                        
#ifdef __ALLOCATE_PRECISION_PARAMETER__      
#define class_type_parameter(NAME,READ_TP,REAL_TP,DEF_VAL) \
REAL_TP NAME;                                    
#endif
#ifdef __PARSE_PRECISION_PARAMETER__
#define class_type_parameter(NAME,READ_TP,REAL_TP,DEF_VAL) \
class_read_ ## READ_TP(#NAME,ppr->NAME);
#endif

```

`include/output.h`:

```h
/** @file output.h Documented includes for output module */

#ifndef __OUTPUT__
#define __OUTPUT__

#include "common.h"
#include "lensing.h"
#include "distortions.h"

/**
 * Maximum number of values of redshift at which the spectra will be
 * written in output files
 */

#define _Z_PK_NUM_MAX_ 100

/**
 * Structure containing various informations on the output format,
 * all of them initialized by user in input module.
 *
 */

struct output {

  //@{

  char root[_FILENAMESIZE_-32]; /**< root for all file names */

  //@}

  /** @name - number and value(s) of redshift at which P(k,z) and T_i(k,z) should be written */

  //@{

  int z_pk_num; /**< number of redshift at which P(k,z) and T_i(k,z) should be written */
  double z_pk[_Z_PK_NUM_MAX_]; /**< value(s) of redshift at which P(k,z) and T_i(k,z) should be written */

  //@}

  /** @name - extra information on output */

  //@{

  short write_header; /**< flag stating whether we should write a header in output files */

  enum file_format output_format; /**< which format for output files (definitions, order of columns, etc.) */

  short write_background; /**< flag for outputing background evolution in file */
  short write_thermodynamics; /**< flag for outputing thermodynamical evolution in file */
  short write_perturbations; /**< flag for outputing perturbations of selected wavenumber(s) in file(s) */
  short write_primordial; /**< flag for outputing scalar/tensor primordial spectra in files */
  short write_exotic_injection; /**< flag for outputing exotic energy injection/deposition in files */
  short write_noninjection; /**< flag for outputing non-injected contributions in files */
  short write_distortions; /**< flag for outputing spectral distortions in files */

  //@}

  /** @name - technical parameters */

  //@{

  short output_verbose; /**< flag regulating the amount of information sent to standard output (none if set to zero) */

  ErrorMsg error_message; /**< zone for writing error messages */

  //@}
};

/*************************************************************************************************************/
/* @cond INCLUDE_WITH_DOXYGEN */
/*
 * Boilerplate for C++
 */
#ifdef __cplusplus
extern "C" {
#endif

  int output_total_cl_at_l(
                           struct harmonic * phr,
                           struct lensing * ple,
                           struct output * pop,
                           int l,
                           double * cl
                           );

  int output_init(
                  struct background * pba,
                  struct thermodynamics * pth,
                  struct perturbations * ppt,
                  struct primordial * ppm,
                  struct transfer * ptr,
                  struct harmonic * phr,
                  struct fourier * pfo,
                  struct lensing * ple,
                  struct distortions * psd,
                  struct output * pop
                  );

  int output_cl(
                struct background * pba,
                struct perturbations * ppt,
                struct harmonic * phr,
                struct lensing * ple,
                struct output * pop
                );

  int output_pk(
                struct background * pba,
                struct perturbations * ppt,
                struct fourier * pfo,
                struct output * pop,
                enum pk_outputs pk_output
                );

  int output_tk(
                struct background * pba,
                struct perturbations * ppt,
                struct output * pop
                );

  int output_background(
                        struct background * pba,
                        struct output * pop
                        );

  int output_thermodynamics(
                            struct background * pba,
                            struct thermodynamics * pth,
                            struct output * pop
                            );

  int output_perturbations(
                           struct background * pba,
                           struct perturbations * ppt,
                           struct output * pop
                           );

  int output_primordial(
                        struct perturbations * ppt,
                        struct primordial * ppm,
                        struct output * pop
                        );

  int output_heating(
                     struct injection* pin,
                     struct noninjection* pni,
                     struct output * pop
                     );

  int output_distortions(
                         struct distortions * psd,
                         struct output * pop
                         );

  int output_print_data(FILE *out,
                        char titles[_MAXTITLESTRINGLENGTH_],
                        double *dataptr,
                        int tau_size);
  int output_open_cl_file(
                          struct harmonic * phr,
                          struct output * pop,
                          FILE ** clfile,
                          FileName filename,
                          char * first_line,
                          int lmax
                          );

  int output_one_line_of_cl(
                            struct background * pba,
                            struct harmonic * phr,
                            struct output * pop,
                            FILE * clfile,
                            double l,
                            double * cl,
                            int ct_size
                            );

  int output_open_pk_file(
                          struct background * pba,
                          struct fourier * pfo,
                          struct output * pop,
                          FILE ** pkfile,
                          FileName filename,
                          char * first_line,
                          double z
                          );

  int output_one_line_of_pk(
                            FILE * tkfile,
                            double one_k,
                            double one_pk
                            );

#ifdef __cplusplus
}
#endif

#endif
/* @endcond */

```

`include/parallel.h`:

```h
// 'MAGIC' parallelization module written by Nils Schöneberg, adapted from the one created by Thomas Tram

//To be used for declaring which arguments a parallel clause 'captures' from the outside
//This would be equivalent to the 'firstprivate' in OPENMP
#define with_arguments(...) __VA_ARGS__
//To declare a list of arguments a parallel clause only has internally
//(necessary since comma-separated lists are interpreted as separate arguments
// except when surrounded by backets as forced by this macro)
#define declare_list_of_variables_inside_parallel_region(...) __VA_ARGS__

// To be called WITHIN a given parallel loop. First argument is the parameters to 'capture',
// corresponding to the 'firstprivate' in OPENMP.
// Usually either '=' to capture all necessary variables, or a list of arguments
// declared within the 'with_arguments' macro for a more precise list
// The second argument is the actual code to execute. That code should be formulated like
// the body of a normal function, e.g. return _SUCCESS_ at the end.
// 'private' arguments in OPENMP can be emulated by just making them local to the function.
// Special care: A list of private arguments needs to be surrounded by the special macro
// 'declare_list_of_variables-inside_parallel_region' due to the peculiarities
// of the C++ preprocessor macros. See examples e.g.
// in source/perturbations.c, source/lensing.c, or tools/hypershperical.c
#define class_run_parallel(arg1, arg2) future_output.push_back(task_system.AsyncTask([arg1] () {arg2}));

// To be called ONLY ONCE without arguments before the intended parallel loop(s).
#define class_setup_parallel()                    \
Tools::TaskSystem task_system;                    \
std::vector<std::future<int>> future_output;

// To be called without arguments AFTER ANY parallel loop in order to actually execute the jobs.
// NEEDS TO BE CALLED BEFORE USING THE RESULTS!
#define class_finish_parallel()                   \
for (std::future<int>& future : future_output) {  \
  if(future.get()!=_SUCCESS_) return _FAILURE_;   \
}                                                 \
future_output.clear();

//
//  thread_pool.h
//  ppCLASS
//
//  Created by Thomas Tram on 02/03/2020.
//  Copyright 2020 Aarhus University. All rights reserved.
//
#ifndef THREAD_POOL_H
#define THREAD_POOL_H
#include <atomic>
#include <condition_variable>
#include <deque>
#include <functional>
#include <future>
#include <mutex>
#include <thread>
#include <utility>
#include <vector>

namespace Tools {

class NotificationQueue {
public:
  bool TryPop(std::function<void()>& x) {
    std::unique_lock<std::mutex> lock(mutex_, std::try_to_lock);
    if (!lock || queue_.empty()) {
      return false;
    }
    x = std::move(queue_.front());
    queue_.pop_front();
    return true;
  }

  bool Pop(std::function<void()>& x) {
    std::unique_lock<std::mutex> lock(mutex_);
    while (queue_.empty() && !done_) {
      ready_.wait(lock);
    }
    if (queue_.empty()) {
      return false;
    }
    x = std::move(queue_.front());
    queue_.pop_front();
    return true;
  }

  template<typename F>
  bool TryPush(F&& f) {
    {
      std::unique_lock<std::mutex> lock(mutex_, std::try_to_lock);
      if (!lock) {
        return false;
      }
      queue_.emplace_back(std::forward<F>(f));
    }
    ready_.notify_one();
    return true;
  }

  template<typename F>
  void Push(F&& f) {
    {
      std::unique_lock<std::mutex> lock(mutex_);
      queue_.emplace_back(std::forward<F>(f));
    }
    ready_.notify_one();
  }

  void Done() {
    {
      std::unique_lock<std::mutex> lock(mutex_);
      done_ = true;
    }
    ready_.notify_all();
  }
private:
  std::deque<std::function<void()>> queue_;
  bool done_ = false;
  std::mutex mutex_;
  std::condition_variable ready_;
};

class TaskSystem {
public:
  TaskSystem(unsigned int count = GetNumThreads())
  : count_(count)
  , index_(0)
  , queues_{count_} {
    for (unsigned int n = 0; n < count_; ++n) {
      threads_.emplace_back([&, n]{ Run(n); });
    }
  }

  ~TaskSystem() {
    for (auto& e : queues_) e.Done();
    for (auto& e : threads_) e.join();
  }

  static unsigned int GetNumThreads() {
    unsigned int number_of_threads = std::thread::hardware_concurrency();
    for (const std::string& env_var_name : {"OMP_NUM_THREADS", "SLURM_CPUS_PER_TASK"}) {
      if (char* s = std::getenv(env_var_name.c_str())) {
        int threads = std::atoi(s);
        if ((threads > 0) && (threads <= 8192)) {
          number_of_threads = threads;
          break;
        }
      }
    }
    return number_of_threads;
  }

  template <typename F>
  void Async(F&& f) {
    auto i = index_++;
    for (unsigned int n = 0; n < count_; ++n) {
      if (queues_[(i + n) % count_].TryPush(std::forward<F>(f))) {
        return;
      }
    }
    queues_[i % count_].Push(std::forward<F>(f));
  }

  template<typename F>
  std::future<typename std::result_of<F()>::type> AsyncTask(F&& f) {
    using return_type = typename std::result_of<F()>::type;
    auto task = std::make_shared<std::packaged_task<return_type()>>(f);
    std::future<return_type> res = task->get_future();

    auto work = [task](){ (*task)(); };
    unsigned int i = index_++;
    for(unsigned int n = 0; n < count_; ++n) {
      if(queues_[(i + n) % count_].TryPush(work)){
        return res;
      }
    }
    queues_[i % count_].Push(work);

    return res;
  }

  template<typename F, typename... Args>
  std::future<typename std::result_of<F(Args...)>::type> AsyncTask(F&& f, Args&&... args) {
    using return_type = typename std::result_of<F(Args...)>::type;
    auto task = std::make_shared<std::packaged_task<return_type()>>(std::bind(std::forward<F>(f), std::forward<Args>(args)...));
    std::future<return_type> res = task->get_future();

    auto work = [task](){ (*task)(); };
    unsigned int i = index_++;
    for(unsigned int n = 0; n < count_; ++n) {
      if(queues_[(i + n) % count_].TryPush(work)){
        return res;
      }
    }
    queues_[i % count_].Push(work);

    return res;
  }

  unsigned int get_num_threads(){
    return count_;
  }

private:
  void Run(unsigned int i) {
    while (true) {
      std::function<void()> f;
      for (unsigned n = 0; n != count_; ++n) {
        if (queues_[(i + n) % count_].TryPop(f)) {
          break;
        }
      }
      if (!f && !queues_[i].Pop(f)) {
        break;
      }
      f();
    }
  }

  const unsigned int count_;
  std::vector<std::thread> threads_;
  std::atomic<unsigned int> index_;
  std::vector<NotificationQueue> queues_;
};

}
#endif

```

`include/parser.h`:

```h
#ifndef __PARSER__
#define __PARSER__

#include "common.h"

#define _LINE_LENGTH_MAX_ 1024 /**< size of the string read in each line of the file (extra characters not taken into account) */
#define _ARGUMENT_LENGTH_MAX_ 1024 /**< maximum size of each argument (name or value), including the final null character */

typedef char FileArg[_ARGUMENT_LENGTH_MAX_];

/* after reading a given file, all relevant information stored in this structure, in view of being processed later*/
struct file_content {
  char * filename;
  int size;
  FileArg * name;      /**< list of (size) names */
  FileArg * value;     /**< list of (size) values */
  short * read;        /**< set to _TRUE_ if this parameter is effectively read */
};

/**************************************************************/

/*
 * Boilerplate for C++
 */
#ifdef __cplusplus
extern "C" {
#endif

  int parser_init(struct file_content * pfc,
                  int size,
                  char * filename,
                  ErrorMsg errmsg);

  int parser_free(struct file_content * pfc);


  int parser_read_file(char * filename,
                       struct file_content * pfc,
                       ErrorMsg errmsg);

  int parser_read_line(char * line,
                       int * is_data,
                       char * name,
                       char * value,
                       ErrorMsg errmsg);

  int parser_read_int(struct file_content * pfc,
                      char * name,
                      int * value,
                      int * found,
                      ErrorMsg errmsg);

  int parser_read_double(struct file_content * pfc,
                         char * name,
                         double * value,
                         int * found,
                         ErrorMsg errmsg);

  int parser_read_double_and_position(struct file_content * pfc,
                                      char * name,
                                      double * value,
                                      int * position,
                                      int * found,
                                      ErrorMsg errmsg);

  int parser_read_string(struct file_content * pfc,
                         char * name,
                         FileArg * value,
                         int * found,
                         ErrorMsg errmsg);

  int parser_read_list_of_doubles(struct file_content * pfc,
                                  char * name,
                                  int * size,
                                  double ** pointer_to_list,
                                  int * found,
                                  ErrorMsg errmsg);

  int parser_read_list_of_integers(struct file_content * pfc,
                                   char * name,
                                   int * size,
                                   int ** pointer_to_list,
                                   int * found,
                                   ErrorMsg errmsg);

  int parser_read_list_of_strings(struct file_content * pfc,
                                  char * name,
                                  int * size,
                                  char ** pointer_to_list,
                                  int * found,
                                  ErrorMsg errmsg);

  int parser_cat(struct file_content * pfc1,
                 struct file_content * pfc2,
                 struct file_content * pfc3,
                 ErrorMsg errmsg);

  int parser_check_options(char * strinput,
                           char ** options,
                           int N_options,
                           int* valid);

  int parser_extend(struct file_content * pfc,
                    int N_extend,
                    ErrorMsg errmsg);

  int parser_copy(struct file_content * pfc_source,
                  struct file_content * pfc_destination,
                  int index_start,
                  int index_end);

  int parser_init_from_pfc(struct file_content * pfc_source,
                           struct file_content * pfc_destination,
                           ErrorMsg errmsg);

#ifdef __cplusplus
}
#endif

#endif

```

`include/perturbations.h`:

```h
/** @file perturbations.h Documented includes for perturbation module */

#ifndef __PERTURBATIONS__
#define __PERTURBATIONS__

#include "thermodynamics.h"

#define _scalars_ ((ppt->has_scalars == _TRUE_) && (index_md == ppt->index_md_scalars))
#define _vectors_ ((ppt->has_vectors == _TRUE_) && (index_md == ppt->index_md_vectors))
#define _tensors_ ((ppt->has_tensors == _TRUE_) && (index_md == ppt->index_md_tensors))

#define _set_source_(index) ppt->sources[index_md][index_ic * ppt->tp_size[index_md] + index][index_tau * ppt->k_size[index_md] + index_k]

/**
 * flags for various approximation schemes
 * (tca = tight-coupling approximation,
 *  rsa = radiation streaming approximation,
 *  ufa = massless neutrinos / ultra-relativistic relics fluid approximation)
 *
 * CAUTION: must be listed below in chronological order, and cannot be
 * reversible. When integrating equations for a given mode, it is only
 * possible to switch from left to right in the lists below.
 */

//@{

enum tca_flags {tca_on, tca_off};
enum rsa_flags {rsa_off, rsa_on};
enum tca_idm_dr_flags {tca_idm_dr_on, tca_idm_dr_off};
enum rsa_idr_flags {rsa_idr_off, rsa_idr_on};
enum ufa_flags {ufa_off, ufa_on};
enum ncdmfa_flags {ncdmfa_off, ncdmfa_on};

//@}

/**
 * labels for the way in which each approximation scheme is implemented
 */

//@{

enum tca_method {first_order_MB,first_order_CAMB,first_order_CLASS,second_order_CRS,second_order_CLASS,compromise_CLASS};
enum rsa_method {rsa_null,rsa_MD,rsa_MD_with_reio,rsa_none};
enum idr_method {idr_free_streaming,idr_fluid}; /* for the idm-idr case */
enum rsa_idr_method {rsa_idr_none,rsa_idr_MD};  /* for the idm-idr case */
enum ufa_method {ufa_mb,ufa_hu,ufa_CLASS,ufa_none};
enum ncdmfa_method {ncdmfa_mb,ncdmfa_hu,ncdmfa_CLASS,ncdmfa_none};
enum tensor_methods {tm_photons_only,tm_massless_approximation,tm_exact};

//@}

/**
 * List of coded gauges. More gauges can in principle be defined.
 */

//@{

enum possible_gauges {
                      newtonian, /**< newtonian (or longitudinal) gauge */
                      synchronous /**< synchronous gauge with \f$ \theta_{cdm} = 0 \f$ by convention */
};

//@}

//@{

/**
 * maximum number and types of selection function (for bins of matter density or cosmic shear)
 */
#define _SELECTION_NUM_MAX_ 100
enum selection_type {gaussian,tophat,dirac};

//@}


//@{

/**
 * maximum number of k-values for perturbation output
 */
#define _MAX_NUMBER_OF_K_FILES_ 30

//@}



/**
 * Structure containing everything about perturbations that other
 * modules need to know, in particular tabled values of the source
 * functions \f$ S(k, \tau) \f$ for all requested modes
 * (scalar/vector/tensor), initial conditions, types (temperature,
 * E-polarization, B-polarization, lensing potential, etc), multipole
 * l and wavenumber k.
 *
 */

struct perturbations
{
  /** @name - input parameters initialized by user in input module
   *  (all other quantities are computed in this module, given these
   *  parameters and the content of the 'precision', 'background' and
   *  'thermodynamics' structures) */

  //@{

  short has_perturbations; /**< do we need to compute perturbations at all ? */

  short has_cls; /**< do we need any harmonic space spectrum \f$ C_l \f$ (and hence Bessel functions, transfer functions, ...)? */

  short has_scalars; /**< do we need scalars? */
  short has_vectors; /**< do we need vectors? */
  short has_tensors; /**< do we need tensors? */

  short has_ad;      /**< do we need adiabatic mode? */
  short has_bi;      /**< do we need isocurvature bi mode? */
  short has_cdi;     /**< do we need isocurvature cdi mode? */
  short has_nid;     /**< do we need isocurvature nid mode? */
  short has_niv;     /**< do we need isocurvature niv mode? */

  /* perturbed recombination */
  /** Do we want to consider perturbed temperature and ionization fraction? */
  short has_perturbed_recombination;
  /** Neutrino contribution to tensors */
  enum tensor_methods tensor_method;  /**< way to treat neutrinos in tensor perturbations(neglect, approximate as massless, take exact equations) */

  short evolve_tensor_ur;             /**< will we evolve ur tensor perturbations (either because we have ur species, or we have ncdm species with massless approximation) ? */
  short evolve_tensor_ncdm;             /**< will we evolve ncdm tensor perturbations (if we have ncdm species and we use the exact method) ? */

  short has_cl_cmb_temperature;       /**< do we need \f$ C_l \f$'s for CMB temperature? */
  short has_cl_cmb_polarization;      /**< do we need \f$ C_l \f$'s for CMB polarization? */
  short has_cl_cmb_lensing_potential; /**< do we need \f$ C_l \f$'s for CMB lensing potential? */
  short has_cl_lensing_potential;     /**< do we need \f$ C_l \f$'s for galaxy lensing potential? */
  short has_cl_number_count;          /**< do we need \f$ C_l \f$'s for density number count? */
  short has_pk_matter;                /**< do we need matter Fourier spectrum? */
  short has_density_transfers;        /**< do we need to output individual matter density transfer functions? */
  short has_velocity_transfers;       /**< do we need to output individual matter velocity transfer functions? */
  short has_metricpotential_transfers;/**< do we need to output individual transfer functions for scalar metric perturbations? */
  short has_Nbody_gauge_transfers;    /**< should we convert density and velocity transfer functions to Nbody gauge? */

  short has_nl_corrections_based_on_delta_m;  /**< do we want to compute non-linear corrections with an algorithm relying on delta_m (like halofit)? */

  short has_nc_density;  /**< in dCl, do we want density terms ? */
  short has_nc_rsd;      /**< in dCl, do we want redshift space distortion terms ? */
  short has_nc_lens;     /**< in dCl, do we want lensing terms ? */
  short has_nc_gr;       /**< in dCl, do we want gravity terms ? */

  int l_scalar_max; /**< maximum l value for CMB scalars \f$ C_l \f$'s */
  int l_vector_max; /**< maximum l value for CMB vectors \f$ C_l \f$'s */
  int l_tensor_max; /**< maximum l value for CMB tensors \f$ C_l \f$'s */
  int l_lss_max; /**< maximum l value for LSS \f$ C_l \f$'s (density and lensing potential in  bins) */
  double k_max_for_pk; /**< maximum value of k in 1/Mpc required for the output of P(k,z) and T(k,z) */

  short want_lcmb_full_limber; /**< In general, do we want to use the full Limber scheme introduced in v3.2.2? With this full Limber scheme, the calculation of the CMB lensing potential spectrum C_l^phiphi for l > ppr->l_switch_limber is based on a new integration scheme. Compared to the previous scheme, which can be recovered by switching this parameter to _FALSE_, the new scheme uses a larger k_max and a coarser k-grid (or q-grid) than the CMB transfer function. The new scheme is used by default, because the old one is inaccurate at large l due to the too small k_max. */

  int selection_num;                            /**< number of selection functions
                                                   (i.e. bins) for matter density \f$ C_l \f$'s */
  enum selection_type selection;                /**< type of selection functions */
  double selection_mean[_SELECTION_NUM_MAX_]; /**< centers of selection functions */
  double selection_width[_SELECTION_NUM_MAX_];  /**< widths of selection functions */

  int switch_sw;   /**< in temperature calculation, do we want to include the intrinsic temperature + Sachs Wolfe term? */
  int switch_eisw; /**< in temperature calculation, do we want to include the early integrated Sachs Wolfe term? */
  int switch_lisw; /**< in temperature calculation, do we want to include the late integrated Sachs Wolfe term? */
  int switch_dop;  /**< in temperature calculation, do we want to include the Doppler term? */
  int switch_pol;  /**< in temperature calculation, do we want to include the polarization-related term? */
  double eisw_lisw_split_z; /**< at which redshift do we define the cut between eisw and lisw ?*/

  int store_perturbations;  /**< Do we want to store perturbations? */
  int k_output_values_num;       /**< Number of perturbation outputs (default=0) */
  double k_output_values[_MAX_NUMBER_OF_K_FILES_];    /**< List of k values where perturbation output is requested. */

  double three_ceff2_ur;/**< 3 x effective squared sound speed for the ultrarelativistic perturbations */
  double three_cvis2_ur;/**< 3 x effective viscosity parameter for the ultrarelativistic perturbations */

  double z_max_pk; /**< when we compute only the matter spectrum / transfer functions, but not the CMB, we are sometimes interested to sample source functions at very high redshift, way before recombination. This z_max_pk will then fix the initial sampling time of the sources. */

  double * alpha_idm_dr; /**< Angular contribution to collisional term at l>=2 for idm_fr-idr */
  double * beta_idr;  /**< Angular contribution to collisional term at l>=2 for idr-idr */

  int idr_nature; /**< Nature of the interacting dark radiation (free streaming or fluid) */

  int l_max_g; /**< max momentum in Boltzmann hierarchy for photons (copied from precision for use in output) */

  //@}

  /** @name - useful flags inferred from the ones above */

  //@{

  short has_cmb; /**< do we need CMB-related sources (temperature, polarization) ? */
  short has_lss; /**< do we need LSS-related sources (lensing potential, ...) ? */

  short has_idm_dr; /**< do we have idm-dr interactions? */
  short has_idm_soundspeed; /**< do we need to consider the dark matter sound speed in interaction models? */
  //@}

  /** @name - gauge in which to perform the calculation */

  //@{

  enum possible_gauges gauge; /**< gauge in which to perform this calculation */

  short has_matter_source_in_current_gauge; /**< whether to keep matter and baryon+CDM sources in current gauge, instead of automatic conversion to gauge-invariant variables */

  //@}

  /** @name - indices running on modes (scalar, vector, tensor) */

  //@{

  int index_md_scalars; /**< index value for scalars */
  int index_md_tensors; /**< index value for tensors */
  int index_md_vectors; /**< index value for vectors */

  int md_size; /**< number of modes included in computation */

  //@}

  /** @name - indices running on initial conditions (for scalars: ad, cdi, nid, niv; for tensors: only one) */

  //@{

  int index_ic_ad; /**< index value for adiabatic */
  int index_ic_cdi; /**< index value for CDM isocurvature */
  int index_ic_bi; /**< index value for baryon isocurvature */
  int index_ic_nid; /**< index value for neutrino density isocurvature */
  int index_ic_niv; /**< index value for neutrino velocity isocurvature */
  int index_ic_ten; /**< index value for unique possibility for tensors */

  int * ic_size;       /**< for a given mode, ic_size[index_md] = number of initial conditions included in computation */

  //@}

  /** @name - flags and indices running on types (temperature, polarization, lensing, ...) */

  //@{

  short has_source_t;          /**< do we need source for CMB temperature? */
  short has_source_p;          /**< do we need source for CMB polarization? */
  short has_source_delta_m;    /**< do we need source for delta of total matter? */
  short has_source_delta_cb;   /**< do we ALSO need source for delta of ONLY cdm and baryon? */
  short has_source_delta_tot;  /**< do we need source for delta total? */
  short has_source_delta_g;    /**< do we need source for delta of gammas? */
  short has_source_delta_b;    /**< do we need source for delta of baryons? */
  short has_source_delta_cdm;  /**< do we need source for delta of cold dark matter? */
  short has_source_delta_idm;  /**< do we need source for delta of interacting dark matter */
  short has_source_delta_idr;  /**< do we need source for delta of interacting dark radiation? */
  short has_source_delta_dcdm; /**< do we need source for delta of DCDM? */
  short has_source_delta_fld;  /**< do we need source for delta of dark energy? */
  short has_source_delta_scf;  /**< do we need source for delta from scalar field? */
  short has_source_delta_dr;   /**< do we need source for delta of decay radiation? */
  short has_source_delta_ur;   /**< do we need source for delta of ultra-relativistic neutrinos/relics? */
  short has_source_delta_ncdm; /**< do we need source for delta of all non-cold dark matter species (e.g. massive neutrinos)? */
  short has_source_theta_m;    /**< do we need source for theta of total matter? */
  short has_source_theta_cb;   /**< do we ALSO need source for theta of ONLY cdm and baryon? */
  short has_source_theta_tot;  /**< do we need source for theta total? */
  short has_source_theta_g;    /**< do we need source for theta of gammas? */
  short has_source_theta_b;    /**< do we need source for theta of baryons? */
  short has_source_theta_cdm;  /**< do we need source for theta of cold dark matter? */
  short has_source_theta_idm;  /**< do we need source for theta of interacting dark matter */
  short has_source_theta_idr;  /**< do we need source for theta of interacting dark radiation? */
  short has_source_theta_dcdm; /**< do we need source for theta of DCDM? */
  short has_source_theta_fld;  /**< do we need source for theta of dark energy? */
  short has_source_theta_scf;  /**< do we need source for theta of scalar field? */
  short has_source_theta_dr;   /**< do we need source for theta of ultra-relativistic neutrinos/relics? */
  short has_source_theta_ur;   /**< do we need source for theta of ultra-relativistic neutrinos/relics? */
  short has_source_theta_ncdm; /**< do we need source for theta of all non-cold dark matter species (e.g. massive neutrinos)? */
  short has_source_phi;        /**< do we need source for metric fluctuation phi? */
  short has_source_phi_prime;  /**< do we need source for metric fluctuation phi'? */
  short has_source_phi_plus_psi; /**< do we need source for metric fluctuation (phi+psi)? */
  short has_source_psi;        /**< do we need source for metric fluctuation psi? */
  short has_source_h;          /**< do we need source for metric fluctuation h? */
  short has_source_h_prime;    /**< do we need source for metric fluctuation h'? */
  short has_source_eta;        /**< do we need source for metric fluctuation eta? */
  short has_source_eta_prime;  /**< do we need source for metric fluctuation eta'? */
  short has_source_H_T_Nb_prime; /**< do we need source for metric fluctuation H_T_Nb'? */
  short has_source_k2gamma_Nb; /**< do we need source for metric fluctuation gamma in Nbody gauge? */


  /* remember that the temperature source function includes three
     terms that we call 0,1,2 (since the strategy in class v > 1.7 is
     to avoid the integration by part that would reduce the source to
     a single term) */
  int index_tp_t0; /**< index value for temperature (j=0 term) */
  int index_tp_t1; /**< index value for temperature (j=1 term) */
  int index_tp_t2; /**< index value for temperature (j=2 term) */
  int index_tp_p; /**< index value for polarization */
  int index_tp_delta_m; /**< index value for matter density fluctuation */
  int index_tp_delta_cb; /**< index value for delta cb */
  int index_tp_delta_tot; /**< index value for total density fluctuation */
  int index_tp_delta_g;   /**< index value for delta of gammas */
  int index_tp_delta_b;   /**< index value for delta of baryons */
  int index_tp_delta_cdm; /**< index value for delta of cold dark matter */
  int index_tp_delta_idm; /**< index value for delta of interacting dark matter */
  int index_tp_delta_dcdm;/**< index value for delta of DCDM */
  int index_tp_delta_fld;  /**< index value for delta of dark energy */
  int index_tp_delta_scf;  /**< index value for delta of scalar field */
  int index_tp_delta_dr; /**< index value for delta of decay radiation */
  int index_tp_delta_ur; /**< index value for delta of ultra-relativistic neutrinos/relics */
  int index_tp_delta_idr; /**< index value for delta of interacting dark radiation */
  int index_tp_delta_ncdm1; /**< index value for delta of first non-cold dark matter species (e.g. massive neutrinos) */
  int index_tp_perturbed_recombination_delta_temp;		/**< Gas temperature perturbation */
  int index_tp_perturbed_recombination_delta_chi;		/**< Inionization fraction perturbation */

  int index_tp_theta_m;     /**< index value for matter velocity fluctuation */
  int index_tp_theta_cb;    /**< index value for theta cb */
  int index_tp_theta_tot;   /**< index value for total velocity fluctuation */
  int index_tp_theta_g;     /**< index value for theta of gammas */
  int index_tp_theta_b;     /**< index value for theta of baryons */
  int index_tp_theta_cdm;   /**< index value for theta of cold dark matter */
  int index_tp_theta_dcdm;  /**< index value for theta of DCDM */
  int index_tp_theta_fld;   /**< index value for theta of dark energy */
  int index_tp_theta_scf;   /**< index value for theta of scalar field */
  int index_tp_theta_ur;    /**< index value for theta of ultra-relativistic neutrinos/relics */
  int index_tp_theta_idr;   /**< index value for theta of interacting dark radiation */
  int index_tp_theta_idm;   /**< index value for theta of interacting dark matter */
  int index_tp_theta_dr;    /**< index value for F1 of decay radiation */
  int index_tp_theta_ncdm1; /**< index value for theta of first non-cold dark matter species (e.g. massive neutrinos) */

  int index_tp_phi;          /**< index value for metric fluctuation phi */
  int index_tp_phi_prime;    /**< index value for metric fluctuation phi' */
  int index_tp_phi_plus_psi; /**< index value for metric fluctuation phi+psi */
  int index_tp_psi;          /**< index value for metric fluctuation psi */
  int index_tp_h;            /**< index value for metric fluctuation h */
  int index_tp_h_prime;      /**< index value for metric fluctuation h' */
  int index_tp_eta;          /**< index value for metric fluctuation eta */
  int index_tp_eta_prime;    /**< index value for metric fluctuation eta' */
  int index_tp_H_T_Nb_prime; /**< index value for metric fluctuation H_T_Nb' */
  int index_tp_k2gamma_Nb;   /**< index value for metric fluctuation gamma times k^2 in Nbody gauge */

  int * tp_size; /**< number of types tp_size[index_md] included in computation for each mode */

  //@}

  /** @name - list of k values for each mode */

  //@{

  int * k_size_cmb;  /**< k_size_cmb[index_md] number of k values used
                        for CMB calculations, requiring a fine
                        sampling in k-space */

  int * k_size_cl;  /**< k_size_cl[index_md] number of k values used
                       for non-CMB \f$ C_l \f$ calculations, requiring a coarse
                       sampling in k-space. */

  int k_size_pk;    /**< number of k values for the P(k,z) and T(k,z) output, not including possible additional values for non-linear corrections */

  int * k_size;     /**< k_size[index_md] = total number of k values,
                       including those needed for all C_l, P(k),
                       nonlinear corrections */

  double ** k;      /**< k[index_md][index_k] = list of values */

  double k_min;     /**< minimum value (over all modes) */
  double k_max;     /**< maximum value (over all modes) */

  //@}

  /** @name - list of conformal time values in the source table
      (common to all modes and types) */

  //@{

  double * tau_sampling;    /**< array of tau values */
  int tau_size;             /**< number of values in this array */

  double selection_min_of_tau_min; /**< used in presence of selection functions (for matter density, cosmic shear...) */
  double selection_max_of_tau_max; /**< used in presence of selection functions (for matter density, cosmic shear...) */

  double selection_delta_tau; /**< used in presence of selection functions (for matter density, cosmic shear...) */

  double * selection_tau_min; /**< value of conformal time below which W(tau) is considered to vanish for each bin */
  double * selection_tau_max; /**< value of conformal time above which W(tau) is considered to vanish for each bin */
  double * selection_tau; /**< value of conformal time at the center of each bin */
  double * selection_function; /**< selection function W(tau), normalized to \f$ \int W(tau) dtau=1 \f$, stored in selection_function[bin*ppt->tau_size+index_tau] */

  //@}

  /** @name - source functions interpolation table */

  //@{

  double *** sources; /**< Pointer towards the source interpolation table
                         sources[index_md]
                         [index_ic * ppt->tp_size[index_md] + index_tp]
                         [index_tau * ppt->k_size + index_k] */

  //@}

  /** @name - arrays related to the interpolation table for sources at late times, corresponding to z < z_max_pk (used for Fourier transfer function and spectra output) */

  //@{

  double * ln_tau;         /**< log of the arrau tau_sampling, covering only the
                               final time range required for the output of
                               Fourier transfer functions (used for interpolations) */
  int ln_tau_size;         /**< total number of values in this array */

  double *** late_sources; /**< Pointer towards the source interpolation table
                              late_sources[index_md]
                              [index_ic * ppt->tp_size[index_md] + index_tp]
                              [index_tau * ppt->k_size + index_k]
                              Note that this is not a replication of part of the sources table,
                              it is just poiting towards the same memory zone, at the place where the late_sources actually start */

  double *** ddlate_sources; /**< Pointer towards the splined source interpolation table with second derivatives with respect to time
                                ddlate_sources[index_md]
                                [index_ic * ppt->tp_size[index_md] + index_tp]
                                [index_tau * ppt->k_size + index_k] */

  //@}

  /** @name - arrays storing the evolution of all sources for given k values, passed as k_output_values */

  //@{

  int * index_k_output_values; /**< List of indices corresponding to k-values close to k_output_values for each mode.
                                  index_k_output_values[index_md*k_output_values_num+ik]*/

  char scalar_titles[_MAXTITLESTRINGLENGTH_]; /**< _DELIMITER_ separated string of titles for scalar perturbation output files. */
  char vector_titles[_MAXTITLESTRINGLENGTH_]; /**< _DELIMITER_ separated string of titles for vector perturbation output files. */
  char tensor_titles[_MAXTITLESTRINGLENGTH_]; /**< _DELIMITER_ separated string of titles for tensor perturbation output files. */

  int number_of_scalar_titles; /**< number of titles/columns in scalar perturbation output files */
  int number_of_vector_titles; /**< number of titles/columns in vector perturbation output files*/
  int number_of_tensor_titles; /**< number of titles/columns in tensor perturbation output files*/

  double * scalar_perturbations_data[_MAX_NUMBER_OF_K_FILES_]; /**< Array of double pointers to perturbation output for scalars */
  double * vector_perturbations_data[_MAX_NUMBER_OF_K_FILES_]; /**< Array of double pointers to perturbation output for vectors */
  double * tensor_perturbations_data[_MAX_NUMBER_OF_K_FILES_]; /**< Array of double pointers to perturbation output for tensors */

  int size_scalar_perturbation_data[_MAX_NUMBER_OF_K_FILES_]; /**< Array of sizes of scalar double pointers  */
  int size_vector_perturbation_data[_MAX_NUMBER_OF_K_FILES_]; /**< Array of sizes of vector double pointers  */
  int size_tensor_perturbation_data[_MAX_NUMBER_OF_K_FILES_]; /**< Array of sizes of tensor double pointers  */

  //@}

  /** @name - technical parameters */

  //@{

  short perturbations_verbose; /**< flag regulating the amount of information sent to standard output (none if set to zero) */

  ErrorMsg error_message; /**< zone for writing error messages */

  short is_allocated; /**< flag is set to true if allocated */

  //@}

};

/**
 * Structure containing the indices and the values of the perturbation
 * variables which are integrated over time (as well as their
 * time-derivatives). For a given wavenumber, the size of these
 * vectors changes when the approximation scheme changes.
 */

struct perturbations_vector
{
  int index_pt_delta_g;   /**< photon density */
  int index_pt_theta_g;   /**< photon velocity */
  int index_pt_shear_g;   /**< photon shear */
  int index_pt_l3_g;      /**< photon l=3 */
  int l_max_g;            /**< max momentum in Boltzmann hierarchy (at least 3) */
  int index_pt_pol0_g;    /**< photon polarization, l=0 */
  int index_pt_pol1_g;    /**< photon polarization, l=1 */
  int index_pt_pol2_g;    /**< photon polarization, l=2 */
  int index_pt_pol3_g;    /**< photon polarization, l=3 */
  int l_max_pol_g;        /**< max momentum in Boltzmann hierarchy (at least 3) */
  int index_pt_delta_b;   /**< baryon density */
  int index_pt_theta_b;   /**< baryon velocity */
  int index_pt_delta_cdm; /**< cdm density */
  int index_pt_theta_cdm; /**< cdm velocity */
  int index_pt_delta_idm; /**< idm density */
  int index_pt_theta_idm; /**< idm velocity */
  int index_pt_delta_dcdm; /**< dcdm density */
  int index_pt_theta_dcdm; /**< dcdm velocity */
  int index_pt_delta_fld;  /**< dark energy density in true fluid case */
  int index_pt_theta_fld;  /**< dark energy velocity in true fluid case */
  int index_pt_Gamma_fld;  /**< unique dark energy dynamical variable in PPF case */
  int index_pt_phi_scf;  /**< scalar field density */
  int index_pt_phi_prime_scf;  /**< scalar field velocity */
  int index_pt_delta_ur; /**< density of ultra-relativistic neutrinos/relics */
  int index_pt_theta_ur; /**< velocity of ultra-relativistic neutrinos/relics */
  int index_pt_shear_ur; /**< shear of ultra-relativistic neutrinos/relics */
  int index_pt_l3_ur;    /**< l=3 of ultra-relativistic neutrinos/relics */
  int l_max_ur;          /**< max momentum in Boltzmann hierarchy (at least 3) */
  int index_pt_delta_idr; /**< density of interacting dark radiation */
  int index_pt_theta_idr; /**< velocity of interacting dark radiation */
  int index_pt_shear_idr; /**< shear of interacting dark radiation */
  int index_pt_l3_idr;    /**< l=3 of interacting dark radiation */
  int l_max_idr;          /**< max momentum in Boltzmann hierarchy (at least 3) for interacting dark radiation */

  /* perturbed recombination */
  int index_pt_perturbed_recombination_delta_temp;		/**< Gas temperature perturbation */
  int index_pt_perturbed_recombination_delta_chi;		/**< Inionization fraction perturbation */

  /** The index to the first Legendre multipole of the DR expansion. Not
      that this is not exactly the usual delta, see Kaplinghat et al.,
      astro-ph/9907388. */
  int index_pt_F0_dr;
  int l_max_dr;          /**< max momentum in Boltzmann hierarchy for dr) */
  int index_pt_psi0_ncdm1; /**< first multipole of perturbation of first ncdm species, Psi_0 */
  int N_ncdm;		/**< number of distinct non-cold-dark-matter (ncdm) species */
  int* l_max_ncdm;	/**< mutipole l at which Boltzmann hierarchy is truncated (for each ncdm species) */
  int* q_size_ncdm;	/**< number of discrete momenta (for each ncdm species) */

  int index_pt_eta;       /**< synchronous gauge metric perturbation eta*/
  int index_pt_phi;	      /**< newtonian gauge metric perturbation phi */
  int index_pt_hv_prime;  /**< vector metric perturbation h_v' in synchronous gauge */
  int index_pt_V;         /**< vector metric perturbation V in Newtonian gauge */

  int index_pt_gw;        /**< tensor metric perturbation h (gravitational waves) */
  int index_pt_gwdot;     /**< its time-derivative */
  int pt_size;            /**< size of perturbation vector */

  double * y;             /**< vector of perturbations to be integrated */
  double * dy;            /**< time-derivative of the same vector */

  int * used_in_sources; /**< boolean array specifying which
                            perturbations enter in the calculation of
                            source functions */

};


/**
 * Workspace containing, among other things, the value at a given time
 * of all background/perturbed quantities, as well as their indices.
 * There will be one such structure created for each mode
 * (scalar/.../tensor) and each thread (in case of parallel computing)
 */

struct perturbations_workspace
{

  /** @name - all possible useful indices for those metric
      perturbations which are not integrated over time, but just
      inferred from Einstein equations. "_mt_" stands for "metric".*/

  //@{

  int index_mt_psi;           /**< psi in longitudinal gauge */
  int index_mt_phi_prime;     /**< (d phi/d conf.time) in longitudinal gauge */
  int index_mt_h_prime;       /**< h' (wrt conf. time) in synchronous gauge */
  int index_mt_h_prime_prime; /**< h'' (wrt conf. time) in synchronous gauge */
  int index_mt_eta_prime;     /**< eta' (wrt conf. time) in synchronous gauge */
  int index_mt_alpha;         /**< \f$ \alpha = (h' + 6 \eta') / (2 k^2) \f$ in synchronous gauge */
  int index_mt_alpha_prime;   /**< \f$ \alpha'\f$ wrt conf. time) in synchronous gauge */
  int index_mt_gw_prime_prime;/**< second derivative wrt conformal time of gravitational wave field, often called h */
  int index_mt_V_prime;       /**< derivative of Newtonian gauge vector metric perturbation V */
  int index_mt_hv_prime_prime;/**< Second derivative of Synchronous gauge vector metric perturbation \f$ h_v\f$ */
  int mt_size;                /**< size of metric perturbation vector */

  //@}

  /** @name - value at a given time of all background/perturbed
      quantities
  */

  //@{

  double * pvecback;          /**< background quantities */
  double * pvecthermo;        /**< thermodynamics quantities */
  double * pvecmetric;        /**< metric quantities */
  struct perturbations_vector * pv; /**< pointer to vector of integrated
                                       perturbations and their
                                       time-derivatives */

  double delta_rho;		    /**< total density perturbation (gives delta Too) */
  double rho_plus_p_theta;	/**< total (rho+p)*theta perturbation (gives delta Toi) */
  double rho_plus_p_shear;	/**< total (rho+p)*shear (gives delta Tij) */
  double delta_p;		    /**< total pressure perturbation (gives Tii) */

  double rho_plus_p_tot;    /**< total (rho+p) (used to infer theta_tot from rho_plus_p_theta) */

  double gw_source;		    /**< stress-energy source term in Einstein's tensor equations (gives Tij[tensor]) */
  double vector_source_pi;	/**< first stress-energy source term in Einstein's vector equations */
  double vector_source_v;	/**< second stress-energy source term in Einstein's vector equations */

  double tca_shear_g;  /**< photon shear in tight-coupling approximation */
  double tca_slip;     /**< photon-baryon slip in tight-coupling approximation */
  double tca_shear_idm_dr; /**< interacting dark radiation shear in tight coupling appproximation */
  double rsa_delta_g;  /**< photon density in radiation streaming approximation */
  double rsa_theta_g;  /**< photon velocity in radiation streaming approximation */
  double rsa_delta_ur; /**< photon density in radiation streaming approximation */
  double rsa_theta_ur; /**< photon velocity in radiation streaming approximation */
  double rsa_delta_idr; /**< interacting dark radiation density in dark radiation streaming approximation */
  double rsa_theta_idr; /**< interacting dark radiation velocity in dark radiation streaming approximation */

  double theta_idm; /**< interacting dark matter velocity */
  double theta_idm_prime; /**< derivative of interacting dark matter velocity in regard to conformal time */

  double * delta_ncdm;	/**< relative density perturbation of each ncdm species */
  double * theta_ncdm;	/**< velocity divergence theta of each ncdm species */
  double * shear_ncdm;	/**< shear for each ncdm species */

  double delta_m;	/**< relative density perturbation of all non-relativistic species */
  double theta_m;	/**< velocity divergence theta of all non-relativistic species */

  double delta_cb;       /**< relative density perturbation of only cdm and baryon */
  double theta_cb;       /**< velocity divergence theta of only cdm and baryon */

  double delta_rho_fld;        /**< density perturbation of fluid, not so trivial in PPF scheme */
  double delta_p_fld;          /**< pressure perturbation of fluid, very non-trivial in PPF scheme */
  double rho_plus_p_theta_fld; /**< velocity divergence of fluid, not so trivial in PPF scheme */
  double S_fld;                /**< S quantity sourcing Gamma_prime evolution in PPF scheme (equivalent to eq. 15 in 0808.3125) */
  double Gamma_prime_fld;      /**< Gamma_prime in PPF scheme (equivalent to eq. 14 in 0808.3125) */

  FILE * perturbations_output_file; /**< filepointer to output file*/
  int index_ikout;            /**< index for output k value (when k_output_values is set) */

  //@}

  /** @name - indices useful for searching background/thermo quantities in tables */

  //@{

  short inter_mode;	/**< flag defining the method used for interpolation background/thermo quantities tables */

  int last_index_back;   /**< the background interpolation function background_at_tau() keeps memory of the last point called through this index */
  int last_index_thermo; /**< the thermodynamics interpolation function thermodynamics_at_z() keeps memory of the last point called through this index */

  //@}

  /** @name - approximations used at a given time */

  //@{

  int index_ap_tca; /**< index for tight-coupling approximation */
  int index_ap_rsa; /**< index for radiation streaming approximation */
  int index_ap_tca_idm_dr; /**< index for dark tight-coupling approximation (idm-idr) */
  int index_ap_rsa_idr; /**< index for dark radiation streaming approximation */
  int index_ap_ufa; /**< index for ur fluid approximation */
  int index_ap_ncdmfa; /**< index for ncdm fluid approximation */
  int ap_size;      /**< number of relevant approximations for a given mode */

  int * approx;     /**< array of approximation flags holding at a given time: approx[index_ap] */

  //@}

  /** @name - approximations used at a given time */

  //@{

  int max_l_max;    /**< maximum l_max for any multipole */
  double * s_l;     /**< array of freestreaming coefficients \f$ s_l = \sqrt{1-K*(l^2-1)/k^2} \f$*/

  //@}

};

/**
 * Structure pointing towards all what the function that perturbations_derivs
 * needs to know: fixed input parameters and indices contained in the
 * various structures, workspace, etc.
 */

struct perturbations_parameters_and_workspace {

  struct precision * ppr;         /**< pointer to the precision structure */
  struct background * pba;        /**< pointer to the background structure */
  struct thermodynamics * pth;            /**< pointer to the thermodynamics structure */
  struct perturbations * ppt;          /**< pointer to the precision structure */
  int index_md;                   /**< index of mode (scalar/.../vector/tensor) */
  int index_ic;			          /**< index of initial condition (adiabatic/isocurvature(s)/...) */
  int index_k;			          /**< index of wavenumber */
  double k;			              /**< current value of wavenumber in 1/Mpc */
  struct perturbations_workspace * ppw; /**< workspace defined above */

};

/*************************************************************************************************************/
/* @cond INCLUDE_WITH_DOXYGEN */
/*
 * Boilerplate for C++
 */
#ifdef __cplusplus
extern "C" {
#endif

  int perturbations_sources_at_tau(
                                   struct perturbations * ppt,
                                   int index_md,
                                   int index_ic,
                                   int index_tp,
                                   double tau,
                                   double * psource_at_tau
                                   );

  int perturbations_sources_at_z(
                                 struct background * pba,
                                 struct perturbations * ppt,
                                 int index_md,
                                 int index_ic,
                                 int index_tp,
                                 double z,
                                 double * psource_at_z
                                 );

   int perturbations_sources_at_k_and_z(
                                        struct background * pba,
                                        struct perturbations * ppt,
                                        int index_md,
                                        int index_ic,
                                        int index_tp,
                                        double k,
                                        double z,
                                        double * psource_at_k_and_z
                                        );

  int perturbations_output_data_at_z(
                                     struct background * pba,
                                     struct perturbations * ppt,
                                     enum file_format output_format,
                                     double z,
                                     int number_of_titles,
                                     double *data
                                     );

  int perturbations_output_data_at_index_tau(
                                             struct background * pba,
                                             struct perturbations * ppt,
                                             enum file_format output_format,
                                             int index_tau,
                                             int number_of_titles,
                                             double *data
                                             );

  int perturbations_output_data(
                                struct background * pba,
                                struct perturbations * ppt,
                                enum file_format output_format,
                                double * tkfull,
                                int number_of_titles,
                                double *data
                                );

  int perturbations_output_titles(
                                  struct background *pba,
                                  struct perturbations *ppt,
                                  enum file_format output_format,
                                  char titles[_MAXTITLESTRINGLENGTH_]
                                  );

  int perturbations_output_firstline_and_ic_suffix(
                                                   struct perturbations *ppt,
                                                   int index_ic,
                                                   char first_line[_LINE_LENGTH_MAX_],
                                                   char ic_suffix[_SUFFIXNAMESIZE_]
                                                   );

  int perturbations_init(
                         struct precision * ppr,
                         struct background * pba,
                         struct thermodynamics * pth,
                         struct perturbations * ppt
                         );

  int perturbations_free_input(
                               struct perturbations * ppt
                               );

  int perturbations_free(
                         struct perturbations * ppt
                         );

  int perturbations_indices(
                            struct precision * ppr,
                            struct background * pba,
                            struct thermodynamics * pth,
                            struct perturbations * ppt
                            );

  int perturbations_timesampling_for_sources(
                                             struct precision * ppr,
                                             struct background * pba,
                                             struct thermodynamics * pth,
                                             struct perturbations * ppt
                                             );
  int perturbations_get_k_list(
                               struct precision * ppr,
                               struct background * pba,
                               struct thermodynamics * pth,
                               struct perturbations * ppt
                               );

  int perturbations_workspace_init(
                                   struct precision * ppr,
                                   struct background * pba,
                                   struct thermodynamics * pth,
                                   struct perturbations * ppt,
                                   int index_md,
                                   struct perturbations_workspace * ppw
                                   );

  int perturbations_workspace_free(
                                   struct perturbations * ppt,
                                   int index_md,
                                   struct perturbations_workspace * ppw
                                   );

  int perturbations_solve(
                          struct precision * ppr,
                          struct background * pba,
                          struct thermodynamics * pth,
                          struct perturbations * ppt,
                          int index_md,
                          int index_ic,
                          int index_k,
                          struct perturbations_workspace * ppw
                          );

  int perturbations_prepare_k_output(
                                     struct background * pba,
                                     struct perturbations * ppt
                                     );

  int perturbations_find_approximation_number(
                                              struct precision * ppr,
                                              struct background * pba,
                                              struct thermodynamics * pth,
                                              struct perturbations * ppt,
                                              int index_md,
                                              double k,
                                              struct perturbations_workspace * ppw,
                                              double tau_ini,
                                              double tau_end,
                                              int * interval_number,
                                              int * interval_number_of
                                              );

  int perturbations_find_approximation_switches(
                                                struct precision * ppr,
                                                struct background * pba,
                                                struct thermodynamics * pth,
                                                struct perturbations * ppt,
                                                int index_md,
                                                double k,
                                                struct perturbations_workspace * ppw,
                                                double tau_ini,
                                                double tau_end,
                                                double precision,
                                                int interval_number,
                                                int * interval_number_of,
                                                double * interval_limit,
                                                int ** interval_approx
                                                );

  int perturbations_vector_init(
                                struct precision * ppr,
                                struct background * pba,
                                struct thermodynamics * pth,
                                struct perturbations * ppt,
                                int index_md,
                                int index_ic,
                                double k,
                                double tau,
                                struct perturbations_workspace * ppw,
                                int * pa_old
                                );

  int perturbations_vector_free(
                                struct perturbations_vector * pv
                                );

  int perturbations_initial_conditions(
                                       struct precision * ppr,
                                       struct background * pba,
                                       struct perturbations * ppt,
                                       int index_md,
                                       int index_ic,
                                       double k,
                                       double tau,
                                       struct perturbations_workspace * ppw
                                       );

  int perturbations_approximations(
                                   struct precision * ppr,
                                   struct background * pba,
                                   struct thermodynamics * pth,
                                   struct perturbations * ppt,
                                   int index_md,
                                   double k,
                                   double tau,
                                   struct perturbations_workspace * ppw
                                   );

  int perturbations_timescale(
                              double tau,
                              void * parameters_and_workspace,
                              double * timescale,
                              ErrorMsg error_message
                              );

  int perturbations_einstein(
                             struct precision * ppr,
                             struct background * pba,
                             struct thermodynamics * pth,
                             struct perturbations * ppt,
                             int index_md,
                             double k,
                             double tau,
                             double * y,
                             struct perturbations_workspace * ppw
                             );

  int perturbations_total_stress_energy(
                                        struct precision * ppr,
                                        struct background * pba,
                                        struct thermodynamics * pth,
                                        struct perturbations * ppt,
                                        int index_md,
                                        double k,
                                        double * y,
                                        struct perturbations_workspace * ppw
                                        );

  int perturbations_sources(
                            double tau,
                            double * pvecperturbations,
                            double * pvecderivs,
                            int index_tau,
                            void * parameters_and_workspace,
                            ErrorMsg error_message
                            );

  int perturbations_print_variables(
                                    double tau,
                                    double * y,
                                    double * dy,
                                    void * parameters_and_workspace,
                                    ErrorMsg error_message
                                    );

  int perturbations_derivs(
                           double tau,
                           double * y,
                           double * dy,
                           void * parameters_and_workspace,
                           ErrorMsg error_message
                           );

  int perturbations_tca_slip_and_shear(
                                       double * y,
                                       void * parameters_and_workspace,
                                       ErrorMsg error_message
                                       );

  int perturbations_rsa_delta_and_theta(
                                        struct precision * ppr,
                                        struct background * pba,
                                        struct thermodynamics * pth,
                                        struct perturbations * ppt,
                                        double k,
                                        double * y,
                                        double a_prime_over_a,
                                        double * pvecthermo,
                                        struct perturbations_workspace * ppw,
                                        ErrorMsg error_message
                                        );

  int perturbations_rsa_idr_delta_and_theta(
                                            struct precision * ppr,
                                            struct background * pba,
                                            struct thermodynamics * pth,
                                            struct perturbations * ppt,
                                            double k,
                                            double * y,
                                            double a_prime_over_a,
                                            double * pvecthermo,
                                            struct perturbations_workspace * ppw,
                                            ErrorMsg error_message
                                            );

#ifdef __cplusplus
}
#endif

/**************************************************************/

#endif
/* @endcond */
```

`include/precisions.h`:

```h
#include "macros_precision.h"

/*
 * Background Quantities
 */

/**
 * Default initial value of scale factor used in the integration of background quantities.
 * For models like ncdm, the code may decide to start the integration earlier.
 */
class_precision_parameter(a_ini_over_a_today_default,double,1.e-14)
/**
 * Number of background integration steps that are stored in the output vector
 */
class_precision_parameter(background_Nloga,int,40000)
/**
 * Evolver to be used for thermodynamics (rk, ndf15)
 */
class_type_parameter(background_evolver,int,enum evolver_type,ndf15)
/**
 * Tolerance of the background integration, giving the allowed relative integration error.
 * (used by both evolvers)
 */
class_precision_parameter(tol_background_integration,double,1.e-10)
/**
 * Only relevant for rk evolver: the default integration step is given
 * by this number multiplied by the timescale defined in
 * background_timescale (given by the sampling step)
 */
class_precision_parameter(background_integration_stepsize,double,0.5)
/**
 * Tolerance of the deviation of \f$ \Omega_r \f$ from 1 for which to start integration:
 * The starting point of integration will be chosen,
 * such that the Omega of radiation at that point is close to 1 within tolerance.
 * (Class starts background integration during complete radiation domination)
 */
class_precision_parameter(tol_initial_Omega_r,double,1.e-4)
/**
 * Tolerance of relative deviation of the used non-cold dark matter mass compared to that which would give the correct density.
 * The dark matter mass is estimated from the dark matter density using a Newton-Method.
 * In the nonrelativistic limit, this could be estimated using M=density/number density
 */
class_precision_parameter(tol_M_ncdm,double,1.e-7)
/**
 * Tolerance on the relative precision of the integration over
 * non-cold dark matter phase-space distributions.
 */
class_precision_parameter(tol_ncdm,double,1.e-3)
/**
 * Tolerance on the relative precision of the integration over
 * non-cold dark matter phase-space distributions in the synchronous gauge.
 */
class_precision_parameter(tol_ncdm_synchronous,double,1.e-3)
/**
 * Tolerance on the relative precision of the integration over
 * non-cold dark matter phase-space distributions in the newtonian gauge.
 */
class_precision_parameter(tol_ncdm_newtonian,double,1.e-5)
/**
 * Tolerance on the relative precision of the integration over
 * non-cold dark matter phase-space distributions during the background evolution.
 */
class_precision_parameter(tol_ncdm_bg,double,1.e-5)
/**
 * Tolerance on the initial deviation of non-cold dark matter from being fully relativistic.
 * Using w = pressure/density, this quantifies the maximum deviation from 1/3. (for relativistic species)
 */
class_precision_parameter(tol_ncdm_initial_w,double,1.e-3)
/**
 * Tolerance on the deviation of the conformal time of equality from the true value in 1/Mpc.
 */
class_precision_parameter(tol_tau_eq,double,1.e-6)

/**
 * Minimum amount of cdm to allow calculations in synchronous gauge comoving with cdm.
 */
class_precision_parameter(Omega0_cdm_min_synchronous,double,1.e-10)

/**
 * Absolute tolerance of root x during shooting (only 2D case)
 */
class_precision_parameter(tol_shooting_deltax,double,1.e-4)
/**
 * Absolute tolerance of function value F during shooting (only 2D case)
 */
class_precision_parameter(tol_shooting_deltaF,double,1.e-6)
/**
 * Relative tolerance of root x during shooting (only 1D case)
 */
class_precision_parameter(tol_shooting_deltax_rel,double,1.e-5)
/**
 * Tolerance on input of various fractions (e.g. f_idm)
 */
class_precision_parameter(tol_fraction_accuracy,double,1.e-10)
/**
 * Threshold value of M_ncdm=T_ncdm/m_ncdm above wich a species is
 * considered a "non-free-streaming" when comuting the parameter
 * Omega0_nfsm, relevant for HyRec and non-linear correction
 * algorithms
 */
class_precision_parameter(M_nfsm_threshold,double,1.e4)
/*
 * Currently unused parameter.
 */

//class_precision_parameter(safe_phi_scf,double,0.0)
/**
 * Big Bang Nucleosynthesis file path. The file specifies the predictions for
 * \f$ Y_\mathrm{He} \f$ for given \f$ \omega_b \f$ and \f$ N_\mathrm{eff} \f$.
 */
class_string_parameter(sBBN_file,"/external/bbn/sBBN_2017.dat","sBBN file")

/*
 *  Thermodynamical quantities
 */

/**
 * The initial z for the calculation of the recombination history
 */
class_precision_parameter(thermo_z_initial,double,5.e6)
/**
 * The initial z for the calculation of the recombination history in
 * presence of idm (unless the later is tightly-coupled at this
 * redshift)
 */
class_precision_parameter(thermo_z_initial_if_idm,double,1.e9)
/**
 * The switch z for the recfast calculation towards linear sampling
 */
class_precision_parameter(thermo_z_linear,double,1.e4)
/**
 * Number of recfast integration steps (linear sampling, intermdiate times between z_linear and reionization)
 */
class_precision_parameter(thermo_Nz_lin,int,20000)
/**
 * Number of recfast integration steps (logarithmnic sampling. early times between z-initial and z_linear)
 */
class_precision_parameter(thermo_Nz_log,int,5000)
/**
 * Evolver to be used for thermodynamics (rk, ndf15)
 */
class_type_parameter(thermo_evolver,int,enum evolver_type,ndf15)
/**
 * Tolerance of the relative value of integral during thermodynamical integration
 * (used by both evolvers)
 */
class_precision_parameter(tol_thermo_integration,double,1.0e-6)
/**
 * Only relevant for rk evolver: the default integration step is given
 * by this number multiplied by the timescale defined in
 * thermodynamics_timescale (given by the sampling step)
 */
class_precision_parameter(thermo_integration_stepsize,double,0.1)
/**
 * Smoothing in redshift of the variation rate of \f$ \exp(-\kappa) \f$, g, and \f$ \frac{dg}{d\tau} \f$ that is used as a timescale afterwards
 */
class_precision_parameter(thermo_rate_smoothing_radius,int,50)
/**
 * Redshift at which CLASS starts to test for too early re-ionization and/or incomplete recombination.
 */
class_precision_parameter(z_end_reco_test,double,500.)
/**
 * Number of sampling points in the case of primordial black holes in ln(1+z)
 */
class_precision_parameter(primordial_black_hole_Nz,int,75000)
/**
 * Number of sampling points in the case of the coarse sampling in noninjection.c in ln(1+z)
 */
class_precision_parameter(noninjection_Nz_log,int,1000)
/**
 * Number of discrete wavenumbers for dissipation of acoustic waves (found to be giving a reasonable precision)
 */
class_precision_parameter(noninjection_Nk_acc_diss,int,500)
class_precision_parameter(k_min_acc_diss,double,0.12) /**< Minimum wavenumber for dissipation of acoustic waves */
class_precision_parameter(k_max_acc_diss,double,1.e6) /**< Maximum wavenumber for dissipation of acoustic waves */
class_precision_parameter(z_wkb_acc_diss,double,1.e6) /**< Redshift of the WKB approximation for diss. of acoustic waves */

/*
 * Recfast 1.4/1.5 parameters
 */

class_precision_parameter(recfast_Heswitch,int,6)       /**< from recfast 1.4, specifies how accurate the Helium recombination should be handled */
class_precision_parameter(recfast_fudge_He,double,0.86) /**< from recfast 1.4, fugde factor for Peeble's equation coefficient of Helium */
class_precision_parameter(recfast_Hswitch,int,_TRUE_)   /**< from recfast 1.5, specifies how accurate the Hydrogen recombination should be handled */
class_precision_parameter(recfast_fudge_H,double,1.14)  /**< from recfast 1.4, fudge factor for Peeble's equation coeffient of Hydrogen */
class_precision_parameter(recfast_delta_fudge_H,double,-0.015) /**< from recfast 1.5.2, increasing Hydrogen fudge factor if Hswitch is enabled */
class_precision_parameter(recfast_AGauss1,double,-0.14) /**< from recfast 1.5, Gaussian Peeble prefactor fit, amplitude */
class_precision_parameter(recfast_AGauss2,double,0.079) /**< from recfast 1.5.2, Gaussian Peeble prefactor fit, amplitude */
class_precision_parameter(recfast_zGauss1,double,7.28)  /**< from recfast 1.5, Gaussian Peeble prefactor fit, center */
class_precision_parameter(recfast_zGauss2,double,6.73)  /**< from recfast 1.5.2, Gaussian Peeble prefactor fit, center */
class_precision_parameter(recfast_wGauss1,double,0.18)  /**< from recfast 1.5, Gaussian Peeble prefactor fit, width */
class_precision_parameter(recfast_wGauss2,double,0.33)  /**< from recfast 1.5, Gaussian Peeble prefactor fit, width */

class_precision_parameter(recfast_z_He_1,double,8000.0) /**< from recfast 1.4, Starting value of Helium recombination 1 */
class_precision_parameter(recfast_delta_z_He_1,double,50.0) /**< Smoothing factor for recombination approximation switching, found to be OK on 3.09.10 */
class_precision_parameter(recfast_z_He_2,double,4500.0) /**< from recfast 1.4, Ending value of Helium recombination 1, changed on 28.10.20 from 5000 to 4500 */
class_precision_parameter(recfast_delta_z_He_2,double,100.0)/**< Smoothing factor for recombination approximation switching, found to be OK on 3.09.10 */
class_precision_parameter(recfast_z_He_3,double,3500.0) /**< from recfast 1.4, Starting value of Helium recombination 2 */
class_precision_parameter(recfast_delta_z_He_3,double,50.0) /**< Smoothing factor for recombination approximation switching, found to be OK on 3.09.10 */

class_precision_parameter(recfast_z_early_H_recombination,double,2870.) /**< from class 3.0, redshift at beginning of early H-recombination (analytic approximation possible), replaces condition  */
class_precision_parameter(recfast_delta_z_early_H_recombination,double,50.) /**< from class 3.0, smoothing radius delta z for beginning of early H-recombination period  */

class_precision_parameter(recfast_z_full_H_recombination,double,1600.)  /**< from class 3.0, redshift at beignning of full H recombination (always use full equations), replaces condition x_H <  recfast_x_H0_trigger */
class_precision_parameter(recfast_delta_z_full_H_recombination,double,50.)  /**< from class 3.0, smoothing radius delta z for full H-recombination period  */

class_precision_parameter(recfast_delta_z_reio,double,2.)  /**< from class 3.0, smoothing radius delta z for reionization period  */

class_precision_parameter(recfast_x_He0_trigger,double,0.995) /**< Switch for Helium full calculation during reco, raised from 0.99 to 0.995 for smoother Helium */
class_precision_parameter(recfast_x_He0_trigger2,double,0.995)     /**< Switch for Helium full calculation during reco, for changing Helium flag, raised from 0.985 to same as previous one for smoother Helium */
class_precision_parameter(recfast_x_He0_trigger_delta,double,0.05) /**< Smoothing factor for recombination approximation switching, found to be OK on 3.09.10 */
class_precision_parameter(recfast_x_H0_trigger,double,0.995)       /**< Switch for Hydrogen full calculation during reco, raised from 0.99 to 0.995 for smoother Hydrogen */
class_precision_parameter(recfast_x_H0_trigger2,double,0.995)      /**< Switch for Hydrogen full calculation during reco, for changing Hydrogen flag, raised from 0.98 to same as previous one for smoother Hydrogen */
class_precision_parameter(recfast_x_H0_trigger_delta,double,0.05)  /**< Smoothing factor for recombination approximation switching, found to be OK on 3.09.10 */

//class_precision_parameter(recfast_H_frac,double,1.0e-3)  /**< from recfast 1.4, specifies the time at which the temperature evolution is calculated by the more precise equation, not used currently */
/**
 * This is an important flag for energy injections! It also modifies wether recfast will switch approximation schemes or not.
 */
class_precision_parameter(recfast_z_switch_late,double,800.)

/*
 * Hyrec Parameters
 */

class_string_parameter(hyrec_path,"/external/HyRec2020/","hyrec_path") /**< Path to hyrec */

/*
 * Reionization parameters
 */

class_precision_parameter(reionization_z_start_max,double,50.0) /**< Maximum starting value in z for reionization */
class_precision_parameter(reionization_sampling,double,1.5e-2)  /**< Minimum sampling density in z during reionization */
class_precision_parameter(reionization_optical_depth_tol,double,1.0e-4) /**< Relative tolerance on finding the user-given optical depth of reionization given a certain redshift of reionization */
class_precision_parameter(reionization_start_factor,double,8.0) /**< Searching optical depth corresponding to the redshift is started from an initial offset beyond z_reionization_start, multiplied by reionization_width */

/*
 * Heating parameters
 */

class_string_parameter(chi_z_Galli,"/external/heating/Galli_et_al_2013.dat","Galli_file") /**< File containing the chi approximation according to Galli et al 2013 */
class_precision_parameter(z_start_chi_approx,double,2.0e3) /**< Switching redshift from full heating to chosen approx for deposition function */

/*
 * Perturbation parameters
 */

class_precision_parameter(k_min_tau0,double,0.1) /**< number defining k_min for the computation of Cl's and P(k)'s (dimensionless): (k_min tau_0), usually chosen much smaller than one */

class_precision_parameter(k_max_tau0_over_l_max,double,1.8) /**< number defining k_max for the computation of Cl's (dimensionless): (k_max tau_0)/l_max, usually chosen around two. In v3.2.2: lowered from 2.4 to 1.8, because the high value 2.4 was needed to keep CMB lensing accurate enough. With the new Limber scheme, this will be the case anyway, and k_max can be lowered in other observables in order to speed up the code. */
class_precision_parameter(k_step_sub,double,0.05) /**< step in k space, in units of one period of acoustic oscillation at decoupling, for scales inside sound horizon at decoupling */
class_precision_parameter(k_step_super,double,0.002) /**< step in k space, in units of one period of acoustic oscillation at decoupling, for scales above sound horizon at decoupling */
class_precision_parameter(k_step_transition,double,0.2) /**< dimensionless number regulating the transition from 'sub' steps to 'super' steps. Decrease for more precision. */
class_precision_parameter(k_step_super_reduction,double,0.1) /**< the step k_step_super is reduced by this amount in the k-->0 limit (below scale of Hubble and/or curvature radius) */

class_precision_parameter(k_per_decade_for_pk,double,10.0) /**< if values needed between kmax inferred from k_oscillations and k_kmax_for_pk, this gives the number of k per decade outside the BAO region*/

class_precision_parameter(idmdr_boost_k_per_decade_for_pk,double,1.0) /**< boost factor for the case of DAO in idm-idr models */

class_precision_parameter(k_per_decade_for_bao,double,70.0) /**< if values needed between kmax inferred from k_oscillations and k_kmax_for_pk, this gives the number of k per decade inside the BAO region (for finer sampling)*/

class_precision_parameter(k_bao_center,double,3.0) /**< in ln(k) space, the central value of the BAO region where sampling is finer is defined as k_rec times this number (recommended: 3, i.e. finest sampling near 3rd BAO peak) */

class_precision_parameter(k_bao_width,double,4.0) /**< in ln(k) space, width of the BAO region where sampling is finer: this number gives roughly the number of BAO oscillations well resolved on both sides of the central value (recommended: 4, i.e. finest sampling from before first up to 3+4=7th peak) */

class_precision_parameter(start_small_k_at_tau_c_over_tau_h,double,0.0015) /**< largest wavelengths start being sampled when universe is sufficiently opaque. This is quantified in terms of the ratio of thermo to hubble time scales, \f$ \tau_c/\tau_H \f$. Start when start_largek_at_tau_c_over_tau_h equals this ratio. Decrease this value to start integrating the wavenumbers earlier in time. */

class_precision_parameter(start_large_k_at_tau_h_over_tau_k,double,0.07)  /**< largest wavelengths start being sampled when mode is sufficiently outside Hubble scale. This is quantified in terms of the ratio of hubble time scale to wavenumber time scale, \f$ \tau_h/\tau_k \f$ which is roughly equal to (k*tau). Start when this ratio equals start_large_k_at_tau_k_over_tau_h. Decrease this value to start integrating the wavenumbers earlier in time. */

/**
 * when to switch off tight-coupling approximation: first condition:
 * \f$ \tau_c/\tau_H \f$ > tight_coupling_trigger_tau_c_over_tau_h.
 * Decrease this value to switch off earlier in time.  If this
 * number is larger than start_sources_at_tau_c_over_tau_h, the code
 * returns an error, because the source computation requires
 * tight-coupling to be switched off.
 */
class_precision_parameter(tight_coupling_trigger_tau_c_over_tau_h,double,0.015)

/**
 * when to switch off tight-coupling approximation:
 * second condition: \f$ \tau_c/\tau_k \equiv k \tau_c \f$ <
 * tight_coupling_trigger_tau_c_over_tau_k.
 * Decrease this value to switch off earlier in time.
 */
class_precision_parameter(tight_coupling_trigger_tau_c_over_tau_k,double,0.01)

/**
 * when to switch off tight-coupling approximation:
 * third condition: for the case of idm with photons.
 */
class_precision_parameter(tight_coupling_trigger_tau_c_over_tau_dmu_idm_g, double, 0.01);

/**
 * when to switch off tight-coupling approximation:
 * fourth condition: for the case of idm with baryons.
 */
class_precision_parameter(tight_coupling_trigger_tau_c_over_tau_R_idm_b, double, 0.01)

class_precision_parameter(start_sources_at_tau_c_over_tau_h,double,0.008) /**< sources start being sampled when universe is sufficiently opaque. This is quantified in terms of the ratio of thermo to hubble time scales, \f$ \tau_c/\tau_H \f$. Start when start_sources_at_tau_c_over_tau_h equals this ratio. Decrease this value to start sampling the sources earlier in time. */

class_precision_parameter(tight_coupling_approximation,int,(int)compromise_CLASS) /**< method for tight coupling approximation */

class_precision_parameter(idm_dr_tight_coupling_trigger_tau_c_over_tau_k,double,0.01)  /**< when to switch off the dark-tight-coupling approximation, first condition (see normal tca for full definition) */
class_precision_parameter(idm_dr_tight_coupling_trigger_tau_c_over_tau_h,double,0.015) /**< when to switch off the dark-tight-coupling approximation, second condition (see normal tca for full definition) */

class_precision_parameter(l_max_g,int,12)     /**< number of momenta in Boltzmann hierarchy for photon temperature (scalar), at least 4 */
class_precision_parameter(l_max_pol_g,int,10) /**< number of momenta in Boltzmann hierarchy for photon polarization (scalar), at least 4 */
class_precision_parameter(l_max_dr,int,17)   /**< number of momenta in Boltzmann hierarchy for decay radiation, at least 4 */
class_precision_parameter(l_max_ur,int,17)   /**< number of momenta in Boltzmann hierarchy for relativistic neutrino/relics (scalar), at least 4 */
class_precision_parameter(l_max_idr,int,17)   /**< number of momenta in Boltzmann hierarchy for interacting dark radiation */
class_precision_parameter(l_max_ncdm,int,17)   /**< number of momenta in Boltzmann hierarchy for relativistic neutrino/relics (scalar), at least 4 */
class_precision_parameter(l_max_g_ten,int,5)     /**< number of momenta in Boltzmann hierarchy for photon temperature (tensor), at least 4 */
class_precision_parameter(l_max_pol_g_ten,int,5) /**< number of momenta in Boltzmann hierarchy for photon polarization (tensor), at least 4 */

class_precision_parameter(curvature_ini,double,1.0)     /**< initial condition for curvature for adiabatic */
class_precision_parameter(entropy_ini,double,1.0) /**< initial condition for entropy perturbation for isocurvature */
class_precision_parameter(gw_ini,double,1.0)      /**< initial condition for tensor metric perturbation h */

/**
 * default step \f$ d \tau \f$ in perturbation integration, in units of the timescale involved in the equations (usually, the min of \f$ 1/k \f$, \f$ 1/aH \f$, \f$ 1/\dot{\kappa} \f$)
 */
class_precision_parameter(perturbations_integration_stepsize,double,0.5)
/**
 * default step \f$ d \tau \f$ for sampling the source function, in units of the timescale involved in the sources: \f$ (\dot{\kappa}- \ddot{\kappa}/\dot{\kappa})^{-1} \f$
 */
class_precision_parameter(perturbations_sampling_stepsize,double,0.1)
/**
 * added in v 3.2.2: age fraction (between 0 and 1 ) such that, when
 * tau > conformal_age * age_fraction, the time sampling of sources is
 * twice finer, in order to boost the accuracy of the lensing
 * line-of-sight integrals (for l < l_switch_limber) without changing
 * that of unlensed CMB observables. Setting to 1.0 disables this
 * functionality.
*/
class_precision_parameter(perturbations_sampling_boost_above_age_fraction, double, 0.9)
/**
 * control parameter for the precision of the perturbation integration,
 * IMPORTANT FOR SETTING THE STEPSIZE OF NDF15
 */
class_precision_parameter(tol_perturbations_integration,double,1.0e-5)
/**
 * cutoff relevant for controlling stiffness in the PPF scheme. It is
 * neccessary for the Runge-Kutta evolver, but not for ndf15. However,
 * the approximation is excellent for a cutoff value of 1000, so we
 * leave it on for both evolvers. (CAMB uses a cutoff value of 30.)
 */
class_precision_parameter(c_gamma_k_H_square_max,double,1.0e3)
/**
 * precision with which the code should determine (by bisection) the
 * times at which sources start being sampled, and at which
 * approximations must be switched on/off (units of Mpc)
 */
class_precision_parameter(tol_tau_approx,double,1.0e-10)
/**
 * method for switching off photon perturbations
 */
class_precision_parameter(radiation_streaming_approximation,int,rsa_MD_with_reio)
/**
 * when to switch off photon perturbations, ie when to switch
 * on photon free-streaming approximation (keep density and thtau, set
 * shear and higher momenta to zero):
 * first condition: \f$ k \tau \f$ > radiation_streaming_trigger_tau_h_over_tau_k
 */
class_precision_parameter(radiation_streaming_trigger_tau_over_tau_k,double,45.0)
/**
 * when to switch off photon perturbations, ie when to switch
 * on photon free-streaming approximation (keep density and theta, set
 * shear and higher momenta to zero):
 * second condition:
 */
class_precision_parameter(radiation_streaming_trigger_tau_c_over_tau,double,5.0)

class_precision_parameter(idr_streaming_approximation,int,rsa_idr_none) /**< method for dark radiation free-streaming approximation */
class_precision_parameter(idr_streaming_trigger_tau_over_tau_k,double,50.0) /**< when to switch on dark radiation (idr) free-streaming approximation, first condition */
class_precision_parameter(idr_streaming_trigger_tau_c_over_tau,double,10.0) /**< when to switch on dark radiation (idr) free-streaming approximation, second condition */

class_precision_parameter(ur_fluid_approximation,int,ufa_CLASS) /**< method for ultra relativistic fluid approximation */
/**
 * when to switch off ur (massless neutrinos / ultra-relativistic
 * relics) fluid approximation
 */
class_precision_parameter(ur_fluid_trigger_tau_over_tau_k,double,30.0)
class_precision_parameter(ncdm_fluid_approximation,int,ncdmfa_CLASS) /**< method for non-cold dark matter fluid approximation */
/**
 * when to switch off ncdm (massive neutrinos / non-cold
 * relics) fluid approximation
 */
class_precision_parameter(ncdm_fluid_trigger_tau_over_tau_k,double,31.0)
/**
 * whether CMB source functions can be approximated as zero when
 * visibility function g(tau) is tiny
 */
class_precision_parameter(neglect_CMB_sources_below_visibility,double,1.0e-3)
/**
 * The type of evolver to use: options are ndf15 or rk
 */
class_type_parameter(evolver,int,enum evolver_type,ndf15)

/*
 * Primordial parameters
 */

class_precision_parameter(k_per_decade_primordial,double,10.0) /**< logarithmic sampling for primordial spectra (number of points per decade in k space) */

class_precision_parameter(primordial_inflation_ratio_min,double,100.0) /**< for each k, start following wavenumber when aH = k/primordial_inflation_ratio_min */
class_precision_parameter(primordial_inflation_ratio_max,double,1.0/50.0) /**< for each k, stop following wavenumber, at the latest, when aH = k/primordial_inflation_ratio_max */
class_precision_parameter(primordial_inflation_phi_ini_maxit,int,10000)      /**< maximum number of iteration when searching a suitable initial field value phi_ini (value reached when no long-enough slow-roll period before the pivot scale) */
class_precision_parameter(primordial_inflation_pt_stepsize,double,0.01)     /**< controls the integration timestep for inflaton perturbations */
class_precision_parameter(primordial_inflation_bg_stepsize,double,0.005)     /**< controls the integration timestep for inflaton background */
class_precision_parameter(primordial_inflation_tol_integration,double,1.0e-3) /**< controls the precision of the ODE integration during inflation */
class_precision_parameter(primordial_inflation_attractor_precision_pivot,double,0.001)   /**< targeted precision when searching attractor solution near phi_pivot */
class_precision_parameter(primordial_inflation_attractor_precision_initial,double,0.1) /**< targeted precision when searching attractor solution near phi_ini */
class_precision_parameter(primordial_inflation_attractor_maxit,int,10) /**< maximum number of iteration when searching attractor solution */
class_precision_parameter(primordial_inflation_tol_curvature,double,1.0e-3) /**< for each k, stop following wavenumber, at the latest, when curvature perturbation R is stable up to to this tolerance */
class_precision_parameter(primordial_inflation_aH_ini_target,double,0.9) /**< control the step size in the search for a suitable initial field value */
class_precision_parameter(primordial_inflation_end_dphi,double,1.0e-10) /**< first bracketing width, when trying to bracket the value phi_end at which inflation ends naturally */
class_precision_parameter(primordial_inflation_end_logstep,double,10.0) /**< logarithmic step for updating the bracketing width, when trying to bracket the value phi_end at which inflation ends naturally */
class_precision_parameter(primordial_inflation_small_epsilon,double,0.1) /**< value of slow-roll parameter epsilon used to define a field value phi_end close to the end of inflation (doesn't need to be exactly at the end): epsilon(phi_end)=small_epsilon (should be smaller than one) */
class_precision_parameter(primordial_inflation_small_epsilon_tol,double,0.01) /**< tolerance in the search for phi_end */
class_precision_parameter(primordial_inflation_extra_efolds,double,2.0) /**< a small number of efolds, irrelevant at the end, used in the search for the pivot scale (backward from the end of inflation) */

/*
 * Transfer function parameters
 */

class_precision_parameter(l_linstep,int,40) /**< factor for logarithmic spacing of values of l over which bessel and transfer functions are sampled */

class_precision_parameter(l_logstep,double,1.12) /**< maximum spacing of values of l over which Bessel and transfer functions are sampled (so, spacing becomes linear instead of logarithmic at some point) */

class_precision_parameter(hyper_x_min,double,1.0e-5)  /**< flat case: lower bound on the smallest value of x at which we sample \f$ \Phi_l^{\nu}(x)\f$ or \f$ j_l(x)\f$ */
class_precision_parameter(hyper_sampling_flat,double,8.0)  /**< flat case: number of sampled points x per approximate wavelength \f$ 2\pi \f$, should remain >7.5 */
class_precision_parameter(hyper_sampling_curved_low_nu,double,7.0)  /**< open/closed cases: number of sampled points x per approximate wavelength \f$ 2\pi/\nu\f$, when \f$ \nu \f$ smaller than hyper_nu_sampling_step */
class_precision_parameter(hyper_sampling_curved_high_nu,double,3.0) /**< open/closed cases: number of sampled points x per approximate wavelength \f$ 2\pi/\nu\f$, when \f$ \nu \f$ greater than hyper_nu_sampling_step */
class_precision_parameter(hyper_nu_sampling_step,double,1000.0)  /**< open/closed cases: value of nu at which sampling changes  */
class_precision_parameter(hyper_phi_min_abs,double,1.0e-10)  /**< small value of Bessel function used in calculation of first point x (\f$ \Phi_l^{\nu}(x) \f$ equals hyper_phi_min_abs) */
class_precision_parameter(hyper_x_tol,double,1.0e-4)  /**< tolerance parameter used to determine first value of x */
class_precision_parameter(hyper_flat_approximation_nu,double,4000.0)  /**< value of nu below which the flat approximation is used to compute Bessel function */

class_precision_parameter(q_linstep,double,0.45)         /**< asymptotic linear sampling step in q
                               space, in units of \f$ 2\pi/r_a(\tau_rec) \f$
                               (comoving angular diameter distance to
                               recombination), very important for CMB */

class_precision_parameter(q_logstep_spline,double,170.0) /**< initial logarithmic sampling step in q
                                space, in units of \f$ 2\pi/r_a(\tau_{rec})\f$
                                (comoving angular diameter distance to
                                recombination), very important for CMB and LSS */

class_precision_parameter(q_logstep_open,double,6.0)   /**< in open models, the value of
                                q_logstep_spline must be decreased
                                according to curvature. Increasing
                                this number will make the calculation
                                more accurate for large positive
                                Omega_k */

class_precision_parameter(q_logstep_trapzd,double,20.0) /**< initial logarithmic sampling step in q
                                space, in units of \f$ 2\pi/r_a(\tau_{rec}) \f$
                                (comoving angular diameter distance to
                                recombination), in the case of small
                                q's in the closed case, for which one
                                must used trapezoidal integration
                                instead of spline (the number of q's
                                for which this is the case decreases
                                with curvature and vanishes in the
                                flat limit) */

class_precision_parameter(q_numstep_transition,double,250.0) /**< number of steps for the transition
                                 from q_logstep_trapzd steps to
                                 q_logstep_spline steps (transition
                                 must be smooth for spline) */

class_precision_parameter(q_logstep_limber,double,1.025) /**< new in v3.2.2: in the new 'full limber' scheme, logarithmic step for the k-grid (and q-grid) */
class_precision_parameter(k_max_limber_over_l_max_scalars,double,0.001) /**< new in v3.2.2: in the new 'full limber' scheme, the integral runs up to k_max = l_max_scalars times this parameter (units of 1/Mpc) */

class_precision_parameter(transfer_neglect_delta_k_S_t0,double,0.15) /**< for temperature source function T0 of scalar mode, range of k values (in 1/Mpc) taken into account in transfer function: for l < (k-delta_k)*tau0, ie for k > (l/tau0 + delta_k), the transfer function is set to zero */
class_precision_parameter(transfer_neglect_delta_k_S_t1,double,0.04) /**< same for temperature source function T1 of scalar mode */
class_precision_parameter(transfer_neglect_delta_k_S_t2,double,0.15) /**< same for temperature source function T2 of scalar mode */
class_precision_parameter(transfer_neglect_delta_k_S_e,double,0.11)  /**< same for polarization source function E of scalar mode */
class_precision_parameter(transfer_neglect_delta_k_V_t1,double,1.0) /**< same for temperature source function T1 of vector mode */
class_precision_parameter(transfer_neglect_delta_k_V_t2,double,1.0) /**< same for temperature source function T2 of vector mode */
class_precision_parameter(transfer_neglect_delta_k_V_e,double,1.0)  /**< same for polarization source function E of vector mode */
class_precision_parameter(transfer_neglect_delta_k_V_b,double,1.0)  /**< same for polarization source function B of vector mode */
class_precision_parameter(transfer_neglect_delta_k_T_t2,double,0.2) /**< same for temperature source function T2 of tensor mode */
class_precision_parameter(transfer_neglect_delta_k_T_e,double,0.25)  /**< same for polarization source function E of tensor mode */
class_precision_parameter(transfer_neglect_delta_k_T_b,double,0.1)  /**< same for polarization source function B of tensor mode */

class_precision_parameter(transfer_neglect_late_source,double,400.0)  /**< value of l below which the CMB source functions can be neglected at late time, excepted when there is a Late ISW contribution */

class_precision_parameter(l_switch_limber,double,10.) /**< when to use the Limber approximation for project gravitational potential cl's */
// For density Cl, we recommend not to use the Limber approximation
// at all, and hence to put here a very large number (e.g. 10000); but
// if you have wide and smooth selection functions you may wish to
// use it; then 100 might be OK
class_precision_parameter(l_switch_limber_for_nc_local_over_z,double,100.0) /**< when to use the Limber approximation for local number count contributions to cl's (relative to central redshift of each bin) */
// For terms integrated along the line-of-sight involving spherical
// Bessel functions (but not their derivatives), Limber
// approximation works well. High precision can be reached with 2000
// only. But if you have wide and smooth selection functions you may
// reduce to e.g. 30.
class_precision_parameter(l_switch_limber_for_nc_los_over_z,double,30.0) /**< when to use the Limber approximation for number count contributions to cl's integrated along the line-of-sight (relative to central redshift of each bin) */

class_precision_parameter(selection_cut_at_sigma,double,5.0)/**< in sigma units, where to cut gaussian selection functions */
class_precision_parameter(selection_sampling,double,50.0) /**< controls sampling of integral over time when selection functions vary quicker than Bessel functions. Increase for better sampling. */
class_precision_parameter(selection_sampling_bessel,double,20.0)/**< controls sampling of integral over time when selection functions vary slower than Bessel functions. Increase for better sampling. IMPORTANT for lensed contributions. */
class_precision_parameter(selection_sampling_bessel_los,double,ppr->selection_sampling_bessel)/**< controls sampling of integral over time when selection functions vary slower than Bessel functions. This parameter is specific to number counts contributions to Cl integrated along the line of sight. Increase for better sampling */
class_precision_parameter(selection_tophat_edge,double,0.1) /**< controls how smooth are the edge of top-hat window function (<<1 for very sharp, 0.1 for sharp) */

/*
 * Fourier module precision parameters
 * */

class_precision_parameter(sigma_k_per_decade,double,80.) /**< logarithmic stepsize controlling the precision of integrals for sigma(R,k) and similar quantitites */

class_precision_parameter(nonlinear_min_k_max,double,5.0) /**< when
                               using an algorithm to compute nonlinear
                               corrections, like halofit or hmcode,
                               k_max must be at least equal to this
                               value. Calculations are done internally
                               until this k_max, but the P(k,z) output
                               is still controlled by P_k_max_1/Mpc or
                               P_k_max_h/Mpc even if they are
                               smaller */

class_precision_parameter(k_max_for_pk_sigma8_min,double,10.) /**< minimal k_max for computation of sigma8 */
class_precision_parameter(k_max_for_pk_sigma8_max,double,100.) /**< maximal k_max for computation of sigma8 */

/** parameters relevant for HALOFIT computation */

class_precision_parameter(halofit_min_k_nonlinear,double,1.0e-4)/**< value of k in 1/Mpc below which non-linear corrections will be neglected */

class_precision_parameter(halofit_k_per_decade,double,80.0) /**< halofit needs to evalute integrals
                               (linear power spectrum times some
                               kernels). They are sampled using
                               this logarithmic step size. */

class_precision_parameter(halofit_sigma_precision,double,0.05) /**< a smaller value will lead to a
                               more precise halofit result at the *highest*
                               redshift at which halofit can make computations,
                               at the expense of requiring a larger k_max; but
                               this parameter is not relevant for the
                               precision on P_nl(k,z) at other redshifts, so
                               there is normally no need to change it */

class_precision_parameter(halofit_tol_sigma,double,1.0e-6) /**< tolerance required on sigma(R) when
                               matching the condition sigma(R_nl)=1,
                               whcih defines the wavenumber of
                               non-linearity, k_nl=1./R_nl */

class_precision_parameter(pk_eq_z_max,double,5.0)  /**< Maximum z for the pk_eq method */
class_precision_parameter(pk_eq_Nzlog,int,10)      /**< Number of logarithmically spaced redshift values for the pk_eq method */
class_precision_parameter(pk_eq_tol,double,1.0e-7) /**< Tolerance on the pk_eq method for finding the pk */

/** Parameters relevant for HMcode computation */

class_precision_parameter(hmcode_max_k_extra,double,1.e6) /**< parameter specifying the maximum k value for
                                                             the extrapolation of the linear power spectrum
                                                             (needed for the sigma computation) */

class_precision_parameter(hmcode_tol_sigma,double,1.e-6) /**< tolerance required on sigma(R) when matching the
                                                            condition sigma(R_nl)=1, which defines the wavenumber
                                                            of non-linearity, k_nl=1./R_nl */

/**
 * parameters controlling stepsize and min/max r & a values for
 * sigma(r) & grow table
 */
class_precision_parameter(n_hmcode_tables,int,64)
class_precision_parameter(rmin_for_sigtab,double,1.e-5)
class_precision_parameter(rmax_for_sigtab,double,1.e3)
class_precision_parameter(ainit_for_growtab,double,1.e-3)
class_precision_parameter(amax_for_growtab,double,1.)

/**
 * parameters controlling stepsize and min/max halomass values for the
 * 1-halo-power integral
 */
class_precision_parameter(nsteps_for_p1h_integral,int,256)
class_precision_parameter(mmin_for_p1h_integral,double,1.e3)
class_precision_parameter(mmax_for_p1h_integral,double,1.e18)


/*
 * Lensing precision parameters
 */

class_precision_parameter(accurate_lensing,int,_FALSE_) /**< switch between Gauss-Legendre quadrature integration and simple quadrature on a subdomain of angles */
class_precision_parameter(num_mu_minus_lmax,int,70) /**< difference between num_mu and l_max, increase for more precision */
class_precision_parameter(delta_l_max,int,500)/**< difference between l_max in unlensed and lensed spectra */
class_precision_parameter(tol_gauss_legendre,double,ppr->smallest_allowed_variation) /**< tolerance with which quadrature points are found: must be very small for an accurate integration (if not entered manually, set automatically to match machine precision) */

/*
 * Spectral distortions precision parameters
 */

class_precision_parameter(sd_z_min,double,1.02e3)
class_precision_parameter(sd_z_max,double,5.0e6)
class_precision_parameter(sd_z_size,int,400)

class_precision_parameter(sd_x_min,double,1.0e-2)
class_precision_parameter(sd_x_max,double,5.0e1)
class_precision_parameter(sd_x_size,int,500)

/**
 * Tolerance on the deviation of the distortions detector quality
 */
class_precision_parameter(tol_sd_detector,double,1.e-5)

class_string_parameter(sd_external_path,"/external/distortions","sd_external_path")


#undef class_precision_parameter
#undef class_string_parameter
#undef class_type_parameter

```

`include/primordial.h`:

```h
/** @file primordial.h Documented includes for primordial module. */

#ifndef __PRIMORDIAL__
#define __PRIMORDIAL__

#include "perturbations.h"

/** enum defining how the primordial spectrum should be computed */

enum primordial_spectrum_type {
                               analytic_Pk,
                               two_scales,
                               inflation_V,
                               inflation_H,
                               inflation_V_end,
                               external_Pk
};

/** enum defining whether the spectrum routine works with linear or logarithmic input/output */

enum linear_or_logarithmic {
                            linear,
                            logarithmic
};

/** enum defining the type of inflation potential function V(phi) */

enum potential_shape {
                      polynomial,
                      natural,
                      higgs_inflation
};

/** enum defining which quantity plays the role of a target for evolving inflationary equations */

enum target_quantity {
                      _aH_,
                      _phi_,
                      _end_inflation_,
                      _a_
};

/** enum specifying if we want to integrate equations forward or backward in time */

enum integration_direction {
                            backward,
                            forward
};

/** enum specifying if we want to evolve quantities with conformal or proper time */

enum time_definition {
                      conformal,
                      proper
};

/** enum specifying how, in the inflation_V_end case, the value of phi_pivot should calculated */

enum phi_pivot_methods {
                        N_star,
                        ln_aH_ratio,
                        ln_aH_ratio_auto
};

/** enum specifying how the inflation module computes the primordial spectrum (default: numerical) */

enum inflation_module_behavior {
                                numerical,
                                analytical
};

/**
 * Structure containing everything about primordial spectra that other modules need to know.
 *
 * Once initialized by primordial_init(), contains a table of all
 * primordial spectra as a function of wavenumber, mode, and pair of initial conditions.
 */

struct primordial {

  /** @name - input parameters initialized by user in input module
      (all other quantities are computed in this module, given these parameters
      and the content of the 'precision' and 'perturbs' structures) */

  //@{

  double k_pivot; /**< pivot scale in \f$ Mpc^{-1} \f$ */
  int has_k_max_for_primordial_pk;
  double k_max_for_primordial_pk; /**< maximum value of k in 1/Mpc in P(k) */

  enum primordial_spectrum_type primordial_spec_type; /**< type of primordial spectrum (simple analytic from, integration of inflationary perturbations, etc.) */

  /* - parameters describing the case primordial_spec_type = analytic_Pk : amplitudes, tilts, runnings, cross-correlations, ... */

  double A_s;  /**< usual scalar amplitude = curvature power spectrum at pivot scale */
  double n_s;  /**< usual scalar tilt = [curvature power spectrum tilt at pivot scale -1] */
  double alpha_s; /**< usual scalar running */
  double beta_s;  /**< running of running */

  double r;    /**< usual tensor to scalar ratio of power spectra, \f$ r=A_T/A_S=P_h/P_R \f$*/
  double n_t;  /**< usual tensor tilt = [GW power spectrum tilt at pivot scale] */
  double alpha_t; /**< usual tensor running */

  double f_bi;  /**< baryon isocurvature (BI) entropy-to-curvature ratio \f$ S_{bi}/R \f$*/
  double n_bi;  /**< BI tilt */
  double alpha_bi; /**< BI running */

  double f_cdi;  /**< CDM isocurvature (CDI) entropy-to-curvature ratio \f$ S_{cdi}/R \f$*/
  double n_cdi;  /**< CDI tilt */
  double alpha_cdi; /**< CDI running */

  double f_nid;  /**< neutrino density isocurvature (NID) entropy-to-curvature ratio \f$ S_{nid}/R \f$*/
  double n_nid;  /**< NID tilt */
  double alpha_nid; /**< NID running */

  double f_niv;  /**< neutrino velocity isocurvature (NIV) entropy-to-curvature ratio \f$ S_{niv}/R \f$*/
  double n_niv;  /**< NIV tilt */
  double alpha_niv; /**< NIV running */

  double c_ad_bi; /**< ADxBI cross-correlation at pivot scale, from -1 to 1 */
  double n_ad_bi; /**< ADxBI cross-correlation tilt */
  double alpha_ad_bi; /**< ADxBI cross-correlation running */

  double c_ad_cdi; /**< ADxCDI cross-correlation at pivot scale, from -1 to 1 */
  double n_ad_cdi; /**< ADxCDI cross-correlation tilt */
  double alpha_ad_cdi; /**< ADxCDI cross-correlation running */

  double c_ad_nid; /**< ADxNID cross-correlation at pivot scale, from -1 to 1 */
  double n_ad_nid; /**< ADxNID cross-correlation tilt */
  double alpha_ad_nid; /**< ADxNID cross-correlation running */

  double c_ad_niv; /**< ADxNIV cross-correlation at pivot scale, from -1 to 1 */
  double n_ad_niv; /**< ADxNIV cross-correlation tilt */
  double alpha_ad_niv; /**< ADxNIV cross-correlation running */

  double c_bi_cdi; /**< BIxCDI cross-correlation at pivot scale, from -1 to 1 */
  double n_bi_cdi; /**< BIxCDI cross-correlation tilt */
  double alpha_bi_cdi; /**< BIxCDI cross-correlation running */

  double c_bi_nid; /**< BIxNIV cross-correlation at pivot scale, from -1 to 1 */
  double n_bi_nid; /**< BIxNIV cross-correlation tilt */
  double alpha_bi_nid; /**< BIxNIV cross-correlation running */

  double c_bi_niv; /**< BIxNIV cross-correlation at pivot scale, from -1 to 1 */
  double n_bi_niv; /**< BIxNIV cross-correlation tilt */
  double alpha_bi_niv; /**< BIxNIV cross-correlation running */

  double c_cdi_nid; /**< CDIxNID cross-correlation at pivot scale, from -1 to 1 */
  double n_cdi_nid; /**< CDIxNID cross-correlation tilt */
  double alpha_cdi_nid; /**< CDIxNID cross-correlation running */

  double c_cdi_niv; /**< CDIxNIV cross-correlation at pivot scale, from -1 to 1 */
  double n_cdi_niv; /**< CDIxNIV cross-correlation tilt */
  double alpha_cdi_niv; /**< CDIxNIV cross-correlation running */

  double c_nid_niv; /**< NIDxNIV cross-correlation at pivot scale, from -1 to 1 */
  double n_nid_niv; /**< NIDxNIV cross-correlation tilt */
  double alpha_nid_niv; /**< NIDxNIV cross-correlation running */

  /** parameters describing the case primordial_spec_type = inflation_V */

  enum potential_shape potential;

  double V0;	/**< one parameter of the function V(phi) */
  double V1;	/**< one parameter of the function V(phi) */
  double V2;	/**< one parameter of the function V(phi) */
  double V3;	/**< one parameter of the function V(phi) */
  double V4;	/**< one parameter of the function V(phi) */

  /* parameters describing the case primordial_spec_type = inflation_H */

  double H0;	/**< one parameter of the function H(phi) */
  double H1;	/**< one parameter of the function H(phi) */
  double H2;	/**< one parameter of the function H(phi) */
  double H3;	/**< one parameter of the function H(phi) */
  double H4;	/**< one parameter of the function H(phi) */

  /* parameters describing inflation_V_end */

  double phi_end;	/**< value of inflaton at the end of inflation */
  enum phi_pivot_methods phi_pivot_method; /**< flag for method used to define and find the pivot scale */
  double phi_pivot_target; /**< For each of the above methods, critical value to be reached between pivot and end of inflation (N_star, [aH]ratio, etc.) */

  /* behavior of the inflation module */
  enum inflation_module_behavior behavior; /**< Specifies if the inflation module computes the primordial spectrum numerically (default) or analytically*/

  /** 'external_Pk' mode: command generating the table of Pk and custom parameters to be passed to it */

  char*  command;  /**< string with the command for calling 'external_Pk' */
  double custom1;  /**< one parameter of the primordial computed in 'external_Pk' */
  double custom2;  /**< one parameter of the primordial computed in 'external_Pk' */
  double custom3;  /**< one parameter of the primordial computed in 'external_Pk' */
  double custom4;  /**< one parameter of the primordial computed in 'external_Pk' */
  double custom5;  /**< one parameter of the primordial computed in 'external_Pk' */
  double custom6;  /**< one parameter of the primordial computed in 'external_Pk' */
  double custom7;  /**< one parameter of the primordial computed in 'external_Pk' */
  double custom8;  /**< one parameter of the primordial computed in 'external_Pk' */
  double custom9;  /**< one parameter of the primordial computed in 'external_Pk' */
  double custom10; /**< one parameter of the primordial computed in 'external_Pk' */

  //@}

  /** @name - pre-computed table of primordial spectra, and related quantities */

  //@{

  int md_size;      /**< number of modes included in computation */

  int * ic_size;    /**< for a given mode, ic_size[index_md] = number of initial conditions included in computation */

  int * ic_ic_size; /**< number of ordered pairs of (index_ic1, index_ic2); this number is just N(N+1)/2  where N = ic_size[index_md] */

  int lnk_size;    /**< number of ln(k) values */

  double * lnk;    /**< list of ln(k) values lnk[index_k] */

  double ** lnpk;  /**< depends on indices index_md, index_ic1, index_ic2, index_k as:
                      lnpk[index_md][index_k*ppm->ic_ic_size[index_md]+index_ic1_ic2]
                      where index_ic1_ic2 labels ordered pairs (index_ic1, index_ic2) (since
                      the primordial spectrum is symmetric in (index_ic1, index_ic2)).
                      - for diagonal elements (index_ic1 = index_ic2) this arrays contains
                      ln[P(k)] where P(k) is positive by construction.
                      - for non-diagonal elements this arrays contains the k-dependent
                      cosine of the correlation angle, namely
                      P(k )_(index_ic1, index_ic2)/sqrt[P(k)_index_ic1 P(k)_index_ic2]
                      This choice is convenient since the sign of the non-diagonal cross-correlation
                      is arbitrary. For fully correlated or anti-correlated initial conditions,
                      this non -diagonal element is independent on k, and equal to +1 or -1.
                   */

  double ** ddlnpk; /**< second derivative of above array, for spline interpolation. So:
                       - for index_ic1 = index_ic, we spline ln[P(k)] vs. ln(k), which is
                       good since this function is usually smooth.
                       - for non-diagonal coefficients, we spline
                       P(k)_(index_ic1, index_ic2)/sqrt[P(k)_index_ic1 P(k)_index_ic2]
                       vs. ln(k), which is fine since this quantity is often assumed to be
                       constant (e.g for fully correlated/anticorrelated initial conditions)
                       or nearly constant, and with arbitrary sign.
                    */

  short ** is_non_zero; /**< is_non_zero[index_md][index_ic1_ic2] set to false if pair
                           (index_ic1, index_ic2) is uncorrelated
                           (ensures more precision and saves time with respect to the option
                           of simply setting P(k)_(index_ic1, index_ic2) to zero) */

  //@}

  //@{

  /** @name - parameters describing the case primordial_spec_type = analytic_Pk : amplitudes, tilts, runnings, cross-correlations, ... */

  double ** amplitude; /**< all amplitudes in matrix form: amplitude[index_md][index_ic1_ic2] */
  double ** tilt;      /**< all tilts in matrix form: tilt[index_md][index_ic1_ic2] */
  double ** running;   /**< all runnings in matrix form: running[index_md][index_ic1_ic2] */

  //@}

  //@{

  /** @name - for the inflation simulator, indices in vector of
      background/perturbation */

  int index_in_a;       /**< scale factor */
  int index_in_phi;     /**< inflaton vev */
  int index_in_dphi;    /**< its time derivative */
  int index_in_ksi_re;  /**< Mukhanov variable (real part) */
  int index_in_ksi_im;  /**< Mukhanov variable (imaginary part) */
  int index_in_dksi_re; /**< Mukhanov variable (real part, time derivative) */
  int index_in_dksi_im; /**< Mukhanov variable (imaginary part, time derivative) */
  int index_in_ah_re;   /**< tensor perturbation (real part) */
  int index_in_ah_im;   /**< tensor perturbation (imaginary part) */
  int index_in_dah_re;  /**< tensor perturbation (real part, time derivative) */
  int index_in_dah_im;  /**< tensor perturbation (imaginary part, time derivative) */
  int in_bg_size;       /**< size of vector of background quantities only */
  int in_size;          /**< full size of vector */

  //@}

  /** @name - derived parameters */

  //@{

  double phi_pivot;      /**< in inflationary module, value of
                            phi_pivot (set to 0 for inflation_V,
                            inflation_H; found by code for
                            inflation_V_end) */
  double phi_min;        /**< in inflationary module, value of phi when \f$ k_{min}=aH \f$*/
  double phi_max;        /**< in inflationary module, value of phi when \f$ k_{max}=aH \f$*/
  double phi_stop;       /**< in inflationary module, value of phi at the end of inflation */

  //@}

  /** @name - technical parameters */

  //@{

  short primordial_verbose; /**< flag regulating the amount of information sent to standard output (none if set to zero) */

  //@}

  ErrorMsg error_message; /**< zone for writing error messages */

  short is_allocated; /**< flag is set to true if allocated */

};

struct primordial_inflation_parameters_and_workspace {

  struct primordial * ppm;
  double N;
  double a2;

  double V;
  double dV;
  double ddV;
  double aH;

  double H;
  double dH;
  double ddH;
  double dddH;

  double zpp_over_z;
  double app_over_a;

  double k;

  enum integration_direction integrate;
  enum time_definition time;

};


/*************************************************************************************************************/
/* @cond INCLUDE_WITH_DOXYGEN */
/*
 * Boilerplate for C++
 */
#ifdef __cplusplus
extern "C" {
#endif

  int primordial_spectrum_at_k(
                               struct primordial * ppm,
                               int index_md,
                               enum linear_or_logarithmic mode,
                               double k,
                               double * pk
                               );

  int primordial_init(
                      struct precision  * ppr,
                      struct background * pba,
                      struct perturbations  * ppt,
                      struct primordial * ppm
                      );

  int primordial_free(
                      struct primordial * ppm
                      );

  int primordial_indices(
                         struct perturbations   * ppt,
                         struct primordial * ppm
                         );

  int primordial_get_lnk_list(
                              struct perturbations * ppt,
                              struct primordial * ppm,
                              double kmin,
                              double kmax,
                              double k_per_decade,
                              int nu_spacing, // For closed universe, the spacing of nu is not just 1, but can be 2, 3, etc.
                              double K,
                              int sgnK
                              );

  int primordial_analytic_spectrum_init(
                                        struct perturbations   * ppt,
                                        struct primordial * ppm
                                        );

  int primordial_analytic_spectrum(
                                   struct primordial * ppm,
                                   int index_md,
                                   int index_ic1_ic2,
                                   double k,
                                   double * pk
                                   );

  int primordial_inflation_potential(
                                     struct primordial * ppm,
                                     double phi,
                                     double * V,
                                     double * dV,
                                     double * ddV
                                     );

  int primordial_inflation_hubble(
                                  struct primordial * ppm,
                                  double phi,
                                  double * H,
                                  double * dH,
                                  double * ddH,
                                  double * dddH
                                  );

  int primordial_inflation_indices(
                                   struct primordial * ppm
                                   );

  int primordial_inflation_solve_inflation(
                                           struct perturbations * ppt,
                                           struct primordial * ppm,
                                           struct precision * ppr
                                           );

  int primordial_inflation_analytic_spectra(
                                            struct perturbations * ppt,
                                            struct primordial * ppm,
                                            struct precision * ppr,
                                            double * y_ini
                                            );

  int primordial_inflation_spectra(
                                   struct perturbations * ppt,
                                   struct primordial * ppm,
                                   struct precision * ppr,
                                   double * y_ini
                                   );

  int primordial_inflation_one_wavenumber(
                                          struct perturbations * ppt,
                                          struct primordial * ppm,
                                          struct precision * ppr,
                                          double * y_ini,
                                          int index_k
                                          );

  int primordial_inflation_one_k(
                                 struct primordial * ppm,
                                 struct precision * ppr,
                                 double k,
                                 double * y,
                                 double * dy,
                                 double * curvature,
                                 double * tensor
                                 );

  int primordial_inflation_find_attractor(
                                          struct primordial * ppm,
                                          struct precision * ppr,
                                          double phi_0,
                                          double precision,
                                          double * y,
                                          double * dy,
                                          double * H_0,
                                          double * dphidt_0
                                          );

  int primordial_inflation_evolve_background(
                                             struct primordial * ppm,
                                             struct precision * ppr,
                                             double * y,
                                             double * dy,
                                             enum target_quantity target,
                                             double stop,
                                             short check_epsilon,
                                             enum integration_direction direction,
                                             enum time_definition time
                                             );

  int primordial_inflation_check_potential(
                                           struct primordial * ppm,
                                           double phi,
                                           double * V,
                                           double * dV,
                                           double * ddV
                                           );

  int primordial_inflation_check_hubble(
                                        struct primordial * ppm,
                                        double phi,
                                        double *H,
                                        double * dH,
                                        double * ddH,
                                        double * dddH
                                        );

  int primordial_inflation_get_epsilon(
                                       struct primordial * ppm,
                                       double phi,
                                       double * epsilon
                                       );

  int primordial_inflation_find_phi_pivot(
                                          struct primordial * ppm,
                                          struct precision * ppr,
                                          double * y,
                                          double * dy
                                          );

  int primordial_inflation_derivs(
                                  double tau,
                                  double * y,
                                  double * dy,
                                  void * parameters_and_workspace,
                                  ErrorMsg error_message
                                  );

  int primordial_external_spectrum_init(
                                        struct perturbations * ppt,
                                        struct primordial * ppm
                                        );

  int primordial_output_titles(struct perturbations * ppt,
                               struct primordial * ppm,
                               char titles[_MAXTITLESTRINGLENGTH_]
                               );

  int primordial_output_data(struct perturbations * ppt,
                             struct primordial * ppm,
                             int number_of_titles,
                             double *data);
#ifdef __cplusplus
}
#endif

/**************************************************************/

/**
 * @name Some limits imposed on parameter values:
 */

//@{

#define _K_PER_DECADE_PRIMORDIAL_MIN_ 1.

//@}

#endif
/* @endcond */

```

`include/quadrature.h`:

```h
#ifndef __QSS__
#define __QSS__

#define _MIN_NUMBER_OF_LAGUERRE_POINTS_ 5

/******************************************/
/* Quadrature Sampling Strategy for CLASS */
/* 10/12 2010                             */
/* Thomas Tram                            */
/******************************************/
#include "common.h"

enum ncdm_quadrature_method {qm_auto, qm_Laguerre, qm_trapz_indefinite, qm_trapz};

/* Structures for QSS */

typedef struct adaptive_integration_tree_node{
  /* binary tree node: */
  double I;		/* Estimate of integral */
  double err;		/* Estimated error */
  double *x;		/* Pointer to the abscissas of node */
  double *w;		/* Pointer to the corresponding weights */
  int leaf_childs;/* Number of leafs under current node. 1 means that the node is a leaf. */
  /* Pointer to children: */
  struct  adaptive_integration_tree_node *left, *right;	/* Pointer to left child. */
} qss_node;

    /**
     * Boilerplate for C++
     */
#ifdef __cplusplus
    extern "C" {
#endif
      int get_qsampling(double *x,
			double *w,
			int *N,
			int N_max, double rtol,
			double *qvec,
			int qsiz,
			int (*test)(void * params_for_function, double q, double *psi),
			int (*function)(void * params_for_function, double q, double *f0),
			void * params_for_function,
			ErrorMsg errmsg);
       int get_qsampling_manual(double *x,
				double *w,
				int N,
				double qmax,
				enum ncdm_quadrature_method method,
				double *qvec,
				int qsiz,
				int (*function)(void * params_for_function, double q, double *f0),
				void * params_for_function,
				ErrorMsg errmsg);

      int sort_x_and_w(double *x, double *w, double *workx, double *workw, int startidx, int endidx);
      int get_leaf_x_and_w(qss_node *node, int *ind, double *x, double *w,int isindefinite);
      int reduce_tree(qss_node *node, int level);
      int burn_tree(qss_node *node);
      int leaf_count(qss_node *node);
      double get_integral(qss_node *node, int level);
      int gk_adapt(
		   qss_node **node,
		   int (*test)(void * params_for_function, double q, double *psi),
		   int (*function)(void * params_for_function, double q, double *f0),
		   void * params_for_function,
		   double tol,
		   int treemode,
		   double a,
		   double b,
		   int isindefinite,
		   ErrorMsg errmsg);
      int compute_Hermite(double *x, double *w, int N, int alpha, double *b, double *c);
      int compute_Laguerre(double *x, double *w, int N, double alpha, double *b, double *c, int totalweight);
      int gk_quad(int (*test)(void * params_for_function, double q, double *psi),
		  int (*function)(void * params_for_function, double q, double *f0),
		  void * params_for_function,
		  qss_node* node,
		  double a,
		  double b,
		  int isindefinite);
      double testfun(double x);

      int quadrature_gauss_legendre(
				    double *mu,
				    double *w8,
				    int n,
				    double tol,
				    ErrorMsg error_message);

      int quadrature_gauss_legendre_2D(
				       int n,
				       double * x,
				       double * y,
				       double * w,
				       ErrorMsg error_message);

      int quadrature_in_rectangle(
				  double xl,
				  double xr,
				  double yl,
				  double yr,
				  int *n,
				  double ** x,
				  double ** y,
				  double ** w,
				  ErrorMsg error_message);

      int cubature_order_eleven(
				double xl,
				double xr,
				double yl,
				double yr,
				double *x,
				double *y,
				double *w,
				ErrorMsg error_message);


#ifdef __cplusplus
    }
#endif


#endif

```

`include/sparse.h`:

```h
#ifndef __SPA__
#define __SPA__
/****************************************/
/* Sparse Matrix algorithms for CLASS   */
/* 15/11 2010                           */
/* Thomas Tram                          */
/****************************************/
#include "common.h"

/* Structures: */
typedef struct sparse_matrix{
	/* Sparse matrix in compressed column form: */
	int ncols;		/* Number of columns */
	int nrows;		/* Number of rows */
	int maxnz;		/* Maximum number of non-zero entries*/
	int *Ap;		/* Ap[0..ncols]. Ap[k+1]-Ap[k] is the number of entries in the k'th column. */
	int *Ai;		/* Ai[0..(maxnz-1)]. Contains the row indices of the entries. */
	double *Ax;		/* Ax[0..(maxnz-1)]. Contains the values of the entries. */
} sp_mat;

typedef struct sparse_numerical{
	/* Sparse LU decomposition along with enough information to do a fast refactorization: */
	int n;			/*Matrix assumed square, [nxn] */
	sp_mat *L;		/*L and U is the factors of the decomposed matrix.*/
	sp_mat *U;
	int **xi;		/*xi[k] points to a row of xi, which holds the topological ordered indices.*/
	int *topvec;	/*topvec[k] holds the first index in xi[k].*/
	int *pinv;		/*Inverse row permutation. */
	int *p;			/*Row permutation. */
	int *q;			/* Column permutation */
	int *wamd;		/* Work array for sp_amd */
	double *w;		/* Work array for sp_lu */
} sp_num;


/**
 * Boilerplate for C++
 */
#ifdef __cplusplus
extern "C" {
#endif
/* Routines and macros: */
int sp_mat_alloc(sp_mat** A, int ncols, int nrows, int maxnz, ErrorMsg error_message);
int sp_mat_free(sp_mat *A);
int sp_num_alloc(sp_num** N, int n,ErrorMsg error_message);
int sp_num_free(sp_num *N);
int reachr(sp_mat *G, sp_mat *B,int k, int *xik,int *pinv);
void dfsr(int j, sp_mat *G, int *top, int *xik, int *pinv);
int sp_splsolve(sp_mat *G, sp_mat *B, int k, int*xik, int top, double *x, int *pinv);
int sp_ludcmp(sp_num *N, sp_mat *A, double pivtol);
int sp_lusolve(sp_num *N, double *b, double *x);
int sp_refactor(sp_num *N, sp_mat *A);
int column_grouping(sp_mat *G, int *col_g, int *col_wi);
int sp_amd(int *Cp, int *Ci, int n, int cnzmax, int *P, int *W);
int sp_wclear(int mark, int lemax, int *w, int n);
int sp_tdfs(int j, int k, int *head, const int *next, int *post, int *stack);


#define SPFLIP(i) (-(i)-2)
#define SPUNFLIP(i) (((i)<0) ? SPFLIP(i) : (i))
#define SPMARKED(w,j) (w[j] < 0)
#define SPMARK(w,j) {w[j] = SPFLIP(w[j]);}

#ifdef __cplusplus
}
#endif


#endif

```

`include/svnversion.h`:

```h
#define _SVN_VERSION_ "6142M"

```

`include/thermodynamics.h`:

```h
/** @file thermodynamics.h Documented includes for thermodynamics module */

#ifndef __THERMODYNAMICS__
#define __THERMODYNAMICS__

#include "background.h"
#include "evolver_ndf15.h"
#include "evolver_rkck.h"
#include "wrap_hyrec.h"
#include "wrap_recfast.h"
#include "injection.h"

/**
 * List of possible recombination algorithms.
 */

enum recombination_algorithm {
                              recfast,
                              hyrec
};

/**
 * List of possible reionization schemes.
 */

enum reionization_parametrization {
                                   reio_none,       /**< no reionization */
                                   reio_camb,       /**< reionization parameterized like in CAMB */
                                   reio_bins_tanh,  /**< binned reionization history with tanh inteprolation between bins */
                                   reio_half_tanh,  /**< half a tanh, instead of the full tanh */
                                   reio_many_tanh,  /**< similar to reio_camb but with more than one tanh */
                                   reio_inter       /**< linear interpolation between specified points */
};

/**
 * Is the input parameter the reionization redshift or optical depth?
 */

enum reionization_z_or_tau {
                            reio_z,  /**< input = redshift */
                            reio_tau /**< input = tau */
};

/**
 * Two useful smooth step functions, for smoothing transitions in recfast.
 */

#define f1(x) (-0.75*x*(x*x/3.-1.)+0.5)  /**< goes from 0 to 1 when x goes from -1 to 1 */
#define f2(x) (x*x*(0.5-x/3.)*6.)        /**< goes from 0 to 1 when x goes from  0 to 1 */

/**
 * All thermodynamics parameters and evolution that other modules need to know.
 *
 * Once initialized by thermodynamics_init(), contains all the necessary information on the thermodynamics, and in particular, a
 * table of thermodynamical quantities as a function of the redshift, used for interpolation in other modules.
 */

struct thermodynamics
{
  /** @name - input parameters initialized by user in input module (all other quantities are computed in this module, given these parameters
   *   and the content of the 'precision' and 'background' structures) */

  //@{

  double YHe;  /**< \f$ Y_{He} \f$: primordial helium mass fraction rho_He/(rho_H+rho_He),
                  close but not exactly equal to the density fraction 4*n_He/(n_H+4*n_He) */
  double bbn_alpha_sensitivity; /**< Related to variation of fundamental constants (sensitivity of YHe to alpha) */

  enum recombination_algorithm recombination; /**< recombination code */

  enum recfast_photoion_modes recfast_photoion_mode; /**< photo-ionization coefficient mode of the recfast algorithm */

  enum reionization_parametrization reio_parametrization; /**< reionization scheme */

  enum reionization_z_or_tau reio_z_or_tau; /**< is the input parameter the reionization redshift or optical depth? */

  double tau_reio; /**< if above set to tau, input value of reionization optical depth */

  double z_reio;   /**< if above set to z,   input value of reionization redshift */

  short compute_cb2_derivatives; /**< do we want to include in computation derivatives of baryon sound speed? */

  short compute_damping_scale; /**< do we want to compute the simplest analytic approximation to the photon damping (or diffusion) scale? */

  /** parameters for interacting dark matter */

  short has_idm_b;    /**< Do we have idm with baryons? */
  short has_idm_g;    /**< Do we have idm with photons? */
  short has_idm_dr;   /**< Do we have idm with dark radiation? */

  /** parameters for reio_camb */

  double reionization_width; /**< width of H reionization */

  double reionization_exponent; /**< shape of H reionization */

  double helium_fullreio_redshift; /**< redshift for of helium reionization */

  double helium_fullreio_width; /**< width of helium reionization */

  /** parameters for reio_bins_tanh */

  int binned_reio_num; /**< with how many bins do we want to describe reionization? */

  double * binned_reio_z; /**< central z value for each bin */

  double * binned_reio_xe; /**< imposed \f$ X_e(z)\f$ value at center of each bin */

  double binned_reio_step_sharpness; /**< sharpness of tanh() step interpolating between binned values */

  /** parameters for reio_many_tanh */

  int many_tanh_num; /**< with how many jumps do we want to describe reionization? */

  double * many_tanh_z; /**< central z value for each tanh jump */

  double * many_tanh_xe; /**< imposed \f$ X_e(z)\f$ value at the end of each jump (ie at later times)*/

  double many_tanh_width; /**< sharpness of tanh() steps */

  /** parameters for reio_inter */

  int reio_inter_num; /**< with how many jumps do we want to describe reionization? */

  double * reio_inter_z; /**< discrete z values */

  double * reio_inter_xe; /**< discrete \f$ X_e(z)\f$ values */

  /** parameters for energy injection */

  short has_exotic_injection; /**< true if some exotic mechanism
                                 injects energy and affects the
                                 evolution of ionization and/or
                                 temperature and/or other
                                 thermodynamics variables that are
                                 relevant for the calculation of CMB
                                 anisotropies (and spectral
                                 distorsions if requested). */

  struct injection in; /**< structure to store exotic energy injections and their energy deposition */

  double annihilation; /**< parameter describing CDM annihilation (f <sigma*v> / m_cdm, see e.g. 0905.0003) */

  short has_on_the_spot; /**< flag to specify if we want to use the on-the-spot approximation **/

  double decay; /**< parameter describing CDM decay (f/tau, see e.g. 1109.6322)*/

  double annihilation_variation; /**< if this parameter is non-zero,
                                    the function F(z)=(f <sigma*v> /
                                    m_cdm)(z) will be a parabola in
                                    log-log scale between zmin and
                                    zmax, with a curvature given by
                                    annihlation_variation (must be
                                    negative), and with a maximum in
                                    zmax; it will be constant outside
                                    this range */

  double annihilation_z; /**< if annihilation_variation is non-zero,
                            this is the value of z at which the
                            parameter annihilation is defined, i.e.
                            F(annihilation_z)=annihilation */

  double annihilation_zmax; /**< if annihilation_variation is non-zero,
                               redshift above which annihilation rate
                               is maximal */

  double annihilation_zmin; /**< if annihilation_variation is non-zero,
                               redshift below which annihilation rate
                               is constant */

  double annihilation_f_halo; /**< takes the contribution of DM annihilation in halos into account*/
  double annihilation_z_halo; /**< characteristic redshift for DM annihilation in halos*/

  /** parameters for varying fundamental constants */

  short has_varconst; /**< presence of varying fundamental constants? */

  //@}

  /** @name - all indices for the vector of thermodynamical (=th) quantities stored in table */

  //@{

  int index_th_xe;            /**< ionization fraction \f$ x_e \f$ */
  int index_th_dkappa;        /**< Thomson scattering rate \f$ d \kappa / d \tau\f$ (units 1/Mpc) */
  int index_th_tau_d;         /**< Baryon drag optical depth */
  int index_th_ddkappa;       /**< scattering rate derivative \f$ d^2 \kappa / d \tau^2 \f$ */
  int index_th_dddkappa;      /**< scattering rate second derivative \f$ d^3 \kappa / d \tau^3 \f$ */
  int index_th_exp_m_kappa;   /**< \f$ exp^{-\kappa} \f$ */
  int index_th_g;             /**< visibility function \f$ g = (d \kappa / d \tau) * exp^{-\kappa} \f$ */
  int index_th_dg;            /**< visibility function derivative \f$ (d g / d \tau) \f$ */
  int index_th_ddg;           /**< visibility function second derivative \f$ (d^2 g / d \tau^2) \f$ */
  int index_th_T_idm;         /**< idm temperature \f$ T_idm \f$ */
  int index_th_c2_idm;        /**< idm sound speed squared \f$ c_idm^2 \f$ */
  int index_th_T_idr;         /**< idr temperature \f$ T_idr \f$ */
  int index_th_dmu_idm_dr;    /**< scattering rate of idr with idm_g_dr (i.e. idr opacity to idm_g_dr scattering) (units 1/Mpc) */
  int index_th_ddmu_idm_dr;   /**< derivative of the idm_g_dr scattering rate */
  int index_th_dddmu_idm_dr;  /**< second derivative of the idm_g_dr scattering rate */
  int index_th_dmu_idr;       /**< idr self-interaction rate */
  int index_th_tau_idm_dr;    /**< optical depth of idm_dr (due to interactions with idr) */
  int index_th_tau_idr;       /**< optical depth of idr (due to self-interactions) */
  int index_th_g_idm_dr;      /**< visibility function of idm_idr */
  int index_th_dmu_idm_g;     /**< idm_g scattering rate \f$ d \mu / d \tau\f$  (analogous to Thomson scattering) (see 1802.06589 for details) */
  int index_th_ddmu_idm_g;    /**< derivative of idm_g scattering, \f$ d^2 \mu / d \tau^2 \f$ */
  int index_th_dddmu_idm_g;   /**< second derivative of idm_g scattering rate, \f$ d^3 \mu / d \tau^3 \f$ */
  int index_th_exp_mu_idm_g;  /**< \f$ exp^{-\mu} \f$ */
  int index_th_R_idm_b;       /**< idm_b interaction coefficient */
  int index_th_dR_idm_b;      /**< derivative of idm_b interaction coefficient wrt conformal time */
  int index_th_ddR_idm_b;     /**< second derivative of ibm_b interaction coefficient wrt conformal time */
  int index_th_Tb;            /**< baryon temperature \f$ T_b \f$ */
  int index_th_dTb;           /**< derivative of baryon temperature */
  int index_th_wb;            /**< baryon equation of state parameter \f$ w_b = k_B T_b / \mu \f$ */
  int index_th_cb2;           /**< squared baryon adiabatic sound speed \f$ c_b^2 \f$ */
  int index_th_dcb2;          /**< derivative wrt conformal time of squared baryon sound speed \f$ d [c_b^2] / d \tau \f$ (only computed if some non-minimal tight-coupling schemes is requested) */
  int index_th_ddcb2;         /**< second derivative wrt conformal time of squared baryon sound speed  \f$ d^2 [c_b^2] / d \tau^2 \f$ (only computed if some non0-minimal tight-coupling schemes is requested) */
  int index_th_rate;          /**< maximum variation rate of \f$ exp^{-\kappa}\f$, g and \f$ (d g / d \tau) \f$, used for computing integration step in perturbation module */
  int index_th_r_d;           /**< simple analytic approximation to the photon comoving damping scale */

  int th_size;                /**< size of thermodynamics vector */

  //@}

  /** @name - thermodynamics interpolation tables */

  //@{

  int tt_size;                   /**< number of lines (redshift steps) in the tables */
  double * z_table;              /**< vector z_table[index_z] with values of redshift (vector of size tt_size) */
  double * tau_table;            /**< vector tau_table[index_tau] with values of conformal time (vector of size tt_size) */
  double * thermodynamics_table; /**< table thermodynamics_table[index_z*pth->tt_size+pba->index_th] with all other quantities (array of size th_size*tt_size) */

  //@}

  /** @name - table of their second derivatives, used for spline interpolation */

  //@{

  double * d2thermodynamics_dz2_table; /**< table d2thermodynamics_dz2_table[index_z*pth->tt_size+pba->index_th] with values of \f$ d^2 t_i / dz^2 \f$ (array of size th_size*tt_size) */

  //@}

  /** @name - characteristic quantities like redshift, conformal time and sound horizon at recombination */

  //@{

  double z_rec;   /**< z at which the visibility reaches its maximum (= recombination redshift) */
  double tau_rec; /**< conformal time at which the visibility reaches its maximum (= recombination time) */
  double rs_rec;  /**< comoving sound horizon at recombination */
  double ds_rec;  /**< physical sound horizon at recombination */
  double ra_rec;  /**< conformal angular diameter distance to recombination */
  double da_rec;  /**< physical angular diameter distance to recombination */
  double rd_rec;  /**< comoving photon damping scale at recombination */

  double z_star;  /**< redshift at which photon optical depth crosses one */
  double tau_star;/**< confirmal time at which photon optical depth crosses one */
  double rs_star; /**< comoving sound horizon at z_star */
  double ds_star; /**< physical sound horizon at z_star */
  double ra_star;  /**< conformal angular diameter distance to z_star */
  double da_star;  /**< physical angular diameter distance to z_star */
  double rd_star;  /**< comoving photon damping scale at z_star */

  double z_d;     /**< baryon drag redshift */
  double tau_d;   /**< baryon drag time */
  double ds_d;    /**< physical sound horizon at baryon drag */
  double rs_d;    /**< comoving sound horizon at baryon drag */

  double tau_cut; /**< at at which the visibility goes below a fixed fraction of the maximum visibility, used for an approximation in perturbation module */

  double angular_rescaling;      /**< [ratio ra_rec / (tau0-tau_rec)]: gives CMB rescaling in angular space relative to flat model (=1 for curvature K=0) */
  double tau_free_streaming;     /**< minimum value of tau at which free-streaming approximation can be switched on */
  double tau_idr_free_streaming; /**< trigger for dark radiation free streaming approximation (idm-idr) */
  double tau_idr;                /**< decoupling time for idr */
  double tau_idm_dr;             /**< decoupling time for idm from idr*/

  //@}

  /** @name - initial conformal time at which thermodynamical variables have been be integrated */

  //@{

  double tau_ini; /**< initial conformal time at which thermodynamical variables have been be integrated */

  //@}

  /** @name - other thermodynamical quantities */

  //@{

  double fHe;  /**< \f$ f_{He} \f$: primordial helium-to-hydrogen nucleon ratio 4*n_He/n_H */
  double n_e;  /**< total number density of electrons today (free or not) */

  //@}

  /** @name - parameters needed for idm */

  //@{

  double m_idm;          /**< dark matter mass for idm */
  double a_idm_dr;       /**< strength of the coupling between interacting dark matter and interacting dark radiation (idm-idr) */
  double b_idr;          /**< strength of the self coupling for interacting dark radiation (idr-idr) */
  double n_index_idm_dr; /**< temperature dependence of the interactions between dark matter and dark radiation */
  double cross_idm_b;    /**< cross section between interacting dark matter and baryons */
  int n_index_idm_b;     /**< temperature dependence of the interactions between dark matter and baryons */
  double n_coeff_idm_b;  /**< numerical n-dependent coefficient for idm_b */
  double cross_idm_g;    /**< cross section between interacting dark matter and photons */
  double u_idm_g;        /**< ratio between idm_g cross section and idm mass */
  int n_index_idm_g;     /**< temperature dependence of the interactions between dark matter and photons */

  //@}

  /**
   *@name - some flags needed for thermodynamics functions
   */

  //@{

  short inter_normal;  /**< flag for calling thermodynamics_at_z and find position in interpolation table normally */
  short inter_closeby; /**< flag for calling thermodynamics_at_z and find position in interpolation table starting from previous position in previous call */

  //@}

  /** @name - technical parameters */

  //@{

  short thermodynamics_verbose; /**< flag regulating the amount of information sent to standard output (none if set to zero) */
  short hyrec_verbose; /**< flag regulating the amount of information sent to standard output from hyrec (none if set to zero) */

  ErrorMsg error_message; /**< zone for writing error messages */

  short is_allocated; /**< flag is set to true if allocated */
  //@}

};

/**
 * Other structures that are used during the thermodynamics module
 * execution (i.e. during thermodynamics_init()) but get erased later
 * on: thus they cannot be accessed by other modules.
 */

/**
 * Vector of thermodynamical quantities to integrate over, and indices of this vector
 */

struct thermo_vector {

  int ti_size;          /**< size of thermo vector (ti stands for thermodynamical, integrated) */

  int index_ti_x_H;     /**< index for hydrogen fraction in y */
  int index_ti_x_He;    /**< index for helium fraction in y */
  int index_ti_D_Tmat;  /**< index for temperature difference between baryons and photons */
  int index_ti_T_idm;   /**< index for idm temperature fraction in y */

  double * y;           /**< vector of quantities to be integrated */
  double * dy;          /**< time-derivative of the same vector */

  int * used_in_output; /**< boolean array specifying which quantities enter in the calculation of output functions */

};

/**
 * Workspace for differential equation of thermodynamics
 */

struct thermo_diffeq_workspace {

  double x_H;        /**< Hydrogen ionization fraction */
  double x_He;       /**< Helium ionization fraction */
  double x_noreio;   /**< Electron ionization fraction, not taking into account reionization */
  double x_reio;     /**< Electron ionization fraction, taking into account reionization */

  double x;          /**< total ionization fraction following usual CMB convention, n_free/n_H = x_H + fHe * x_He; */

  double Tmat;       /**< matter temperature */

  double R_idm_b;       /**< idm_b interaction coefficient */
  double T_idm;         /**< idm_g temperature \f$ T_{idm-g} \f$ */
  double T_idm_prime;   /**< derivative of idm_g temperature */
  double dmu_idm_g;     /**< scattering rate for idm_g \f& d \mu / d \tau \f$ */
  double c2_idm;        /**< sound speed for idm_g \f$ c_{idm-g}^2  \f$*/
  double dmu_idm_dr;    /**< scattering rate of idr with idm_g_dr (i.e. idr opacity to idm_g_dr scattering) (units 1/Mpc) */
  double dmu_idr;       /**< idr self-interaction rate */
  double Sinv_idm_dr;   /**< ratio of idm and idr densities */

  /* index of approximation schemes for the thermal history */
  int index_ap_idmtca;/**< index for approximation during idm-g, idm-b or idm-dr tca*/
  int index_ap_brec;  /**< before H- and He-recombination */
  int index_ap_He1;   /**< during 1st He-recombination (HeIII) */
  int index_ap_He1f;  /**< in between 1st and 2nd He recombination */
  int index_ap_He2;   /**< beginning of 2nd He-recombination (HeII) */
  int index_ap_H;     /**< beginning of H-recombination (HI) */
  int index_ap_frec;  /**< during and after full H- and HeII-recombination */
  int index_ap_reio;  /**< during reionization */

  int ap_current;     /** current approximation scheme index */
  int ap_size;        /**< number of approximation intervals used during evolver loop */
  int ap_size_loaded; /**< number of all approximations  */

  double * ap_z_limits;       /**< vector storing ending limits of each approximation */
  double * ap_z_limits_delta; /**< vector storing smoothing deltas of each approximation */

  int require_H;  /** in given approximation scheme, do we need to integrate hydrogen ionization fraction? */
  int require_He; /** in given approximation scheme, do we need to integrate helium ionization fraction? */

  struct thermo_vector * ptv;       /**< pointer to vector of integrated quantities and their time-derivatives */
  struct thermohyrec * phyrec;     /**< pointer to wrapper of HyRec structure */
  struct thermorecfast * precfast; /**< pointer to wrapper of RecFast structure */

};

/**
 * Workspace for reionization
 */

struct thermo_reionization_parameters{

  /* parameters used by reio_camb */

  int index_re_reio_redshift;  /**< hydrogen reionization redshift */
  int index_re_reio_exponent;  /**< an exponent used in the function x_e(z) in the reio_camb scheme */
  int index_re_reio_width;     /**< a width defining the duration of hydrogen reionization in the reio_camb scheme */
  int index_re_xe_before; /**< ionization fraction at redshift 'reio_start' */
  int index_re_xe_after;  /**< ionization fraction after full reionization */
  int index_re_helium_fullreio_fraction; /**< helium full reionization fraction inferred from primordial helium fraction */
  int index_re_helium_fullreio_redshift; /**< helium full reionization redshift */
  int index_re_helium_fullreio_width;    /**< a width defining the duration of helium full reionization in the reio_camb scheme */

  /* parameters used by reio_bins_tanh, reio_many_tanh, reio_inter */

  int re_z_size;                /**< number of reionization jumps */
  int index_re_first_z;        /**< redshift at which we start to impose reionization function */
  int index_re_first_xe;       /**< ionization fraction at redshift first_z (inferred from recombination code) */
  int index_re_step_sharpness; /**< sharpness of tanh jump */

  /* parameters used by all schemes */

  int index_re_reio_start;     /**< redshift above which hydrogen reionization neglected */

  double * reionization_parameters; /**< vector containing all reionization parameters necessary to compute xe(z) */
  int re_size;              /**< length of vector reionization_parameters */
};

/**
 * General parameters relevant to thermal history and pointers to few other more specialised worspaces
 */

struct thermo_workspace {

  /* Number of z values */
  int Nz_reco_lin;             /**< number of redshifts linearly sampled for recombination during the evolver loop */
  int Nz_reco_log;             /**< number of redshifts logarithmically sampled for recombination during the evolver loop */
  int Nz_reco;                 /**< number of redshifts for recombination during the evolver loop */
  int Nz_reio;                 /**< number of redshift points of reionization during evolver loop*/
  int Nz_tot;                  /**< total number of sampled redshifts */

  /* Most important and useful parameters of evolution */
  double YHe;          /**< defined as in RECFAST : primordial helium mass fraction */
  double fHe;          /**< defined as in RECFAST : primordial helium-to-hydrogen nucleon ratio */
  double SIunit_H0;    /**< defined as in RECFAST : Hubble parameter today in SI units */
  double SIunit_nH0;   /**< defined as in RECFAST : Hydrogen number density today in SI units*/
  double Tcmb;         /**< CMB temperature today in Kelvin */

  /* Most important and useful constants */
  double const_NR_numberdens;  /**< prefactor in number density of nonrelativistic species */
  double const_Tion_H;         /**< ionization energy for HI as temperature */
  double const_Tion_HeI;       /**< ionization energy for HeI as temperature */
  double const_Tion_HeII;      /**< ionization energy for HeII as temperature */

  short has_ap_idmtca;         /**< flag to determine if we have idm tight-coupling approximation */
  double z_ap_idmtca;          /**< redshift at which we start idm tight-coupling approximation */

  double reionization_optical_depth; /**< reionization optical depth inferred from reionization history */

  int last_index_back; /**< nearest location in background table */

  struct thermo_diffeq_workspace * ptdw;        /**< pointer to workspace for differential equations */
  struct thermo_reionization_parameters * ptrp; /**< pointer to workspace for reionization */

};

/**
 * temporary parameters and workspace passed to the thermodynamics_derivs function
 */

struct thermodynamics_parameters_and_workspace {

  /* structures containing fixed input parameters (indices, ...) */
  struct background * pba;
  struct precision * ppr;
  struct thermodynamics * pth;

  /* workspace */
  struct thermo_workspace * ptw;
  double * pvecback;
};

/**************************************************************/
/* @cond INCLUDE_WITH_DOXYGEN */
/*
 * Boilerplate for C++
 */
#ifdef __cplusplus
extern "C" {
#endif

  /* external functions of the module*/

  int thermodynamics_at_z(struct background * pba,
                          struct thermodynamics * pth,
                          double z,
                          enum interpolation_method inter_mode,
                          int * last_index,
                          double * pvecback,
                          double * pvecthermo);

  int thermodynamics_init(struct precision * ppr,
                          struct background * pba,
                          struct thermodynamics * pth);

  int thermodynamics_free(struct thermodynamics * pth);

  int thermodynamics_free_input(struct thermodynamics * pth);

  /* internal functions of the module */

  int thermodynamics_helium_from_bbn(struct precision * ppr,
                                     struct background * pba,
                                     struct thermodynamics * pth);

  int thermodynamics_checks(struct precision * ppr,
                            struct background* pba,
                            struct thermodynamics * pth);

  int thermodynamics_workspace_init(struct precision * ppr,
                                    struct background * pba,
                                    struct thermodynamics * pth,
                                    struct thermo_workspace * ptw);

  int thermodynamics_indices(struct background * pba,
                             struct thermodynamics * pth,
                             struct thermo_workspace* ptw);

  int thermodynamics_lists(struct precision * ppr,
                           struct background* pba,
                           struct thermodynamics* pth,
                           struct thermo_workspace* ptw);

  int thermodynamics_set_parameters_reionization(struct precision * ppr,
                                                 struct background * pba,
                                                 struct thermodynamics * pth,
                                                 struct thermo_reionization_parameters * preio);

  int thermodynamics_solve(struct precision * ppr,
                           struct background * pba,
                           struct thermodynamics * pth,
                           struct thermo_workspace* ptw,
                           double * pvecback);

  int thermodynamics_calculate_remaining_quantities(struct precision * ppr,
                                                    struct background * pba,
                                                    struct thermodynamics* pth,
                                                    double* pvecback);

  int thermodynamics_output_summary(struct background* pba,
                                    struct thermodynamics* pth);

  int thermodynamics_workspace_free(struct thermodynamics* pth, struct thermo_workspace * ptw);

  int thermodynamics_vector_init(struct precision * ppr,
                                 struct background * pba,
                                 struct thermodynamics * pth,
                                 double z,
                                 struct thermo_workspace * ptw);

  int thermodynamics_reionization_evolve_with_tau(struct thermodynamics_parameters_and_workspace * tpaw,
                                                  double mz_ini,
                                                  double mz_end,
                                                  double * mz_output,
                                                  int Nz);

  int thermodynamics_derivs(
                            double mz,
                            double * y,
                            double * dy,
                            void * parameters_and_workspace,
                            ErrorMsg error_message
                            );

  int thermodynamics_timescale(double z,
                               void * thermo_parameters_and_workspace,
                               double * timescale,
                               ErrorMsg error_message);

  int thermodynamics_sources(double mz,
                             double * y,
                             double * dy,
                             int index_z,
                             void * thermo_parameters_and_workspace,
                             ErrorMsg error_message);

  int thermodynamics_reionization_get_tau(struct precision * ppr,
                                          struct background * pba,
                                          struct thermodynamics * pth,
                                          struct thermo_workspace * ptw);

  int thermodynamics_vector_free(struct thermo_vector * tv);


  int thermodynamics_calculate_conformal_drag_time(struct background* pba,
                                                   struct thermodynamics* pth,
                                                   double* pvecback);

  int thermodynamics_calculate_damping_scale(struct background* pba,
                                             struct thermodynamics* pth,
                                             double* pvecback);

  int thermodynamics_calculate_opticals(struct precision* ppr,
                                        struct thermodynamics* pth);

  int thermodynamics_calculate_recombination_quantities(struct precision* ppr,
                                                        struct background * pba,
                                                        struct thermodynamics* pth,
                                                        double* pvecback);

  int thermodynamics_calculate_drag_quantities(struct precision* ppr,
                                               struct background * pba,
                                               struct thermodynamics* pth,
                                               double* pvecback);

  int thermodynamics_ionization_fractions(
                                          double z,
                                          double * y,
                                          struct background * pba,
                                          struct thermodynamics * pth,
                                          struct thermo_workspace * ptw,
                                          int current_ap
                                          );

  int thermodynamics_reionization_function(double z,
                                           struct thermodynamics * pth,
                                           struct thermo_reionization_parameters * preio,
                                           double * x);

  int thermodynamics_obtain_z_ini(
                                  struct precision * ppr,
                                  struct background *pba,
                                  struct thermodynamics *pth,
                                  struct thermo_workspace * ptw
                                  );

  int thermodynamics_output_titles(struct background * pba,
                                   struct thermodynamics *pth,
                                   char titles[_MAXTITLESTRINGLENGTH_]);

  int thermodynamics_output_data(struct background * pba,
                                 struct thermodynamics *pth,
                                 int number_of_titles,
                                 double *data);

  int thermodynamics_calculate_idm_and_idr_quantities(struct precision * ppr,
                                                      struct background * pba,
                                                      struct thermodynamics * pth,
                                                      double* pvecback);

  int thermodynamics_idm_quantities(struct background * pba,
                                    double z,
                                    double * y,
                                    double * dy,
                                    struct thermodynamics * pth,
                                    struct thermo_workspace * ptw,
                                    double * pvecback);

  int thermodynamics_idm_initial_temperature(struct background* pba,
                                             struct thermodynamics* pth,
                                             double z_ini,
                                             struct thermo_diffeq_workspace * ptdw);

#ifdef __cplusplus
}
#endif

/**************************************************************/

/**
 * @name some flags
 */

//@{

#define _YHE_BBN_ -1 /**< value assigned to the parameter pth->YHe by the input module when this parameter must be computed using BBN tables */

//@}

/**
 * @name Some basic constants needed by RECFAST:
 */

//@{

#define _m_e_ 9.10938215e-31  /**< electron mass in Kg */
#define _m_p_ 1.672621637e-27 /**< proton mass in Kg */
#define _m_H_ 1.673575e-27    /**< Hydrogen mass in Kg */
#define _not4_ 3.9715         /**< Helium to Hydrogen mass ratio */
#define _sigma_ 6.6524616e-29 /**< Thomson cross-section in m^2 */

#define _RECFAST_INTEG_SIZE_ 3

//@}

/**
 * @name Some other physical constants
 */

//@{

#define _s_over_Mpc_ 9.71561189e-15  /**< conversion factor from s to megaparsecs (1 s= const*Mpc) */
#define _Mpc_over_GeV_ 1.56373832e38  /**< conversion factor from GeV to megaparsecs (1 GeV= const/Mpc) */
#define _GeV_over_kg_ 1.78266191e-27  /**< conversion factor from GeV to kg  (1 GeV= const*kg) */
#define _GeVcm3_over_Mpc2_ 94.7024726  /**< conversion factor from  CLASS_rho 1/Mpc^2 to rho in GeV/cm^3 (rho in GeV/cm^3=const*CLASS_rho) */
#define _Jm3_over_Mpc2_ 0.0151730087  /**< conversion factor from  CLASS_rho 1/Mpc^2 to rho in Joule/m^3 (rho in Joule/m^3=const*CLASS_rho) */
#define _Sun_mass_ 1.98855e30 /**< sun mass in kg */
#define _eV_over_Kelvin_ 8.61733034e-5   /**< kB in eV/K */
#define _eV_over_joules_ 6.24150647996e+18 /**< eV/J */


//@}

/* @endcond */

/**
 * @name Some limits imposed on cosmological parameter values:
 */

//@{

#define _YHE_BIG_ 0.5      /**< maximal \f$ Y_{He} \f$ */
#define _YHE_SMALL_ 0.01   /**< minimal \f$ Y_{He} \f$ */
#define _Z_REC_MAX_ 2000.
#define _Z_REC_MIN_ 500.

//@}

#endif

```

`include/transfer.h`:

```h
/** @file transfer.h Documented includes for transfer module. */

#ifndef __TRANSFER__
#define __TRANSFER__

#include "fourier.h"
#include "hyperspherical.h"
#include "errno.h"

/* macro: test if index_tt is in the range between index and index+num, while the flag is true */
#define _index_tt_in_range_(index,num,flag) (flag == _TRUE_) && (index_tt >= index) && (index_tt < index+num)
/* macro: test if index_tt corresponds to an integrated nCl/sCl contribution */
#define _integrated_ncl_ (_index_tt_in_range_(ptr->index_tt_lensing, ppt->selection_num, ppt->has_cl_lensing_potential)) || \
  (_index_tt_in_range_(ptr->index_tt_nc_lens, ppt->selection_num, ppt->has_nc_lens)) || \
    (_index_tt_in_range_(ptr->index_tt_nc_g4,   ppt->selection_num, ppt->has_nc_gr)) || \
    (_index_tt_in_range_(ptr->index_tt_nc_g5,   ppt->selection_num, ppt->has_nc_gr))
/* macro: test if index_tt corresponds to an non-integrated nCl/sCl contribution */
#define _nonintegrated_ncl_ (_index_tt_in_range_(ptr->index_tt_density, ppt->selection_num, ppt->has_nc_density)) || \
  (_index_tt_in_range_(ptr->index_tt_rsd,     ppt->selection_num, ppt->has_nc_rsd)) || \
    (_index_tt_in_range_(ptr->index_tt_d0,      ppt->selection_num, ppt->has_nc_rsd)) || \
    (_index_tt_in_range_(ptr->index_tt_d1,      ppt->selection_num, ppt->has_nc_rsd)) || \
    (_index_tt_in_range_(ptr->index_tt_nc_g1,   ppt->selection_num, ppt->has_nc_gr))  || \
    (_index_tt_in_range_(ptr->index_tt_nc_g2,   ppt->selection_num, ppt->has_nc_gr))  || \
    (_index_tt_in_range_(ptr->index_tt_nc_g3,   ppt->selection_num, ppt->has_nc_gr))
/* macro: bin number associated to particular redshift bin and selection function for non-integrated contributions*/
#define _get_bin_nonintegrated_ncl_(index_tt)                           \
  if (_index_tt_in_range_(ptr->index_tt_density, ppt->selection_num, ppt->has_nc_density)) \
    bin = index_tt - ptr->index_tt_density;                             \
  if (_index_tt_in_range_(ptr->index_tt_rsd,     ppt->selection_num, ppt->has_nc_rsd)) \
    bin = index_tt - ptr->index_tt_rsd;                                 \
  if (_index_tt_in_range_(ptr->index_tt_d0,      ppt->selection_num, ppt->has_nc_rsd)) \
    bin = index_tt - ptr->index_tt_d0;                                  \
  if (_index_tt_in_range_(ptr->index_tt_d1,      ppt->selection_num, ppt->has_nc_rsd)) \
    bin = index_tt - ptr->index_tt_d1;                                  \
  if (_index_tt_in_range_(ptr->index_tt_nc_g1,   ppt->selection_num, ppt->has_nc_gr)) \
    bin = index_tt - ptr->index_tt_nc_g1;                               \
  if (_index_tt_in_range_(ptr->index_tt_nc_g2,   ppt->selection_num, ppt->has_nc_gr)) \
    bin = index_tt - ptr->index_tt_nc_g2;                               \
  if (_index_tt_in_range_(ptr->index_tt_nc_g3,   ppt->selection_num, ppt->has_nc_gr)) \
    bin = index_tt - ptr->index_tt_nc_g3;
/* macro: bin number associated to particular redshift bin and selection function for integrated contributions*/
#define _get_bin_integrated_ncl_(index_tt)                              \
  if (_index_tt_in_range_(ptr->index_tt_lensing, ppt->selection_num, ppt->has_cl_lensing_potential)) \
    bin = index_tt - ptr->index_tt_lensing;                             \
  if (_index_tt_in_range_(ptr->index_tt_nc_lens, ppt->selection_num, ppt->has_nc_lens)) \
    bin = index_tt - ptr->index_tt_nc_lens;                             \
  if (_index_tt_in_range_(ptr->index_tt_nc_g4,   ppt->selection_num, ppt->has_nc_gr)) \
    bin = index_tt - ptr->index_tt_nc_g4;                               \
  if (_index_tt_in_range_(ptr->index_tt_nc_g5,   ppt->selection_num, ppt->has_nc_gr)) \
    bin = index_tt - ptr->index_tt_nc_g5;
/**
 * Structure containing everything about transfer functions in
 * harmonic space \f$ \Delta_l^{X} (q) \f$ that other modules need to
 * know.
 *
 * Once initialized by transfer_init(), contains all tables of
 * transfer functions used for interpolation in other modules, for all
 * requested modes (scalar/vector/tensor), initial conditions, types
 * (temperature, polarization, etc), multipoles l, and wavenumbers q.
 *
 * Wavenumbers are called q in this module and k in the perturbation
 * module. In flat universes k=q. In non-flat universes q and k differ
 * through q2 = k2 + K(1+m), where m=0,1,2 for scalar, vector,
 * tensor. q should be used throughout the transfer module, except
 * when interpolating or manipulating the source functions S(k,tau)
 * calculated in the perturbation module: for a given value of q, this
 * should be done at the corresponding k(q).
 *
 * The content of this structure is entirely computed in this module,
 * given the content of the 'precision', 'bessels', 'background',
 * 'thermodynamics' and 'perturbation' structures.
 */

struct transfer {

  /** @name - input parameters initialized by user in input module
   *  (all other quantities are computed in this module, given these
   *  parameters and the content of previous structures) */

  //@{

  double lcmb_rescale; /**< normally set to one, can be used
                          exceptionally to rescale by hand the CMB
                          lensing potential */
  double lcmb_tilt;    /**< normally set to zero, can be used
                          exceptionally to tilt by hand the CMB
                          lensing potential */
  double lcmb_pivot;   /**< if lcmb_tilt non-zero, corresponding pivot
                          scale */

  double selection_bias[_SELECTION_NUM_MAX_];               /**< light-to-mass bias in the transfer function of density number count */
  double selection_magnification_bias[_SELECTION_NUM_MAX_]; /**< magnification bias in the transfer function of density number count */

  short has_nz_file;     /**< Has dN/dz (selection function) input file? */
  short has_nz_analytic; /**< Use analytic form for dN/dz (selection function) distribution? */
  FileName nz_file_name; /**< dN/dz (selection function) input file name */
  int nz_size;           /**< number of redshift values in input tabulated selection function */
  double * nz_z;         /**< redshift values in input tabulated selection function */
  double * nz_nz;        /**< input tabulated values of selection function */
  double * nz_ddnz;      /**< second derivatives in splined selection function*/

  short has_nz_evo_file;      /**< Has dN/dz (evolution function) input file? */
  short has_nz_evo_analytic;  /**< Use analytic form for dN/dz (evolution function) distribution? */
  FileName nz_evo_file_name;  /**< dN/dz (evolution function) input file name */
  int nz_evo_size;            /**< number of redshift values in input tabulated evolution function */
  double * nz_evo_z;          /**< redshift values in input tabulated evolution function */
  double * nz_evo_nz;         /**< input tabulated values of evolution function */
  double * nz_evo_dlog_nz;    /**< log of tabulated values of evolution function */
  double * nz_evo_dd_dlog_nz; /**< second derivatives in splined log of evolution function */

  //@}

  /** @name - flag stating whether we need transfer functions at all */

  //@{

  short has_cls; /**< copy of same flag in perturbation structure */

  //@}

  /** @name - number of modes and transfer function types */

  //@{

  int md_size;       /**< number of modes included in computation */

  int index_tt_t0;      /**< index for transfer type = temperature (j=0 term) */
  int index_tt_t1;      /**< index for transfer type = temperature (j=1 term) */
  int index_tt_t2;      /**< index for transfer type = temperature (j=2 term) */
  int index_tt_e;       /**< index for transfer type = E-polarization */
  int index_tt_b;       /**< index for transfer type = B-polarization */
  int index_tt_lcmb;    /**< index for transfer type = CMB lensing */
  int index_tt_density; /**< index for first bin of transfer type = matter density */
  int index_tt_lensing; /**< index for first bin of transfer type = galaxy lensing */

  int index_tt_rsd;     /**< index for first bin of transfer type = redshift space distortion of number count */
  int index_tt_d0;      /**< index for first bin of transfer type = doppler effect for of number count (j=0 term) */
  int index_tt_d1;      /**< index for first bin of transfer type = doppler effect for of number count (j=1 term) */
  int index_tt_nc_lens; /**< index for first bin of transfer type = lensing for of number count */
  int index_tt_nc_g1;   /**< index for first bin of transfer type = gravity term G1 for of number count */
  int index_tt_nc_g2;   /**< index for first bin of transfer type = gravity term G2 for of number count */
  int index_tt_nc_g3;   /**< index for first bin of transfer type = gravity term G3 for of number count */
  int index_tt_nc_g4;   /**< index for first bin of transfer type = gravity term G3 for of number count */
  int index_tt_nc_g5;   /**< index for first bin of transfer type = gravity term G3 for of number count */

  int * tt_size;     /**< number of requested transfer types tt_size[index_md] for each mode */

  //@}

  /** @name - number and list of multipoles */

  //@{

  int ** l_size_tt;  /**< number of multipole values for which we effectively compute the transfer function,l_size_tt[index_md][index_tt] */

  int * l_size;   /**< number of multipole values for each requested mode, l_size[index_md] */

  int l_size_max; /**< greatest of all l_size[index_md] */

  int * l;        /**< list of multipole values l[index_l] */

  //int * l_size_bessel; /**< for each wavenumber, maximum value of l at which bessel functions must be evaluated */

  double angular_rescaling; /**< correction between l and k space due to curvature (= comoving angular diameter distance to recombination / comoving radius to recombination) */

  //@}

  /** @name - number and list of wavenumbers */

  //@{

  size_t q_size; /**< number of wavenumber values corresponding to k up to k_max_cl */

  double * q;  /**< list of wavenumber values, q[index_q] */

  double ** k; /**< list of wavenumber values for each requested mode, k[index_md][index_q]. In flat universes k=q. In non-flat universes q and k differ through q2 = k2 + K(1+m), where m=0,1,2 for scalar, vector, tensor. q should be used throughout the transfer module, excepted when interpolating or manipulating the source functions S(k,tau): for a given value of q this should be done in k(q). */

  int index_q_flat_approximation; /**< index of the first q value using the flat rescaling approximation */

  short do_lcmb_full_limber; /**< in this particular run, will we use the full Limber scheme? */

  size_t q_size_limber; /**< number of wavenumber values corresponding to k up to k_max */

  double * q_limber;  /**< list of wavenumber values used in full limber scheme, q_limber[index_q] */

  double ** k_limber; /**< list of wavenumber values used in full limber scheme */

  //@}

  /** @name - transfer functions */

  //@{

  double ** transfer; /**< table of transfer functions for each mode, initial condition, type, multipole and wavenumber, with argument transfer[index_md][((index_ic * ptr->tt_size[index_md] + index_tt) * ptr->l_size[index_md] + index_l) * ptr->q_size + index_q] */

  double ** transfer_limber; /**< table of transfer functions used in full limber scheme */

  //@}

  /** @name - technical parameters */

  //@{

  short transfer_verbose; /**< flag regulating the amount of information sent to standard output (none if set to zero) */

  ErrorMsg error_message; /**< zone for writing error messages */

  short is_allocated; /**< flag is set to true if allocated */

  //@}
};

/**
 * Structure containing all the quantities that each thread needs to
 * know for computing transfer functions (but that can be forgotten
 * once the transfer functions are known, otherwise they would be
 * stored in the transfer module)
 */

struct transfer_workspace {

  /** @name - quantities related to Bessel functions */

  //@{

  HyperInterpStruct HIS; /**< structure containing all hyperspherical bessel functions (flat case) or all hyperspherical bessel functions for a given value of beta=q/sqrt(|K|) (non-flat case). HIS = Hyperspherical Interpolation Structure. */

  int HIS_allocated; /**< flag specifying whether the previous structure has been allocated */

  HyperInterpStruct * pBIS;  /**< pointer to structure containing all the spherical bessel functions of the flat case (used even in the non-flat case, for approximation schemes). pBIS = pointer to Bessel Interpolation Structure. */

  int l_size;        /**< number of l values */

  //@}

  /** @name - quantities related to the integrand of the transfer functions (most of them are arrays of time) */

  //@{

  int tau_size;                  /**< number of discrete time values for a given type */
  int tau_size_max;              /**< maximum number of discrete time values for all types */
  double * interpolated_sources; /**< interpolated_sources[index_tau]:
                                    sources interpolated from the
                                    perturbation module at the right
                                    value of k */
  double * sources;              /**< sources[index_tau]: sources
                                    used in transfer module, possibly
                                    differing from those in the
                                    perturbation module by some
                                    resampling or rescaling */
  double * tau0_minus_tau;       /**< tau0_minus_tau[index_tau]: values of (tau0 - tau) */
  double * w_trapz;              /**< w_trapz[index_tau]: values of weights in trapezoidal integration (related to time steps) */
  double * chi;                  /**< chi[index_tau]: value of argument of bessel
                                    function: k(tau0-tau) (flat case)
                                    or sqrt(|K|)(tau0-tau) (non-flat
                                    case) */
  double * cscKgen;              /**< cscKgen[index_tau]: useful trigonometric function */
  double * cotKgen;              /**< cotKgen[index_tau]: useful trigonometric function */

  //@}

  /** @name - parameters defining the spatial curvature (copied from background structure) */

  //@{

  double K; /**< curvature parameter (see background module for details) */
  int sgnK; /**< 0 (flat), 1 (positive curvature, spherical, closed), -1 (negative curvature, hyperbolic, open) */

  //@}

  double tau0_minus_tau_cut; /**< critical value of (tau0-tau) in time cut approximation for the wavenumber at hand */
  short neglect_late_source; /**< flag stating whether we use the time cut approximation for the wavenumber at hand */
};

/**
 * enumeration of possible source types. This looks redundant with
 * respect to the definition of indices index_tt_... This definition is however
 * convenient and time-saving: it allows to use a "case" statement in
 * transfer_radial_function()
 */

typedef enum {SCALAR_TEMPERATURE_0,
              SCALAR_TEMPERATURE_1,
              SCALAR_TEMPERATURE_2,
              SCALAR_POLARISATION_E,
              VECTOR_TEMPERATURE_1,
              VECTOR_TEMPERATURE_2,
              VECTOR_POLARISATION_E,
              VECTOR_POLARISATION_B,
              TENSOR_TEMPERATURE_2,
              TENSOR_POLARISATION_E,
              TENSOR_POLARISATION_B,
              NC_RSD} radial_function_type;

enum Hermite_Interpolation_Order {HERMITE3, HERMITE4, HERMITE6};

/*************************************************************************************************************/
/* @cond INCLUDE_WITH_DOXYGEN */
/*
 * Boilerplate for C++
 */
#ifdef __cplusplus
extern "C" {
#endif

  int transfer_functions_at_q(
                              struct transfer * ptr,
                              int index_md,
                              int index_ic,
                              int index_type,
                              int index_l,
                              double q,
                              double * ptransfer_local
                              );

  int transfer_init(
                    struct precision * ppr,
                    struct background * pba,
                    struct thermodynamics * pth,
                    struct perturbations * ppt,
                    struct fourier * pfo,
                    struct transfer * ptr
                    );

  int transfer_free(
                    struct transfer * ptr
                    );

  int transfer_indices(
                       struct precision * ppr,
                       struct perturbations * ppt,
                       struct transfer * ptr,
                       double q_period,
                       int nu_spacing,
                       double K,
                       int sgnK
                       );

  int transfer_perturbation_copy_sources_and_nl_corrections(
                                                            struct perturbations * ppt,
                                                            struct fourier * pfo,
                                                            struct transfer * ptr,
                                                            double *** sources
                                                            );

  int transfer_perturbation_source_spline(
                                          struct perturbations * ppt,
                                          struct transfer * ptr,
                                          double *** sources,
                                          double *** sources_spline
                                          );

  int transfer_perturbation_sources_free(
                                         struct perturbations * ppt,
                                         struct fourier * pfo,
                                         struct transfer * ptr,
                                         double *** sources
                                         );

  int transfer_perturbation_sources_spline_free(
                                                struct perturbations * ppt,
                                                struct transfer * ptr,
                                                double *** sources_spline
                                                );

  int transfer_get_l_list(
                          struct precision * ppr,
                          struct perturbations * ppt,
                          struct transfer * ptr
                          );

  int transfer_get_q_list(
                          struct precision * ppr,
                          struct perturbations * ppt,
                          struct transfer * ptr,
                          double q_period,
                          int nu_spacing, // For closed universe, the spacing of nu is not just 1, but can be 2, 3, etc.
                          double K,
                          int sgnK
                          );

  int transfer_get_q_limber_list(
                                 struct precision * ppr,
                                 struct perturbations * ppt,
                                 struct transfer * ptr,
                                 double K,
                                 int sgnK
                                 );

  int transfer_get_k_list(
                          struct perturbations * ppt,
                          struct transfer * ptr,
                          double K
                          );

  int transfer_get_source_correspondence(
                                         struct perturbations * ppt,
                                         struct transfer * ptr,
                                         int ** tp_of_tt
                                         );

  int transfer_free_source_correspondence(
                                          struct transfer * ptr,
                                          int ** tp_of_tt
                                          );

  int transfer_source_tau_size_max(
                                   struct precision * ppr,
                                   struct background * pba,
                                   struct perturbations * ppt,
                                   struct transfer * ptr,
                                   double tau_rec,
                                   double tau0,
                                   int * tau_size_max
                                   );

  int transfer_source_tau_size(
                               struct precision * ppr,
                               struct background * pba,
                               struct perturbations * ppt,
                               struct transfer * ptr,
                               double tau_rec,
                               double tau0,
                               int index_md,
                               int index_tt,
                               int * tau_size
                               );

  int transfer_compute_for_each_q(
                                  struct precision * ppr,
                                  struct background * pba,
                                  struct perturbations * ppt,
                                  struct transfer * ptr,
                                  int ** tp_of_tt,
                                  int index_q,
                                  int tau_size_max,
                                  double tau_rec,
                                  double *** sources,
                                  double *** sources_spline,
                                  double * window,
                                  struct transfer_workspace * ptw,
                                  short use_full_limber
                                  );

  int transfer_radial_coordinates(
                                  struct transfer * ptr,
                                  struct transfer_workspace * ptw,
                                  int index_md,
                                  int index_q
                                  );

  int transfer_interpolate_sources(
                                   struct perturbations * ppt,
                                   struct transfer * ptr,
                                   double k,
                                   int index_md,
                                   int index_ic,
                                   int index_type,
                                   double * sources,
                                   double * source_spline,
                                   double * interpolated_sources
                                   );

  int transfer_sources(
                       struct precision * ppr,
                       struct background * pba,
                       struct perturbations * ppt,
                       struct transfer * ptr,
                       double * interpolated_sources,
                       double tau_rec,
                       double k,
                       int index_md,
                       int index_tt,
                       double * sources,
                       double * window,
                       int tau_size_max,
                       double * tau0_minus_tau,
                       double * delta_tau,
                       int * tau_size_out
                       );

  int transfer_selection_function(
                                  struct precision * ppr,
                                  struct perturbations * ppt,
                                  struct transfer * ptr,
                                  int bin,
                                  double z,
                                  double * selection);

  int transfer_dNdz_analytic(
                             struct transfer * ptr,
                             double z,
                             double * dNdz,
                             double * dln_dNdz_dz);

  int transfer_selection_sampling(
                                  struct precision * ppr,
                                  struct background * pba,
                                  struct perturbations * ppt,
                                  struct transfer * ptr,
                                  int bin,
                                  double * tau0_minus_tau,
                                  int tau_size);

  int transfer_lensing_sampling(
                                struct precision * ppr,
                                struct background * pba,
                                struct perturbations * ppt,
                                struct transfer * ptr,
                                int bin,
                                double tau0,
                                double * tau0_minus_tau,
                                int tau_size);

  int transfer_source_resample(
                               struct precision * ppr,
                               struct background * pba,
                               struct perturbations * ppt,
                               struct transfer * ptr,
                               int bin,
                               double * tau0_minus_tau,
                               int tau_size,
                               int index_md,
                               double tau0,
                               double * interpolated_sources,
                               double * sources);

  int transfer_selection_times(
                               struct precision * ppr,
                               struct background * pba,
                               struct perturbations * ppt,
                               struct transfer * ptr,
                               int bin,
                               double * tau_min,
                               double * tau_mean,
                               double * tau_max);

  int transfer_selection_compute(
                                 struct precision * ppr,
                                 struct background * pba,
                                 struct perturbations * ppt,
                                 struct transfer * ptr,
                                 double * selection,
                                 double * tau0_minus_tau,
                                 double * delta_tau,
                                 int tau_size,
                                 double * pvecback,
                                 double tau0,
                                 int bin);

  int transfer_compute_for_each_l(
                                  struct transfer_workspace * ptw,
                                  struct precision * ppr,
                                  struct perturbations * ppt,
                                  struct transfer * ptr,
                                  int index_q,
                                  int index_md,
                                  int index_ic,
                                  int index_tt,
                                  int index_l,
                                  double l,
                                  double q_max_bessel,
                                  radial_function_type radial_type,
                                  short use_full_limber
                                  );

  int transfer_use_limber(
                          struct precision * ppr,
                          struct perturbations * ppt,
                          struct transfer * ptr,
                          double q_max_bessel,
                          int index_md,
                          int index_tt,
                          double q,
                          double l,
                          short * use_limber
                          );

  int transfer_integrate(
                         struct perturbations * ppt,
                         struct transfer * ptr,
                         struct transfer_workspace *ptw,
                         int index_q,
                         int index_md,
                         int index_tt,
                         double l,
                         int index_l,
                         double q,
                         radial_function_type radial_type,
                         double * trsf
                         );

  int transfer_limber(
                      struct transfer * ptr,
                      struct transfer_workspace * ptw,
                      int index_md,
                      int index_q,
                      double l,
                      double q,
                      radial_function_type radial_type,
                      double * trsf
                      );

  int transfer_limber_interpolate(
                                  struct transfer * ptr,
                                  double * tau0_minus_tau,
                                  double * sources,
                                  int tau_size,
                                  double tau0_minus_tau_limber,
                                  double * S
                                  );

  int transfer_limber2(
                       int tau_size,
                       struct transfer * ptr,
                       int index_md,
                       int index_q,
                       double l,
                       double q,
                       double * tau0_minus_tau,
                       double * sources,
                       radial_function_type radial_type,
                       double * trsf
                       );

  int transfer_can_be_neglected(
                                struct precision * ppr,
                                struct perturbations * ppt,
                                struct transfer * ptr,
                                int index_md,
                                int index_ic,
                                int index_tt,
                                double ra_rec,
                                double q,
                                double l,
                                short * neglect
                                );

  int transfer_late_source_can_be_neglected(
                                            struct precision * ppr,
                                            struct perturbations * ppt,
                                            struct transfer * ptr,
                                            int index_md,
                                            int index_tt,
                                            double l,
                                            short * neglect);

  int transfer_select_radial_function(
                                      struct perturbations * ppt,
                                      struct transfer * ptr,
                                      int index_md,
                                      int index_tt,
                                      radial_function_type *radial_type
                                      );

  int transfer_radial_function(
                               struct transfer_workspace * ptw,
                               struct perturbations * ppt,
                               struct transfer * ptr,
                               double k,
                               int index_q,
                               int index_l,
                               int x_size,
                               double * radial_function,
                               radial_function_type radial_type
                               );

  int transfer_init_HIS_from_bessel(
                                    struct transfer * ptr,
                                    HyperInterpStruct *pHIS
                                    );

  int transfer_global_selection_read(
                                     struct transfer * ptr
                                     );

  int transfer_workspace_init(
                              struct transfer * ptr,
                              struct precision * ppr,
                              struct transfer_workspace *ptw,
                              int perturbations_tau_size,
                              int tau_size_max,
                              double K,
                              int sgnK,
                              double tau0_minus_tau_cut,
                              HyperInterpStruct * pBIS
                              );

  int transfer_workspace_free(
                              struct transfer * ptr,
                              struct transfer_workspace *ptw
                              );

  int transfer_update_HIS(
                          struct precision * ppr,
                          struct transfer * ptr,
                          struct transfer_workspace * ptw,
                          int index_q,
                          double tau0
                          );

  int transfer_get_lmax(int (*get_xmin_generic)(int sgnK,
                                                int l,
                                                double nu,
                                                double xtol,
                                                double phiminabs,
                                                double *x_nonzero,
                                                int *fevals),
                        int sgnK,
                        double nu,
                        int *lvec,
                        int lsize,
                        double phiminabs,
                        double xmax,
                        double xtol,
                        int *index_l_left,
                        int *index_l_right,
                        ErrorMsg error_message);

  int transfer_precompute_selection(
                                    struct precision * ppr,
                                    struct background * pba,
                                    struct perturbations * ppt,
                                    struct transfer * ptr,
                                    double tau_rec,
                                    int tau_size_max,
                                    double ** window
                                    );

  int transfer_f_evo(
                     struct background* pba,
                     struct transfer * ptr,
                     double* pvecback,
                     int last_index,
                     double cotKgen,
                     double* f_evo
                     );

#ifdef __cplusplus
}
#endif

#endif
/* @endcond */

```

`include/trigonometric_integrals.h`:

```h
/**
 * definitions for module trigonometric_integrals.c
 */

#ifndef __TRIGONOMETRIC_INTEGRALS__
#define __TRIGONOMETRIC_INTEGRALS__

#include "common.h"

/**
 * Boilerplate for C++
 */
#ifdef __cplusplus
extern "C" {
#endif

  int cosine_integral(
				 double x,
				 double *Ci,
         ErrorMsg error_message
				 );

  int sine_integral(
				 double x,
				 double *Si,
         ErrorMsg error_message
				 );

#ifdef __cplusplus
}
#endif

#endif

```

`source/background.c`:

```c
/** @file background.c Documented background module
 *
 * * Julien Lesgourgues, 17.04.2011
 * * routines related to ncdm written by T. Tram in 2011
 * * new integration scheme written by N. Schoeneberg in 2020
 *
 * Deals with the cosmological background evolution.
 * This module has two purposes:
 *
 * - at the beginning, to initialize the background, i.e. to integrate
 *    the background equations, and store all background quantities
 *    as a function of conformal time inside an interpolation table.
 *
 * - to provide routines which allow other modules to evaluate any
 *    background quantity for a given value of the conformal time (by
 *    interpolating within the interpolation table), or to find the
 *    correspondence between redshift and conformal time.
 *
 *
 * The overall logic in this module is the following:
 *
 * 1. most background parameters that we will call {A}
 * (e.g. rho_gamma, ..) can be expressed as simple analytical
 * functions of the scale factor 'a' plus a few variables that we will
 * call {B} (e.g. (phi, phidot) for quintessence, or some temperature
 * for exotic particles, etc...). [Side note: for simplicity, all variables
 * {B} are declared redundently inside {A}.]
 *
 * 2. in turn, quantities {B} can be found as a function of the the
 * scale factor [or rather (a/a_0)] by integrating the
 * background equations. Thus {B} also includes the density of species
 * which energy conservation equation must be integrated explicitely,
 * like the density of fluids or of decaying dark matter.
 *
 * 3. some other quantities that we will call {C} (like e.g. proper
 * and conformal time, the sound horizon, the analytic scale-invariant
 * growth factor) also require an explicit integration with respect to
 * (a/a_0) [or rather log(a/a_p)], since they cannot be inferred
 * analytically from (a/a_0) and parameters {B}. The difference
 * between {B} and {C} parameters is that {C} parameters do not need
 * to be known in order to get {A}.
 *
 * So, we define the following routines:
 *
 * - background_functions() returns all background quantities {A} as a
 *    function of (a/a_0) and of quantities {B}.
 *
 * - background_solve() integrates the quantities {B} and {C} with
 *    respect to log(a/a_0); this integration requires many calls to
 *    background_functions().
 *
 * - the result is stored in the form of a big table in the background
 *    structure. There is one column for the scale factor, and one for
 *    each quantity {A} or {C} [Side note: we don;t include {B} here
 *    because the {B} variables are already decalred redundently also
 *    as {A} quantitites.]
 *
 * Later in the code:
 *
 * - If we know the variables (a/a_0) + {B} and need some quantity {A}
 *    (but not {C}), the quickest and most precise way is to call
 *    directly background_functions() (for instance, in simple models,
 *    if we want H at a given value of the scale factor).
 *
 * - If we know 'tau' and want any other quantity, we can call
 *    background_at_tau(), which interpolates in the table and returns
 *    all values.
 *
 * - If we know 'z' but not the {B} variables, or if we know 'z' and
 *    we want {C} variables, we need to call background_at_z(), which
 *    interpolates in the table and returns all values.
 *
 * - Finally, it can be useful to get 'tau' for a given redshift 'z'
 *    or vice-versa: this can be done with background_tau_of_z() or
 *    background_z_of_tau().
 *
 *
 * In order to save time, background_at_tau() ans background_at_z()
 * can be called in three modes: short_info, normal_info, long_info
 * (returning only essential quantities, or useful quantities, or
 * rarely useful quantities). Each line in the interpolation table is
 * a vector whose first few elements correspond to the short_info
 * format; a larger fraction contribute to the normal format; and the
 * full vector corresponds to the long format. The guideline is that
 * short_info returns only geometric quantities like a, H, H'; normal
 * format returns quantities strictly needed at each step in the
 * integration of perturbations; long_info returns quantities needed
 * only occasionally.
 *
 * In summary, the following functions can be called from other modules:
 *
 * -# background_init() at the beginning background_at_tau(),
 * -# background_at_z(), background_tau_of_z(), background_z_of_tau() at any later time
 * -# background_free() at the end, when no more calls to the previous functions are needed
 *
 * For units and normalisation conventions, there are two guiding principles:
 *
 * 1) All quantities are expressed in natural units in which everything is in powers of Mpc, e.g.:
 *
 * - t stands for (cosmological or proper time)*c in Mpc
 * - tau stands for (conformal time)*c in Mpc
 * - H stands for (Hubble parameter)/c in \f$ Mpc^{-1} \f$
 * - etc.
 *
 * 2) New since v3.0: all quantities that should normally scale with some power of
 * a_0^n are renormalised by a_0^{-n}, in order to be independent of a_0, e.g.
 *
 * - a in the code stands for \f$ a/a_0 \f$ in reality
 * - tau in the code stands for \f$ a_0 \tau c \f$ in Mpc
 * - any prime in the code stands for \f$ (1/a_0) d/d\tau \f$
 * - r stands for any comoving radius times a_0
 * - etc.
 */

#include "background.h"

/**
 * Background quantities at given redshift z.
 *
 * Evaluates all background quantities at a given value of
 * redshift by reading the pre-computed table and interpolating.
 *
 * @param pba           Input: pointer to background structure (containing pre-computed table)
 * @param z             Input: redshift
 * @param return_format Input: format of output vector (short_info, normal_info, long_info)
 * @param inter_mode     Input: interpolation mode (normal or closeby)
 * @param last_index    Input/Output: index of the previous/current point in the interpolation array (input only for closeby mode, output for both)
 * @param pvecback      Output: vector (assumed to be already allocated)
 * @return the error status
 */

int background_at_z(
                    struct background *pba,
                    double z,
                    enum vecback_format return_format,
                    enum interpolation_method inter_mode,
                    int * last_index,
                    double * pvecback /* vector with argument pvecback[index_bg] (must be already allocated with a size compatible with return_format) */
                    ) {

  /** Summary: */

  /** - define local variables */

  /* size of output vector, controlled by input parameter return_format */
  int pvecback_size;

  /* log(a) (in fact, given our normalisation conventions, this is log(a/a_0)) */
  double loga;

  /** - check that log(a) = log(1/(1+z)) = -log(1+z) is in the pre-computed range */
  loga = -log(1+z);

  class_test(loga < pba->loga_table[0],
             pba->error_message,
             "out of range: a/a_0 = %e < a_min/a_0 = %e, you should decrease the precision parameter a_ini_over_a_today_default\n",1./(1.+z),exp(pba->loga_table[0]));

  class_test(loga > pba->loga_table[pba->bt_size-1],
             pba->error_message,
             "out of range: a/a_0 = %e > a_max/a_0 = %e\n",1./(1.+z),exp(pba->loga_table[pba->bt_size-1]));

  /** - deduce length of returned vector from format mode */

  if (return_format == normal_info) {
    pvecback_size=pba->bg_size_normal;
  }
  else {
    if (return_format == short_info) {
      pvecback_size=pba->bg_size_short;
    }
    else {
      pvecback_size=pba->bg_size;
    }
  }


  /** - interpolate from pre-computed table with array_interpolate()
      or array_interpolate_growing_closeby() (depending on
      interpolation mode) */

  if (inter_mode == inter_normal) {
    class_call(array_interpolate_spline(
                                        pba->loga_table,
                                        pba->bt_size,
                                        pba->background_table,
                                        pba->d2background_dloga2_table,
                                        pba->bg_size,
                                        loga,
                                        last_index,
                                        pvecback,
                                        pvecback_size,
                                        pba->error_message),
               pba->error_message,
               pba->error_message);
  }
  if (inter_mode == inter_closeby) {
    class_call(array_interpolate_spline_growing_closeby(
                                                        pba->loga_table,
                                                        pba->bt_size,
                                                        pba->background_table,
                                                        pba->d2background_dloga2_table,
                                                        pba->bg_size,
                                                        loga,
                                                        last_index,
                                                        pvecback,
                                                        pvecback_size,
                                                        pba->error_message),
               pba->error_message,
               pba->error_message);
  }

  return _SUCCESS_;
}

/**
 * Background quantities at given conformal time tau.
 *
 * Evaluates all background quantities at a given value of
 * conformal time by reading the pre-computed table and interpolating.
 *
 * @param pba           Input: pointer to background structure (containing pre-computed table)
 * @param tau           Input: value of conformal time
 * @param return_format Input: format of output vector (short_info, normal_info, long_info)
 * @param inter_mode     Input: interpolation mode (normal or closeby)
 * @param last_index    Input/Output: index of the previous/current point in the interpolation array (input only for closeby mode, output for both)
 * @param pvecback      Output: vector (assumed to be already allocated)
 * @return the error status
 */

int background_at_tau(
                      struct background *pba,
                      double tau,
                      enum vecback_format return_format,
                      enum interpolation_method inter_mode,
                      int * last_index,
                      double * pvecback /* vector with argument pvecback[index_bg] (must be already allocated with a size compatible with return_format) */
                      ) {

  /** Summary: */

  /** - define local variables */
  double z;

  /** - Get current redshift */
  class_call(background_z_of_tau(pba,tau,&z),
             pba->error_message,
             pba->error_message);

  /** - Get background at corresponding redshift */
  class_call(background_at_z(pba,z,return_format,inter_mode,last_index,pvecback),
             pba->error_message,
             pba->error_message);

  return _SUCCESS_;
}

/**
 * Conformal time at given redshift.
 *
 * Returns tau(z) by interpolation from pre-computed table.
 *
 * @param pba Input: pointer to background structure
 * @param z   Input: redshift
 * @param tau Output: conformal time
 * @return the error status
 */

int background_tau_of_z(
                        struct background *pba,
                        double z,
                        double * tau
                        ) {

  /** Summary: */

  /** - define local variables */

  /* necessary for calling array_interpolate(), but never used */
  int last_index;

  /** - check that \f$ z \f$ is in the pre-computed range */
  class_test(z < pba->z_table[pba->bt_size-1],
             pba->error_message,
             "out of range: z=%e < z_min=%e\n",z,pba->z_table[pba->bt_size-1]);

  class_test(z > pba->z_table[0],
             pba->error_message,
             "out of range: z=%e > z_max=%e\n",z,pba->z_table[0]);

  /** - interpolate from pre-computed table with array_interpolate() */
  class_call(array_interpolate_spline(
                                      pba->z_table,
                                      pba->bt_size,
                                      pba->tau_table,
                                      pba->d2tau_dz2_table,
                                      1,
                                      z,
                                      &last_index,
                                      tau,
                                      1,
                                      pba->error_message),
             pba->error_message,
             pba->error_message);

  return _SUCCESS_;
}
/**
 * Redshift at given conformal time.
 *
 * Returns z(tau) by interpolation from pre-computed table.
 *
 * @param pba Input: pointer to background structure
 * @param tau Input: conformal time
 * @param z   Output: redshift
 * @return the error status
 */

int background_z_of_tau(
                        struct background *pba,
                        double tau,
                        double * z
                        ) {

  /** Summary: */

  /** - define local variables */

  /* necessary for calling array_interpolate(), but never used */
  int last_index;

  /** - check that \f$ tau \f$ is in the pre-computed range */
  class_test(tau < pba->tau_table[0],
             pba->error_message,
             "out of range: tau=%e < tau_min=%e\n",tau,pba->tau_table[0]);

  class_test(tau > pba->tau_table[pba->bt_size-1],
             pba->error_message,
             "out of range: tau=%e > tau_max=%e\n",tau,pba->tau_table[pba->bt_size-1]);

  /** - interpolate from pre-computed table with array_interpolate() */
  class_call(array_interpolate_spline(
                                      pba->tau_table,
                                      pba->bt_size,
                                      pba->z_table,
                                      pba->d2z_dtau2_table,
                                      1,
                                      tau,
                                      &last_index,
                                      z,
                                      1,
                                      pba->error_message),
             pba->error_message,
             pba->error_message);

  return _SUCCESS_;
}

/**
 * Function evaluating all background quantities which can be computed
 * analytically as a function of a and of {B} quantities (see
 * discussion at the beginning of this file).
 *
 * @param pba           Input: pointer to background structure
 * @param a             Input: scale factor (in fact, with our normalisation conventions, this is (a/a_0) )
 * @param pvecback_B    Input: vector containing all {B} quantities
 * @param return_format Input: format of output vector
 * @param pvecback      Output: vector of background quantities (assumed to be already allocated)
 * @return the error status
 */

int background_functions(
                         struct background * pba,
                         double a,
                         double * pvecback_B, /* vector with argument pvecback[index_bi] */
                         enum vecback_format return_format,
                         double * pvecback /* vector with argument pvecback[index_bg] (must be already allocated with a size compatible with return_format) */
                         ) {

  /** Summary: */

  /** - define local variables */

  /* total density */
  double rho_tot;
  /* critical density */
  double rho_crit;
  /* total pressure */
  double p_tot;
  /* total relativistic density */
  double rho_r;
  /* total non-relativistic density */
  double rho_m;
  /* background ncdm quantities */
  double rho_ncdm,p_ncdm,pseudo_p_ncdm;
  /* index for n_ncdm species */
  int n_ncdm;
  /* fluid's time-dependent equation of state parameter */
  double w_fld, dw_over_da, integral_fld;
  /* scalar field quantities */
  double phi, phi_prime;
  /* Since we only know a_prime_over_a after we have rho_tot,
     it is not possible to simply sum up p_tot_prime directly.
     Instead we sum up dp_dloga = p_prime/a_prime_over_a. The formula is
     p_prime = a_prime_over_a * dp_dloga = a_prime_over_a * Sum [ (w_prime/a_prime_over_a -3(1+w)w)rho].
     Note: The scalar field contribution must be added in the end, as an exception!*/
  double dp_dloga;

  /** - initialize local variables */
  rho_tot = 0.;
  p_tot = 0.;
  dp_dloga = 0.;
  rho_r=0.;
  rho_m=0.;

  class_test(a <= 0.,
             pba->error_message,
             "a = %e instead of strictly positive",a);

  /** - pass value of \f$ a\f$ to output */
  pvecback[pba->index_bg_a] = a;

  /** - compute each component's density and pressure */

  /* photons */
  pvecback[pba->index_bg_rho_g] = pba->Omega0_g * pow(pba->H0,2) / pow(a,4);
  rho_tot += pvecback[pba->index_bg_rho_g];
  p_tot += (1./3.) * pvecback[pba->index_bg_rho_g];
  dp_dloga += -(4./3.) * pvecback[pba->index_bg_rho_g];
  rho_r += pvecback[pba->index_bg_rho_g];

  /* baryons */
  pvecback[pba->index_bg_rho_b] = pba->Omega0_b * pow(pba->H0,2) / pow(a,3);
  rho_tot += pvecback[pba->index_bg_rho_b];
  p_tot += 0;
  rho_m += pvecback[pba->index_bg_rho_b];

  /* cdm */
  if (pba->has_cdm == _TRUE_) {
    pvecback[pba->index_bg_rho_cdm] = pba->Omega0_cdm * pow(pba->H0,2) / pow(a,3);
    rho_tot += pvecback[pba->index_bg_rho_cdm];
    p_tot += 0.;
    rho_m += pvecback[pba->index_bg_rho_cdm];
  }

  /* idm */
  if (pba->has_idm == _TRUE_) {
    pvecback[pba->index_bg_rho_idm] = pba->Omega0_idm * pow(pba->H0,2) / pow(a,3);
    rho_tot += pvecback[pba->index_bg_rho_idm];
    p_tot += 0.;
    rho_m += pvecback[pba->index_bg_rho_idm];
  }

  /* dcdm */
  if (pba->has_dcdm == _TRUE_) {
    /* Pass value of rho_dcdm to output */
    pvecback[pba->index_bg_rho_dcdm] = pvecback_B[pba->index_bi_rho_dcdm];
    rho_tot += pvecback[pba->index_bg_rho_dcdm];
    p_tot += 0.;
    rho_m += pvecback[pba->index_bg_rho_dcdm];
  }

  /* dr */
  if (pba->has_dr == _TRUE_) {
    /* Pass value of rho_dr to output */
    pvecback[pba->index_bg_rho_dr] = pvecback_B[pba->index_bi_rho_dr];
    rho_tot += pvecback[pba->index_bg_rho_dr];
    p_tot += (1./3.)*pvecback[pba->index_bg_rho_dr];
    dp_dloga += -(4./3.) * pvecback[pba->index_bg_rho_dr];
    rho_r += pvecback[pba->index_bg_rho_dr];
  }

  /* Scalar field */
  if (pba->has_scf == _TRUE_) {
    phi = pvecback_B[pba->index_bi_phi_scf];
    phi_prime = pvecback_B[pba->index_bi_phi_prime_scf];
    pvecback[pba->index_bg_phi_scf] = phi; // value of the scalar field phi
    pvecback[pba->index_bg_phi_prime_scf] = phi_prime; // value of the scalar field phi derivative wrt conformal time
    pvecback[pba->index_bg_V_scf] = V_scf(pba,phi); //V_scf(pba,phi); //write here potential as function of phi
    pvecback[pba->index_bg_dV_scf] = dV_scf(pba,phi); // dV_scf(pba,phi); //potential' as function of phi
    pvecback[pba->index_bg_ddV_scf] = ddV_scf(pba,phi); // ddV_scf(pba,phi); //potential'' as function of phi
    pvecback[pba->index_bg_rho_scf] = (phi_prime*phi_prime/(2*a*a) + V_scf(pba,phi))/3.; // energy of the scalar field. The field units are set automatically by setting the initial conditions
    pvecback[pba->index_bg_p_scf] =(phi_prime*phi_prime/(2*a*a) - V_scf(pba,phi))/3.; // pressure of the scalar field
    rho_tot += pvecback[pba->index_bg_rho_scf];
    p_tot += pvecback[pba->index_bg_p_scf];
    dp_dloga += 0.0; /** <-- This depends on a_prime_over_a, so we cannot add it now! */
    //divide relativistic & nonrelativistic (not very meaningful for oscillatory models)
    rho_r += 3.*pvecback[pba->index_bg_p_scf]; //field pressure contributes radiation
    rho_m += pvecback[pba->index_bg_rho_scf] - 3.* pvecback[pba->index_bg_p_scf]; //the rest contributes matter
    //printf(" a= %e, Omega_scf = %f, \n ",a, pvecback[pba->index_bg_rho_scf]/rho_tot );
  }

  /* ncdm */
  if (pba->has_ncdm == _TRUE_) {

    /* Loop over species: */
    for (n_ncdm=0; n_ncdm<pba->N_ncdm; n_ncdm++) {

      /* function returning background ncdm[n_ncdm] quantities (only
         those for which non-NULL pointers are passed) */
      class_call(background_ncdm_momenta(
                                         pba->q_ncdm_bg[n_ncdm],
                                         pba->w_ncdm_bg[n_ncdm],
                                         pba->q_size_ncdm_bg[n_ncdm],
                                         pba->M_ncdm[n_ncdm],
                                         pba->factor_ncdm[n_ncdm],
                                         1./a-1.,
                                         NULL,
                                         &rho_ncdm,
                                         &p_ncdm,
                                         NULL,
                                         &pseudo_p_ncdm),
                 pba->error_message,
                 pba->error_message);

      pvecback[pba->index_bg_rho_ncdm1+n_ncdm] = rho_ncdm;
      rho_tot += rho_ncdm;
      pvecback[pba->index_bg_p_ncdm1+n_ncdm] = p_ncdm;
      p_tot += p_ncdm;
      pvecback[pba->index_bg_pseudo_p_ncdm1+n_ncdm] = pseudo_p_ncdm;
      /** See e.g. Eq. A6 in 1811.00904. */
      dp_dloga += (pseudo_p_ncdm - 5*p_ncdm);

      /* (3 p_ncdm1) is the "relativistic" contribution to rho_ncdm1 */
      rho_r += 3.* p_ncdm;

      /* (rho_ncdm1 - 3 p_ncdm1) is the "non-relativistic" contribution
         to rho_ncdm1 */
      rho_m += rho_ncdm - 3.* p_ncdm;
    }
  }

  /* Lambda */
  if (pba->has_lambda == _TRUE_) {
    pvecback[pba->index_bg_rho_lambda] = pba->Omega0_lambda * pow(pba->H0,2);
    rho_tot += pvecback[pba->index_bg_rho_lambda];
    p_tot -= pvecback[pba->index_bg_rho_lambda];
  }

  /* fluid with w(a) and constant cs2 */
  if (pba->has_fld == _TRUE_) {

    /* get rho_fld from vector of integrated variables */
    pvecback[pba->index_bg_rho_fld] = pvecback_B[pba->index_bi_rho_fld];

    /* get w_fld from dedicated function */
    class_call(background_w_fld(pba,a,&w_fld,&dw_over_da,&integral_fld), pba->error_message, pba->error_message);
    pvecback[pba->index_bg_w_fld] = w_fld;

    // Obsolete: at the beginning, we had here the analytic integral solution corresponding to the case w=w0+w1(1-a/a0):
    // pvecback[pba->index_bg_rho_fld] = pba->Omega0_fld * pow(pba->H0,2) / pow(a,3.*(1.+pba->w0_fld+pba->wa_fld)) * exp(3.*pba->wa_fld*(a-1.));
    // But now everthing is integrated numerically for a given w_fld(a) defined in the function background_w_fld.

    rho_tot += pvecback[pba->index_bg_rho_fld];
    p_tot += w_fld * pvecback[pba->index_bg_rho_fld];
    dp_dloga += (a*dw_over_da-3*(1+w_fld)*w_fld)*pvecback[pba->index_bg_rho_fld];
  }

  /* relativistic neutrinos (and all relativistic relics) */
  if (pba->has_ur == _TRUE_) {
    pvecback[pba->index_bg_rho_ur] = pba->Omega0_ur * pow(pba->H0,2) / pow(a,4);
    rho_tot += pvecback[pba->index_bg_rho_ur];
    p_tot += (1./3.) * pvecback[pba->index_bg_rho_ur];
    dp_dloga += -(4./3.) * pvecback[pba->index_bg_rho_ur];
    rho_r += pvecback[pba->index_bg_rho_ur];
  }

  /* interacting dark radiation */
  if (pba->has_idr == _TRUE_) {
    pvecback[pba->index_bg_rho_idr] = pba->Omega0_idr * pow(pba->H0,2) / pow(a,4);
    rho_tot += pvecback[pba->index_bg_rho_idr];
    p_tot += (1./3.) * pvecback[pba->index_bg_rho_idr];
    rho_r += pvecback[pba->index_bg_rho_idr];
  }

  /** - compute expansion rate H from Friedmann equation: this is the
      only place where the Friedmann equation is assumed. Remember
      that densities are all expressed in units of \f$ [3c^2/8\pi G] \f$, ie
      \f$ \rho_{class} = [8 \pi G \rho_{physical} / 3 c^2]\f$ */
  pvecback[pba->index_bg_H] = sqrt(rho_tot-pba->K/a/a);

  /** - compute derivative of H with respect to conformal time */
  pvecback[pba->index_bg_H_prime] = - (3./2.) * (rho_tot + p_tot) * a + pba->K/a;

  /* Total energy density*/
  pvecback[pba->index_bg_rho_tot] = rho_tot;

  /* Total pressure */
  pvecback[pba->index_bg_p_tot] = p_tot;

  /* Derivative of total pressure w.r.t. conformal time */
  pvecback[pba->index_bg_p_tot_prime] = a*pvecback[pba->index_bg_H]*dp_dloga;
  if (pba->has_scf == _TRUE_) {
    /** The contribution of scf was not added to dp_dloga, add p_scf_prime here: */
    pvecback[pba->index_bg_p_prime_scf] = pvecback[pba->index_bg_phi_prime_scf]*
      (-pvecback[pba->index_bg_phi_prime_scf]*pvecback[pba->index_bg_H]/a-2./3.*pvecback[pba->index_bg_dV_scf]);
    pvecback[pba->index_bg_p_tot_prime] += pvecback[pba->index_bg_p_prime_scf];
  }

  /** - compute critical density */
  rho_crit = rho_tot-pba->K/a/a;
  class_test(rho_crit <= 0.,
             pba->error_message,
             "rho_crit = %e instead of strictly positive",rho_crit);

  /** - compute relativistic density to total density ratio */
  pvecback[pba->index_bg_Omega_r] = rho_r / rho_crit;

  /** - compute other quantities in the exhaustive, redundant format */
  if (return_format == long_info) {

    /** - store critical density */
    pvecback[pba->index_bg_rho_crit] = rho_crit;

    /** - compute Omega_m */
    pvecback[pba->index_bg_Omega_m] = rho_m / rho_crit;

    /** - cosmological time */
    pvecback[pba->index_bg_time] = pvecback_B[pba->index_bi_time];

    /** - comoving sound horizon */
    pvecback[pba->index_bg_rs] = pvecback_B[pba->index_bi_rs];

    /** - growth factor */
    pvecback[pba->index_bg_D] = pvecback_B[pba->index_bi_D];

    /** - velocity growth factor */
    pvecback[pba->index_bg_f] = pvecback_B[pba->index_bi_D_prime]/( pvecback_B[pba->index_bi_D]*a*pvecback[pba->index_bg_H]);

    /**- Varying fundamental constants */
    if (pba->has_varconst == _TRUE_) {
      class_call(background_varconst_of_z(pba,
                                          1./a-1.,
                                          &(pvecback[pba->index_bg_varc_alpha]),
                                          &(pvecback[pba->index_bg_varc_me])
                                          ),
                 pba->error_message,
                 pba->error_message);
    }

    /* one can put other variables here */
    /*  */
    /*  */

  }

  return _SUCCESS_;

}

/**
 * Single place where the fluid equation of state is
 * defined. Parameters of the function are passed through the
 * background structure. Generalisation to arbitrary functions should
 * be simple.
 *
 * @param pba            Input: pointer to background structure
 * @param a              Input: current value of scale factor (in fact, with our conventions, of (a/a_0))
 * @param w_fld          Output: equation of state parameter w_fld(a)
 * @param dw_over_da_fld Output: function dw_fld/da
 * @param integral_fld   Output: function \f$ \int_{a}^{a_0} da 3(1+w_{fld})/a \f$
 * @return the error status
 */

int background_w_fld(
                     struct background * pba,
                     double a,
                     double * w_fld,
                     double * dw_over_da_fld,
                     double * integral_fld
                     ) {

  double Omega_ede = 0.;
  double dOmega_ede_over_da = 0.;
  double d2Omega_ede_over_da2 = 0.;
  double a_eq, Omega_r, Omega_m;

  /** - first, define the function w(a) */
  switch (pba->fluid_equation_of_state) {
  case CLP:
    *w_fld = pba->w0_fld + pba->wa_fld * (1. - a);
    break;
  case EDE:
    // Omega_ede(a) taken from eq. (10) in 1706.00730
    Omega_ede = (pba->Omega0_fld - pba->Omega_EDE*(1.-pow(a,-3.*pba->w0_fld)))
      /(pba->Omega0_fld+(1.-pba->Omega0_fld)*pow(a,3.*pba->w0_fld))
      + pba->Omega_EDE*(1.-pow(a,-3.*pba->w0_fld));

    // d Omega_ede / d a taken analytically from the above
    dOmega_ede_over_da = - pba->Omega_EDE* 3.*pba->w0_fld*pow(a,-3.*pba->w0_fld-1.)/(pba->Omega0_fld+(1.-pba->Omega0_fld)*pow(a,3.*pba->w0_fld))
      - (pba->Omega0_fld - pba->Omega_EDE*(1.-pow(a,-3.*pba->w0_fld)))*(1.-pba->Omega0_fld)*3.*pba->w0_fld*pow(a,3.*pba->w0_fld-1.)/pow(pba->Omega0_fld+(1.-pba->Omega0_fld)*pow(a,3.*pba->w0_fld),2)
      + pba->Omega_EDE*3.*pba->w0_fld*pow(a,-3.*pba->w0_fld-1.);

    // find a_equality (needed because EDE tracks first radiation, then matter)
    Omega_r = pba->Omega0_g * (1. + 3.044 * 7./8.*pow(4./11.,4./3.)); // assumes LambdaCDM + eventually massive neutrinos so light that they are relativistic at equality; needs to be generalised later on.
    Omega_m = pba->Omega0_b;
    if (pba->has_cdm == _TRUE_) Omega_m += pba->Omega0_cdm;
    if (pba->has_idm == _TRUE_) Omega_m += pba->Omega0_idm;
    if (pba->has_dcdm == _TRUE_)
      class_stop(pba->error_message,"Early Dark Energy not compatible with decaying Dark Matter because we omitted to code the calculation of a_eq in that case, but it would not be difficult to add it if necessary, should be a matter of 5 minutes");
    a_eq = Omega_r/Omega_m; // assumes a flat universe with a=1 today

    // w_ede(a) taken from eq. (11) in 1706.00730
    *w_fld = - dOmega_ede_over_da*a/Omega_ede/3./(1.-Omega_ede)+a_eq/3./(a+a_eq);
    break;
  }


  /** - then, give the corresponding analytic derivative dw/da (used
      by perturbation equations; we could compute it numerically,
      but with a loss of precision; as long as there is a simple
      analytic expression of the derivative of the previous
      function, let's use it! */
  switch (pba->fluid_equation_of_state) {
  case CLP:
    *dw_over_da_fld = - pba->wa_fld;
    break;
  case EDE:
    d2Omega_ede_over_da2 = 0.;
    *dw_over_da_fld = - d2Omega_ede_over_da2*a/3./(1.-Omega_ede)/Omega_ede
      - dOmega_ede_over_da/3./(1.-Omega_ede)/Omega_ede
      + dOmega_ede_over_da*dOmega_ede_over_da*a/3./(1.-Omega_ede)/(1.-Omega_ede)/Omega_ede
      + a_eq/3./(a+a_eq)/(a+a_eq);
    break;
  }

  /** - finally, give the analytic solution of the following integral:
      \f$ \int_{a}^{a0} da 3(1+w_{fld})/a \f$. This is used in only
      one place, in the initial conditions for the background, and
      with a=a_ini. If your w(a) does not lead to a simple analytic
      solution of this integral, no worry: instead of writing
      something here, the best would then be to leave it equal to
      zero, and then in background_initial_conditions() you should
      implement a numerical calculation of this integral only for
      a=a_ini, using for instance Romberg integration. It should be
      fast, simple, and accurate enough. */
  switch (pba->fluid_equation_of_state) {
  case CLP:
    *integral_fld = 3.*((1.+pba->w0_fld+pba->wa_fld)*log(1./a) + pba->wa_fld*(a-1.));
    break;
  case EDE:
    class_stop(pba->error_message,"EDE implementation not finished: to finish it, read the comments in background.c just before this line\n");
    break;
  }

  /** note: of course you can generalise these formulas to anything,
      defining new parameters pba->w..._fld. Just remember that so
      far, HyRec explicitely assumes that w(a)= w0 + wa (1-a/a0); but
      Recfast does not assume anything */

  return _SUCCESS_;
}

/**
 * Single place where the variation of fundamental constants is
 * defined. Parameters of the function are passed through the
 * background structure. Generalisation to arbitrary functions should
 * be simple.
 *
 * @param pba            Input: pointer to background structure
 * @param z              Input: current value of redhsift
 * @param alpha          Output: fine structure constant relative to its current value
 * @param me             Output: effective electron mass relative to its current value
 * @return the error status
 */

int background_varconst_of_z(
                             struct background* pba,
                             double z,
                             double* alpha,
                             double* me
                             ){

  switch(pba->varconst_dep){

  case varconst_none:
    *alpha = 1.;
    *me = 1.;
    break;

  case varconst_instant:
    if (z>pba->varconst_transition_redshift){
      *alpha = pba->varconst_alpha;
      *me = pba->varconst_me;
    }
    else{
      *alpha = 1.;
      *me = 1.;
    }
    break;

    /* Implement here your arbitrary model of varying fundamental constants! */
  }
  return _SUCCESS_;
}

/**
 * Initialize the background structure, and in particular the
 * background interpolation table.
 *
 * @param ppr Input: pointer to precision structure
 * @param pba Input/Output: pointer to initialized background structure
 * @return the error status
 */

int background_init(
                    struct precision * ppr,
                    struct background * pba
                    ) {

  /** Summary: */

  /** - write class version */
  if (pba->background_verbose > 0) {
    printf("Running CLASS version %s\n",_VERSION_);
    printf("Computing background\n");
  }

  /** - if shooting failed during input, catch the error here */
  class_test(pba->shooting_failed == _TRUE_,
             pba->error_message,
             "Shooting failed, try optimising input_get_guess(). Error message:\n\n%s",
             pba->shooting_error);

  /** - assign values to all indices in vectors of background quantities */
  class_call(background_indices(pba),
             pba->error_message,
             pba->error_message);

  /** - check that input parameters make sense and write additional information about them */
  class_call(background_checks(ppr,pba),
             pba->error_message,
             pba->error_message);

  /** - integrate the background over log(a), allocate and fill the background table */
  class_call(background_solve(ppr,pba),
             pba->error_message,
             pba->error_message);

  /** - find and store a few derived parameters at radiation-matter equality */
  class_call(background_find_equality(ppr,pba),
             pba->error_message,
             pba->error_message);

  /* - write a summary of the budget of the universe */
  class_call(background_output_budget(pba),
             pba->error_message,
             pba->error_message);

  pba->is_allocated = _TRUE_;

  return _SUCCESS_;

}

/**
 * Free all memory space allocated by background_init() and by input_read_parameters().
 *
 *
 * @param pba Input: pointer to background structure (to be freed)
 * @return the error status
 */

int background_free(
                    struct background *pba
                    ) {

  class_call(background_free_noinput(pba),
             pba->error_message,
             pba->error_message);

  class_call(background_free_input(pba),
             pba->error_message,
             pba->error_message);

  pba->is_allocated = _FALSE_;

  return _SUCCESS_;
}

/**
 * Free only the memory space NOT allocated through
 * input_read_parameters(), but through background_init()
 *
 * @param pba Input: pointer to background structure (to be freed)
 * @return the error status
 */

int background_free_noinput(
                            struct background *pba
                            ) {

  free(pba->tau_table);
  free(pba->z_table);
  free(pba->loga_table);
  free(pba->d2tau_dz2_table);
  free(pba->d2z_dtau2_table);
  free(pba->background_table);
  free(pba->d2background_dloga2_table);

  return _SUCCESS_;
}
/**
 * Free pointers inside background structure which were
 * allocated in input_read_parameters()
 *
 * @param pba Input: pointer to background structure
 * @return the error status
 */

int background_free_input(
                          struct background *pba
                          ) {

  int k;

  if (pba->Omega0_ncdm_tot != 0.) {
    for (k=0; k<pba->N_ncdm; k++) {
      free(pba->q_ncdm[k]);
      free(pba->w_ncdm[k]);
      free(pba->q_ncdm_bg[k]);
      free(pba->w_ncdm_bg[k]);
      free(pba->dlnf0_dlnq_ncdm[k]);
    }
    free(pba->ncdm_quadrature_strategy);
    free(pba->ncdm_input_q_size);
    free(pba->ncdm_qmax);
    free(pba->q_ncdm);
    free(pba->w_ncdm);
    free(pba->q_ncdm_bg);
    free(pba->w_ncdm_bg);
    free(pba->dlnf0_dlnq_ncdm);
    free(pba->q_size_ncdm);
    free(pba->q_size_ncdm_bg);
    free(pba->M_ncdm);
    free(pba->T_ncdm);
    free(pba->ksi_ncdm);
    free(pba->deg_ncdm);
    free(pba->Omega0_ncdm);
    free(pba->m_ncdm_in_eV);
    free(pba->factor_ncdm);
    if (pba->got_files!=NULL)
      free(pba->got_files);
    if (pba->ncdm_psd_files!=NULL)
      free(pba->ncdm_psd_files);
    if (pba->ncdm_psd_parameters!=NULL)
      free(pba->ncdm_psd_parameters);
  }

  if (pba->Omega0_scf != 0.) {
    if (pba->scf_parameters != NULL)
      free(pba->scf_parameters);
  }
  return _SUCCESS_;
}

/**
 * Assign value to each relevant index in vectors of background quantities.
 *
 * @param pba Input: pointer to background structure
 * @return the error status
 */

int background_indices(
                       struct background *pba
                       ) {

  /** Summary: */

  /** - define local variables */

  /* a running index for the vector of background quantities */
  int index_bg;
  /* a running index for the vector of background quantities to be integrated */
  int index_bi;

  /** - initialize all flags: which species are present? */

  pba->has_cdm = _FALSE_;
  pba->has_idm = _FALSE_;
  pba->has_ncdm = _FALSE_;
  pba->has_dcdm = _FALSE_;
  pba->has_dr = _FALSE_;
  pba->has_scf = _FALSE_;
  pba->has_lambda = _FALSE_;
  pba->has_fld = _FALSE_;
  pba->has_ur = _FALSE_;
  pba->has_idr = _FALSE_;
  pba->has_curvature = _FALSE_;
  pba->has_varconst  = _FALSE_;

  if (pba->Omega0_cdm != 0.)
    pba->has_cdm = _TRUE_;

  if (pba->Omega0_idm != 0.)
    pba->has_idm = _TRUE_;

  if (pba->Omega0_ncdm_tot != 0.)
    pba->has_ncdm = _TRUE_;

  if (pba->Omega0_dcdmdr != 0.) {
    pba->has_dcdm = _TRUE_;
    if (pba->Gamma_dcdm != 0.)
      pba->has_dr = _TRUE_;
  }

  if (pba->Omega0_scf != 0.)
    pba->has_scf = _TRUE_;

  if (pba->Omega0_lambda != 0.)
    pba->has_lambda = _TRUE_;

  if (pba->Omega0_fld != 0.)
    pba->has_fld = _TRUE_;

  if (pba->Omega0_ur != 0.)
    pba->has_ur = _TRUE_;

  if (pba->Omega0_idr != 0.)
    pba->has_idr = _TRUE_;

  if (pba->sgnK != 0)
    pba->has_curvature = _TRUE_;

  if (pba->varconst_dep != varconst_none)
    pba->has_varconst = _TRUE_;

  /** - initialize all indices */

  index_bg=0;

  /* index for scale factor */
  class_define_index(pba->index_bg_a,_TRUE_,index_bg,1);

  /* - indices for H and its conformal-time-derivative */
  class_define_index(pba->index_bg_H,_TRUE_,index_bg,1);
  class_define_index(pba->index_bg_H_prime,_TRUE_,index_bg,1);

  /* - end of indices in the short vector of background values */
  pba->bg_size_short = index_bg;

  /* - index for rho_g (photon density) */
  class_define_index(pba->index_bg_rho_g,_TRUE_,index_bg,1);

  /* - index for rho_b (baryon density) */
  class_define_index(pba->index_bg_rho_b,_TRUE_,index_bg,1);

  /* - index for rho_cdm */
  class_define_index(pba->index_bg_rho_cdm,pba->has_cdm,index_bg,1);

  /* - index for rho_idm  */
  class_define_index(pba->index_bg_rho_idm,pba->has_idm,index_bg,1);

  /* - indices for ncdm. We only define the indices for ncdm1
     (density, pressure, pseudo-pressure), the other ncdm indices
     are contiguous */
  class_define_index(pba->index_bg_rho_ncdm1,pba->has_ncdm,index_bg,pba->N_ncdm);
  class_define_index(pba->index_bg_p_ncdm1,pba->has_ncdm,index_bg,pba->N_ncdm);
  class_define_index(pba->index_bg_pseudo_p_ncdm1,pba->has_ncdm,index_bg,pba->N_ncdm);

  /* - index for dcdm */
  class_define_index(pba->index_bg_rho_dcdm,pba->has_dcdm,index_bg,1);

  /* - index for dr */
  class_define_index(pba->index_bg_rho_dr,pba->has_dr,index_bg,1);

  /* - indices for scalar field */
  class_define_index(pba->index_bg_phi_scf,pba->has_scf,index_bg,1);
  class_define_index(pba->index_bg_phi_prime_scf,pba->has_scf,index_bg,1);
  class_define_index(pba->index_bg_V_scf,pba->has_scf,index_bg,1);
  class_define_index(pba->index_bg_dV_scf,pba->has_scf,index_bg,1);
  class_define_index(pba->index_bg_ddV_scf,pba->has_scf,index_bg,1);
  class_define_index(pba->index_bg_rho_scf,pba->has_scf,index_bg,1);
  class_define_index(pba->index_bg_p_scf,pba->has_scf,index_bg,1);
  class_define_index(pba->index_bg_p_prime_scf,pba->has_scf,index_bg,1);

  /* - index for Lambda */
  class_define_index(pba->index_bg_rho_lambda,pba->has_lambda,index_bg,1);

  /* - index for fluid */
  class_define_index(pba->index_bg_rho_fld,pba->has_fld,index_bg,1);
  class_define_index(pba->index_bg_w_fld,pba->has_fld,index_bg,1);

  /* - index for ultra-relativistic neutrinos/species */
  class_define_index(pba->index_bg_rho_ur,pba->has_ur,index_bg,1);

  /* - index for total density */
  class_define_index(pba->index_bg_rho_tot,_TRUE_,index_bg,1);

  /* - index for total pressure */
  class_define_index(pba->index_bg_p_tot,_TRUE_,index_bg,1);

  /* - index for derivative of total pressure */
  class_define_index(pba->index_bg_p_tot_prime,_TRUE_,index_bg,1);

  /* - index for Omega_r (relativistic density fraction) */
  class_define_index(pba->index_bg_Omega_r,_TRUE_,index_bg,1);

  /* - index interacting for dark radiation */
  class_define_index(pba->index_bg_rho_idr,pba->has_idr,index_bg,1);

  /* - put here additional ingredients that you want to appear in the
     normal vector */
  /*    */
  /*    */

  /* - end of indices in the normal vector of background values */
  pba->bg_size_normal = index_bg;

  /* - indices in the long version : */

  /* -> critical density */
  class_define_index(pba->index_bg_rho_crit,_TRUE_,index_bg,1);

  /* - index for Omega_m (non-relativistic density fraction) */
  class_define_index(pba->index_bg_Omega_m,_TRUE_,index_bg,1);

  /* -> conformal distance */
  class_define_index(pba->index_bg_conf_distance,_TRUE_,index_bg,1);

  /* -> angular diameter distance */
  class_define_index(pba->index_bg_ang_distance,_TRUE_,index_bg,1);

  /* -> luminosity distance */
  class_define_index(pba->index_bg_lum_distance,_TRUE_,index_bg,1);

  /* -> proper time (for age of the Universe) */
  class_define_index(pba->index_bg_time,_TRUE_,index_bg,1);

  /* -> conformal sound horizon */
  class_define_index(pba->index_bg_rs,_TRUE_,index_bg,1);

  /* -> density growth factor in dust universe */
  class_define_index(pba->index_bg_D,_TRUE_,index_bg,1);

  /* -> velocity growth factor in dust universe */
  class_define_index(pba->index_bg_f,_TRUE_,index_bg,1);

  /* -> varying fundamental constant -- alpha (fine structure) */
  class_define_index(pba->index_bg_varc_alpha,pba->has_varconst,index_bg,1);

  /* -> varying fundamental constant -- me (effective electron mass) */
  class_define_index(pba->index_bg_varc_me,pba->has_varconst,index_bg,1);

  /* -> put here additional quantities describing background */
  /*    */
  /*    */

  /* -> end of indices in the long vector of background values */
  pba->bg_size = index_bg;

  /* - now, indices in vector of variables to integrate.
     First {B} variables, then {C} variables. */

  index_bi=0;

  /* -> index for conformal time in vector of variables to integrate */
  class_define_index(pba->index_bi_tau,_TRUE_,index_bi,1);

  /* -> energy density in DCDM */
  class_define_index(pba->index_bi_rho_dcdm,pba->has_dcdm,index_bi,1);

  /* -> energy density in DR */
  class_define_index(pba->index_bi_rho_dr,pba->has_dr,index_bi,1);

  /* -> energy density in fluid */
  class_define_index(pba->index_bi_rho_fld,pba->has_fld,index_bi,1);

  /* -> scalar field and its derivative wrt conformal time (Zuma) */
  class_define_index(pba->index_bi_phi_scf,pba->has_scf,index_bi,1);
  class_define_index(pba->index_bi_phi_prime_scf,pba->has_scf,index_bi,1);

  /* End of {B} variables */
  pba->bi_B_size = index_bi;

  /* now continue with {C} variables */

  /* -> proper time (for age of the Universe) */
  class_define_index(pba->index_bi_time,_TRUE_,index_bi,1);

  /* -> sound horizon */
  class_define_index(pba->index_bi_rs,_TRUE_,index_bi,1);

  /* -> Second order equation for growth factor */
  class_define_index(pba->index_bi_D,_TRUE_,index_bi,1);
  class_define_index(pba->index_bi_D_prime,_TRUE_,index_bi,1);


  /* -> end of indices in the vector of variables to integrate */
  pba->bi_size = index_bi;

  return _SUCCESS_;

}

/**
 * This is the routine where the distribution function f0(q) of each
 * ncdm species is specified (it is the only place to modify if you
 * need a partlar f0(q))
 *
 * @param pbadist Input:  structure containing all parameters defining f0(q)
 * @param q       Input:  momentum
 * @param f0      Output: phase-space distribution
 */

int background_ncdm_distribution(
                                 void * pbadist,
                                 double q,
                                 double * f0
                                 ) {
  struct background * pba;
  struct background_parameters_for_distributions * pbadist_local;
  int n_ncdm,lastidx;
  double ksi;
  double qlast,dqlast,f0last,df0last;
  double *param;
  /* Variables corresponding to entries in param: */
  //double square_s12,square_s23,square_s13;
  //double mixing_matrix[3][3];
  //int i;

  /** - extract from the input structure pbadist all the relevant information */
  pbadist_local = pbadist;          /* restore actual format of pbadist */
  pba = pbadist_local->pba;         /* extract the background structure from it */
  param = pba->ncdm_psd_parameters; /* extract the optional parameter list from it */
  n_ncdm = pbadist_local->n_ncdm;   /* extract index of ncdm species under consideration */
  ksi = pba->ksi_ncdm[n_ncdm];      /* extract chemical potential */

  /** - shall we interpolate in file, or shall we use analytical formula below? */

  /** - a) deal first with the case of interpolating in files */
  if (pba->got_files[n_ncdm]==_TRUE_) {

    lastidx = pbadist_local->tablesize-1;
    if (q<pbadist_local->q[0]) {
      //Handle q->0 case:
      *f0 = pbadist_local->f0[0];
    }
    else if (q>pbadist_local->q[lastidx]) {
      //Handle q>qmax case (ensure continuous and derivable function with Boltzmann tail):
      qlast=pbadist_local->q[lastidx];
      f0last=pbadist_local->f0[lastidx];
      dqlast=qlast - pbadist_local->q[lastidx-1];
      df0last=f0last - pbadist_local->f0[lastidx-1];

      *f0 = f0last*exp(-(qlast-q)*df0last/f0last/dqlast);
    }
    else{
      //Do interpolation:
      class_call(array_interpolate_spline(
                                          pbadist_local->q,
                                          pbadist_local->tablesize,
                                          pbadist_local->f0,
                                          pbadist_local->d2f0,
                                          1,
                                          q,
                                          &pbadist_local->last_index,
                                          f0,
                                          1,
                                          pba->error_message),
                 pba->error_message,     pba->error_message);
    }
  }

  /** - b) deal now with case of reading analytical function */
  else{
    /**
       Next enter your analytic expression(s) for the p.s.d.'s. If
       you need different p.s.d.'s for different species, put each
       p.s.d inside a condition, like for instance: if (n_ncdm==2)
       {*f0=...}.  Remember that n_ncdm = 0 refers to the first
       species.
    */

    /**************************************************/
    /*    FERMI-DIRAC INCLUDING CHEMICAL POTENTIALS   */
    /**************************************************/

    *f0 = 1.0/pow(2*_PI_,3)*(1./(exp(q-ksi)+1.) +1./(exp(q+ksi)+1.));

    /**************************************************/

    /** This form is only appropriate for approximate studies, since in
        reality the chemical potentials are associated with flavor
        eigenstates, not mass eigenstates. It is easy to take this into
        account by introducing the mixing angles. In the later part
        (not read by the code) we illustrate how to do this. */

    if (_FALSE_) {

      /* We must use the list of extra parameters read in input, stored in the
         ncdm_psd_parameter list, extracted above from the structure
         and now called param[..] */

      /* check that this list has been read */
      class_test(param == NULL,
                 pba->error_message,
                 "Analytic expression wants to use 'ncdm_psd_parameters', but they have not been entered!");

      /* extract values from the list (in this example, mixing angles) */
      double square_s12=param[0];
      double square_s23=param[1];
      double square_s13=param[2];

      /* infer mixing matrix */
      double mixing_matrix[3][3];
      int i;

      mixing_matrix[0][0]=pow(fabs(sqrt((1-square_s12)*(1-square_s13))),2);
      mixing_matrix[0][1]=pow(fabs(sqrt(square_s12*(1-square_s13))),2);
      mixing_matrix[0][2]=fabs(square_s13);
      mixing_matrix[1][0]=pow(fabs(sqrt((1-square_s12)*square_s13*square_s23)+sqrt(square_s12*(1-square_s23))),2);
      mixing_matrix[1][1]=pow(fabs(sqrt(square_s12*square_s23*square_s13)-sqrt((1-square_s12)*(1-square_s23))),2);
      mixing_matrix[1][2]=pow(fabs(sqrt(square_s23*(1-square_s13))),2);
      mixing_matrix[2][0]=pow(fabs(sqrt(square_s12*square_s23)-sqrt((1-square_s12)*square_s13*(1-square_s23))),2);
      mixing_matrix[2][1]=pow(sqrt((1-square_s12)*square_s23)+sqrt(square_s12*square_s13*(1-square_s23)),2);
      mixing_matrix[2][2]=pow(fabs(sqrt((1-square_s13)*(1-square_s23))),2);

      /* loop over flavor eigenstates and compute psd of mass eigenstates */
      *f0=0.0;
      for (i=0;i<3;i++) {

        *f0 += mixing_matrix[i][n_ncdm]*1.0/pow(2*_PI_,3)*(1./(exp(q-pba->ksi_ncdm[i])+1.) +1./(exp(q+pba->ksi_ncdm[i])+1.));

      }
    } /* end of region not used, but shown as an example */
  }

  return _SUCCESS_;
}

/**
 * This function is only used for the purpose of finding optimal
 * quadrature weights. The logic is: if we can accurately convolve
 * f0(q) with this function, then we can convolve it accurately with
 * any other relevant function.
 *
 * @param pbadist Input:  structure containing all background parameters
 * @param q       Input:  momentum
 * @param test    Output: value of the test function test(q)
 */

int background_ncdm_test_function(
                                  void * pbadist,
                                  double q,
                                  double * test
                                  ) {

  double c = 2.0/(3.0*_zeta3_);
  double d = 120.0/(7.0*pow(_PI_,4));
  double e = 2.0/(45.0*_zeta5_);

  /** Using a + bq creates problems for otherwise acceptable distributions
      which diverges as \f$ 1/r \f$ or \f$ 1/r^2 \f$ for \f$ r\to 0 \f$*/
  *test = pow(2.0*_PI_,3)/6.0*(c*q*q-d*q*q*q-e*q*q*q*q);

  return _SUCCESS_;
}

/**
 * This function finds optimal quadrature weights for each ncdm
 * species
 *
 * @param ppr Input: precision structure
 * @param pba Input/Output: background structure
 */

int background_ncdm_init(
                         struct precision *ppr,
                         struct background *pba
                         ) {

  int index_q, k,tolexp,row,status,filenum;
  double f0m2,f0m1,f0,f0p1,f0p2,dq,q,df0dq,tmp1,tmp2;
  struct background_parameters_for_distributions pbadist;
  FILE *psdfile;

  pbadist.pba = pba;

  /* Allocate pointer arrays: */
  class_alloc(pba->q_ncdm, sizeof(double*)*pba->N_ncdm,pba->error_message);
  class_alloc(pba->w_ncdm, sizeof(double*)*pba->N_ncdm,pba->error_message);
  class_alloc(pba->q_ncdm_bg, sizeof(double*)*pba->N_ncdm,pba->error_message);
  class_alloc(pba->w_ncdm_bg, sizeof(double*)*pba->N_ncdm,pba->error_message);
  class_alloc(pba->dlnf0_dlnq_ncdm, sizeof(double*)*pba->N_ncdm,pba->error_message);

  /* Allocate pointers: */
  class_alloc(pba->q_size_ncdm,sizeof(int)*pba->N_ncdm,pba->error_message);
  class_alloc(pba->q_size_ncdm_bg,sizeof(int)*pba->N_ncdm,pba->error_message);
  class_alloc(pba->factor_ncdm,sizeof(double)*pba->N_ncdm,pba->error_message);

  for (k=0, filenum=0; k<pba->N_ncdm; k++) {
    pbadist.n_ncdm = k;
    pbadist.q = NULL;
    pbadist.tablesize = 0;
    /*Do we need to read in a file to interpolate the distribution function? */
    if ((pba->got_files!=NULL)&&(pba->got_files[k]==_TRUE_)) {
      psdfile = fopen(pba->ncdm_psd_files+filenum*_ARGUMENT_LENGTH_MAX_,"r");
      class_test(psdfile == NULL,pba->error_message,
                 "Could not open file %s!",pba->ncdm_psd_files+filenum*_ARGUMENT_LENGTH_MAX_);
      // Find size of table:
      for (row=0,status=2; status==2; row++) {
        status = fscanf(psdfile,"%lf %lf",&tmp1,&tmp2);
      }
      rewind(psdfile);
      pbadist.tablesize = row-1;

      /*Allocate room for interpolation table: */
      class_alloc(pbadist.q,sizeof(double)*pbadist.tablesize,pba->error_message);
      class_alloc(pbadist.f0,sizeof(double)*pbadist.tablesize,pba->error_message);
      class_alloc(pbadist.d2f0,sizeof(double)*pbadist.tablesize,pba->error_message);
      for (row=0; row<pbadist.tablesize; row++) {
        status = fscanf(psdfile,"%lf %lf",
                        &pbadist.q[row],&pbadist.f0[row]);
        //        printf("(q,f0) = (%g,%g)\n",pbadist.q[row],pbadist.f0[row]);
      }
      fclose(psdfile);
      /* Call spline interpolation: */
      class_call(array_spline_table_lines(pbadist.q,
                                          pbadist.tablesize,
                                          pbadist.f0,
                                          1,
                                          pbadist.d2f0,
                                          _SPLINE_EST_DERIV_,
                                          pba->error_message),
                 pba->error_message,
                 pba->error_message);
      filenum++;
    }

    /* Handle perturbation qsampling: */
    if (pba->ncdm_quadrature_strategy[k]==qm_auto) {
      /** Automatic q-sampling for this species */
      class_alloc(pba->q_ncdm[k],_QUADRATURE_MAX_*sizeof(double),pba->error_message);
      class_alloc(pba->w_ncdm[k],_QUADRATURE_MAX_*sizeof(double),pba->error_message);

      class_call(get_qsampling(pba->q_ncdm[k],
                               pba->w_ncdm[k],
                               &(pba->q_size_ncdm[k]),
                               _QUADRATURE_MAX_,
                               ppr->tol_ncdm,
                               pbadist.q,
                               pbadist.tablesize,
                               background_ncdm_test_function,
                               background_ncdm_distribution,
                               &pbadist,
                               pba->error_message),
                 pba->error_message,
                 pba->error_message);
      class_realloc(pba->q_ncdm[k],pba->q_size_ncdm[k]*sizeof(double), pba->error_message);
      class_realloc(pba->w_ncdm[k],pba->q_size_ncdm[k]*sizeof(double), pba->error_message);

      if (pba->background_verbose > 0) {
        printf("ncdm species i=%d sampled with %d points for purpose of perturbation integration\n",
               k+1,
               pba->q_size_ncdm[k]);
      }

      /* Handle background q_sampling: */
      class_alloc(pba->q_ncdm_bg[k],_QUADRATURE_MAX_BG_*sizeof(double),pba->error_message);
      class_alloc(pba->w_ncdm_bg[k],_QUADRATURE_MAX_BG_*sizeof(double),pba->error_message);

      class_call(get_qsampling(pba->q_ncdm_bg[k],
                               pba->w_ncdm_bg[k],
                               &(pba->q_size_ncdm_bg[k]),
                               _QUADRATURE_MAX_BG_,
                               ppr->tol_ncdm_bg,
                               pbadist.q,
                               pbadist.tablesize,
                               background_ncdm_test_function,
                               background_ncdm_distribution,
                               &pbadist,
                               pba->error_message),
                 pba->error_message,
                 pba->error_message);

      class_realloc(pba->q_ncdm_bg[k],pba->q_size_ncdm_bg[k]*sizeof(double), pba->error_message);
      class_realloc(pba->w_ncdm_bg[k],pba->q_size_ncdm_bg[k]*sizeof(double), pba->error_message);

      /** - in verbose mode, inform user of number of sampled momenta
          for background quantities */
      if (pba->background_verbose > 0) {
        printf("ncdm species i=%d sampled with %d points for purpose of background integration\n",
               k+1,
               pba->q_size_ncdm_bg[k]);
      }
    }
    else{
      /** Manual q-sampling for this species. Same sampling used for both perturbation and background sampling, since this will usually be a high precision setting anyway */
      pba->q_size_ncdm_bg[k] = pba->ncdm_input_q_size[k];
      pba->q_size_ncdm[k] = pba->ncdm_input_q_size[k];
      class_alloc(pba->q_ncdm_bg[k],pba->q_size_ncdm_bg[k]*sizeof(double),pba->error_message);
      class_alloc(pba->w_ncdm_bg[k],pba->q_size_ncdm_bg[k]*sizeof(double),pba->error_message);
      class_alloc(pba->q_ncdm[k],pba->q_size_ncdm[k]*sizeof(double),pba->error_message);
      class_alloc(pba->w_ncdm[k],pba->q_size_ncdm[k]*sizeof(double),pba->error_message);
      class_call(get_qsampling_manual(pba->q_ncdm[k],
                                      pba->w_ncdm[k],
                                      pba->q_size_ncdm[k],
                                      pba->ncdm_qmax[k],
                                      pba->ncdm_quadrature_strategy[k],
                                      pbadist.q,
                                      pbadist.tablesize,
                                      background_ncdm_distribution,
                                      &pbadist,
                                      pba->error_message),
                 pba->error_message,
                 pba->error_message);
      for (index_q=0; index_q<pba->q_size_ncdm[k]; index_q++) {
        pba->q_ncdm_bg[k][index_q] = pba->q_ncdm[k][index_q];
        pba->w_ncdm_bg[k][index_q] = pba->w_ncdm[k][index_q];
      }
      /** - in verbose mode, inform user of number of sampled momenta
          for background quantities */
      if (pba->background_verbose > 0) {
        printf("ncdm species i=%d sampled with %d points for purpose of background andperturbation integration using the manual method\n",
               k+1,
               pba->q_size_ncdm[k]);
      }
    }

    class_alloc(pba->dlnf0_dlnq_ncdm[k],
                pba->q_size_ncdm[k]*sizeof(double),
                pba->error_message);


    for (index_q=0; index_q<pba->q_size_ncdm[k]; index_q++) {
      q = pba->q_ncdm[k][index_q];
      class_call(background_ncdm_distribution(&pbadist,q,&f0),
                 pba->error_message,pba->error_message);

      //Loop to find appropriate dq:
      for (tolexp=_PSD_DERIVATIVE_EXP_MIN_; tolexp<_PSD_DERIVATIVE_EXP_MAX_; tolexp++) {

        if (index_q == 0) {
          dq = MIN((0.5-ppr->smallest_allowed_variation)*q,2*exp(tolexp)*(pba->q_ncdm[k][index_q+1]-q));
        }
        else if (index_q == pba->q_size_ncdm[k]-1) {
          dq = exp(tolexp)*2.0*(pba->q_ncdm[k][index_q]-pba->q_ncdm[k][index_q-1]);
        }
        else{
          dq = exp(tolexp)*(pba->q_ncdm[k][index_q+1]-pba->q_ncdm[k][index_q-1]);
        }

        class_call(background_ncdm_distribution(&pbadist,q-2*dq,&f0m2),
                   pba->error_message,pba->error_message);
        class_call(background_ncdm_distribution(&pbadist,q+2*dq,&f0p2),
                   pba->error_message,pba->error_message);

        if (fabs((f0p2-f0m2)/f0)>sqrt(ppr->smallest_allowed_variation)) break;
      }

      class_call(background_ncdm_distribution(&pbadist,q-dq,&f0m1),
                 pba->error_message,pba->error_message);
      class_call(background_ncdm_distribution(&pbadist,q+dq,&f0p1),
                 pba->error_message,pba->error_message);
      //5 point estimate of the derivative:
      df0dq = (+f0m2-8*f0m1+8*f0p1-f0p2)/12.0/dq;
      //printf("df0dq[%g] = %g. dlf=%g ?= %g. f0 =%g.\n",q,df0dq,q/f0*df0dq,
      //Avoid underflow in extreme tail:
      if (fabs(f0)==0.)
        pba->dlnf0_dlnq_ncdm[k][index_q] = -q; /* valid for whatever f0 with exponential tail in exp(-q) */
      else
        pba->dlnf0_dlnq_ncdm[k][index_q] = q/f0*df0dq;
    }

    pba->factor_ncdm[k]=pba->deg_ncdm[k]*4*_PI_*pow(pba->T_cmb*pba->T_ncdm[k]*_k_B_,4)*8*_PI_*_G_
      /3./pow(_h_P_/2./_PI_,3)/pow(_c_,7)*_Mpc_over_m_*_Mpc_over_m_;

    /* If allocated, deallocate interpolation table:  */
    if ((pba->got_files!=NULL)&&(pba->got_files[k]==_TRUE_)) {
      free(pbadist.q);
      free(pbadist.f0);
      free(pbadist.d2f0);
    }
  }


  return _SUCCESS_;
}

/**
 * For a given ncdm species: given the quadrature weights, the mass
 * and the redshift, find background quantities by a quick weighted
 * sum over.  Input parameters passed as NULL pointers are not
 * evaluated for speed-up
 *
 * @param qvec     Input: sampled momenta
 * @param wvec     Input: quadrature weights
 * @param qsize    Input: number of momenta/weights
 * @param M        Input: mass
 * @param factor   Input: normalization factor for the p.s.d.
 * @param z        Input: redshift
 * @param n        Output: number density
 * @param rho      Output: energy density
 * @param p        Output: pressure
 * @param drho_dM  Output: derivative used in next function
 * @param pseudo_p Output: pseudo-pressure used in perturbation module for fluid approx
 *
 */

int background_ncdm_momenta(
                            /* Only calculate for non-NULL pointers: */
                            double * qvec,
                            double * wvec,
                            int qsize,
                            double M,
                            double factor,
                            double z,
                            double * n,
                            double * rho, // density
                            double * p,   // pressure
                            double * drho_dM,  // d rho / d M used in next function
                            double * pseudo_p  // pseudo-p used in ncdm fluid approx
                            ) {

  int index_q;
  double epsilon;
  double q2;
  double factor2;
  /** Summary: */

  /** - rescale normalization at given redshift */
  factor2 = factor*pow(1+z,4);

  /** - initialize quantities */
  if (n!=NULL) *n = 0.;
  if (rho!=NULL) *rho = 0.;
  if (p!=NULL) *p = 0.;
  if (drho_dM!=NULL) *drho_dM = 0.;
  if (pseudo_p!=NULL) *pseudo_p = 0.;

  /** - loop over momenta */
  for (index_q=0; index_q<qsize; index_q++) {

    /* squared momentum */
    q2 = qvec[index_q]*qvec[index_q];

    /* energy */
    epsilon = sqrt(q2+M*M/(1.+z)/(1.+z));

    /* integrand of the various quantities */
    if (n!=NULL) *n += q2*wvec[index_q];
    if (rho!=NULL) *rho += q2*epsilon*wvec[index_q];
    if (p!=NULL) *p += q2*q2/3./epsilon*wvec[index_q];
    if (drho_dM!=NULL) *drho_dM += q2*M/(1.+z)/(1.+z)/epsilon*wvec[index_q];
    if (pseudo_p!=NULL) *pseudo_p += pow(q2/epsilon,3)/3.0*wvec[index_q];
  }

  /** - adjust normalization */
  if (n!=NULL) *n *= factor2/(1.+z);
  if (rho!=NULL) *rho *= factor2;
  if (p!=NULL) *p *= factor2;
  if (drho_dM!=NULL) *drho_dM *= factor2;
  if (pseudo_p!=NULL) *pseudo_p *=factor2;

  return _SUCCESS_;
}

/**
 * When the user passed the density fraction Omega_ncdm or
 * omega_ncdm in input but not the mass, infer the mass with Newton iteration method.
 *
 * @param ppr    Input: precision structure
 * @param pba    Input/Output: background structure
 * @param n_ncdm Input: index of ncdm species
 */

int background_ncdm_M_from_Omega(
                                 struct precision *ppr,
                                 struct background *pba,
                                 int n_ncdm
                                 ) {
  double rho0,rho,n,M,deltaM,drhodM;
  int iter,maxiter=50;

  rho0 = pba->H0*pba->H0*pba->Omega0_ncdm[n_ncdm]; /*Remember that rho is defined such that H^2=sum(rho_i) */
  M = 0.0;

  background_ncdm_momenta(pba->q_ncdm_bg[n_ncdm],
                          pba->w_ncdm_bg[n_ncdm],
                          pba->q_size_ncdm_bg[n_ncdm],
                          M,
                          pba->factor_ncdm[n_ncdm],
                          0.,
                          &n,
                          &rho,
                          NULL,
                          NULL,
                          NULL);

  /* Is the value of Omega less than a massless species?*/
  class_test(rho0<rho,pba->error_message,
             "The value of Omega for the %dth species, %g, is less than for a massless species! It should be atleast %g. Check your input.",
             n_ncdm,pba->Omega0_ncdm[n_ncdm],pba->Omega0_ncdm[n_ncdm]*rho/rho0);

  /* In the strict NR limit we have rho = n*(M) today, giving a zeroth order guess: */
  M = rho0/n; /* This is our guess for M. */
  for (iter=1; iter<=maxiter; iter++) {

    /* Newton iteration. First get relevant quantities at M: */
    background_ncdm_momenta(pba->q_ncdm_bg[n_ncdm],
                            pba->w_ncdm_bg[n_ncdm],
                            pba->q_size_ncdm_bg[n_ncdm],
                            M,
                            pba->factor_ncdm[n_ncdm],
                            0.,
                            NULL,
                            &rho,
                            NULL,
                            &drhodM,
                            NULL);

    deltaM = (rho0-rho)/drhodM; /* By definition of the derivative */
    if ((M+deltaM)<0.0) deltaM = -M/2.0; /* Avoid overshooting to negative M value. */
    M += deltaM; /* Update value of M.. */
    if (fabs(deltaM/M)<ppr->tol_M_ncdm) {
      /* Accuracy reached.. */
      pba->M_ncdm[n_ncdm] = M;
      break;
    }
  }
  class_test(iter>=maxiter,pba->error_message,
             "Newton iteration could not converge on a mass for some reason.");
  return _SUCCESS_;
}

/**
 * Perform some check on the input background quantities, and send to
 * standard output some information about them
 *
 * @param ppr Input: pointer to precision structure
 * @param pba Input: pointer to initialized background structure
 * @return the error status
 */

int background_checks(
                      struct precision* ppr,
                      struct background* pba
                      ) {

  /** - define local variables */
  int n_ncdm;
  double rho_ncdm_rel,rho_nu_rel;
  double N_dark;
  double w_fld, dw_over_da, integral_fld;
  int filenum=0;

  /** - control that we have photons and baryons in the problem */
  class_test((pba->Omega0_g<=0) || (pba->Omega0_b<=0),
             pba->error_message,
             "CLASS is conceived to work in a universe containing at least two species: photons and baryons. You could work in the limit where Omega_g or Omega_b are very small, but not zero");

  /** - control that cosmological parameter values make sense, otherwise inform user */

  /* H0 in Mpc^{-1} */
  /* Many users asked for this test to be supressed. It is commented out. */
  /*class_test((pba->H0 < _H0_SMALL_)||(pba->H0 > _H0_BIG_),
    pba->error_message,
    "H0=%g out of bounds (%g<H0<%g) \n",pba->H0,_H0_SMALL_,_H0_BIG_);*/

  /* consistency between h and H0 */
  class_test(fabs(pba->h * 1.e5 / _c_  / pba->H0 -1.)>ppr->smallest_allowed_variation,
             pba->error_message,
             "inconsistency between Hubble and reduced Hubble parameters: you have H0=%f/Mpc=%fkm/s/Mpc, but h=%f",pba->H0,pba->H0/1.e5* _c_,pba->h);

  /* T_cmb in K */
  /* Many users asked for this test to be supressed. It is commented out. */
  /*class_test((pba->T_cmb < _TCMB_SMALL_)||(pba->T_cmb > _TCMB_BIG_),
    pba->error_message,
    "T_cmb=%g out of bounds (%g<T_cmb<%g)",pba->T_cmb,_TCMB_SMALL_,_TCMB_BIG_);*/

  /* Omega_k */
  /* Many users asked for this test to be supressed. It is commented out. */
  /*class_test((pba->Omega0_k < _OMEGAK_SMALL_)||(pba->Omega0_k > _OMEGAK_BIG_),
    pba->error_message,
    "Omegak = %g out of bounds (%g<Omegak<%g) \n",pba->Omega0_k,_OMEGAK_SMALL_,_OMEGAK_BIG_);*/

  /* fluid equation of state */
  if (pba->has_fld == _TRUE_) {

    class_call(background_w_fld(pba,0.,&w_fld,&dw_over_da,&integral_fld), pba->error_message, pba->error_message);

    class_test(w_fld >= 1./3.,
               pba->error_message,
               "Your choice for w(a--->0)=%g is suspicious, since it is bigger than 1/3 there cannot be radiation domination at early times\n",
               w_fld);
  }

  /* Varying fundamental constants */
  if (pba->has_varconst == _TRUE_) {
    class_test(pba->varconst_alpha <= 0,
               pba->error_message,
               "incorrect fine structure constant before transition");
    class_test(pba->varconst_me <= 0,
               pba->error_message,
               "incorrect effective electron mass before transition");
    class_test(pba->varconst_transition_redshift < 0,
               pba->error_message,
               "incorrect transition redshift");
  }

  /** - in verbose mode, send to standard output some additional information on non-obvious background parameters */
  if (pba->background_verbose > 0) {

    if (pba->has_ncdm == _TRUE_) {

      /* loop over ncdm species */
      for (n_ncdm=0;n_ncdm<pba->N_ncdm; n_ncdm++) {

        /* inform if p-s-d read in files */
        if (pba->got_files[n_ncdm] == _TRUE_) {
          printf(" -> ncdm species i=%d read from file %s\n",n_ncdm+1,pba->ncdm_psd_files+filenum*_ARGUMENT_LENGTH_MAX_);
          filenum++;
        }

        /* inform the user also about the value of the ncdm
           masses in eV and about */
        printf(" -> non-cold dark matter species with i=%d has m_i = %e eV (so m_i / omega_i =%e eV)\n",
               n_ncdm+1,
               pba->m_ncdm_in_eV[n_ncdm],
               pba->m_ncdm_in_eV[n_ncdm]*pba->deg_ncdm[n_ncdm]/pba->Omega0_ncdm[n_ncdm]/pba->h/pba->h);

        /* call this function to get rho_ncdm */
        background_ncdm_momenta(pba->q_ncdm_bg[n_ncdm],
                                pba->w_ncdm_bg[n_ncdm],
                                pba->q_size_ncdm_bg[n_ncdm],
                                0.,
                                pba->factor_ncdm[n_ncdm],
                                0.,
                                NULL,
                                &rho_ncdm_rel,
                                NULL,
                                NULL,
                                NULL);

        /* inform user of the contribution of each species to
           radiation density (in relativistic limit): should be
           between 1.01 and 1.02 for each active neutrino species;
           evaluated as rho_ncdm/rho_nu_rel where rho_nu_rel is the
           density of one neutrino in the instantaneous decoupling
           limit, i.e. assuming T_nu=(4/11)^1/3 T_gamma (this comes
           from the definition of N_eff) */
        rho_nu_rel = 56.0/45.0*pow(_PI_,6)*pow(4.0/11.0,4.0/3.0)*_G_/pow(_h_P_,3)/pow(_c_,7)*
          pow(_Mpc_over_m_,2)*pow(pba->T_cmb*_k_B_,4);

        printf(" -> ncdm species i=%d sampled with %d (resp. %d) points for purpose of background (resp. perturbation) integration. In the relativistic limit it gives Delta N_eff = %g\n",
               n_ncdm+1,
               pba->q_size_ncdm_bg[n_ncdm],
               pba->q_size_ncdm[n_ncdm],
               rho_ncdm_rel/rho_nu_rel);
      }
    }

    /* contribution of interacting dark radiation _idr to N_eff */
    if (pba->has_idr == _TRUE_) {
      N_dark = pba->Omega0_idr/7.*8./pow(4./11.,4./3.)/pba->Omega0_g;
      printf(" -> dark radiation Delta Neff %e\n",N_dark);
    }
  }

  return _SUCCESS_;
}

/**
 *  This function integrates the background over time, allocates and
 *  fills the background table
 *
 * @param ppr Input: precision structure
 * @param pba Input/Output: background structure
 */

int background_solve(
                     struct precision *ppr,
                     struct background *pba
                     ) {

  /** Summary: */

  /** - define local variables */

  /* parameters and workspace for the background_derivs function */
  struct background_parameters_and_workspace bpaw;
  /* vector of quantities to be integrated */
  double * pvecback_integration;
  /* vector of all background quantities */
  double * pvecback;
  /* comoving radius coordinate in Mpc (equal to conformal distance in flat case) */
  double comoving_radius=0.;
  /* conformal distance in Mpc (equal to comoving radius in flat case) */
  double conformal_distance;

  /* evolvers */
  extern int evolver_rk(EVOLVER_PROTOTYPE);
  extern int evolver_ndf15(EVOLVER_PROTOTYPE);
  int (*generic_evolver)(EVOLVER_PROTOTYPE) = evolver_ndf15;

  /* initial and final loga values */
  double loga_ini, loga_final;
  /* growth factor today */
  double D_today;
  /* indices for the different arrays */
  int index_loga, index_scf;
  /* what parameters are used in the output? */
  int * used_in_output;

  /* index of ncdm species */
  int n_ncdm;

  /** - setup background workspace */
  bpaw.pba = pba;
  class_alloc(pvecback,pba->bg_size*sizeof(double),pba->error_message);
  bpaw.pvecback = pvecback;

  /** - allocate vector of quantities to be integrated */
  class_alloc(pvecback_integration,pba->bi_size*sizeof(double),pba->error_message);

  /** - impose initial conditions with background_initial_conditions() */
  class_call(background_initial_conditions(ppr,pba,pvecback,pvecback_integration,&(loga_ini)),
             pba->error_message,
             pba->error_message);

  /** - Determine output vector */
  loga_final = 0.; // with our conventions, loga is in fact log(a/a_0); we integrate until today, when log(a/a_0) = 0
  pba->bt_size = ppr->background_Nloga;

  /** - allocate background tables */
  class_alloc(pba->tau_table,pba->bt_size * sizeof(double),pba->error_message);
  class_alloc(pba->z_table,pba->bt_size * sizeof(double),pba->error_message);
  class_alloc(pba->loga_table,pba->bt_size * sizeof(double),pba->error_message);

  class_alloc(pba->d2tau_dz2_table,pba->bt_size * sizeof(double),pba->error_message);
  class_alloc(pba->d2z_dtau2_table,pba->bt_size * sizeof(double),pba->error_message);

  class_alloc(pba->background_table,pba->bt_size * pba->bg_size * sizeof(double),pba->error_message);
  class_alloc(pba->d2background_dloga2_table,pba->bt_size * pba->bg_size * sizeof(double),pba->error_message);

  class_alloc(used_in_output, pba->bt_size*sizeof(int), pba->error_message);

  /** - define values of loga at which results will be stored */
  for (index_loga=0; index_loga<pba->bt_size; index_loga++) {
    pba->loga_table[index_loga] = loga_ini + index_loga*(loga_final-loga_ini)/(pba->bt_size-1);
    used_in_output[index_loga] = 1;
  }

  /** - choose the right evolver */
  switch (ppr->background_evolver) {

  case rk:
    generic_evolver = evolver_rk;
    if (pba->background_verbose > 1) {
      printf("%s\n", "Chose rk as generic_evolver");
    }
    break;

  case ndf15:
    generic_evolver = evolver_ndf15;
    if (pba->background_verbose > 1) {
      printf("%s\n", "Chose ndf15 as generic_evolver");
    }
    break;
  }

  /** - perform the integration */
  class_call(generic_evolver(background_derivs,
                             loga_ini,
                             loga_final,
                             pvecback_integration,
                             used_in_output,
                             pba->bi_size,
                             &bpaw,
                             ppr->tol_background_integration,
                             ppr->smallest_allowed_variation,
                             background_timescale, //'evaluate_timescale', required by evolver_rk but not by ndf15
                             ppr->background_integration_stepsize,
                             pba->loga_table,
                             pba->bt_size,
                             background_sources,
                             NULL, //'print_variables' in evolver_rk could be set, but, not required
                             pba->error_message),
             pba->error_message,
             pba->error_message);

  /** - recover some quantities today */
  /* -> age in Gyears */
  pba->age = pvecback_integration[pba->index_bi_time]/_Gyr_over_Mpc_;
  /* -> conformal age in Mpc */
  pba->conformal_age = pvecback_integration[pba->index_bi_tau];
  /* -> contribution of decaying dark matter and dark radiation to the critical density today: */
  if (pba->has_dcdm == _TRUE_) {
    pba->Omega0_dcdm = pvecback_integration[pba->index_bi_rho_dcdm]/pba->H0/pba->H0;
  }
  if (pba->has_dr == _TRUE_) {
    pba->Omega0_dr = pvecback_integration[pba->index_bi_rho_dr]/pba->H0/pba->H0;
  }
  /* -> scale-invariant growth rate today */
  D_today = pvecback_integration[pba->index_bi_D];

  /** - In a loop over lines, fill rest of background table for
      quantities that depend on numbers like "conformal_age" or
      "D_today" that were calculated just before */
  for (index_loga=0; index_loga < pba->bt_size; index_loga++) {

    pba->background_table[index_loga*pba->bg_size+pba->index_bg_D]*= 1./D_today;

    conformal_distance = pba->conformal_age - pba->tau_table[index_loga];
    pba->background_table[index_loga*pba->bg_size+pba->index_bg_conf_distance] = conformal_distance;

    if (pba->sgnK == 0) { comoving_radius = conformal_distance; }
    else if (pba->sgnK == 1) { comoving_radius = sin(sqrt(pba->K)*conformal_distance)/sqrt(pba->K); }
    else if (pba->sgnK == -1) { comoving_radius = sinh(sqrt(-pba->K)*conformal_distance)/sqrt(-pba->K); }

    pba->background_table[index_loga*pba->bg_size+pba->index_bg_ang_distance] = comoving_radius/(1.+pba->z_table[index_loga]);
    pba->background_table[index_loga*pba->bg_size+pba->index_bg_lum_distance] = comoving_radius*(1.+pba->z_table[index_loga]);
  }

  /** - fill tables of second derivatives (in view of spline interpolation) */
  class_call(array_spline_table_lines(pba->z_table,
                                      pba->bt_size,
                                      pba->tau_table,
                                      1,
                                      pba->d2tau_dz2_table,
                                      _SPLINE_EST_DERIV_,
                                      pba->error_message),
             pba->error_message,
             pba->error_message);

  class_call(array_spline_table_lines(pba->tau_table,
                                      pba->bt_size,
                                      pba->z_table,
                                      1,
                                      pba->d2z_dtau2_table,
                                      _SPLINE_EST_DERIV_,
                                      pba->error_message),
             pba->error_message,
             pba->error_message);

  class_call(array_spline_table_lines(pba->loga_table,
                                      pba->bt_size,
                                      pba->background_table,
                                      pba->bg_size,
                                      pba->d2background_dloga2_table,
                                      _SPLINE_EST_DERIV_,
                                      pba->error_message),
             pba->error_message,
             pba->error_message);

  /** - compute remaining "related parameters" */

  /**  - so-called "effective neutrino number", computed at earliest
       time in interpolation table. This should be seen as a
       definition: Neff is the equivalent number of
       instantaneously-decoupled neutrinos accounting for the
       radiation density, beyond photons */

  pba->Neff = (pba->background_table[pba->index_bg_Omega_r]
               *pba->background_table[pba->index_bg_rho_crit]
               -pba->background_table[pba->index_bg_rho_g])
    /(7./8.*pow(4./11.,4./3.)*pba->background_table[pba->index_bg_rho_g]);

  /** - send information to standard output */
  if (pba->background_verbose > 0) {
    printf(" -> age = %f Gyr\n",pba->age);
    printf(" -> conformal age = %f Mpc\n",pba->conformal_age);
    printf(" -> N_eff = %g (summed over all species that are non-relativistic at early times) \n",pba->Neff);
  }

  if (pba->background_verbose > 2) {
    if ((pba->has_dcdm == _TRUE_)&&(pba->has_dr == _TRUE_)) {
      printf("    Decaying Cold Dark Matter details: (DCDM --> DR)\n");
      printf("     -> Omega0_dcdm = %f\n",pba->Omega0_dcdm);
      printf("     -> Omega0_dr = %f\n",pba->Omega0_dr);
      printf("     -> Omega0_dr+Omega0_dcdm = %f, input value = %f\n",
             pba->Omega0_dr+pba->Omega0_dcdm,pba->Omega0_dcdmdr);
      printf("     -> Omega_ini_dcdm/Omega_b = %f\n",pba->Omega_ini_dcdm/pba->Omega0_b);
    }
    if (pba->has_scf == _TRUE_) {
      printf("    Scalar field details:\n");
      printf("     -> Omega_scf = %g, wished %g\n",
             pba->background_table[(pba->bt_size-1)*pba->bg_size+pba->index_bg_rho_scf]/pba->background_table[(pba->bt_size-1)*pba->bg_size+pba->index_bg_rho_crit], pba->Omega0_scf);
      if (pba->has_lambda == _TRUE_) {
        printf("     -> Omega_Lambda = %g, wished %g\n",
               pba->background_table[(pba->bt_size-1)*pba->bg_size+pba->index_bg_rho_lambda]/pba->background_table[(pba->bt_size-1)*pba->bg_size+pba->index_bg_rho_crit], pba->Omega0_lambda);
      }
      printf("     -> parameters: [lambda, alpha, A, B] = \n");
      printf("                    [");
      for (index_scf=0; index_scf<pba->scf_parameters_size-1; index_scf++) {
        printf("%.3f, ",pba->scf_parameters[index_scf]);
      }
      printf("%.3f]\n",pba->scf_parameters[pba->scf_parameters_size-1]);
    }
  }

  /**  - store information in the background structure */
  pba->Omega0_m = pba->background_table[(pba->bt_size-1)*pba->bg_size+pba->index_bg_Omega_m];
  pba->Omega0_r = pba->background_table[(pba->bt_size-1)*pba->bg_size+pba->index_bg_Omega_r];
  pba->Omega0_de = 1. - (pba->Omega0_m + pba->Omega0_r + pba->Omega0_k);

  /* Compute the density fraction of non-free-streaming matter (in the minimal LambdaCDM model, this would be just Omega_b + Omega_cdm). This definition takes into account interating, decaying and warm dark matter, but it would need to be refined if some part of the matter component was modelled by the fluid (fld) or the scalar field (scf). */
  pba->Omega0_nfsm =  pba->Omega0_b;
  if (pba->has_cdm == _TRUE_)
    pba->Omega0_nfsm += pba->Omega0_cdm;
  if (pba->has_idm == _TRUE_)
    pba->Omega0_nfsm += pba->Omega0_idm;
  if (pba->has_dcdm == _TRUE_)
    pba->Omega0_nfsm += pba->Omega0_dcdm;
  for (n_ncdm=0;n_ncdm<pba->N_ncdm; n_ncdm++) {
    /* here we define non-free-streaming matter as: any non-relatistic species with a dimensionless ratio m/T bigger than a threshold ppr->M_nfsm_threshold; if this threshold is of the order of 10^4, this corresponds to the condition "becoming non-relativistic during radiation domination". Beware: this definition won't work in the case in which the user passes a customised p.s.d. for ncdm, such that M_ncdm is not defined.  */
    if (pba->M_ncdm[n_ncdm] > ppr->M_nfsm_threshold) {
      pba->Omega0_nfsm += pba->Omega0_ncdm[n_ncdm];
    }
  }

  free(pvecback);
  free(pvecback_integration);
  free(used_in_output);

  return _SUCCESS_;

}

/**
 * Assign initial values to background integrated variables.
 *
 * @param ppr                  Input: pointer to precision structure
 * @param pba                  Input: pointer to background structure
 * @param pvecback             Input: vector of background quantities used as workspace
 * @param pvecback_integration Output: vector of background quantities to be integrated, returned with proper initial values
 * @param loga_ini             Output: value of loga (in fact with our conventions log(a/a_0)) at initial time
 * @return the error status
 */

int background_initial_conditions(
                                  struct precision *ppr,
                                  struct background *pba,
                                  double * pvecback, /* vector with argument pvecback[index_bg] (must be already allocated, normal format is sufficient) */
                                  double * pvecback_integration, /* vector with argument pvecback_integration[index_bi] (must be already allocated with size pba->bi_size) */
                                  double * loga_ini
                                  ) {

  /** Summary: */

  /** - define local variables */

  /* scale factor */
  double a;

  double rho_ncdm, p_ncdm, rho_ncdm_rel_tot=0.;
  double f,Omega_rad, rho_rad;
  int counter,is_early_enough,n_ncdm;
  double scf_lambda;
  double rho_fld_today;
  double w_fld,dw_over_da_fld,integral_fld;

  /** - fix initial value of \f$ a \f$ */
  a = ppr->a_ini_over_a_today_default;

  /**  If we have ncdm species, perhaps we need to start earlier
       than the standard value for the species to be relativistic.
       This could happen for some WDM models.
  */

  if (pba->has_ncdm == _TRUE_) {

    for (counter=0; counter < _MAX_IT_; counter++) {

      is_early_enough = _TRUE_;
      rho_ncdm_rel_tot = 0.;

      for (n_ncdm=0; n_ncdm<pba->N_ncdm; n_ncdm++) {

        class_call(background_ncdm_momenta(pba->q_ncdm_bg[n_ncdm],
                                           pba->w_ncdm_bg[n_ncdm],
                                           pba->q_size_ncdm_bg[n_ncdm],
                                           pba->M_ncdm[n_ncdm],
                                           pba->factor_ncdm[n_ncdm],
                                           1./a-1.0,
                                           NULL,
                                           &rho_ncdm,
                                           &p_ncdm,
                                           NULL,
                                           NULL),
                   pba->error_message,
                   pba->error_message);
        rho_ncdm_rel_tot += 3.*p_ncdm;
        if (fabs(p_ncdm/rho_ncdm-1./3.)>ppr->tol_ncdm_initial_w) {
          is_early_enough = _FALSE_;
        }
      }
      if (is_early_enough == _TRUE_) {
        break;
      }
      else {
        a *= _SCALE_BACK_;
      }
    }
    class_test(counter == _MAX_IT_,
               pba->error_message,
               "Search for initial scale factor a such that all ncdm species are relativistic failed.");
  }

  /* Set initial values of {B} variables: */
  Omega_rad = pba->Omega0_g;
  if (pba->has_ur == _TRUE_) {
    Omega_rad += pba->Omega0_ur;
  }
  if (pba->has_idr == _TRUE_) {
    Omega_rad += pba->Omega0_idr;
  }
  rho_rad = Omega_rad*pow(pba->H0,2)/pow(a,4);
  if (pba->has_ncdm == _TRUE_) {
    /** - We must add the relativistic contribution from NCDM species */
    rho_rad += rho_ncdm_rel_tot;
  }
  if (pba->has_dcdm == _TRUE_) {
    /* Remember that the critical density today in CLASS conventions is H0^2 */
    pvecback_integration[pba->index_bi_rho_dcdm] =
      pba->Omega_ini_dcdm*pba->H0*pba->H0*pow(a,-3);
    if (pba->background_verbose > 3)
      printf("Density is %g. Omega_ini=%g\n",pvecback_integration[pba->index_bi_rho_dcdm],pba->Omega_ini_dcdm);
  }

  if (pba->has_dr == _TRUE_) {
    if (pba->has_dcdm == _TRUE_) {
      /**  - f is the critical density fraction of DR. The exact solution is:
       *
       * `f = -Omega_rad+pow(pow(Omega_rad,3./2.)+0.5*pow(a,6)*pvecback_integration[pba->index_bi_rho_dcdm]*pba->Gamma_dcdm/pow(pba->H0,3),2./3.);`
       *
       * but it is not numerically stable for very small f which is always the case.
       * Instead we use the Taylor expansion of this equation, which is equivalent to
       * ignoring f(a) in the Hubble rate.
       */
      f = 1./3.*pow(a,6)*pvecback_integration[pba->index_bi_rho_dcdm]*pba->Gamma_dcdm/pow(pba->H0,3)/sqrt(Omega_rad);
      pvecback_integration[pba->index_bi_rho_dr] = f*pba->H0*pba->H0/pow(a,4);
    }
    else{
      /** There is also a space reserved for a future case where dr is not sourced by dcdm */
      pvecback_integration[pba->index_bi_rho_dr] = 0.0;
    }
  }

  if (pba->has_fld == _TRUE_) {

    /* rho_fld today */
    rho_fld_today = pba->Omega0_fld * pow(pba->H0,2);

    /* integrate rho_fld(a) from a_ini to a_0, to get rho_fld(a_ini) given rho_fld(a0) */
    class_call(background_w_fld(pba,a,&w_fld,&dw_over_da_fld,&integral_fld), pba->error_message, pba->error_message);

    /* Note: for complicated w_fld(a) functions with no simple
       analytic integral, this is the place were you should compute
       numerically the simple 1d integral [int_{a_ini}^{a_0} 3
       [(1+w_fld)/a] da] (e.g. with the Romberg method?) instead of
       calling background_w_fld */

    /* rho_fld at initial time */
    pvecback_integration[pba->index_bi_rho_fld] = rho_fld_today * exp(integral_fld);

  }

  /** - Fix initial value of \f$ \phi, \phi' \f$
   * set directly in the radiation attractor => fixes the units in terms of rho_ur
   *
   * TODO:
   * - There seems to be some small oscillation when it starts.
   * - Check equations and signs. Sign of phi_prime?
   * - is rho_ur all there is early on?
   */
  if (pba->has_scf == _TRUE_) {
    scf_lambda = pba->scf_parameters[0];
    if (pba->attractor_ic_scf == _TRUE_) {
      pvecback_integration[pba->index_bi_phi_scf] = -1/scf_lambda*
        log(rho_rad*4./(3*pow(scf_lambda,2)-12))*pba->phi_ini_scf;
      if (3.*pow(scf_lambda,2)-12. < 0) {
        /** - --> If there is no attractor solution for scf_lambda, assign some value. Otherwise would give a nan.*/
        pvecback_integration[pba->index_bi_phi_scf] = 1./scf_lambda;//seems to do the work
        if (pba->background_verbose > 0) {
          printf(" No attractor IC for lambda = %.3e ! \n ",scf_lambda);
        }
      }
      pvecback_integration[pba->index_bi_phi_prime_scf] = 2.*a*sqrt(V_scf(pba,pvecback_integration[pba->index_bi_phi_scf]))*pba->phi_prime_ini_scf;
    }
    else {
      printf("Not using attractor initial conditions\n");
      /** - --> If no attractor initial conditions are assigned, gets the provided ones. */
      pvecback_integration[pba->index_bi_phi_scf] = pba->phi_ini_scf;
      pvecback_integration[pba->index_bi_phi_prime_scf] = pba->phi_prime_ini_scf;
    }
    class_test(!isfinite(pvecback_integration[pba->index_bi_phi_scf]) ||
               !isfinite(pvecback_integration[pba->index_bi_phi_scf]),
               pba->error_message,
               "initial phi = %e phi_prime = %e -> check initial conditions",
               pvecback_integration[pba->index_bi_phi_scf],
               pvecback_integration[pba->index_bi_phi_scf]);
  }

  /* Infer pvecback from pvecback_integration */
  class_call(background_functions(pba, a, pvecback_integration, normal_info, pvecback),
             pba->error_message,
             pba->error_message);

  /* Just checking that our initial time indeed is deep enough in the radiation
     dominated regime */
  class_test(fabs(pvecback[pba->index_bg_Omega_r]-1.) > ppr->tol_initial_Omega_r,
             pba->error_message,
             "Omega_r = %e, not close enough to 1. Decrease a_ini_over_a_today_default in order to start from radiation domination.",
             pvecback[pba->index_bg_Omega_r]);

  /** - compute initial proper time, assuming radiation-dominated
      universe since Big Bang and therefore \f$ t=1/(2H) \f$ (good
      approximation for most purposes) */

  class_test(pvecback[pba->index_bg_H] <= 0.,
             pba->error_message,
             "H = %e instead of strictly positive",pvecback[pba->index_bg_H]);

  pvecback_integration[pba->index_bi_time] = 1./(2.* pvecback[pba->index_bg_H]);

  /** - compute initial conformal time, assuming radiation-dominated
      universe since Big Bang and therefore \f$ \tau=1/(aH) \f$
      (good approximation for most purposes) */
  pvecback_integration[pba->index_bi_tau] = 1./(a * pvecback[pba->index_bg_H]);

  /** - compute initial sound horizon, assuming \f$ c_s=1/\sqrt{3} \f$ initially */
  pvecback_integration[pba->index_bi_rs] = pvecback_integration[pba->index_bi_tau]/sqrt(3.);

  /** - set initial value of D and D' in RD. D and D' need only be set up to an overall constant, since they will later be re-normalized. From Ma&Bertschinger, one can derive D ~ (ktau)^2 at early times, from which one finds D'/D = 2 aH (assuming aH=1/tau during RD) */
  pvecback_integration[pba->index_bi_D] = 1.;
  pvecback_integration[pba->index_bi_D_prime] = 2.*a*pvecback[pba->index_bg_H];

  /** - return the value finally chosen for the initial log(a) */
  *loga_ini = log(a);

  return _SUCCESS_;

}

/**
 * Find the time of radiation/matter equality and store characteristic
 * quantitites at that time in the background structure..
 *
 * @param ppr                  Input: pointer to precision structure
 * @param pba                  Input/Output: pointer to background structure
 * @return the error status
 */

int background_find_equality(
                             struct precision *ppr,
                             struct background *pba
                             ) {

  double Omega_m_over_Omega_r=0.;
  int index_tau_minus = 0;
  int index_tau_plus = pba->bt_size-1;
  int index_tau_mid = 0;
  double tau_minus,tau_plus,tau_mid=0.;
  double * pvecback;

  /* first bracket the right tau value between two consecutive indices in the table */

  while ((index_tau_plus - index_tau_minus) > 1) {

    index_tau_mid = (int)(0.5*(index_tau_plus+index_tau_minus));

    Omega_m_over_Omega_r = pba->background_table[index_tau_mid*pba->bg_size+pba->index_bg_Omega_m]
      /pba->background_table[index_tau_mid*pba->bg_size+pba->index_bg_Omega_r];

    if (Omega_m_over_Omega_r > 1)
      index_tau_plus = index_tau_mid;
    else
      index_tau_minus = index_tau_mid;

  }

  /* then get a better estimate within this range */

  tau_minus = pba->tau_table[index_tau_minus];
  tau_plus =  pba->tau_table[index_tau_plus];

  class_alloc(pvecback,pba->bg_size*sizeof(double),pba->error_message);

  while ((tau_plus - tau_minus) > ppr->tol_tau_eq) {

    tau_mid = 0.5*(tau_plus+tau_minus);

    class_call(background_at_tau(pba,tau_mid,long_info,inter_closeby,&index_tau_minus,pvecback),
               pba->error_message,
               pba->error_message);

    Omega_m_over_Omega_r = pvecback[pba->index_bg_Omega_m]/pvecback[pba->index_bg_Omega_r];

    if (Omega_m_over_Omega_r > 1)
      tau_plus = tau_mid;
    else
      tau_minus = tau_mid;

  }

  pba->a_eq = pvecback[pba->index_bg_a];
  pba->H_eq = pvecback[pba->index_bg_H];
  pba->z_eq = 1./pba->a_eq -1.;
  pba->tau_eq = tau_mid;

  if (pba->background_verbose > 0) {
    printf(" -> radiation/matter equality at z = %f\n",pba->z_eq);
    printf("    corresponding to conformal time = %f Mpc\n",pba->tau_eq);
  }

  free(pvecback);

  return _SUCCESS_;

}


/**
 * Subroutine for formatting background output
 *
 * @param pba                  Input: pointer to background structure
 * @param titles               Ouput: name of columns when printing the background table
 * @return the error status
 */

int background_output_titles(
                             struct background * pba,
                             char titles[_MAXTITLESTRINGLENGTH_]
                             ) {

  /** - Length of the column title should be less than _OUTPUTPRECISION_+6
      to be indented correctly, but it can be as long as . */
  int n;
  char tmp[40];

  class_store_columntitle(titles,"z",_TRUE_);
  class_store_columntitle(titles,"proper time [Gyr]",_TRUE_);
  class_store_columntitle(titles,"conf. time [Mpc]",_TRUE_);
  class_store_columntitle(titles,"H [1/Mpc]",_TRUE_);
  class_store_columntitle(titles,"comov. dist.",_TRUE_);
  class_store_columntitle(titles,"ang.diam.dist.",_TRUE_);
  class_store_columntitle(titles,"lum. dist.",_TRUE_);
  class_store_columntitle(titles,"comov.snd.hrz.",_TRUE_);
  class_store_columntitle(titles,"(.)rho_g",_TRUE_);
  class_store_columntitle(titles,"(.)rho_b",_TRUE_);
  class_store_columntitle(titles,"(.)rho_cdm",pba->has_cdm);
  class_store_columntitle(titles,"(.)rho_idm",pba->has_idm);
  if (pba->has_ncdm == _TRUE_) {
    for (n=0; n<pba->N_ncdm; n++) {
      class_sprintf(tmp,"(.)rho_ncdm[%d]",n);
      class_store_columntitle(titles,tmp,_TRUE_);
      class_sprintf(tmp,"(.)p_ncdm[%d]",n);
      class_store_columntitle(titles,tmp,_TRUE_);
    }
  }
  class_store_columntitle(titles,"(.)rho_lambda",pba->has_lambda);
  class_store_columntitle(titles,"(.)rho_fld",pba->has_fld);
  class_store_columntitle(titles,"(.)w_fld",pba->has_fld);
  class_store_columntitle(titles,"(.)rho_ur",pba->has_ur);
  class_store_columntitle(titles,"(.)rho_idr",pba->has_idr);
  class_store_columntitle(titles,"(.)rho_crit",_TRUE_);
  class_store_columntitle(titles,"(.)rho_dcdm",pba->has_dcdm);
  class_store_columntitle(titles,"(.)rho_dr",pba->has_dr);

  class_store_columntitle(titles,"(.)rho_scf",pba->has_scf);
  class_store_columntitle(titles,"(.)p_scf",pba->has_scf);
  class_store_columntitle(titles,"(.)p_prime_scf",pba->has_scf);
  class_store_columntitle(titles,"phi_scf",pba->has_scf);
  class_store_columntitle(titles,"phi'_scf",pba->has_scf);
  class_store_columntitle(titles,"V_scf",pba->has_scf);
  class_store_columntitle(titles,"V'_scf",pba->has_scf);
  class_store_columntitle(titles,"V''_scf",pba->has_scf);

  class_store_columntitle(titles,"(.)rho_tot",_TRUE_);
  class_store_columntitle(titles,"(.)p_tot",_TRUE_);
  class_store_columntitle(titles,"(.)p_tot_prime",_TRUE_);

  class_store_columntitle(titles,"gr.fac. D",_TRUE_);
  class_store_columntitle(titles,"gr.fac. f",_TRUE_);

  class_store_columntitle(titles,"rel. alpha",pba->has_varconst);
  class_store_columntitle(titles,"rel. m_e",pba->has_varconst);

  return _SUCCESS_;
}

/**
 * Subroutine for writing the background output
 *
 * @param pba                  Input: pointer to background structure
 * @param number_of_titles     Input: number of background quantities to print at each time step
 * @param data                 Ouput: 1d array storing all the background table
 * @return the error status
 */

int background_output_data(
                           struct background *pba,
                           int number_of_titles,
                           double *data
                           ) {

  int index_tau, storeidx, n;
  double *dataptr, *pvecback;

  /** Stores quantities */
  for (index_tau=0; index_tau<pba->bt_size; index_tau++) {
    dataptr = data + index_tau*number_of_titles;
    pvecback = pba->background_table + index_tau*pba->bg_size;
    storeidx = 0;

    class_store_double(dataptr,1./pvecback[pba->index_bg_a]-1.,_TRUE_,storeidx);
    class_store_double(dataptr,pvecback[pba->index_bg_time]/_Gyr_over_Mpc_,_TRUE_,storeidx);
    class_store_double(dataptr,pba->conformal_age-pvecback[pba->index_bg_conf_distance],_TRUE_,storeidx);
    class_store_double(dataptr,pvecback[pba->index_bg_H],_TRUE_,storeidx);
    class_store_double(dataptr,pvecback[pba->index_bg_conf_distance],_TRUE_,storeidx);
    class_store_double(dataptr,pvecback[pba->index_bg_ang_distance],_TRUE_,storeidx);
    class_store_double(dataptr,pvecback[pba->index_bg_lum_distance],_TRUE_,storeidx);
    class_store_double(dataptr,pvecback[pba->index_bg_rs],_TRUE_,storeidx);
    class_store_double(dataptr,pvecback[pba->index_bg_rho_g],_TRUE_,storeidx);
    class_store_double(dataptr,pvecback[pba->index_bg_rho_b],_TRUE_,storeidx);
    class_store_double(dataptr,pvecback[pba->index_bg_rho_cdm],pba->has_cdm,storeidx);
    class_store_double(dataptr,pvecback[pba->index_bg_rho_idm],pba->has_idm,storeidx);
    if (pba->has_ncdm == _TRUE_) {
      for (n=0; n<pba->N_ncdm; n++) {
        class_store_double(dataptr,pvecback[pba->index_bg_rho_ncdm1+n],_TRUE_,storeidx);
        class_store_double(dataptr,pvecback[pba->index_bg_p_ncdm1+n],_TRUE_,storeidx);
      }
    }
    class_store_double(dataptr,pvecback[pba->index_bg_rho_lambda],pba->has_lambda,storeidx);
    class_store_double(dataptr,pvecback[pba->index_bg_rho_fld],pba->has_fld,storeidx);
    class_store_double(dataptr,pvecback[pba->index_bg_w_fld],pba->has_fld,storeidx);
    class_store_double(dataptr,pvecback[pba->index_bg_rho_ur],pba->has_ur,storeidx);
    class_store_double(dataptr,pvecback[pba->index_bg_rho_idr],pba->has_idr,storeidx);
    class_store_double(dataptr,pvecback[pba->index_bg_rho_crit],_TRUE_,storeidx);
    class_store_double(dataptr,pvecback[pba->index_bg_rho_dcdm],pba->has_dcdm,storeidx);
    class_store_double(dataptr,pvecback[pba->index_bg_rho_dr],pba->has_dr,storeidx);

    class_store_double(dataptr,pvecback[pba->index_bg_rho_scf],pba->has_scf,storeidx);
    class_store_double(dataptr,pvecback[pba->index_bg_p_scf],pba->has_scf,storeidx);
    class_store_double(dataptr,pvecback[pba->index_bg_p_prime_scf],pba->has_scf,storeidx);
    class_store_double(dataptr,pvecback[pba->index_bg_phi_scf],pba->has_scf,storeidx);
    class_store_double(dataptr,pvecback[pba->index_bg_phi_prime_scf],pba->has_scf,storeidx);
    class_store_double(dataptr,pvecback[pba->index_bg_V_scf],pba->has_scf,storeidx);
    class_store_double(dataptr,pvecback[pba->index_bg_dV_scf],pba->has_scf,storeidx);
    class_store_double(dataptr,pvecback[pba->index_bg_ddV_scf],pba->has_scf,storeidx);

    class_store_double(dataptr,pvecback[pba->index_bg_rho_tot],_TRUE_,storeidx);
    class_store_double(dataptr,pvecback[pba->index_bg_p_tot],_TRUE_,storeidx);
    class_store_double(dataptr,pvecback[pba->index_bg_p_tot_prime],_TRUE_,storeidx);

    class_store_double(dataptr,pvecback[pba->index_bg_D],_TRUE_,storeidx);
    class_store_double(dataptr,pvecback[pba->index_bg_f],_TRUE_,storeidx);

    class_store_double(dataptr,pvecback[pba->index_bg_varc_alpha],pba->has_varconst,storeidx);
    class_store_double(dataptr,pvecback[pba->index_bg_varc_me],pba->has_varconst,storeidx);
  }

  return _SUCCESS_;
}


/**
 * Subroutine evaluating the derivative with respect to loga
 * of quantities which are integrated (tau, t, etc).
 *
 * This is one of the few functions in the code which is passed to
 * the generic_integrator() routine.  Since generic_integrator()
 * should work with functions passed from various modules, the format
 * of the arguments is a bit special:
 *
 * - fixed input parameters and workspaces are passed through a generic
 * pointer. Here, this is just a pointer to the background structure
 * and to a background vector, but generic_integrator() doesn't know
 * its fine structure.
 *
 * - the error management is a bit special: errors are not written as
 * usual to pba->error_message, but to a generic error_message passed
 * in the list of arguments.
 *
 * @param loga                     Input: current value of log(a)
 * @param y                        Input: vector of variable
 * @param dy                       Output: its derivative (already allocated)
 * @param parameters_and_workspace Input: pointer to fixed parameters (e.g. indices)
 * @param error_message            Output: error message
 */

int background_derivs(
                      double loga,
                      double* y, /* vector with argument y[index_bi] (must be already allocated with size pba->bi_size) */
                      double* dy, /* vector with argument dy[index_bi]
                                     (must be already allocated with
                                     size pba->bi_size) */
                      void * parameters_and_workspace,
                      ErrorMsg error_message
                      ) {

  /** Summary: */

  /** - define local variables */

  struct background_parameters_and_workspace * pbpaw;
  struct background * pba;
  double * pvecback, a, H, rho_M;

  pbpaw = parameters_and_workspace;
  pba =  pbpaw->pba;
  pvecback = pbpaw->pvecback;

  /** - scale factor a (in fact, given our normalisation conventions, this stands for a/a_0) */
  a = exp(loga);

  /** - calculate functions of \f$ a \f$ with background_functions() */
  class_call(background_functions(pba, a, y, normal_info, pvecback),
             pba->error_message,
             error_message);

  /** - Short hand notation for Hubble */
  H = pvecback[pba->index_bg_H];

  /** - calculate derivative of cosmological time \f$ dt/dloga = 1/H \f$ */
  dy[pba->index_bi_time] = 1./H;

  /** - calculate derivative of conformal time \f$ d\tau/dloga = 1/aH \f$ */
  dy[pba->index_bi_tau] = 1./a/H;

  class_test(pvecback[pba->index_bg_rho_g] <= 0.,
             error_message,
             "rho_g = %e instead of strictly positive",pvecback[pba->index_bg_rho_g]);

  /** - calculate detivative of sound horizon \f$ drs/dloga = drs/dtau * dtau/dloga = c_s/aH \f$*/
  dy[pba->index_bi_rs] = 1./a/H/sqrt(3.*(1.+3.*pvecback[pba->index_bg_rho_b]/4./pvecback[pba->index_bg_rho_g]))*sqrt(1.-pba->K*y[pba->index_bi_rs]*y[pba->index_bi_rs]); // TBC: curvature correction

  /** - solve second order growth equation \f$ [D''(\tau)=-aHD'(\tau)+3/2 a^2 \rho_M D(\tau) \f$
      written as \f$ dD/dloga = D' / (aH) \f$ and \f$ dD'/dloga = -D' + (3/2) (a/H) \rho_M D \f$ */
  rho_M = pvecback[pba->index_bg_rho_b];
  if (pba->has_cdm == _TRUE_) {
    rho_M += pvecback[pba->index_bg_rho_cdm];
  }
  if (pba->has_idm == _TRUE_){
    rho_M += pvecback[pba->index_bg_rho_idm];
  }

  dy[pba->index_bi_D] = y[pba->index_bi_D_prime]/a/H;
  dy[pba->index_bi_D_prime] = -y[pba->index_bi_D_prime] + 1.5*a*rho_M*y[pba->index_bi_D]/H;

  if (pba->has_dcdm == _TRUE_) {
    /** - compute dcdm density \f$ d\rho/dloga = -3 \rho - \Gamma/H \rho \f$*/
    dy[pba->index_bi_rho_dcdm] = -3.*y[pba->index_bi_rho_dcdm] - pba->Gamma_dcdm/H*y[pba->index_bi_rho_dcdm];
  }

  if ((pba->has_dcdm == _TRUE_) && (pba->has_dr == _TRUE_)) {
    /** - Compute dr density \f$ d\rho/dloga = -4\rho - \Gamma/H \rho \f$ */
    dy[pba->index_bi_rho_dr] = -4.*y[pba->index_bi_rho_dr]+pba->Gamma_dcdm/H*y[pba->index_bi_rho_dcdm];
  }

  if (pba->has_fld == _TRUE_) {
    /** - Compute fld density \f$ d\rho/dloga = -3 (1+w_{fld}(a)) \rho \f$ */
    dy[pba->index_bi_rho_fld] = -3.*(1.+pvecback[pba->index_bg_w_fld])*y[pba->index_bi_rho_fld];
  }

  if (pba->has_scf == _TRUE_) {
    /** - Scalar field equation: \f$ \phi'' + 2 a H \phi' + a^2 dV = 0 \f$  (note H is wrt cosmological time)
        written as \f$ d\phi/dlna = phi' / (aH) \f$ and \f$ d\phi'/dlna = -2*phi' - (a/H) dV \f$ */
    dy[pba->index_bi_phi_scf] = y[pba->index_bi_phi_prime_scf]/a/H;
    dy[pba->index_bi_phi_prime_scf] = - 2*y[pba->index_bi_phi_prime_scf] - a*dV_scf(pba,y[pba->index_bi_phi_scf])/H ;
  }

  return _SUCCESS_;

}

/**
 * At some step during the integraton of the background equations,
 * this function extracts the qantities that we want to keep memory
 * of, and stores them in a row of the background table (as well as
 * extra tables: z_table, tau_table).
 *
 * This is one of the few functions in the code which is passed to the generic_integrator() routine.
 * Since generic_integrator() should work with functions passed from various modules, the format of the arguments
 * is a bit special:
 * - fixed parameters and workspaces are passed through a generic pointer.
 *   generic_integrator() doesn't know the content of this pointer.
 * - the error management is a bit special: errors are not written as usual to pba->error_message, but to a generic
 *   error_message passed in the list of arguments.
 *
 * @param loga                     Input: current value of log(a)
 * @param y                        Input: current vector of integrated quantities (with index_bi)
 * @param dy                       Input: current derivative of y w.r.t log(a)
 * @param index_loga               Input: index of the log(a) value within the background_table
 * @param parameters_and_workspace Input/output: fixed parameters (e.g. indices), workspace, background structure where the output is written...
 * @param error_message            Output: error message
 */

int background_sources(
                       double loga,
                       double * y,
                       double * dy,
                       int index_loga,
                       void * parameters_and_workspace,
                       ErrorMsg error_message
                       ) {

  struct background_parameters_and_workspace * pbpaw;
  struct background * pba;
  double a;
  double * bg_table_row;

  pbpaw = parameters_and_workspace;
  pba =  pbpaw->pba;

  /** - localize the row inside background_table where the current values must be stored */
  bg_table_row = pba->background_table + index_loga*pba->bg_size;

  /** - scale factor a (in fact, given our normalisation conventions, this stands for a/a_0) */
  a = exp(loga);

  /** - corresponding redhsift 1/a-1 */
  pba->z_table[index_loga] = MAX(0.,1./a-1.);

  /** - corresponding conformal time */
  pba->tau_table[index_loga] = y[pba->index_bi_tau];

  /** -> compute all other quantities depending only on a + {B} variables and get them stored
      in one row of background_table
      The value of {B} variables in pData are also copied to pvecback.*/
  class_call(background_functions(pba, a, y, long_info, bg_table_row),
             pba->error_message,
             pba->error_message);

  return _SUCCESS_;

}

/**
 * Evalute the typical timescale for the integration of he background
 * over loga=log(a/a_0). This is only required for rkck, but not for
 * the ndf15 evolver.
 *
 * The evolver will take steps equal to this value times
 * ppr->background_integration_stepsize.  Since our variable of
 * integration is loga, and the time steps are (delta a)/a, the
 * reference timescale is precisely one, i.e., the code will take some
 * steps such that (delta a)/a = ppr->background_integration_stepsize.
 *
 * The argument list is predetermined by the format of
 * generic_evolver; however in this particular case, they are never
 * used.
 *
 * This is one of the few functions in the code which is passed to the generic_integrator() routine.
 * Since generic_integrator() should work with functions passed from various modules, the format of the arguments
 * is a bit special:
 * - fixed parameters and workspaces are passed through a generic pointer (void *).
 *   generic_integrator() doesn't know the content of this pointer.
 * - the error management is a bit special: errors are not written as usual to pba->error_message, but to a generic
 *   error_message passed in the list of arguments.
 *
 * @param loga                     Input: current value of log(a/a_0)
 * @param parameters_and_workspace Input: fixed parameters (e.g. indices), workspace, approximation used, etc.
 * @param timescale                Output: perturbation variation timescale
 * @param error_message            Output: error message
 */

int background_timescale(
                         double loga,
                         void * parameters_and_workspace,
                         double * timescale,
                         ErrorMsg error_message
                         ) {

  *timescale = 1.;
  return _SUCCESS_;
}

/**
 * Function outputting the fractions Omega of the total critical density
 * today, and also the reduced fractions omega=Omega*h*h
 *
 * It also prints the total budgets of non-relativistic, relativistic,
 * and other contents, and of the total
 *
 * @param pba                      Input: Pointer to background structure
 * @return the error status
 */

int background_output_budget(
                             struct background* pba
                             ) {

  double budget_matter, budget_radiation, budget_other,budget_neutrino;
  int index_ncdm;

  budget_matter = 0;
  budget_radiation = 0;
  budget_other = 0;
  budget_neutrino = 0;

  //The name for the class_print_species macro can be at most 30 characters total
  if (pba->background_verbose > 1) {

    printf(" ---------------------------- Budget equation ----------------------- \n");

    printf(" ---> Nonrelativistic Species \n");
    class_print_species("Bayrons",b);
    budget_matter+=pba->Omega0_b;
    if (pba->has_cdm == _TRUE_) {
      class_print_species("Cold Dark Matter",cdm);
      budget_matter+=pba->Omega0_cdm;
    }
    if (pba->has_idm == _TRUE_){
      class_print_species("Interacting DM - idr,b,g",idm);
      budget_matter+=pba->Omega0_idm;
    }
    if (pba->has_dcdm == _TRUE_) {
      class_print_species("Decaying Cold Dark Matter",dcdm);
      budget_matter+=pba->Omega0_dcdm;
    }

    if (pba->N_ncdm > 0) {
      printf(" ---> Non-Cold Dark Matter Species (incl. massive neutrinos)\n");
    }
    if (pba->N_ncdm > 0) {
      for (index_ncdm=0;index_ncdm<pba->N_ncdm;++index_ncdm) {
        printf("-> %-26s%-4d Omega = %-15g , omega = %-15g\n","Non-Cold Species Nr.",index_ncdm+1,pba->Omega0_ncdm[index_ncdm],pba->Omega0_ncdm[index_ncdm]*pba->h*pba->h);
        budget_neutrino+=pba->Omega0_ncdm[index_ncdm];
        budget_matter+=pba->Omega0_ncdm[index_ncdm];
      }
    }

    printf(" ---> Relativistic Species \n");
    class_print_species("Photons",g);
    budget_radiation+=pba->Omega0_g;
    if (pba->has_ur == _TRUE_) {
      class_print_species("Ultra-relativistic relics",ur);
      budget_radiation+=pba->Omega0_ur;
    }
    if (pba->has_dr == _TRUE_) {
      class_print_species("Dark Radiation (from decay)",dr);
      budget_radiation+=pba->Omega0_dr;
    }
    if (pba->has_idr == _TRUE_) {
      class_print_species("Interacting Dark Radiation",idr);
      budget_radiation+=pba->Omega0_idr;
    }

    if ((pba->has_lambda == _TRUE_) || (pba->has_fld == _TRUE_) || (pba->has_scf == _TRUE_) || (pba->has_curvature == _TRUE_)) {
      printf(" ---> Other Content \n");
    }
    if (pba->has_lambda == _TRUE_) {
      class_print_species("Cosmological Constant",lambda);
      budget_other+=pba->Omega0_lambda;
    }
    if (pba->has_fld == _TRUE_) {
      class_print_species("Dark Energy Fluid",fld);
      budget_other+=pba->Omega0_fld;
    }
    if (pba->has_scf == _TRUE_) {
      class_print_species("Scalar Field",scf);
      budget_other+=pba->Omega0_scf;
    }
    if (pba->has_curvature == _TRUE_) {
      class_print_species("Spatial Curvature",k);
      budget_other+=pba->Omega0_k;
    }

    printf(" ---> Total budgets \n");
    printf(" Radiation                        Omega = %-15g , omega = %-15g \n",budget_radiation,budget_radiation*pba->h*pba->h);
    printf(" Non-relativistic                 Omega = %-15g , omega = %-15g \n",budget_matter,budget_matter*pba->h*pba->h);
    if (pba->N_ncdm > 0) {
      printf(" - Non-Free-Streaming Matter      Omega = %-15g , omega = %-15g \n",pba->Omega0_nfsm,pba->Omega0_nfsm*pba->h*pba->h);
      printf(" - Non-Cold Dark Matter           Omega = %-15g , omega = %-15g \n",budget_neutrino,budget_neutrino*pba->h*pba->h);
    }
    if ((pba->has_lambda == _TRUE_) || (pba->has_fld == _TRUE_) || (pba->has_scf == _TRUE_) || (pba->has_curvature == _TRUE_)) {
      printf(" Other Content                    Omega = %-15g , omega = %-15g \n",budget_other,budget_other*pba->h*pba->h);
    }
    printf(" TOTAL                            Omega = %-15g , omega = %-15g \n",budget_radiation+budget_matter+budget_other,(budget_radiation+budget_matter+budget_other)*pba->h*pba->h);
    printf(" -------------------------------------------------------------------- \n");
  }

  return _SUCCESS_;
}

/**
 * Scalar field potential and its derivatives with respect to the field _scf
 * For Albrecht & Skordis model: 9908085
 * - \f$ V = V_{p_{scf}}*V_{e_{scf}} \f$
 * - \f$ V_e =  \exp(-\lambda \phi) \f$ (exponential)
 * - \f$ V_p = (\phi - B)^\alpha + A \f$ (polynomial bump)
 *
 * TODO:
 * - Add some functionality to include different models/potentials (tuning would be difficult, though)
 * - Generalize to Kessence/Horndeski/PPF and/or couplings
 * - A default module to numerically compute the derivatives when no analytic functions are given should be added.
 * - Numerical derivatives may further serve as a consistency check.
 *
 */

/**
 *
 * The units of phi, tau in the derivatives and the potential V are the following:
 * - phi is given in units of the reduced Planck mass \f$ m_{pl} = (8 \pi G)^{(-1/2)}\f$
 * - tau in the derivative is given in units of Mpc.
 * - the potential \f$ V(\phi) \f$ is given in units of \f$ m_{pl}^2/Mpc^2 \f$.
 * With this convention, we have
 * \f$ \rho^{class} = (8 \pi G)/3 \rho^{physical} = 1/(3 m_{pl}^2) \rho^{physical} = 1/3 * [ 1/(2a^2) (\phi')^2 + V(\phi) ] \f$
 and \f$ \rho^{class} \f$ has the proper dimension \f$ Mpc^-2 \f$.
*/

double V_e_scf(struct background *pba,
               double phi
               ) {
  double scf_lambda = pba->scf_parameters[0];
  //  double scf_alpha  = pba->scf_parameters[1];
  //  double scf_A      = pba->scf_parameters[2];
  //  double scf_B      = pba->scf_parameters[3];

  return  exp(-scf_lambda*phi);
}

double dV_e_scf(struct background *pba,
                double phi
                ) {
  double scf_lambda = pba->scf_parameters[0];
  //  double scf_alpha  = pba->scf_parameters[1];
  //  double scf_A      = pba->scf_parameters[2];
  //  double scf_B      = pba->scf_parameters[3];

  return -scf_lambda*V_e_scf(pba,phi);
}

double ddV_e_scf(struct background *pba,
                 double phi
                 ) {
  double scf_lambda = pba->scf_parameters[0];
  //  double scf_alpha  = pba->scf_parameters[1];
  //  double scf_A      = pba->scf_parameters[2];
  //  double scf_B      = pba->scf_parameters[3];

  return pow(-scf_lambda,2)*V_e_scf(pba,phi);
}


/** parameters and functions for the polynomial coefficient
 * \f$ V_p = (\phi - B)^\alpha + A \f$(polynomial bump)
 *
 * double scf_alpha = 2;
 *
 * double scf_B = 34.8;
 *
 * double scf_A = 0.01; (values for their Figure 2)
 */

double V_p_scf(
               struct background *pba,
               double phi) {
  //  double scf_lambda = pba->scf_parameters[0];
  double scf_alpha  = pba->scf_parameters[1];
  double scf_A      = pba->scf_parameters[2];
  double scf_B      = pba->scf_parameters[3];

  return  pow(phi - scf_B,  scf_alpha) +  scf_A;
}

double dV_p_scf(
                struct background *pba,
                double phi) {

  //  double scf_lambda = pba->scf_parameters[0];
  double scf_alpha  = pba->scf_parameters[1];
  //  double scf_A      = pba->scf_parameters[2];
  double scf_B      = pba->scf_parameters[3];

  return   scf_alpha*pow(phi -  scf_B,  scf_alpha - 1);
}

double ddV_p_scf(
                 struct background *pba,
                 double phi) {
  //  double scf_lambda = pba->scf_parameters[0];
  double scf_alpha  = pba->scf_parameters[1];
  //  double scf_A      = pba->scf_parameters[2];
  double scf_B      = pba->scf_parameters[3];

  return  scf_alpha*(scf_alpha - 1.)*pow(phi -  scf_B,  scf_alpha - 2);
}

/** Fianlly we can obtain the overall potential \f$ V = V_p*V_e \f$
 */

double V_scf(
             struct background *pba,
             double phi) {
  return  V_e_scf(pba,phi)*V_p_scf(pba,phi);
}

double dV_scf(
              struct background *pba,
              double phi) {
  return dV_e_scf(pba,phi)*V_p_scf(pba,phi) + V_e_scf(pba,phi)*dV_p_scf(pba,phi);
}

double ddV_scf(
               struct background *pba,
               double phi) {
  return ddV_e_scf(pba,phi)*V_p_scf(pba,phi) + 2*dV_e_scf(pba,phi)*dV_p_scf(pba,phi) + V_e_scf(pba,phi)*ddV_p_scf(pba,phi);
}

```

`source/distortions.c`:

```c
/** @file distortions.c Documented module on spectral distortions
 * Matteo Lucca, 31.10.2018
 * Nils Schoeneberg, 18.02.2019
 *
 * When using this module please consider citing:
 * Lucca et al. 2019 (JCAP02(2020)026, arXiv:1910.04619)
 * as well as related pioneering works such as:
 * Chluba & Sunyaev 2012 (MNRAS419(2012)1294-1314, arXiv:1109.6552)
 * Chluba 2013 (MNRAS434(2013)352, arXiv:1304.6120)
 * Clube & Jeong 2014 (MNRAS438(2014)2065–2082, arXiv:1306.5751)
 */

#include "distortions.h"

/**
 * Initialize the distortions structure.
 *
 * @param ppr        Input: pointer to precision structure
 * @param pba        Input: pointer to background structure
 * @param pth        Input: pointer to the thermodynamics structure
 * @param ppt        Input: pointer to the perturbations structure
 * @param ppm        Input: pointer to the primordial structure
 * @param psd        Input/Output: pointer to initialized distortions structure
 * @return the error status
 */

int distortions_init(struct precision * ppr,
                     struct background * pba,
                     struct thermodynamics * pth,
                     struct perturbations * ppt,
                     struct primordial * ppm,
                     struct distortions * psd) {

  if (psd->has_distortions == _FALSE_) {
    if (psd->distortions_verbose > 0)
      printf("No distortions requested. Distortions module skipped.\n");
    return _SUCCESS_;
  }
  if (psd->distortions_verbose > 0) {
    printf("Computing spectral distortions\n");
  }

  class_test(pth->compute_damping_scale==_FALSE_,
             psd->error_message,
             "Cannot compute spectral distortions without damping scale\n");

  /** Set physical constants */
  class_call(distortions_constants(ppr,pba,pth,psd),
             psd->error_message,
             psd->error_message);

  if (psd->sd_branching_approx == bra_exact) {
    /** Set/Check the distortions detector */
    class_call(distortions_set_detector(ppr,psd),
               psd->error_message,
               psd->error_message);
  }

  /** Assign values to all indices in the distortions structure */
  class_call(distortions_indices(psd),
             psd->error_message,
             psd->error_message);

  /** Define z and x arrays */
  class_call(distortions_get_xz_lists(ppr,pba,pth,psd),
             psd->error_message,
             psd->error_message);

  /** Define branching ratios */
  class_call(distortions_compute_branching_ratios(ppr,psd),
             psd->error_message,
             psd->error_message);

  /** Define heating function */
  class_call(distortions_compute_heating_rate(ppr,pba,pth,ppt,ppm,psd),
             psd->error_message,
             psd->error_message);

  /** Define final spectral distortions */
  class_call(distortions_compute_spectral_shapes(ppr,pba,pth,psd),
             psd->error_message,
             psd->error_message);

  psd->is_allocated = _TRUE_;

  return _SUCCESS_;
}

/**
 * Free all memory space allocated by distortions_init()
 *
 * @param psd     Input: pointer to distortions structure (to be freed)
 * @return the error status
 */

int distortions_free(struct distortions * psd) {

  /** Define local variables */
  int index_type;

  if (psd->has_distortions == _TRUE_) {
    /** Delete lists */
    free(psd->z);
    free(psd->z_weights);
    free(psd->x);
    free(psd->x_weights);

    /** Delete noise file */
    if (psd->has_detector_file == _TRUE_) {
      free(psd->delta_Ic_array);
    }

    /** Delete branching ratios */
    for (index_type=0;index_type<psd->type_size;++index_type){
      free(psd->br_table[index_type]);
    }
    free(psd->br_table);

    /** Delete heating functions */
    free(psd->dQrho_dz_tot);

    /** Delete distortion shapes */
    for (index_type=0;index_type<psd->type_size;++index_type){
      free(psd->sd_shape_table[index_type]);
      free(psd->sd_table[index_type]);
    }
    free(psd->sd_shape_table);
    free(psd->sd_table);

    /** Delete distortion amplitudes */
    free(psd->sd_parameter_table);

    /** Delete total distortion */
    free(psd->DI);
  }
  psd->is_allocated = _FALSE_;

  return _SUCCESS_;
}

/**
 * Calculate physical constant.
 *
 * @param ppr        Input: pointer to precision structure
 * @param pba        Input: pointer to background structure
 * @param pth        Input: pointer to thermodynamics structure
 * @param psd        Input: pointer to the distortions structure
 * @return the error status
 */

int distortions_constants(struct precision * ppr,
                          struct background * pba,
                          struct thermodynamics * pth,
                          struct distortions * psd){

  /** Define unit conventions */
  psd->x_to_nu = (_k_B_*pba->T_cmb/_h_P_)/1e9;                    // [GHz]
  psd->DI_units = 2.*pow(_k_B_*pba->T_cmb,3.)/pow(_h_P_*_c_,2.);  // [W/(m^2 Hz sr)]

  /** Define transition redshifts z_muy and z_th */
  psd->z_muy = 5.e4;
  psd->z_th = 1.98e6*
    pow((1.-pth->YHe/2.)/0.8767,-2./5.)*
    pow(pba->Omega0_b*pow(pba->h,2.)/0.02225,-2./5.)*
    pow(pba->T_cmb/2.726,1./5.);

  class_sprintf(psd->sd_PCA_file_generator,"%s/%s",ppr->sd_external_path,"generate_PCA_files.py");
  class_sprintf(psd->sd_detector_list_file,"%s/%s",ppr->sd_external_path,"detectors_list.dat");

  return _SUCCESS_;
}

/**
 * Check wether the detector name and the detector properties
 * are a valid combination.
 *
 * There are four options for the user
 *
 * defined_name = true, defined_detector = true
 * Meaning: The user requests a specific detector with specific settings
 * --> Check that the detector exists and has the same settings
 *
 * defined_name = true, defined_detector = false
 * Meaning: The user requests a specific detector
 * --> Check that the detector exists and use the given settings
 *
 * defined_name = false, defined_detector = true
 * Meaning: The user requests specific settings, but does not name their detector
 * --> Check that the settings exists, or create them
 *
 * defined_name = false, defined_detector = false
 * Meaning: The user just wants the default detector and settings
 * --> Just use the default settings and skip this function
 *
 * @param ppr        Input: pointer to precision structure
 * @param psd        Input/Output: pointer to initialized distortions structure
 * @return the error status
 */

int distortions_set_detector(struct precision * ppr,
                             struct distortions * psd){

  /** Local variables */
  FILE* det_list_file;
  char line[_LINE_LENGTH_MAX_];
  DetectorName detector_name;
  DetectorFileName detector_noise_file_name;
  double nu_min,nu_max,nu_delta,delta_Ic;
  int has_detector_noise_file;
  int N_bins;
  char * left;
  int headlines = 0;
  int found_detector;

  has_detector_noise_file = _FALSE_;

  if (psd->has_user_defined_name == _FALSE_) {
    /* The user wants the default */
    if (psd->has_user_defined_detector == _FALSE_ && psd->has_detector_file == _FALSE_) {
      if (psd->distortions_verbose > 0) {
        printf(" -> Using the default (%s) detector\n",psd->sd_detector_name);
      }
      return _SUCCESS_; // Nothing more to do
    }
    /* The user wants a new detector with specified settings, but without name */
    else {
      /* Generate a custom name for this custom detector, so we can check if it has already been defined */
      if (psd->has_detector_file == _TRUE_) {
        class_sprintf(psd->sd_detector_name,
                "Custom__%.80s__Detector",
                psd->sd_detector_file_name);
      }
      else {
        class_sprintf(psd->sd_detector_name,
                "Custom__%7.2e_%7.2e_%7.2e_%i_%7.2e__Detector",
                psd->sd_detector_nu_min,psd->sd_detector_nu_max,psd->sd_detector_nu_delta,psd->sd_detector_bin_number,psd->sd_detector_delta_Ic);
      }
    }
  }

  /** Open file */
  class_open(det_list_file, psd->sd_detector_list_file, "r",
             psd->error_message);

  found_detector = _FALSE_;
  while (fgets(line,_LINE_LENGTH_MAX_-1,det_list_file) != NULL) {
    headlines++;

    /* Eliminate blank spaces at beginning of line */
    left=line;
    while (left[0]==' ') {
      left++;
    }
    if (left[0] > 39) {
      if (sscanf(line,"%s %lg %lg %lg %i %lg",detector_name,&nu_min,&nu_max,&nu_delta,&N_bins,&delta_Ic) != 6) {
        has_detector_noise_file = _TRUE_;
        if (sscanf(line,"%s %s",detector_name,detector_noise_file_name) != 2) {
          class_stop(psd->error_message,
                     "Could not read line %i in file '%s'\n",headlines,psd->sd_detector_list_file);
        }
      }
      else {
        has_detector_noise_file = _FALSE_;
      }

      /* Detector has been found */
      if (strcmp(psd->sd_detector_name,detector_name)==0) {
        if (psd->distortions_verbose > 0){
          printf(" -> Found detector %s (user defined = %s)\n",detector_name,(psd->has_user_defined_detector?"TRUE":"FALSE"));
        }
        found_detector = _TRUE_;

        if (has_detector_noise_file == _TRUE_) {
          if (psd->distortions_verbose > 1){
            printf(" -> Properties:    Noise file name = %s \n",
                   detector_noise_file_name);
          }
          if (psd->has_detector_file == _TRUE_) {
            class_test(strcmp(psd->sd_detector_file_name,detector_noise_file_name) != 0,
                       psd->error_message,
                       "Noise file path (sd_detector_file_name) disagrees between stored detector '%s' and input ->  %s (input) vs %s (stored)",
                       detector_name,psd->sd_detector_file_name,detector_noise_file_name);
          }
          class_test(psd->has_user_defined_detector,
                     psd->error_message,
                     "Detector property type disagrees between stored detector '%s' and input  ->  Userdefined (input) vs Noisefile (stored)",
                     detector_name);
          class_sprintf(psd->sd_detector_file_name, "%s", detector_noise_file_name);
          psd->has_detector_file = has_detector_noise_file;
        }
        else {
          if (psd->distortions_verbose > 1) {
            printf(" -> Properties:    nu_min = %lg    nu_max = %lg    delta_nu = %lg    N_bins = %i    delta_Ic = %lg \n",
                   nu_min, nu_max, nu_delta, N_bins, delta_Ic);
          }
          /* If the user has defined the detector, check that their and our definitions agree */
          if (psd->has_user_defined_detector == _TRUE_) {
            class_test(fabs(psd->sd_detector_nu_min-nu_min)>ppr->tol_sd_detector,
                       psd->error_message,
                       "Minimal frequency (sd_detector_nu_min) disagrees between stored detector '%s' and input ->  %.10e (input) vs %.10e (stored)",
                       detector_name,psd->sd_detector_nu_min,nu_min);
            class_test(fabs(psd->sd_detector_nu_max-nu_max)>ppr->tol_sd_detector,
                       psd->error_message,
                       "Maximal frequency (sd_detector_nu_min) disagrees between stored detector '%s' and input ->  %.10e (input) vs %.10e (stored)",
                       detector_name,psd->sd_detector_nu_max,nu_max);
            class_test(fabs(psd->sd_detector_nu_delta-nu_delta)>ppr->tol_sd_detector,
                       psd->error_message,
                       "Delta frequency (sd_detector_nu_delta) disagrees between stored detector '%s' and input ->  %.10e (input) vs %.10e (stored)",
                       detector_name,psd->sd_detector_nu_delta,nu_delta);
            class_test(abs(psd->sd_detector_bin_number-N_bins)>ppr->tol_sd_detector,
                       psd->error_message,
                       "Number of bins (sd_detector_bin_number) disagrees between stored detector '%s' and input ->  %i (input) vs %i (stored)",
                       detector_name,psd->sd_detector_bin_number,N_bins);
            class_test(fabs(psd->sd_detector_delta_Ic-delta_Ic)>ppr->tol_sd_detector,
                       psd->error_message,
                       "Detector accuracy (sd_detector_delta_Ic) disagrees between stored detector '%s' and input ->  %.10e (input) vs %.10e (stored)",
                       detector_name,psd->sd_detector_delta_Ic,delta_Ic);
          }
          class_test(psd->has_detector_file,
                     psd->error_message,
                     "Detector property type disagrees between stored detector '%s' and input  ->  Noisefile (input) vs Userdefined (stored)",
                     detector_name);

          /* In any case, just take the detector definition from the file */
          psd->sd_detector_nu_min = nu_min;
          psd->sd_detector_nu_max = nu_max;
          psd->sd_detector_nu_delta = nu_delta;
          psd->sd_detector_bin_number = N_bins;
          psd->sd_detector_delta_Ic = delta_Ic;
        }
      }
    }
  }

  fclose(det_list_file);

  /* If the detector has not been found, either the user has specified the settings and we create a new one,
   * or the user hasn't specified the settings and we have to stop */
  if (found_detector == _FALSE_) {
    if (psd->has_user_defined_detector==_TRUE_ || psd->has_detector_file==_TRUE_) {
      if (psd->distortions_verbose > 0) {
        printf(" -> Generating detector '%s' \n",psd->sd_detector_name);
      }
      class_call(distortions_generate_detector(ppr,psd),
                 psd->error_message,
                 psd->error_message);
    }
    else {
      class_stop(psd->error_message,
                 "You asked for detector '%s', but it was not in the database '%s'.\nPlease check the name of your detector, or specify its properties if you want to create a new one",
                 psd->sd_detector_name,
                 psd->sd_detector_list_file);
    }
  }

  if (psd->has_detector_file ==_TRUE_) {
    class_call(distortions_read_detector_noisefile(ppr,psd),
               psd->error_message,
               psd->error_message);
  }

  return _SUCCESS_;
}

/**
 * Evaluate branching ratios, spectral shapes, E and S vectors for a given detector as
 * described in external/distortions/README using generate_PCA_files.py.
 *
 * @param ppr        Input: pointer to precision structure
 * @param psd        Input: pointer to the distortions structure
 * @return the error status
 */

int distortions_generate_detector(struct precision * ppr,
                                  struct distortions * psd){

  /** Define local variables*/
  int is_success;
  char temporary_string[2*_FILENAMESIZE_+2*_MAX_DETECTOR_NAME_LENGTH_+1024];


  /* Test first whether or not python exists*/
  if (psd->distortions_verbose > 0) {
    printf(" -> Testing python\n");
  }
  is_success = system("python --version");
  class_test(is_success == -1,
             psd->error_message,
             "The command 'python --version' failed.\nPlease install a valid version of python.");

  /* Then activate the PCA generator*/
  if (psd->distortions_verbose > 0) {
    printf(" -> Executing the PCA generator\n");
  }

  if (psd->has_detector_file == _TRUE_) {
    class_sprintf(temporary_string,"python %s %s %s %s %.10e %.10e %i %i %.10e %.10e %.10e",
            psd->sd_PCA_file_generator,
            psd->sd_detector_name,
            ppr->sd_external_path,
            psd->sd_detector_file_name,
            ppr->sd_z_min,
            ppr->sd_z_max,
            ppr->sd_z_size,
            6,
            psd->z_th,
            psd->DI_units,
            psd->x_to_nu);

  }
  else {
    class_sprintf(temporary_string,"python %s %s %.10e %.10e %.10e  %i %.10e %.10e %i %.10e %i %.10e %.10e %.10e",
            psd->sd_PCA_file_generator,
            psd->sd_detector_name,
            psd->sd_detector_nu_min,
            psd->sd_detector_nu_max,
            psd->sd_detector_nu_delta,
            psd->sd_detector_bin_number,
            ppr->sd_z_min,
            ppr->sd_z_max,
            ppr->sd_z_size,
            psd->sd_detector_delta_Ic,
            6,
            psd->z_th,
            psd->DI_units,
            psd->x_to_nu);
  }
  is_success = system(temporary_string);
  class_test(is_success == -1,
             psd->error_message,
             "The command 'python %s' failed.\nPlease make sure the file exists.",psd->sd_PCA_file_generator);

  return _SUCCESS_;
}

/**
 * Reads the external detector noise file containing the
 * array of frequencies and the detector accuracies
 * Assumed to be in units of [GHz] and [10^-26 W/m^2/Hz/sr] respectively
 *
 * @param ppr        Input: pointer to the precisions structure
 * @param psd        Input: pointer to the distortions structure
 * @return the error status
 */
int distortions_read_detector_noisefile(struct precision * ppr,
                                        struct distortions * psd){

  /** Define local variables */
  int index_x;
  double nu_temp,delta_Ic_temp;
  FILE * infile;
  char line[_LINE_LENGTH_MAX_];
  char * left;
  int headlines = 0;
  int numcols;

  /** Open file */
  class_sprintf(psd->sd_detector_noise_file,"%s/%s",ppr->sd_external_path,psd->sd_detector_file_name);
  class_open(infile, psd->sd_detector_noise_file, "r", psd->error_message);

  /** Read header */
  psd->br_exact_Nz = 0;
  while (fgets(line,_LINE_LENGTH_MAX_-1,infile) != NULL) {
    headlines++;

    /* Eliminate blank spaces at beginning of line */
    left=line;
    while (left[0]==' ') {
      left++;
    }

    if (left[0] > 39) {
      /** Read number of lines, infer size of arrays and allocate them */
      class_test(sscanf(line,"%d %d", &psd->x_size, &numcols) != 2,
                 psd->error_message,
                 "could not header (number of lines, number of columns) at line %i in file '%s' \n",headlines,psd->sd_detector_noise_file);
      class_test(numcols !=2,
                 psd->error_message,
                 "Incorrect number of columns in the detector noise file '%s'",psd->sd_detector_noise_file);

      class_alloc(psd->x, psd->x_size*sizeof(double), psd->error_message);
      class_alloc(psd->delta_Ic_array, psd->x_size*sizeof(double), psd->error_message);
      break;
    }
  }

  /** Read parameters */
  for (index_x=0; index_x<psd->x_size; ++index_x){
    class_test(fscanf(infile, "%le",
                      &(nu_temp))!=1,                                                 // [-]
               psd->error_message,
               "Could not read nu at line %i in file '%s'",index_x+headlines,psd->sd_detector_noise_file);
    psd->x[index_x] = nu_temp/psd->x_to_nu;
    class_test(fscanf(infile, "%le",
                      &(delta_Ic_temp))!=1,                            // [-]
               psd->error_message,
               "Could not read delta_Ic(nu) at line %i in file '%s'",index_x+headlines,psd->sd_detector_noise_file);
    psd->delta_Ic_array[index_x] = delta_Ic_temp*1e-26;
  }

  fclose(infile);

  return _SUCCESS_;
}

/**
 * Assign value to each relevant index in vectors of distortions quantities.
 *
 * @param psd     Input: pointer to distortions structure
 * @return the error status
 */

int distortions_indices(struct distortions * psd) {

  /** Define local variables */
  int index_type = 0;

  /** Define indeces for tables - br_table defined in distortions_compute_branching_ratios,
      - sd_parameter_table and
      - sd_table defined in distortions_compute_spectral_shapes */
  class_define_index(psd->index_type_g,_TRUE_,index_type,1);
  class_define_index(psd->index_type_y,_TRUE_,index_type,1);
  class_define_index(psd->index_type_mu,_TRUE_,index_type,1);
  class_define_index(psd->index_type_PCA,_TRUE_,index_type,psd->sd_PCA_size);

  psd->type_size = index_type;

  return _SUCCESS_;
}

/**
 * Calculate redshift and frequency vectors and weights for redshift integral.
 *
 * @param ppr        Input: pointer to precision structure
 * @param pba        Input: pointer to background structure
 * @param pth        Input: pointer to the thermodynamics structure
 * @param psd        Input/Output: pointer to initialized distortions structure
 * @return the error status
 */

int distortions_get_xz_lists(struct precision * ppr,
                             struct background * pba,
                             struct thermodynamics * pth,
                             struct distortions * psd){

  /** Define local variables */
  int index_z, index_x;

  /** Define and allocate z array */
  psd->z_min = ppr->sd_z_min;
  psd->z_max = ppr->sd_z_max;
  psd->z_size = ppr->sd_z_size;
  psd->z_delta = (log(psd->z_max)-log(psd->z_min))/psd->z_size;

  class_alloc(psd->z,
              psd->z_size*sizeof(double),
              psd->error_message);

  for (index_z = 0; index_z < psd->z_size; index_z++) {
    psd->z[index_z] = exp(log(psd->z_min+1)+psd->z_delta*index_z);
  }

  /** Define and allocate integrating weights for z array */
  class_alloc(psd->z_weights,
              psd->z_size*sizeof(double),
              psd->error_message);
  class_call(array_trapezoidal_weights(
                                       psd->z,
                                       psd->z_size,
                                       psd->z_weights,
                                       psd->error_message),
             psd->error_message,
             psd->error_message);

  /** Define and allocate x array */
  if (psd->sd_branching_approx != bra_exact) {
    psd->x_min = ppr->sd_x_min;
    psd->x_max = ppr->sd_x_max;
    psd->x_size = ppr->sd_x_size;
    psd->x_delta = (log(psd->x_max)-log(psd->x_min))/psd->x_size;

    class_alloc(psd->x,
                psd->x_size*sizeof(double),
                psd->error_message);

    for (index_x = 0; index_x<psd->x_size; index_x++) {
      psd->x[index_x] = exp(log(psd->x_min)+psd->x_delta*index_x);
    }

  }
  else if (psd->has_detector_file == _FALSE_) {
    psd->x_min = psd->sd_detector_nu_min/psd->x_to_nu;
    psd->x_max = psd->sd_detector_nu_max/psd->x_to_nu;
    psd->x_delta = psd->sd_detector_nu_delta/psd->x_to_nu;
    psd->x_size = psd->sd_detector_bin_number+1;

    class_alloc(psd->x,
                psd->x_size*sizeof(double),
                psd->error_message);

    for (index_x = 0; index_x<psd->x_size; index_x++){
      psd->x[index_x] = psd->x_min+psd->x_delta*index_x;
    }
  }

  /** Define and allocate integrating weights for x array */
  class_alloc(psd->x_weights,
              psd->x_size*sizeof(double),
              psd->error_message);
  class_call(array_trapezoidal_weights(
                                       psd->x,
                                       psd->x_size,
                                       psd->x_weights,
                                       psd->error_message),
             psd->error_message,
             psd->error_message);

  return _SUCCESS_;
}

/**
 * Calculate branching ratios.
 *
 * Computing the full evolution of the thermal history of the universe is rather time consuming
 * and mathematically challenging. It is therefore not implemented here. However, there are
 * (at least) 5 levels of possible approximatin to evaluate the SD branching ratios (see also
 * Chluba 2016 for useful discussion)
 *    1) Use a sharp transition at z_mu-y and no distortions before z_th ('branching approx'=sharp_sharp)
 *    2) Use a sharp transition at z_mu-y and a soft transition at z_th ('branching approx'=sharp_soft)
 *    3) Use a soft transition at a_mu-y and z_th as described in Chluba 2013 ('branching approx'=soft_soft)
 *       In this case, the user must be aware that energy conservation is violated and no residuals
 *       are taken into consideration.
 *    4) Use a soft transition at a_mu-y and z_th imposing conservation of energy
 *       ('branching approx'=soft_soft_cons)
 *    5) Use a PCA method as described in Chluba & Jeong 2014 ('branching approx'=exact)
 *       In this case, the definition of the BRs is detector dependent and the user has therefore to
 *       specify the detector type and corresponding characteristics.
 *
 * All quantities are stored in the table br_table.
 *
 * @param ppr        Input: pointer to the precision structure
 * @param psd        Input: pointer to the distortions structure
 * @return the error status
 */

int distortions_compute_branching_ratios(struct precision * ppr,
                                         struct distortions* psd){

  /** Define local variables */
  int index_z,index_type,index_k;
  double f_g, f_y, f_mu;
  double *f_E;
  double bb_vis;
  int last_index = 0;

  /** Allocate space for branching ratios in br_table */
  class_alloc(psd->br_table,
              psd->type_size*sizeof(double*),
              psd->error_message);
  for (index_type=0; index_type<psd->type_size; ++index_type){
    class_alloc(psd->br_table[index_type],
                psd->z_size*sizeof(double),
                psd->error_message);
  }

  /** Calulate branching ratios */
  if (psd->sd_branching_approx != bra_exact) {
    for (index_z=0; index_z<psd->z_size; ++index_z){
      bb_vis = exp(-pow(psd->z[index_z]/psd->z_th,2.5));

      /* 1) Calculate branching ratios using sharp_sharp transition */
      if (psd->sd_branching_approx == bra_sharp_sharp) {
        if (psd->z[index_z]>psd->z_th) {
          f_g = 1.;
          f_y = 0.;
          f_mu = 0.;
        }
        if (psd->z[index_z]<psd->z_th && psd->z[index_z]>psd->z_muy) {
          f_g = 0.;
          f_y = 0.;
          f_mu = 1.;
        }
        if (psd->z[index_z]<psd->z_muy) {
          f_g = 0.;
          f_y = 1.;
          f_mu = 0.;
        }
      }

      /* 2) Calculate branching ratios using sharp_soft transition */
      if (psd->sd_branching_approx == bra_sharp_soft) {
        f_g = 1.-bb_vis;
        if (psd->z[index_z]>psd->z_muy) {
          f_y = 0.;
          f_mu = bb_vis;
        }
        if (psd->z[index_z]<psd->z_muy) {
          f_y = 1.;
          f_mu = 0.;
        }
      }

      /* 3) Calculate branching ratios unsing soft_soft transitions */
      if (psd->sd_branching_approx == bra_soft_soft) {
        f_g = 1.-bb_vis;
        f_y = 1.0/(1.0+pow((1.0+psd->z[index_z])/(6.0e4),2.58));
        f_mu = bb_vis*(1.-exp(-pow((1.0+psd->z[index_z])/(5.8e4),1.88)));
      }

      /* 4) Calculate branching ratios unsing soft_soft_cons transitions */
      if (psd->sd_branching_approx == bra_soft_soft_cons) {
        f_g = 1.-bb_vis;
        f_y = 1.0/(1.0+pow((1.0+psd->z[index_z])/(6.0e4),2.58));
        f_mu = bb_vis*(1.-f_y);
      }

      psd->br_table[psd->index_type_g][index_z] = f_g;
      psd->br_table[psd->index_type_y][index_z] = f_y;
      psd->br_table[psd->index_type_mu][index_z] = f_mu;

    }
  }
  else {
    /* 5) Calculate branching ratios according to Chluba & Jeong 2014 */

    /* Read and spline data from file branching_ratios.dat */
    class_call(distortions_read_br_data(ppr,psd),
               psd->error_message,
               psd->error_message);
    class_call(distortions_spline_br_data(psd),
               psd->error_message,
               psd->error_message);

    /* Allocate local variable */
    class_alloc(f_E,
                psd->sd_PCA_size*sizeof(double),
                psd->error_message);

    /* Interpolate over z */
    for (index_z=0; index_z<psd->z_size; ++index_z){
      class_call(distortions_interpolate_br_data(psd,
                                                 psd->z[index_z],
                                                 &f_g,
                                                 &f_y,
                                                 &f_mu,
                                                 f_E,
                                                 &last_index),
                 psd->error_message,
                 psd->error_message);

      /* Store quantities in the table*/
      psd->br_table[psd->index_type_g][index_z] = f_g;
      psd->br_table[psd->index_type_y][index_z] = f_y;
      psd->br_table[psd->index_type_mu][index_z] = f_mu;
      for (index_k=0; index_k<psd->sd_PCA_size; ++index_k){
        psd->br_table[psd->index_type_PCA+index_k][index_z] = f_E[index_k];
      }

    }

    /* Free space allocated in distortions_read_br_data */
    class_call(distortions_free_br_data(psd),
               psd->error_message,
               psd->error_message);
    free(f_E);

  }

  return _SUCCESS_;
}

/**
 * Import heating rates from heating structure.
 *
 * @param ppr        Input: pointer to precision structure
 * @param pba        Input: pointer to background structure
 * @param pth        Input: pointer to the thermodynamics structure
 * @param ppt        Input: pointer to the perturbations structure
 * @param ppm        Input: pointer to the primordial structure
 * @param psd        Input: pointer to the distortions structure
 * @return the error status
 */

int distortions_compute_heating_rate(struct precision* ppr,
                                     struct background* pba,
                                     struct thermodynamics * pth,
                                     struct perturbations * ppt,
                                     struct primordial * ppm,
                                     struct distortions * psd){

  /** Define local variables */
  struct noninjection* pni = &(psd->ni);
  struct injection* pin = &(pth->in);

  int index_z;
  double tau;
  int last_index_back;
  double *pvecback;
  double heat;
  double H, a, rho_g;

  if (psd->include_only_exotic == _FALSE_) {
    /** Update heating table with second order contributions */
    class_call(noninjection_init(ppr,pba,pth,ppt,ppm,pni),
               pni->error_message,
               psd->error_message);
  }

  /** Allocate space for background vector */
  last_index_back = 0;
  class_alloc(pvecback,
              pba->bg_size*sizeof(double),
              psd->error_message);

  /** Allocate space for total heating function */
  class_alloc(psd->dQrho_dz_tot,
              psd->z_size*sizeof(double*),
              psd->error_message);

  /* Loop over z and calculate the heating at each point */
  for (index_z=0; index_z<psd->z_size; ++index_z){

    /** Import quantities from background structure */
    class_call(background_tau_of_z(pba,
                                   psd->z[index_z],
                                   &tau),
               pba->error_message,
               psd->error_message);
    class_call(background_at_tau(pba,
                                 tau,
                                 long_info,
                                 inter_closeby,
                                 &last_index_back,
                                 pvecback),
               pba->error_message,
               psd->error_message);
    H = pvecback[pba->index_bg_H]*_c_/_Mpc_over_m_;               // [1/s]
    a = pvecback[pba->index_bg_a];                                // [-]
    rho_g = pvecback[pba->index_bg_rho_g]*_Jm3_over_Mpc2_;        // [J/m^3]

    heat = 0;

    /** Import heat from non-injection structure */
    if (psd->include_only_exotic == _FALSE_) {
      class_call(noninjection_photon_heating_at_z(pni,
                                                  psd->z[index_z],
                                                  &heat),           // [J/(m^3 s)]
                 pni->error_message,
                 psd->error_message);
    }

    /** Add heat from injection structure */
    if (pth->has_exotic_injection == _TRUE_) {
      class_call(injection_deposition_at_z(pth,
                                           psd->z[index_z]),
                 pin->error_message,
                 psd->error_message);
      heat += pin->pvecdeposition[pin->index_dep_heat];
    }

    /** Calculate total heating rate */
    psd->dQrho_dz_tot[index_z] = heat*a/(H*rho_g);                // [-]
  }

  free(pvecback);

  if (psd->include_only_exotic == _FALSE_) {
    /** Update heating table with second order contributions */
    class_call(noninjection_free(pni),
               pni->error_message,
               psd->error_message);
  }

  return _SUCCESS_;
}

/**
 * Calculate spectral amplitudes and corresponding distortions.
 *
 * The calculation has been done according to Chluba & Jeong 2014 (arxiv:1306.5751).
 * All quantities are stored in the tables sd_parameter_table and sd_table.
 *
 * @param ppr        Input: pointer to precision structure
 * @param pba        Input: pointer to background structure
 * @param pth        Input: pointer to thermodynamics structure
 * @param psd        Input: pointer to the distortions structure
 * @return the error status
 */

int distortions_compute_spectral_shapes(struct precision * ppr,
                                        struct background * pba,
                                        struct thermodynamics * pth,
                                        struct distortions * psd){

  /** Define local variables */
  double * S;
  int last_index = 0;
  int index_type, index_x, index_k;
  double sum_S, sum_G;
  double g;
  double y_reio, DI_reio;

  /** Allocate space for spectral distortion amplitude in table sd_parameter_table */
  class_alloc(psd->sd_parameter_table,
              psd->type_size*sizeof(double),
              psd->error_message);

  /** Compute distortion amplitudes corresponding to each branching ratio (g, y and mu) */
  /* Define y, mu, g and mu_k from heating rates */
  for (index_type=0; index_type<psd->type_size; ++index_type){
    class_call(array_trapezoidal_convolution(psd->dQrho_dz_tot,
                                             psd->br_table[index_type],
                                             psd->z_size,
                                             psd->z_weights,
                                             &(psd->sd_parameter_table[index_type]),
                                             psd->error_message),
               psd->error_message,
               psd->error_message);

    if (index_type>=psd->index_type_PCA) {
      /* The S_k are not properly normalized, we have to renormalize here */
      psd->sd_parameter_table[index_type] /= (log(1.+psd->z[1])-log(1.+psd->z[0]));
    }
  }

  psd->sd_parameter_table[psd->index_type_g] /= 4.;
  psd->sd_parameter_table[psd->index_type_y] /= 4.;
  psd->sd_parameter_table[psd->index_type_mu] *= 1.401;

  psd->sd_parameter_table[psd->index_type_y] += psd->sd_add_y;
  psd->sd_parameter_table[psd->index_type_mu] += psd->sd_add_mu;

  /** Allocate space for distortions shapes in distortions_table */
  class_alloc(psd->sd_shape_table,
              psd->type_size*sizeof(double*),
              psd->error_message);
  for (index_type=0; index_type<psd->type_size; ++index_type){
    class_alloc(psd->sd_shape_table[index_type],
                psd->x_size*sizeof(double),
                psd->error_message);
  }

  /** Calculate spectral shapes */
  if (psd->sd_branching_approx != bra_exact || psd->sd_PCA_size == 0) {
    /* If no PCA analysis is required, the shapes have simple analistical form */
    for (index_x=0; index_x<psd->x_size; ++index_x){
      psd->sd_shape_table[psd->index_type_g][index_x] = pow(psd->x[index_x],4.)*exp(-psd->x[index_x])/
        pow(1.-exp(-psd->x[index_x]),2.);        // [-]
      psd->sd_shape_table[psd->index_type_y][index_x] = psd->sd_shape_table[psd->index_type_g][index_x]*
        (psd->x[index_x]*(1.+exp(-psd->x[index_x]))/
         (1.-exp(-psd->x[index_x]))-4.);          // [-]
      psd->sd_shape_table[psd->index_type_mu][index_x] = psd->sd_shape_table[psd->index_type_g][index_x]*
        (1./2.19229-1./psd->x[index_x]);         // [-]
    }
  }
  else {
    /* If PCA analysis is required, the shapes has to be vectorized. This is done in the external
       file spectral_shapes.dat using generate_PCA_files.py */

    /* Read and spline data from file spectral_shapes.dat */
    class_call(distortions_read_sd_data(ppr,psd),
               psd->error_message,
               psd->error_message);
    class_call(distortions_spline_sd_data(psd),
               psd->error_message,
               psd->error_message);

    /* Allocate local variable */
    class_alloc(S,
                psd->sd_PCA_size*sizeof(double),
                psd->error_message);

    /* Interpolate over z */
    for (index_x=0; index_x<psd->x_size; ++index_x){
      class_call(distortions_interpolate_sd_data(psd,
                                                 psd->x[index_x]*psd->x_to_nu,
                                                 &psd->sd_shape_table[psd->index_type_g][index_x],
                                                 &psd->sd_shape_table[psd->index_type_y][index_x],
                                                 &psd->sd_shape_table[psd->index_type_mu][index_x],
                                                 S,
                                                 &last_index),
                 psd->error_message,
                 psd->error_message);

      for (index_k=0; index_k<psd->sd_PCA_size; ++index_k){
        psd->sd_shape_table[psd->index_type_PCA+index_k][index_x] = S[index_k];
      }
    }

    /* Free allocated space */
    class_call(distortions_free_sd_data(psd),
               psd->error_message,
               psd->error_message);
    free(S);
  }

  /** Compute distortion amplitude for residual parameter epsilon */
  /* For the details of the calculation see Chluba & Jeong 2014, left column of page 6 */
  psd->epsilon = 0.;

  if (psd->sd_branching_approx == bra_exact && psd->sd_PCA_size != 0) {
    class_call(array_trapezoidal_integral(psd->sd_shape_table[psd->index_type_g],
                                          psd->x_size,
                                          psd->x_weights,
                                          &(sum_G),
                                          psd->error_message),
               psd->error_message,
               psd->error_message);
    for (index_k=0; index_k<psd->sd_PCA_size; ++index_k){
      class_call(array_trapezoidal_integral(psd->sd_shape_table[psd->index_type_PCA+index_k],
                                            psd->x_size,
                                            psd->x_weights,
                                            &(sum_S),
                                            psd->error_message),
                 psd->error_message,
                 psd->error_message);
      psd->epsilon += (4.*sum_S/sum_G)*psd->sd_parameter_table[psd->index_type_PCA+index_k];
    }
  }

  /** Allocate space for final spectral distortion */
  class_alloc(psd->DI,
              psd->x_size*sizeof(double),
              psd->error_message);

  class_alloc(psd->sd_table,
              psd->type_size*sizeof(double*),
              psd->error_message);
  for (index_type=0; index_type<psd->type_size; ++index_type){
    class_alloc(psd->sd_table[index_type],
                psd->x_size*sizeof(double),
                psd->error_message);
  }

  /** Calculate spectral distortions according to Chluba & Jeong 2014 (arxiv:1306.5751, Eq. (11)) */
  for (index_x=0;index_x<psd->x_size;++index_x){
    psd->DI[index_x] = 0.;

    for (index_type=0;index_type<psd->type_size;++index_type){
      if (index_type==psd->index_type_g) {
        if (psd->include_g_distortion == _TRUE_) {
          g = psd->sd_parameter_table[psd->index_type_g];
          psd->sd_table[index_type][index_x] = (1.+g)*g*psd->sd_shape_table[psd->index_type_g][index_x]+
            g*g*0.5*psd->sd_shape_table[psd->index_type_y][index_x];
        }
        else {
          g = 0.;
          psd->sd_table[index_type][index_x] = 0.;
        }
      }
      else {
        psd->sd_table[index_type][index_x] = psd->sd_parameter_table[index_type]*psd->sd_shape_table[index_type][index_x];
      }

      psd->DI[index_x] += psd->sd_table[index_type][index_x];
    }
  }

  /** Include additional sources of distortions */
  /* Superposition of blackbodies */
  //psd->sd_parameter_table[psd->index_type_y] += 2.525e-7;   // CMB Dipole (Chluba & Sunyaev 2004)
  //psd->sd_parameter_table[psd->index_type_y] += 4.59e-13;   // CMB Quadrupole (Chluba & Sunyaev 2004)

  /* Reionization */
  if (psd->has_SZ_effect == _TRUE_) {
    for (index_x=0;index_x<psd->x_size;++index_x){
      class_call(distortions_add_effects_reio(pba,pth,psd,
                                              5.e0,
                                              2.e-4,
                                              1./300.,
                                              1./300.,
                                              psd->x[index_x],
                                              &y_reio,
                                              &DI_reio),
                 psd->error_message,
                 psd->error_message);
      psd->DI[index_x] += DI_reio;
    }

    psd->sd_parameter_table[psd->index_type_y] += y_reio;
  }

  /** Compute total heating */
  psd->Drho_over_rho = psd->sd_parameter_table[psd->index_type_y]*4.+
    psd->sd_parameter_table[psd->index_type_mu]/1.401+
    psd->epsilon;

  if (psd->include_g_distortion == _TRUE_) {
    psd->Drho_over_rho += psd->sd_parameter_table[psd->index_type_g]*4.;
  }

  /** Print found parameters */
  if (psd->distortions_verbose > 1) {

    if (psd->distortions_verbose > 3 && psd->include_g_distortion == _TRUE_) {
      printf(" -> g-parameter %g (Note, that this does not include contributions from earlier than sd_z_max=%g)\n", psd->sd_parameter_table[psd->index_type_g], ppr->sd_z_max);
    }

    if (psd->sd_parameter_table[psd->index_type_mu] > 9.e-5) {
      printf(" -> mu-parameter = %g. WARNING: The value of your mu-parameter is larger than the FIRAS constraint mu<9e-5.\n", psd->sd_parameter_table[psd->index_type_mu]);
    }
    else {
      printf(" -> mu-parameter = %g\n", psd->sd_parameter_table[psd->index_type_mu]);
    }

    if (psd->sd_parameter_table[psd->index_type_y]>1.5e-5) {
      printf(" -> y-parameter = %g. WARNING: The value of your y-parameter is larger than the FIRAS constraint y<1.5e-5.\n", psd->sd_parameter_table[psd->index_type_y]);
    }
    else {
      printf(" -> y-parameter = %g\n", psd->sd_parameter_table[psd->index_type_y]);
    }

    if (psd->sd_branching_approx == bra_exact && psd->sd_PCA_size != 0) {
      if (psd->distortions_verbose > 2) {
        for (index_k=0; index_k<psd->sd_PCA_size; ++index_k){
          printf(" -> PCA multipole mu_%d = %g\n", index_k+1, psd->sd_parameter_table[psd->index_type_PCA+index_k]);
        }
      }
      printf(" -> epsilon-parameter = %g\n", psd->epsilon);
    }

    printf(" -> total injected/extracted heat = %g\n", psd->Drho_over_rho);
  }

  return _SUCCESS_;
}

/**
 * Compute relativistic contribution from reionization and structure formation according to
 *        1) Nozawa et al. 2005 (up to order 3 in theta_e) or
 *        2) Chluba et al. 2012 (up to order ? in ?). Note that, for the moment, this appoximation
 *           is only valid for cluster temperatures lower than few KeV.
 *
 * @param pba        Input: pointer to background structure
 * @param pth        Input: pointer to thermodynamics structure
 * @param psd        Input: pointer to the distortions structure
 * @param T_e        Input: electron temperature in keV
 * @param Dtau       Input: optical depth
 * @param beta       Input: peculiar velocity of the cluster
 * @param beta_z     Input: peculiar velocity of the cluster with respect to the line-of-sight
 * @param x          Input: dimensionless frequency
 * @param y_reio     Output: y-parameter
 * @param DI_reio    Output: spectral distortion
 * @return the error status
 */

int distortions_add_effects_reio(struct background * pba,
                                 struct thermodynamics * pth,
                                 struct distortions * psd,
                                 double T_e,
                                 double Dtau,
                                 double beta,
                                 double beta_z,
                                 double x,
                                 double * y_reio,
                                 double * DI_reio){

  /** Define local variables */
  double theta_e, cos_theta, P_1, P_2, x_tilde, S_tilde;
  double G_T, Y_SZ;
  double M_low, M_k, D_low, D_k, Q_low, Q_k;
  int index_k, index_n;
  double Y_0, Y_1, Y_2;
  double B_0, B_1, B_2, B_3;
  double C_0, C_1, C_2, C_3;
  double D_0, D_1, D_2, D_3;
  double DI_tSZ_non_rel, DI_tSZ_rel, DI_tSZ, DI_kSZ;

  /* Compute related quantities */
  theta_e = T_e*1.e3/(_m_e_/_GeV_over_kg_*1.e9);
  cos_theta = beta_z/beta;
  P_1 = cos_theta;
  P_2 = (3.*pow(cos_theta,2.)-1.)/2.;
  x_tilde = x/tanh(x/2.);  // coth=1/tanh
  S_tilde = x/sinh(x/2.);

  G_T = pow(x,4.)*exp(-x)/pow(1.-exp(-x),2.);
  Y_SZ = G_T*(x_tilde-4.);

  double Delta_x[8] = {-1.,
                       x_tilde,
                       -(pow(x_tilde,2.)
                         +pow(S_tilde,2.)/2.),
                       x_tilde*(pow(x_tilde,2.)
                                +pow(S_tilde,2.)*2.),
                       -(pow(x_tilde,4.)
                         +pow(x_tilde,2.)*pow(S_tilde,2.)*11./2.
                         +pow(S_tilde,4.)),
                       x_tilde*(pow(x_tilde,4.)
                                +pow(x_tilde,2.)*pow(S_tilde,2.)*13.
                                +pow(S_tilde,4.)*17./2.),
                       -(pow(x_tilde,6.)
                         +pow(x_tilde,4.)*pow(S_tilde,2.)*57./2.
                         +pow(x_tilde,2.)*pow(S_tilde,4.)*45.
                         +pow(S_tilde,6.)*17./4.),
                       x_tilde*(pow(x_tilde,6.)
                                +pow(x_tilde,4.)*pow(S_tilde,2.)*60.
                                +pow(x_tilde,2.)*pow(S_tilde,4.)*192.
                                +pow(S_tilde,6.)*62.)};

  /** Thermal SZ effect (TSZ) */
  /* Fill coefficient tables from appendix A1 of Chluba et al. 2012 */
  double a[6][3] = {{4., 10.,    15./2.},
                    {1., 47./2., 1023./8.},
                    {0., 42./5., 868./5.},
                    {0., 7./10., 329./5.},
                    {0., 0.,     44./5.},
                    {0., 0.,     11./30.}};

  double Y_k[3] = {0., 0., 0.};

  for (index_k=0; index_k<3; ++index_k){
    Y_k[index_k] = 0.;
    for (index_n=0; index_n<2*index_k+2; ++index_n){
      Y_k[index_k]+=a[index_n][index_k]*Delta_x[index_n];
    }
  }

  /** Non-relativistic TSZ */
  DI_tSZ_non_rel = Dtau*theta_e*G_T*Y_k[0];

  /** Relativistic TSZ */
  DI_tSZ_rel = 0.;
  for (index_k=1; index_k<3; ++index_k){
    DI_tSZ_rel += Dtau*pow(theta_e,index_k+1)*G_T*Y_k[index_k];
  }

  DI_tSZ = DI_tSZ_non_rel+DI_tSZ_rel;

  /** Kinematic SZ effect (kSZ) */
  /* Calculated according to Nozawa et al. 2005 */
  switch(psd->sd_reio_type){
  case sd_reio_Nozawa:
    Y_0 = Y_k[0];
    Y_1 = Y_k[1];
    Y_2 = Y_k[2];

    B_0 = 1.*Y_0/3.;
    B_1 = 5.*Y_0/6.
      +2.*Y_1/3.;
    B_2 = 5.*Y_0/8.
      +3.*Y_1/2.
      +Y_2;
    B_3 = -5.*Y_0/8.
      +5.*Y_1/4.
      +5.*Y_2/2.;

    C_0 = 1.;
    C_1 = 10.
      -47.*x_tilde/5.
      +7.*pow(x_tilde,2.)/5.
      +7.*pow(S_tilde,2.)/10.;
    C_2 = 25.
      -1117.*x_tilde/10.
      +847.*pow(x_tilde,2.)/10.
      -183.*pow(x_tilde,3.)/10.
      +11.*pow(x_tilde,4.)/10.
      +pow(S_tilde,2.)*(847./20.
                        -183.*x_tilde/5.
                        +121.*pow(x_tilde,2.)/20.)
      +11.*pow(S_tilde,4.)/10.;
    C_3 = 75./4.
      -21873.*x_tilde/40.
      +49161.*pow(x_tilde,2.)/40.
      -27519.*pow(x_tilde,3.)/35.
      +6684.*pow(x_tilde,4.)/35.
      -3917.*pow(x_tilde,5.)/210.
      +64.*pow(x_tilde,6.)/105.
      +pow(S_tilde,2.)*(49161./80.
                        -55038.*x_tilde/35.
                        +36762.*pow(x_tilde,2.)/35.
                        -50921.*pow(x_tilde,3.)/210.
                        +608.*pow(x_tilde,4.)/35.)
      +pow(S_tilde,4.)*(6684./35.
                        -66589.*x_tilde/420.
                        +192.*pow(x_tilde,2.)/7.)
      +272.*pow(S_tilde,6.)/105.;

    D_0 = -2./3.
      +11.*x_tilde/30.;
    D_1 = -4.
      +12.*x_tilde
      -6.*pow(x_tilde,2.)
      +19.*pow(x_tilde,3.)/30.
      +pow(S_tilde,2.)*(-3.
                        +19.*x_tilde/15.);
    D_2 = -10.
      +542.*x_tilde/5.
      -843.*pow(x_tilde,2.)/5.
      +10603.*pow(x_tilde,3.)/140.
      -409.*pow(x_tilde,4.)/35.
      +23.*pow(x_tilde,5.)/42.
      +pow(S_tilde,2.)*(-843./10.
                        +10603.*x_tilde/70.
                        -4499.*pow(x_tilde,2.)/70.
                        +299.*pow(x_tilde,3.)/42.)
      +pow(S_tilde,4.)*(-409./35.
                        +391.*x_tilde/84.);
    D_3 = -15./2.
      +4929.*x_tilde/40.
      -39777.*pow(x_tilde,2.)/20.
      +1199897.*pow(x_tilde,3.)/560.
      -4392.*pow(x_tilde,4.)/5.
      +16364.*pow(x_tilde,5.)/105.
      -3764.*pow(x_tilde,6.)/315.
      +101.*pow(x_tilde,7.)/315.
      +pow(S_tilde,2.)*(-39777./40.
                        +1199897.*x_tilde/280.
                        -24156.*pow(x_tilde,2.)/5.
                        +212732.*pow(x_tilde,3.)/105.
                        -35758.*pow(x_tilde,4.)/105.
                        +404.*pow(x_tilde,5.)/21.)
      +pow(S_tilde,4.)*(-4392./5.
                        +139094.*x_tilde/105.
                        -3764.*pow(x_tilde,2.)/7.
                        +6464.*pow(x_tilde,3.)/105.)
      +pow(S_tilde,6.)*(-15997./315.
                        +6262.*x_tilde/315.);

    M_low = G_T*(B_0+theta_e*B_1+pow(theta_e,2.)*B_2+pow(theta_e,3.)*B_3);
    D_low = G_T*(C_0+theta_e*C_1+pow(theta_e,2.)*C_2+pow(theta_e,3.)*C_3);
    Q_low = G_T*(D_0+theta_e*D_1+pow(theta_e,2.)*D_2+pow(theta_e,3.)*D_3);
    break;
    /* Calculated according to Chluba et al. 2012 */
  case sd_reio_Chluba:
    /* Low temperature approximation */
    if (T_e < 10.) {
      double d[7][3] = {{-2./5., -1./5.,   407./140.},
                        {-8./5., -24./5., -233./35.},
                        {-2./5., -66./5., -10433./140.},
                        { 0.,    -24./5., -3876./35.},
                        { 0.,    -2./5.,  -1513./35.},
                        { 0.,     0.,     -204./35.},
                        { 0.,     0.,     -17./70.}};

      double q[7][4] = {{-3./5.,   183./70., -429./40.},
                        { 2./5.,  -5./7.,     207./20.},
                        { 1./10.,  115./28.,  1647./80.},
                        { 0.,      12./7.,    44.},
                        { 0.,      1./7.,     19.},
                        { 0.,      0.,        92./35.},
                        { 0.,      0.,        23./210.}};

      M_low = 1./3.*(Y_SZ+G_T);
      for (index_k=0; index_k<3; ++index_k){
        M_k = 0.;
        for (index_n=0; index_n<2*index_k+2; ++index_n){
          M_k += (a[index_n][index_k]-d[index_n][index_k])
            *(index_n*(index_n+2)*Delta_x[index_n]+
              (2*index_n+3)*Delta_x[index_n+1]+
              Delta_x[index_n+2]
              );
        }
        M_k *= 1./3.;
        M_low += pow(theta_e,index_k+1)*M_k*G_T;
      }

      D_low = G_T;
      for (index_k=0; index_k<3; ++index_k){
        D_k = 0.;
        for (index_n=0; index_n<2*index_k+2; ++index_n){
          D_k += (d[index_n][index_k]-a[index_n][index_k])
            *(index_n*Delta_x[index_n]+
              Delta_x[index_n+1]
              );
        }
        D_low += pow(theta_e,index_k+1)*D_k*G_T;
      }

      Q_low = 11./30.*(x_tilde*G_T);
      for (index_k=0; index_k<3; ++index_k){
        Q_k = 0.;
        for (index_n=0; index_n<2*index_k+2; ++index_n){
          Q_k += (a[index_n][index_k]+q[index_n][index_k]-2.*d[index_n][index_k])
            *(index_n*(index_n-1)*Delta_x[index_n]+
              2*index_n*Delta_x[index_n+1]+
              Delta_x[index_n+2]
              );
        }
        Q_k *= 1./3.;
        Q_low += pow(theta_e,index_k+1)*Q_k*G_T;
      }
    }
    /* High temperature approximation (not implemented yet) */
    else {
      M_low = 0.;
      D_low = 0.;
      Q_low = 0.;
    }
    break;
  default:
    class_stop(psd->error_message,"Unrecognized sd_reio_type='%i'.",psd->sd_reio_type);
  }

  DI_kSZ = Dtau*beta*(beta*M_low+P_1*D_low+beta*P_2*Q_low);

  /** Total distortion */
  *y_reio = theta_e*Dtau;
  *DI_reio = DI_tSZ+DI_kSZ;

  return _SUCCESS_;
}

/**
 * Reads the external file branching_ratios calculated according to Chluba & Jeong 2014
 *
 * @param ppr        Input: pointer to precision structure
 * @param psd        Input: pointer to the distortions structure
 * @return the error status
 */

int distortions_read_br_data(struct precision * ppr,
                             struct distortions * psd){

  /** Define local variables */
  int index_k,index_z;
  FILE * infile;
  DetectorFileName br_file;
  char line[_LINE_LENGTH_MAX_];
  char * left;
  int headlines = 0;

  /** Open file */
  class_sprintf(br_file,"%s/%s_branching_ratios.dat", ppr->sd_external_path, psd->sd_detector_name);
  class_open(infile, br_file, "r", psd->error_message);

  /** Read header */
  psd->br_exact_Nz = 0;
  while (fgets(line,_LINE_LENGTH_MAX_-1,infile) != NULL) {
    headlines++;

    /* Eliminate blank spaces at beginning of line */
    left=line;
    while (left[0]==' ') {
      left++;
    }

    if (left[0] > 39) {
      /** Read number of lines, infer size of arrays and allocate them */
      class_test(sscanf(line,"%d %d", &psd->br_exact_Nz, &psd->E_vec_size) != 2,
                 psd->error_message,
                 "could not header (number of lines, number of multipoles) at line %i in file '%s' \n",headlines,br_file);

      class_alloc(psd->br_exact_z, psd->br_exact_Nz*sizeof(double), psd->error_message);
      class_alloc(psd->f_g_exact, psd->br_exact_Nz*sizeof(double), psd->error_message);
      class_alloc(psd->f_y_exact, psd->br_exact_Nz*sizeof(double), psd->error_message);
      class_alloc(psd->f_mu_exact, psd->br_exact_Nz*sizeof(double), psd->error_message);

      class_alloc(psd->E_vec, psd->br_exact_Nz*psd->E_vec_size*sizeof(double), psd->error_message);
      break;
    }
  }

  /** Read parameters */
  for (index_z=0; index_z<psd->br_exact_Nz; ++index_z){
    class_test(fscanf(infile, "%le",
                      &(psd->br_exact_z[index_z]))!=1,                                // [-]
               psd->error_message,
               "Could not read z at line %i in file '%s'",index_z+headlines,br_file);
    class_test(fscanf(infile, "%le",
                      &(psd->f_g_exact[index_z]))!=1,                                 // [-]
               psd->error_message,
               "Could not read f_g at line %i in file '%s'",index_z+headlines,br_file);
    class_test(fscanf(infile, "%le",
                      &(psd->f_y_exact[index_z]))!=1,                                 // [-]
               psd->error_message,
               "Could not read f_y at line %i in file '%s'",index_z+headlines,br_file);
    class_test(fscanf(infile,"%le",
                      &(psd->f_mu_exact[index_z]))!=1,                                // [-]
               psd->error_message,
               "Could not read f_mu at line %i in file '%s'",index_z+headlines,br_file);
    for (index_k=0; index_k<psd->E_vec_size; ++index_k){
      class_test(fscanf(infile,"%le",
                        &(psd->E_vec[index_k*psd->br_exact_Nz+index_z]))!=1,           // [-]
                 psd->error_message,
                 "Could not read E vector at line %i in file '%s'",index_z+headlines,br_file);
    }
  }

  fclose(infile);

  return _SUCCESS_;
}

/**
 * Spline the quantitites read in distortions_read_br_data
 *
 * @param psd        Input: pointer to the distortions structure
 * @return the error status
 */

int distortions_spline_br_data(struct distortions* psd){

  /** Allocate second derivatives */
  class_alloc(psd->ddf_g_exact,
              psd->br_exact_Nz*sizeof(double),
              psd->error_message);
  class_alloc(psd->ddf_y_exact,
              psd->br_exact_Nz*sizeof(double),
              psd->error_message);
  class_alloc(psd->ddf_mu_exact,
              psd->br_exact_Nz*sizeof(double),
              psd->error_message);
  class_alloc(psd->ddE_vec,
              psd->E_vec_size*psd->br_exact_Nz*sizeof(double),
              psd->error_message);

  /** Spline branching ratios */
  class_call(array_spline_table_columns(psd->br_exact_z,
                                        psd->br_exact_Nz,
                                        psd->f_g_exact,
                                        1,
                                        psd->ddf_g_exact,
                                        _SPLINE_EST_DERIV_,
                                        psd->error_message),
             psd->error_message,
             psd->error_message);
  class_call(array_spline_table_columns(psd->br_exact_z,
                                        psd->br_exact_Nz,
                                        psd->f_y_exact,
                                        1,
                                        psd->ddf_y_exact,
                                        _SPLINE_EST_DERIV_,
                                        psd->error_message),
             psd->error_message,
             psd->error_message);
  class_call(array_spline_table_columns(psd->br_exact_z,
                                        psd->br_exact_Nz,
                                        psd->f_mu_exact,
                                        1,
                                        psd->ddf_mu_exact,
                                        _SPLINE_EST_DERIV_,
                                        psd->error_message),
             psd->error_message,
             psd->error_message);
  class_call(array_spline_table_columns(psd->br_exact_z,
                                        psd->br_exact_Nz,
                                        psd->E_vec,
                                        psd->E_vec_size,
                                        psd->ddE_vec,
                                        _SPLINE_EST_DERIV_,
                                        psd->error_message),
             psd->error_message,
             psd->error_message);

  return _SUCCESS_;
}

/**
 * Interpolate the quantitites splined in distortions_spline_br_data
 *
 * @param psd        Input: pointer to the distortions structure
 * @param z          Input: redshift
 * @param f_g        Output: branching ratio for temperature shift
 * @param f_y        Output: branching ratio for y distortions
 * @param f_mu       Output: branching ratio for mu-distortions
 * @param f_E        Output: branching ratio for residuals (multipole expansion)
 * @param last_index Output: multipole of PCA expansion for f_E
 * @return the error status
 */

int distortions_interpolate_br_data(struct distortions* psd,
                                    double z,
                                    double * f_g,
                                    double * f_y,
                                    double * f_mu,
                                    double * f_E,
                                    int * last_index){

  /** Define local variables */
  int index = *last_index;
  int index_k;
  double h,a,b;

  /** Find z position */
  class_call(array_spline_hunt(psd->br_exact_z,
                               psd->br_exact_Nz,
                               z,
                               &index,
                               &h,&a,&b,
                               psd->error_message),
             psd->error_message,
             psd->error_message);

  /** Evaluate corresponding values for the branching ratios */
  *f_g = 4*array_spline_eval(psd->f_g_exact,
                             psd->ddf_g_exact,
                             index,
                             index+1,
                             h,a,b);
  *f_y = 4*array_spline_eval(psd->f_y_exact,
                             psd->ddf_y_exact,
                             index,
                             index+1,
                             h,a,b);
  *f_mu = 1./1.401*array_spline_eval(psd->f_mu_exact,
                                     psd->ddf_mu_exact,
                                     index,
                                     index+1,
                                     h,a,b);

  for (index_k=0; index_k<psd->sd_PCA_size; ++index_k){
    f_E[index_k] = array_spline_eval(psd->E_vec+index_k*psd->br_exact_Nz,
                                     psd->ddE_vec+index_k*psd->br_exact_Nz,
                                     index,
                                     index+1,
                                     h,a,b);
  }

  *last_index = index;

  return _SUCCESS_;
}

/**
 * Free from distortions_read_br_data and distortions_spline_br_data
 *
 * @param psd     Input: pointer to distortions structure (to be freed)
 * @return the error status
 */

int distortions_free_br_data(struct distortions * psd){

  free(psd->br_exact_z);
  free(psd->f_g_exact);
  free(psd->ddf_g_exact);
  free(psd->f_y_exact);
  free(psd->ddf_y_exact);
  free(psd->f_mu_exact);
  free(psd->ddf_mu_exact);
  free(psd->E_vec);
  free(psd->ddE_vec);

  return _SUCCESS_;
}

/**
 * Reads the external file distortions_shapes calculated according to Chluba & Jeong 2014
 *
 * @param ppr        Input: pointer to precision structure
 * @param psd        Input: pointer to the distortions structure
 * @return the error status
 */

int distortions_read_sd_data(struct precision * ppr,
                             struct distortions * psd){

  /** Define local variables */
  FILE * infile;
  DetectorFileName sd_file;
  char line[_LINE_LENGTH_MAX_];
  char * left;
  int headlines = 0;
  int index_x,index_k;

  /** Open file */
  class_sprintf(sd_file,"%s/%s_distortions_shapes.dat",ppr->sd_external_path, psd->sd_detector_name);
  class_open(infile, sd_file, "r", psd->error_message);

  /** Read header */
  psd->PCA_Nnu = 0;
  while (fgets(line,_LINE_LENGTH_MAX_-1,infile) != NULL) {
    headlines++;

    /* Eliminate blank spaces at beginning of line */
    left=line;
    while (left[0]==' ') {
      left++;
    }

    if (left[0] > 39) {
      /** Read number of lines, infer size of arrays and allocate them */
      class_test(sscanf(line, "%d %d", &psd->PCA_Nnu, &psd->S_vec_size) != 2,
                 psd->error_message,
                 "could not header (number of lines, number of multipoles) at line %i in file '%s' \n",headlines,sd_file);

      class_alloc(psd->PCA_nu, psd->PCA_Nnu*sizeof(double), psd->error_message);
      class_alloc(psd->PCA_G_T, psd->PCA_Nnu*sizeof(double), psd->error_message);
      class_alloc(psd->PCA_Y_SZ, psd->PCA_Nnu*sizeof(double), psd->error_message);
      class_alloc(psd->PCA_M_mu, psd->PCA_Nnu*sizeof(double), psd->error_message);

      class_alloc(psd->S_vec, psd->PCA_Nnu*psd->S_vec_size*sizeof(double), psd->error_message);
      break;
    }
  }

  /** Read parameters */
  for (index_x=0; index_x<psd->PCA_Nnu; ++index_x){
    class_test(fscanf(infile,"%le",
                      &(psd->PCA_nu[index_x]))!=1,                                                  // [GHz]
               psd->error_message,
               "Could not read z at line %i in file '%s'",index_x+headlines,sd_file);
    class_test(fscanf(infile,"%le",
                      &(psd->PCA_G_T[index_x]))!=1,                                                 // [10^-18 W/(m^2 Hz sr)]
               psd->error_message,
               "Could not read f_g at line %i in file '%s'",index_x+headlines,sd_file);
    psd->PCA_G_T[index_x] /= (psd->DI_units*1.e18);                                                 // [-]
    class_test(fscanf(infile,"%le",
                      &(psd->PCA_Y_SZ[index_x]))!=1,                                                // [10^-18 W/(m^2 Hz sr)]
               psd->error_message,
               "Could not read f_y at line %i in file '%s'",index_x+headlines,sd_file);
    psd->PCA_Y_SZ[index_x] /= (psd->DI_units*1.e18);                                                // [-]
    class_test(fscanf(infile,"%le",
                      &(psd->PCA_M_mu[index_x]))!=1,                                                // [10^-18 W/(m^2 Hz sr)]
               psd->error_message,
               "Could not read f_mu at line %i in file '%s'",index_x+headlines,sd_file);
    psd->PCA_M_mu[index_x] /= (psd->DI_units*1.e18);                                                // [-]
    for (index_k=0; index_k<psd->S_vec_size; ++index_k){
      class_test(fscanf(infile,"%le",
                        &(psd->S_vec[index_k*psd->PCA_Nnu+index_x]))!=1,                            // [10^-18 W/(m^2 Hz sr)]
                 psd->error_message,
                 "Could not read E vector at line %i in file '%s'",index_x+headlines,sd_file);
      psd->S_vec[index_k*psd->PCA_Nnu+index_x] /= (psd->DI_units*1.e18);                            // [-]
    }

  }

  fclose(infile);

  return _SUCCESS_;
}

/**
 * Spline the quantitites read in distortions_read_sd_data
 *
 * @param psd        Input: pointer to the distortions structure
 * @return the error status
 */

int distortions_spline_sd_data(struct distortions* psd){

  /** Allocate second derivatievs */
  class_alloc(psd->ddPCA_G_T,
              psd->PCA_Nnu*sizeof(double),
              psd->error_message);
  class_alloc(psd->ddPCA_Y_SZ,
              psd->PCA_Nnu*sizeof(double),
              psd->error_message);
  class_alloc(psd->ddPCA_M_mu,
              psd->PCA_Nnu*sizeof(double),
              psd->error_message);
  class_alloc(psd->ddS_vec,
              psd->S_vec_size*psd->PCA_Nnu*sizeof(double),
              psd->error_message);

  /** Spline branching ratios */
  class_call(array_spline_table_columns(psd->PCA_nu,
                                        psd->PCA_Nnu,
                                        psd->PCA_G_T,
                                        1,
                                        psd->ddPCA_G_T,
                                        _SPLINE_EST_DERIV_,
                                        psd->error_message),
             psd->error_message,
             psd->error_message);
  class_call(array_spline_table_columns(psd->PCA_nu,
                                        psd->PCA_Nnu,
                                        psd->PCA_Y_SZ,
                                        1,
                                        psd->ddPCA_Y_SZ,
                                        _SPLINE_EST_DERIV_,
                                        psd->error_message),
             psd->error_message,
             psd->error_message);
  class_call(array_spline_table_columns(psd->PCA_nu,
                                        psd->PCA_Nnu,
                                        psd->PCA_M_mu,
                                        1,
                                        psd->ddPCA_M_mu,
                                        _SPLINE_EST_DERIV_,
                                        psd->error_message),
             psd->error_message,
             psd->error_message);
  class_call(array_spline_table_columns(psd->PCA_nu,
                                        psd->PCA_Nnu,
                                        psd->S_vec,
                                        psd->S_vec_size,
                                        psd->ddS_vec,
                                        _SPLINE_EST_DERIV_,
                                        psd->error_message),
             psd->error_message,
             psd->error_message);

  return _SUCCESS_;
}

/**
 * Interpolate the quantitites splined in distortions_spline_sd_data
 *
 * @param psd        Input: pointer to the distortions structure
 * @param nu         Input: dimnetionless frequency
 * @param G_T        Output: shape of temperature shift
 * @param Y_SZ       Output: shape of y distortions
 * @param M_mu       Output: shape of mu-distortions
 * @param S          Output: shape of residuals (multipole expansion)
 * @param index      Output: multipole of PCA expansion for S
 * @return the error status
 */

int distortions_interpolate_sd_data(struct distortions* psd,
                                    double nu,
                                    double * G_T,
                                    double * Y_SZ,
                                    double * M_mu,
                                    double * S,
                                    int * index){

  /** Define local variables */
  int last_index = *index;
  int index_k;
  double h,a,b;
  double nu_round;

  /** Find z position */
  nu_round = round(nu*pow(10.,3))/pow(10.,3); // The rounding is necessary for the interpolation with the external file
  class_call(array_spline_hunt(psd->PCA_nu,
                               psd->PCA_Nnu,
                               nu_round,
                               &last_index,
                               &h,&a,&b,
                               psd->error_message),
             psd->error_message,
             psd->error_message);

  /** Evaluate corresponding values for the branching ratios */
  *G_T = array_spline_eval(psd->PCA_G_T,
                           psd->ddPCA_G_T,
                           last_index,
                           last_index+1,
                           h,a,b);
  *Y_SZ = array_spline_eval(psd->PCA_Y_SZ,
                            psd->ddPCA_Y_SZ,
                            last_index,
                            last_index+1,
                            h,a,b);
  *M_mu = array_spline_eval(psd->PCA_M_mu,
                            psd->ddPCA_M_mu,
                            last_index,
                            last_index+1,
                            h,a,b);

  for (index_k=0; index_k<psd->sd_PCA_size; ++index_k){
    S[index_k] = array_spline_eval(psd->S_vec+index_k*psd->PCA_Nnu,
                                   psd->ddS_vec+index_k*psd->PCA_Nnu,
                                   last_index,
                                   last_index+1,
                                   h,a,b);
  }

  *index = last_index;

  return _SUCCESS_;
}

/**
 * Free from distortions_read_sd_data and distortions_spline_sd_data
 *
 * @param psd     Input: pointer to distortions structure (in which some fields should be freed)
 * @return the error status
 */

int distortions_free_sd_data(struct distortions * psd){

  free(psd->PCA_nu);
  free(psd->PCA_G_T);
  free(psd->ddPCA_G_T);
  free(psd->PCA_Y_SZ);
  free(psd->ddPCA_Y_SZ);
  free(psd->PCA_M_mu);
  free(psd->ddPCA_M_mu);
  free(psd->S_vec);
  free(psd->ddS_vec);

  return _SUCCESS_;
}

/**
 * Define title of columns in the heat output
 *
 * @param psd     Input: pointer to distortions structure
 * @param titles  Output: title of each column in the output
 */

int distortions_output_heat_titles(struct distortions * psd,
                                   char titles[_MAXTITLESTRINGLENGTH_]){

  class_store_columntitle(titles,"Redshift z",_TRUE_);
  class_store_columntitle(titles,"Heat  [-]",_TRUE_);
  class_store_columntitle(titles,"LHeat [-]",_TRUE_);

  return _SUCCESS_;
}

/**
 * Store data in the heat output
 *
 * @param psd              Input/Output: pointer to distortions structure
 * @param number_of_titles Input: numbert of column in the output
 * @param data             Input: data to be stored
 */

int distortions_output_heat_data(struct distortions * psd,
                                 int number_of_titles,
                                 double * data){
  int storeidx;
  double * dataptr;
  int index_z;

  for (index_z=0; index_z<psd->z_size; index_z++) {
    dataptr = data + index_z*number_of_titles;
    storeidx = 0;
    class_store_double(dataptr, psd->z[index_z], _TRUE_, storeidx);
    class_store_double(dataptr, psd->dQrho_dz_tot[index_z], _TRUE_, storeidx);
    class_store_double(dataptr, psd->dQrho_dz_tot[index_z]*(1.+psd->z[index_z]), _TRUE_, storeidx);
  }

  return _SUCCESS_;
}

/**
 * Define title of columns in the spectral distortion output
 *
 * @param psd     Input: pointer to distortions structure
 * @param titles  Output: title of each column in the output
 */

int distortions_output_sd_titles(struct distortions * psd,
                                 char titles[_MAXTITLESTRINGLENGTH_]){

  char temp_title[256];
  int index_type;
  class_store_columntitle(titles,"Dimensionless frequency x",_TRUE_);
  class_store_columntitle(titles,"Frequency nu [GHz]",_TRUE_);
  class_store_columntitle(titles,"SD_tot",_TRUE_);
  for (index_type=0;index_type<psd->type_size;++index_type){
    if (index_type==psd->index_type_g) {
      class_sprintf(temp_title,"SD[g]");
    }
    if (index_type==psd->index_type_y) {
      class_sprintf(temp_title,"SD[y]");
    }
    if (index_type==psd->index_type_mu) {
      class_sprintf(temp_title,"SD[mu]");
    }
    if (index_type>=psd->index_type_PCA) {
      class_sprintf(temp_title,"SD[e_%i]",(index_type-psd->index_type_PCA));
    }
    class_store_columntitle(titles,temp_title,_TRUE_);
  }

  return _SUCCESS_;
}

/**
 * Store data in the distortion output
 *
 * @param psd              Input/Output: pointer to distortions structure
 * @param number_of_titles Input: numbert of column in the output
 * @param data             Input: data to be stored
 */

int distortions_output_sd_data(struct distortions * psd,
                               int number_of_titles,
                               double * data){
  int index_type;
  int storeidx;
  double * dataptr;
  int index_x;

  for (index_x=0; index_x<psd->x_size; index_x++) {
    dataptr = data + index_x*number_of_titles;
    storeidx = 0;

    class_store_double(dataptr, psd->x[index_x], _TRUE_,storeidx);
    class_store_double(dataptr, psd->x[index_x]*psd->x_to_nu, _TRUE_,storeidx);
    class_store_double(dataptr, psd->DI[index_x]*1.e26*psd->DI_units, _TRUE_,storeidx);
    for (index_type=0;index_type<psd->type_size;++index_type){
      class_store_double(dataptr, psd->sd_table[index_type][index_x]*1.e26*psd->DI_units, _TRUE_,storeidx);
    }
  }

  return _SUCCESS_;
}

```

`source/fourier.c`:

```c
/** @file fourier.c Documented fourier module
 *
 * Julien Lesgourgues, 6.03.2014
 *
 * New module replacing an older one present up to version 2.0 The new
 * module is located in a better place in the main, allowing it to
 * compute non-linear correction to \f$ C_l\f$'s and not just \f$ P(k)\f$. It will
 * also be easier to generalize to new methods.  The old implementation
 * of one-loop calculations and TRG calculations has been dropped from
 * this version, they can still be found in older versions.
 *
 */

#include "fourier.h"

/**
 * Return the P(k,z) for a given redshift z and pk type (_m, _cb)
 * (linear if pk_output = pk_linear, nonlinear if pk_output = pk_nonlinear)
 *
 * In the linear case, if there are several initial conditions *and* the
 * input pointer out_pk_ic is not set to NULL, the function also
 * returns the decomposition into different IC contributions.
 *
 * Hints on input index_pk:
 *
 * a. if you want the total matter spectrum P_m(k,z), pass in input
 *    pfo->index_pk_total
 *    (this index is always defined)
 *
 * b. if you want the power spectrum relevant for galaxy or halos,
 *    given by P_cb if there is non-cold-dark-matter (e.g. massive neutrinos)
 *    and to P_m otherwise, pass in input
 *    pfo->index_pk_cluster
 *    (this index is always defined)
 *
 * c. there is another possible syntax (use it only if you know what you are doing):
 *    if pfo->has_pk_m == _TRUE_ you may pass pfo->index_pk_m to get P_m
 *    if pfo->has_pk_cb == _TRUE_ you may pass pfo->index_pk_cb to get P_cb
 *
 * Output format:
 *
 * 1. if mode = logarithmic (most straightforward for the code):
 *     out_pk = ln(P(k))
 *     out_pk_ic[diagonal] = ln(P_ic(k))
 *     out_pk_ic[non-diagonal] = cos(correlation angle icxic)
 *
 * 2. if mode = linear (a conversion is done internally in this function)
 *     out_pk = P(k)
 *     out_pk_ic[diagonal] = P_ic(k)
 *     out_pk_ic[non-diagonal] = P_icxic(k)
 *
 * @param pba         Input: pointer to background structure
 * @param pfo         Input: pointer to fourier structure
 * @param mode        Input: linear or logarithmic
 * @param pk_output   Input: linear or nonlinear
 * @param z           Input: redshift
 * @param index_pk    Input: index of pk type (_m, _cb)
 * @param out_pk      Output: P(k) returned as out_pk_l[index_k]
 * @param out_pk_ic   Output:  P_ic(k) returned as  out_pk_ic[index_k * pfo->ic_ic_size + index_ic1_ic2]
 * @return the error status
 */

int fourier_pk_at_z(
                    struct background * pba,
                    struct fourier *pfo,
                    enum linear_or_logarithmic mode,
                    enum pk_outputs pk_output,
                    double z,
                    int index_pk,
                    double * out_pk, // array out_pk[index_k]
                    double * out_pk_ic // array out_pk_ic[index_k * pfo->ic_ic_size + index_ic1_ic2]
                    ) {
  double tau;
  double ln_tau;
  int index_k;
  int index_ic1;
  int index_ic2;
  int index_ic1_ic1;
  int index_ic2_ic2;
  int index_ic1_ic2;
  int last_index;
  short do_ic = _FALSE_;

  /** - check whether we need the decomposition into contributions from each initial condition */

  if ((pk_output == pk_linear) && (pfo->ic_size > 1) && (out_pk_ic != NULL))
    do_ic = _TRUE_;

  class_test(pk_output == pk_nonlinear && pfo->method == nl_none, pfo->error_message, "Cannot get nonlinear power spectrum when no nonlinear method is employed");

  /** - case z=0 requiring no interpolation in z */
  if (z == 0) {

    for (index_k=0; index_k<pfo->k_size; index_k++) {

      if (pk_output == pk_linear) {
        out_pk[index_k] = pfo->ln_pk_l[index_pk][(pfo->ln_tau_size-1)*pfo->k_size+index_k];

        if (do_ic == _TRUE_) {
          for (index_ic1_ic2 = 0; index_ic1_ic2 < pfo->ic_ic_size; index_ic1_ic2++) {
            out_pk_ic[index_k * pfo->ic_ic_size + index_ic1_ic2] =
              pfo->ln_pk_ic_l[index_pk][((pfo->ln_tau_size-1)*pfo->k_size+index_k)*pfo->ic_ic_size+index_ic1_ic2];
          }
        }
      }
      else {
        out_pk[index_k] = pfo->ln_pk_nl[index_pk][(pfo->ln_tau_size-1)*pfo->k_size+index_k];
      }
    }
  }

  /** - interpolation in z */
  else {

    class_test(pfo->ln_tau_size == 1,
               pfo->error_message,
               "You are asking for the matter power spectrum at z=%e but the code was asked to store it only at z=0. You probably forgot to pass the input parameter z_max_pk (see explanatory.ini)",z);

    /** --> get value of contormal time tau */
    class_call(background_tau_of_z(pba,
                                   z,
                                   &tau),
               pba->error_message,
               pfo->error_message);

    ln_tau = log(tau);
    last_index = pfo->ln_tau_size-1;

    /** -> check that tau is in pre-computed table */

    if (ln_tau <= pfo->ln_tau[0]) {

      /** --> if ln(tau) much too small, raise an error */
      class_test(ln_tau<pfo->ln_tau[0]-100.*_EPSILON_,
                 pfo->error_message,
                 "requested z was not inside of tau tabulation range (Requested ln(tau_=%.10e, Min %.10e). Solution might be to increase input parameter z_max_pk (see explanatory.ini)",ln_tau,pfo->ln_tau[0]);

      /** --> if ln(tau) too small but within tolerance, round it and get right values without interpolating */
      ln_tau = pfo->ln_tau[0];

      for (index_k = 0 ; index_k < pfo->k_size; index_k++) {
        if (pk_output == pk_linear) {
          out_pk[index_k] = pfo->ln_pk_l[index_pk][index_k];
          if (do_ic == _TRUE_) {
            for (index_ic1_ic2 = 0; index_ic1_ic2 < pfo->ic_ic_size; index_ic1_ic2++) {
              out_pk_ic[index_k * pfo->ic_ic_size + index_ic1_ic2] = pfo->ln_pk_ic_l[index_pk][index_k * pfo->ic_ic_size + index_ic1_ic2];
            }
          }
        }
        else {
          out_pk[index_k] = pfo->ln_pk_nl[index_pk][index_k];
        }
      }
    }

    else if (ln_tau >= pfo->ln_tau[pfo->ln_tau_size-1]) {

      /** --> if ln(tau) much too large, raise an error */
      class_test(ln_tau>pfo->ln_tau[pfo->ln_tau_size-1]+_EPSILON_,
                 pfo->error_message,
                 "requested z was not inside of tau tabulation range (Requested ln(tau_=%.10e, Max %.10e) ",ln_tau,pfo->ln_tau[pfo->ln_tau_size-1]);

      /** --> if ln(tau) too large but within tolerance, round it and get right values without interpolating */
      ln_tau = pfo->ln_tau[pfo->ln_tau_size-1];

      for (index_k = 0 ; index_k < pfo->k_size; index_k++) {
        if (pk_output == pk_linear) {
          out_pk[index_k] = pfo->ln_pk_l[index_pk][(pfo->ln_tau_size-1) * pfo->k_size + index_k];
          if (do_ic == _TRUE_) {
            for (index_ic1_ic2 = 0; index_ic1_ic2 < pfo->ic_ic_size; index_ic1_ic2++) {
              out_pk_ic[index_k * pfo->ic_ic_size + index_ic1_ic2] = pfo->ln_pk_ic_l[index_pk][((pfo->ln_tau_size-1) * pfo->k_size + index_k) * pfo->ic_ic_size + index_ic1_ic2];
            }
          }
        }
        else {
          out_pk[index_k] = pfo->ln_pk_nl[index_pk][(pfo->ln_tau_size-1) * pfo->k_size + index_k];
        }
      }
    }

    /** -> tau is in pre-computed table: interpolate */
    else {

      if (pk_output == pk_linear) {

        /** --> interpolate P_l(k) at tau from pre-computed array */
        class_call(array_interpolate_spline(pfo->ln_tau,
                                            pfo->ln_tau_size,
                                            pfo->ln_pk_l[index_pk],
                                            pfo->ddln_pk_l[index_pk],
                                            pfo->k_size,
                                            ln_tau,
                                            &last_index,
                                            out_pk,
                                            pfo->k_size,
                                            pfo->error_message),
                   pfo->error_message,
                   pfo->error_message);

        /** --> interpolate P_ic_l(k) at tau from pre-computed array */
        if (do_ic == _TRUE_) {
          class_call(array_interpolate_spline(pfo->ln_tau,
                                              pfo->ln_tau_size,
                                              pfo->ln_pk_ic_l[index_pk],
                                              pfo->ddln_pk_ic_l[index_pk],
                                              pfo->k_size*pfo->ic_ic_size,
                                              ln_tau,
                                              &last_index,
                                              out_pk_ic,
                                              pfo->k_size*pfo->ic_ic_size,
                                              pfo->error_message),
                     pfo->error_message,
                     pfo->error_message);
        }
      }
      else {

        /** --> interpolate P_nl(k) at tau from pre-computed array */
        class_call(array_interpolate_spline(pfo->ln_tau,
                                            pfo->ln_tau_size,
                                            pfo->ln_pk_nl[index_pk],
                                            pfo->ddln_pk_nl[index_pk],
                                            pfo->k_size,
                                            ln_tau,
                                            &last_index,
                                            out_pk,
                                            pfo->k_size,
                                            pfo->error_message),
                   pfo->error_message,
                   pfo->error_message);
      }
    }
  }

  /** - so far, all output stored in logarithmic format. Eventually, convert to linear one. */

  if (mode == linear) {

    /** --> loop over k */
    for (index_k=0; index_k<pfo->k_size; index_k++) {

      /** --> convert total spectrum */
      out_pk[index_k] = exp(out_pk[index_k]);

      if (do_ic == _TRUE_) {
        /** --> convert contribution of each ic (diagonal elements) */
        for (index_ic1=0; index_ic1 < pfo->ic_size; index_ic1++) {
          index_ic1_ic1 = index_symmetric_matrix(index_ic1,index_ic1,pfo->ic_size);

          out_pk_ic[index_k * pfo->ic_ic_size + index_ic1_ic1] = exp(out_pk_ic[index_k * pfo->ic_ic_size + index_ic1_ic1]);
        }

        /** --> convert contribution of each ic (non-diagonal elements) */
        for (index_ic1=0; index_ic1 < pfo->ic_size; index_ic1++) {
          for (index_ic2=index_ic1+1; index_ic2 < pfo->ic_size; index_ic2++) {
            index_ic1_ic1 = index_symmetric_matrix(index_ic1,index_ic1,pfo->ic_size);
            index_ic2_ic2 = index_symmetric_matrix(index_ic2,index_ic2,pfo->ic_size);
            index_ic1_ic2 = index_symmetric_matrix(index_ic1,index_ic2,pfo->ic_size);

            /* P_ic1xic2 = cos(angle) * sqrt(P_ic1 * P_ic2) */
            out_pk_ic[index_k * pfo->ic_ic_size + index_ic1_ic2]
              = out_pk_ic[index_k * pfo->ic_ic_size + index_ic1_ic2]
              *sqrt(out_pk_ic[index_k * pfo->ic_ic_size + index_ic1_ic1]
                    *out_pk_ic[index_k * pfo->ic_ic_size + index_ic2_ic2]);
          }
        }
      }
    }
  }

  return _SUCCESS_;
}

/*
 * Same as fourier_pk_at_z() (see the comments there about
 * the input/output format), excepted that we don't pass in input one
 * type of P(k) through index_pk. Instead, we get all existing types
 * in output. This function is maintained to enhance compatibility
 * with old versions, but the use of fourier_pk_at_z() should
 * be preferred.
 *
 * @param pba            Input: pointer to background structure
 * @param pfo            Input: pointer to fourier structure
 * @param mode           Input: linear or logarithmic
 * @param z              Input: redshift
 * @param out_pk_l       Output: P_m(k) returned as out_pk_l[index_k]
 * @param out_pk_ic_l    Output:  P_m_ic(k) returned as  out_pk_ic_l[index_k * pfo->ic_ic_size + index_ic1_ic2]
 * @param out_pk_cb_l    Output: P_cb(k) returned as out_pk_cb_l[index_k]
 * @param out_pk_cb_ic_l Output:  P_cb_ic(k) returned as  out_pk_cb_ic_l[index_k * pfo->ic_ic_size + index_ic1_ic2]
 * @return the error status
 */

int fourier_pks_at_z(
                     struct background * pba,
                     struct fourier * pfo,
                     enum linear_or_logarithmic mode,
                     enum pk_outputs pk_output,
                     double z,
                     double * out_pk,      // array out_pk[index_k]
                     double * out_pk_ic,   // array out_pk_ic[index_k * pfo->ic_ic_size + index_ic1_ic2]
                     double * out_pk_cb,   // array out_pk_cb[index_k]
                     double * out_pk_cb_ic // array out_pk_cb_ic[index_k * pfo->ic_ic_size + index_ic1_ic2]
                     ) {

  if (pfo->has_pk_cb == _TRUE_) {

    class_call(fourier_pk_at_z(pba,
                               pfo,
                               mode,
                               pk_output,
                               z,
                               pfo->index_pk_cb,
                               out_pk_cb,
                               out_pk_cb_ic
                               ),
               pfo->error_message,
               pfo->error_message);
  }

  if (pfo->has_pk_m == _TRUE_) {

    class_call(fourier_pk_at_z(pba,
                               pfo,
                               mode,
                               pk_output,
                               z,
                               pfo->index_pk_m,
                               out_pk,
                               out_pk_ic
                               ),
               pfo->error_message,
               pfo->error_message);
  }

  return _SUCCESS_;
}

/**
 * Return the P(k,z) for a given (k,z) and pk type (_m, _cb)
 * (linear if pk_output = pk_linear, nonlinear if pk_output = pk_nonlinear)
 *
 * In the linear case, if there are several initial conditions *and* the
 * input pointer out_pk_ic is not set to NULL, the function also
 * returns the decomposition into different IC contributions.
 *
 * Hints on input index_pk:
 *
 * a. if you want the total matter spectrum P_m(k,z), pass in input
 *    pfo->index_pk_total
 *    (this index is always defined)
 *
 * b. if you want the power spectrum relevant for galaxy or halos,
 *    given by P_cb if there is non-cold-dark-matter (e.g. massive neutrinos)
 *    and to P_m otherwise, pass in input
 *    pfo->index_pk_cluster
 *    (this index is always defined)
 *
 * c. there is another possible syntax (use it only if you know what you are doing):
 *    if pfo->has_pk_m == _TRUE_ you may pass pfo->index_pk_m to get P_m
 *    if pfo->has_pk_cb == _TRUE_ you may pass pfo->index_pk_cb to get P_cb
 *
 * Output format:
 *
 *     out_pk = P(k)
 *     out_pk_ic[diagonal] = P_ic(k)
 *     out_pk_ic[non-diagonal] = P_icxic(k)
 *
 * @param pba         Input: pointer to background structure
 * @param ppm         Input: pointer to primordial structure
 * @param pfo         Input: pointer to fourier structure
 * @param pk_output   Input: linear or nonlinear
 * @param k           Input: wavenumber in 1/Mpc
 * @param z           Input: redshift
 * @param index_pk    Input: index of pk type (_m, _cb)
 * @param out_pk      Output: pointer to P
 * @param out_pk_ic   Ouput:  P_ic returned as out_pk_ic_l[index_ic1_ic2]
 * @return the error status
 */

int fourier_pk_at_k_and_z(
                          struct background * pba,
                          struct primordial * ppm,
                          struct fourier *pfo,
                          enum pk_outputs pk_output,
                          double k,
                          double z,
                          int index_pk,
                          double * out_pk, // number *out_pk_l
                          double * out_pk_ic // array out_pk_ic_l[index_ic_ic]
                          ) {

  double * out_pk_at_z;
  double * out_pk_ic_at_z = NULL;
  double * ddout_pk_at_z;
  double * ddout_pk_ic_at_z;
  int last_index;
  int index_ic1;
  int index_ic2;
  int index_ic1_ic1;
  int index_ic2_ic2;
  int index_ic1_ic2;
  double kmin;
  double * pk_primordial_k;
  double * pk_primordial_kmin;
  short do_ic = _FALSE_;

  /** - preliminary: check whether we need the decomposition into contributions from each initial condition */

  if ((pk_output == pk_linear) && (pfo->ic_size > 1) && (out_pk_ic != NULL))
    do_ic = _TRUE_;

  /** - first step: check that k is in valid range [0:kmax]
      (the test for z will be done when calling fourier_pk_linear_at_z()) */

  class_test((k < 0.) || (k > exp(pfo->ln_k[pfo->k_size-1])),
             pfo->error_message,
             "k=%e out of bounds [%e:%e]",k,0.,exp(pfo->ln_k[pfo->k_size-1]));

  /** - deal with case k = 0 for which P(k) is set to zero
      (this non-physical result can be useful for interpolations) */

  if (k == 0.) {
    *out_pk = 0.;

    if (do_ic == _TRUE_) {
      for (index_ic1_ic2=0; index_ic1_ic2<pfo->ic_ic_size; index_ic1_ic2++) {
        out_pk_ic[index_ic1_ic2] = 0.;
      }
    }
  }

  /** - deal with 0 < k <= kmax */

  else {

    class_alloc(out_pk_at_z,
                pfo->k_size*sizeof(double),
                pfo->error_message);

    if (do_ic == _TRUE_) {
      class_alloc(out_pk_ic_at_z,
                  pfo->k_size*pfo->ic_ic_size*sizeof(double),
                  pfo->error_message);
    }

    /** - deal with standard case kmin <= k <= kmax */

    if (k > exp(pfo->ln_k[0])) {

      /** --> First, get P(k) at the right z (in logarithmic format for more accurate interpolation, and then convert to linear format) */

      class_call(fourier_pk_at_z(pba,
                                 pfo,
                                 logarithmic,
                                 pk_output,
                                 z,
                                 index_pk,
                                 out_pk_at_z,
                                 out_pk_ic_at_z
                                 ),
                 pfo->error_message,
                 pfo->error_message);

      /** --> interpolate total spectrum */

      class_alloc(ddout_pk_at_z,
                  pfo->k_size*sizeof(double),
                  pfo->error_message);

      class_call(array_spline_table_lines(pfo->ln_k,
                                          pfo->k_size,
                                          out_pk_at_z,
                                          1,
                                          ddout_pk_at_z,
                                          _SPLINE_NATURAL_,
                                          pfo->error_message),
                 pfo->error_message,
                 pfo->error_message);

      class_call(array_interpolate_spline(pfo->ln_k,
                                          pfo->k_size,
                                          out_pk_at_z,
                                          ddout_pk_at_z,
                                          1,
                                          log(k),
                                          &last_index,
                                          out_pk,
                                          1,
                                          pfo->error_message),
                 pfo->error_message,
                 pfo->error_message);

      free(ddout_pk_at_z);

      // uncomment this part if you prefer a linear interpolation

      /*
        class_call(array_interpolate_linear(pfo->ln_k,
        pfo->k_size,
        out_pk_at_z,
        1,
        log(k),
        &last_index,
        out_pk,
        1,
        pfo->error_message),
        pfo->error_message,
        pfo->error_message);
      */

      /** --> convert from logarithmic to linear format */

      *out_pk = exp(*out_pk);

      /** --> interpolate each ic component */

      if (do_ic == _TRUE_) {

        class_alloc(ddout_pk_ic_at_z,
                    pfo->k_size*pfo->ic_ic_size*sizeof(double),
                    pfo->error_message);

        class_call(array_spline_table_lines(pfo->ln_k,
                                            pfo->k_size,
                                            out_pk_ic_at_z,
                                            pfo->ic_ic_size,
                                            ddout_pk_ic_at_z,
                                            _SPLINE_NATURAL_,
                                            pfo->error_message),
                   pfo->error_message,
                   pfo->error_message);

        class_call(array_interpolate_spline(pfo->ln_k,
                                            pfo->k_size,
                                            out_pk_ic_at_z,
                                            ddout_pk_ic_at_z,
                                            pfo->ic_ic_size,
                                            log(k),
                                            &last_index,
                                            out_pk_ic,
                                            pfo->ic_ic_size,
                                            pfo->error_message),
                   pfo->error_message,
                   pfo->error_message);

        free(ddout_pk_ic_at_z);

        /** --> convert each ic component from logarithmic to linear format */

        for (index_ic1=0; index_ic1 < pfo->ic_size; index_ic1++) {
          index_ic1_ic1 = index_symmetric_matrix(index_ic1,index_ic1,pfo->ic_size);
          out_pk_ic[index_ic1_ic1] = exp(out_pk_ic[index_ic1_ic1]);
        }
        for (index_ic1=0; index_ic1 < pfo->ic_size; index_ic1++) {
          for (index_ic2=index_ic1+1; index_ic2 < pfo->ic_size; index_ic2++) {
            index_ic1_ic1 = index_symmetric_matrix(index_ic1,index_ic1,pfo->ic_size);
            index_ic2_ic2 = index_symmetric_matrix(index_ic2,index_ic2,pfo->ic_size);
            index_ic1_ic2 = index_symmetric_matrix(index_ic1,index_ic2,pfo->ic_size);
            out_pk_ic[index_ic1_ic2]
              = out_pk_ic[index_ic1_ic2]*sqrt(out_pk_ic[index_ic1_ic1]*out_pk_ic[index_ic2_ic2]);
          }
        }
      }
    }

    /** --> deal with case 0 < k < kmin that requires extrapolation
     *    P(k) = [some number] * k  * P_primordial(k)
     *    so
     *    P(k) = P(kmin) * (k P_primordial(k)) / (kmin P_primordial(kmin))
     *    (note that the result is accurate only if kmin is such that [a0 kmin] << H0)
     *
     *    This is accurate for the synchronous gauge; TODO: write
     *    newtonian gauge case. Also, In presence of isocurvature
     *    modes, we assumes for simplicity that the mode with
     *    index_ic1_ic2=0 dominates at small k: exact treatment should be
     *    written if needed.
     */

    else {

      /** --> First, get P(k) at the right z (in linear format) */

      class_call(fourier_pk_at_z(pba,
                                 pfo,
                                 linear,
                                 pk_output,
                                 z,
                                 index_pk,
                                 out_pk_at_z,
                                 out_pk_ic_at_z
                                 ),
                 pfo->error_message,
                 pfo->error_message);

      /* get P(kmin) */
      *out_pk = out_pk_at_z[0];

      if (do_ic == _TRUE_) {
        for (index_ic1_ic2=0; index_ic1_ic2<pfo->ic_ic_size; index_ic1_ic2++) {
          out_pk_ic[index_ic1_ic2] = out_pk_ic_at_z[index_ic1_ic2];
        }
      }

      /* compute P_primordial(k) */

      class_alloc(pk_primordial_k,
                  sizeof(double)*pfo->ic_ic_size,
                  pfo->error_message);

      class_call(primordial_spectrum_at_k(ppm,
                                          pfo->index_md_scalars,
                                          linear,
                                          k,
                                          pk_primordial_k),
                 ppm->error_message,
                 pfo->error_message);

      /* compute P_primordial(kmin) */

      kmin = exp(pfo->ln_k[0]);

      class_alloc(pk_primordial_kmin,
                  sizeof(double)*pfo->ic_ic_size,
                  pfo->error_message);

      class_call(primordial_spectrum_at_k(ppm,
                                          pfo->index_md_scalars,
                                          linear,
                                          kmin,
                                          pk_primordial_kmin),
                 ppm->error_message,
                 pfo->error_message);

      /* finally, infer P(k) */

      *out_pk *= (k*pk_primordial_k[0]/kmin/pk_primordial_kmin[0]);

      if (do_ic == _TRUE_) {
        for (index_ic1_ic2=0; index_ic1_ic2<pfo->ic_ic_size; index_ic1_ic2++) {
          out_pk_ic[index_ic1_ic2] *= (k*pk_primordial_k[index_ic1_ic2]
                                       /kmin/pk_primordial_kmin[index_ic1_ic2]);
        }
      }

      free(pk_primordial_k);
      free(pk_primordial_kmin);
    }

    free(out_pk_at_z);
    if (do_ic == _TRUE_) {
      free(out_pk_ic_at_z);
    }
  }

  return _SUCCESS_;
}

/*
 * Same as fourier_pk_at_k_and_z() (see the comments there about
 * the input/output format), excepted that we don't pass in input one
 * type of P(k) through index_pk. Instead, we get all existing types
 * in output. This function is maintained to enhance compatibility
 * with old versions, but the use of fourier_pk_at_k_and_z() should
 * be preferred.
 *
 * @param pba            Input: pointer to background structure
 * @param ppm            Input: pointer to primordial structure
 * @param pfo            Input: pointer to fourier structure
 * @param k              Input: wavenumber
 * @param z              Input: redshift
 * @param out_pk_l       Output: P_m(k) returned as out_pk_l[index_k]
 * @param out_pk_ic_l    Output:  P_m_ic(k) returned as  out_pk_ic_l[index_k * pfo->ic_ic_size + index_ic1_ic2]
 * @param out_pk_cb_l    Output: P_cb(k) returned as out_pk_cb_l[index_k]
 * @param out_pk_cb_ic_l Output:  P_cb_ic(k) returned as  out_pk_cb_ic_l[index_k * pfo->ic_ic_size + index_ic1_ic2]
 * @return the error status
 */

int fourier_pks_at_k_and_z(
                           struct background * pba,
                           struct primordial * ppm,
                           struct fourier *pfo,
                           enum pk_outputs pk_output,
                           double k,
                           double z,
                           double * out_pk, // number P_m(k)
                           double * out_pk_ic, // array P_m_ic(k) of index [index_ic1_ic2]
                           double * out_pk_cb, // number P_cb(k)
                           double * out_pk_cb_ic // array P__cb_ic(k)of index [index_ic1_ic2]
                           ) {

  if (pfo->has_pk_cb == _TRUE_) {

    class_call(fourier_pk_at_k_and_z(pba,
                                     ppm,
                                     pfo,
                                     pk_output,
                                     k,
                                     z,
                                     pfo->index_pk_cb,
                                     out_pk_cb,
                                     out_pk_cb_ic
                                     ),
               pfo->error_message,
               pfo->error_message);
  }
  if (pfo->has_pk_m == _TRUE_) {

    class_call(fourier_pk_at_k_and_z(pba,
                                     ppm,
                                     pfo,
                                     pk_output,
                                     k,
                                     z,
                                     pfo->index_pk_m,
                                     out_pk,
                                     out_pk_ic
                                     ),
               pfo->error_message,
               pfo->error_message);
  }

  return _SUCCESS_;
}

/**
 * Return the P(k,z) for a grid of (k_i,z_j) passed in input,
 * for all available pk types (_m, _cb),
 * either linear or nonlinear depending on input.
 *
 * If there are several initial conditions, this function is not
 * designed to return individual contributions.
 *
 * The main goal of this routine is speed. Unlike
 * fourier_pk_at_k_and_z(), it performs no extrapolation when an
 * input k_i falls outside the pre-computed range [kmin,kmax]: in that
 * case, it just returns P(k,z)=0 for such a k_i
 *
 * @param pba            Input: pointer to background structure
 * @param pfo            Input: pointer to fourier structure
 * @param pk_output      Input: pk_linear or pk_nonlinear
 * @param kvec           Input: array of wavenumbers in ascending order (in 1/Mpc)
 * @param kvec_size      Input: size of array of wavenumbers
 * @param zvec           Input: array of redshifts in arbitrary order
 * @param zvec_size      Input: size of array of redshifts
 * @param out_pk         Output: P(k_i,z_j) for total matter (if available) in Mpc**3
 * @param out_pk_cb      Output: P_cb(k_i,z_j) for cdm+baryons (if available) in Mpc**3
 * @return the error status
 */

int fourier_pks_at_kvec_and_zvec(
                                 struct background * pba,
                                 struct fourier * pfo,
                                 enum pk_outputs pk_output,
                                 double * kvec, // kvec[index_kvec]
                                 int kvec_size,
                                 double * zvec, // zvec[index_zvec]
                                 int zvec_size,
                                 double * out_pk,   // output_pk[index_zvec*kvec_size+index_kvec],
                                                    // already allocated
                                                    //(or NULL if user knows there is no _m output)
                                 double * out_pk_cb // output_pk[index_zvec*kvec_size+index_kvec],
                                                    //already allocated
                                                    //(or NULL if user knows there is no _cb output)
                                 ) {

  /** Summary: */

  /** - define local variables */

  int index_k, index_kvec, index_zvec;
  double * ln_kvec;
  double * ln_pk_table = NULL;
  double * ddln_pk_table = NULL;
  double * ln_pk_cb_table = NULL;
  double * ddln_pk_cb_table = NULL;
  double h, a, b;

  /** - Allocate arrays */

  class_alloc(ln_kvec, sizeof(double)*kvec_size,
              pfo->error_message);

  if (pfo->has_pk_m == _TRUE_) {
    class_alloc(ln_pk_table, sizeof(double)*pfo->k_size*zvec_size,
                pfo->error_message);
    class_alloc(ddln_pk_table, sizeof(double)*pfo->k_size*zvec_size,
                pfo->error_message);
  }
  if (pfo->has_pk_cb == _TRUE_) {
    class_alloc(ln_pk_cb_table, sizeof(double)*pfo->k_size*zvec_size,
                pfo->error_message);
    class_alloc(ddln_pk_cb_table, sizeof(double)*pfo->k_size*zvec_size,
                pfo->error_message);
  }

  /** - Construct table of log(P(k_n,z_j)) for pre-computed wavenumbers but requested redshifts: */

  for (index_zvec=0; index_zvec<zvec_size; index_zvec++){

    if (pfo->has_pk_m == _TRUE_) {
      class_call(fourier_pk_at_z(pba,
                                 pfo,
                                 logarithmic,
                                 pk_output,
                                 zvec[index_zvec],
                                 pfo->index_pk_m,
                                 &(ln_pk_table[index_zvec * pfo->k_size]),
                                 NULL),
                 pfo->error_message,
                 pfo->error_message);
    }
    if (pfo->has_pk_cb == _TRUE_) {
      class_call(fourier_pk_at_z(pba,
                                 pfo,
                                 logarithmic,
                                 pk_output,
                                 zvec[index_zvec],
                                 pfo->index_pk_cb,
                                 &(ln_pk_cb_table[index_zvec * pfo->k_size]),
                                 NULL),
                 pfo->error_message,
                 pfo->error_message);
    }
  }

  /** - Spline it for interpolation along k */

  if (pfo->has_pk_m == _TRUE_) {

    class_call(array_spline_table_columns2(pfo->ln_k,
                                           pfo->k_size,
                                           ln_pk_table,
                                           zvec_size,
                                           ddln_pk_table,
                                           _SPLINE_NATURAL_,
                                           pfo->error_message),
               pfo->error_message,
               pfo->error_message);
  }
  if (pfo->has_pk_cb == _TRUE_) {

    class_call(array_spline_table_columns2(pfo->ln_k,
                                           pfo->k_size,
                                           ln_pk_cb_table,
                                           zvec_size,
                                           ddln_pk_cb_table,
                                           _SPLINE_NATURAL_,
                                           pfo->error_message),
               pfo->error_message,
               pfo->error_message);
  }

  /** - Construct ln(kvec): */

  for (index_kvec=0; index_kvec<kvec_size; index_kvec++)
    ln_kvec[index_kvec] = log(kvec[index_kvec]);

  /** - Loop over first k values. If k<kmin, fill output with zeros. If not, go to next step. */

  for (index_kvec = 0; index_kvec<kvec_size; index_kvec++){

    /* check whether one should go to next step */
    if (ln_kvec[index_kvec] >= pfo->ln_k[0])
      break;

    /* deal with k<k_min */
    for (index_zvec = 0; index_zvec < zvec_size; index_zvec++) {
      if (pfo->has_pk_m == _TRUE_)     out_pk[index_zvec*kvec_size+index_kvec] = 0.;
      if (pfo->has_pk_cb == _TRUE_) out_pk_cb[index_zvec*kvec_size+index_kvec] = 0.;
      /* (If needed, one could add instead some extrapolation here) */
    }
  }

  /** - Deal with case kmin<=k<=kmax. For better performance, do not
      loop through kvec, but through pre-computed k values. */

  for (index_k=0; index_k < (pfo->k_size-1); index_k++){

    /** --> Loop through k_i's that fall in interval [k_n,k_n+1] */

    while ((index_kvec < kvec_size) && (ln_kvec[index_kvec] <= pfo->ln_k[index_k+1])){

      /** --> for each of them, perform spine interpolation */

      h = pfo->ln_k[index_k+1]-pfo->ln_k[index_k];
      b = (ln_kvec[index_kvec] - pfo->ln_k[index_k])/h;
      a = 1.-b;

      for (index_zvec = 0; index_zvec < zvec_size; index_zvec++) {

        if (pfo->has_pk_m == _TRUE_) {

          out_pk[index_zvec*kvec_size+index_kvec] =
            exp(
                array_spline_eval(ln_pk_table,
                                  ddln_pk_table,
                                  (index_zvec * pfo->k_size + index_k),
                                  (index_zvec * pfo->k_size + index_k+1),
                                  h,a,b)
                );
        }
        if (pfo->has_pk_cb == _TRUE_) {

          out_pk_cb[index_zvec*kvec_size+index_kvec] =
            exp(
                array_spline_eval(ln_pk_cb_table,
                                  ddln_pk_cb_table,
                                  (index_zvec * pfo->k_size + index_k),
                                  (index_zvec * pfo->k_size + index_k+1),
                                  h,a,b)
                );
        }
      }
      index_kvec++;
    }
  }

  /** - Loop over possible remaining k values with k > kmax, to fill output with zeros. */

  while (index_kvec < kvec_size) {

    for (index_zvec = 0; index_zvec < zvec_size; index_zvec++) {
      if (pfo->has_pk_m == _TRUE_)     out_pk[index_zvec*kvec_size+index_kvec] = 0.;
      if (pfo->has_pk_cb == _TRUE_) out_pk_cb[index_zvec*kvec_size+index_kvec] = 0.;
      /* (If needed, one could add instead some extrapolation here) */
    }
    index_kvec++;
  }

  free(ln_kvec);
  if (pfo->has_pk_m == _TRUE_) {
    free(ln_pk_table);
    free(ddln_pk_table);
  }
  if (pfo->has_pk_cb == _TRUE_) {
    free(ln_pk_cb_table);
    free(ddln_pk_cb_table);
  }

  return _SUCCESS_;
}

/**
 * Return the logarithmic slope of P(k,z) for a given (k,z), a given pk type (_m, _cb)
 * (computed with linear P_L if pk_output = pk_linear, nonlinear P_NL if pk_output = pk_nonlinear)
 *
 * @param pba         Input: pointer to background structure
 * @param ppm         Input: pointer to primordial structure
 * @param pfo         Input: pointer to fourier structure
 * @param pk_output   Input: linear or nonlinear
 * @param k           Input: wavenumber in 1/Mpc
 * @param z           Input: redshift
 * @param index_pk    Input: index of pk type (_m, _cb)
 * @param pk_tilt     Output: logarithmic slope of P(k,z)
 * @return the error status
 */

int fourier_pk_tilt_at_k_and_z(
                               struct background * pba,
                               struct primordial * ppm,
                               struct fourier * pfo,
                               enum pk_outputs pk_output,
                               double k,
                               double z,
                               int index_pk,
                               double * pk_tilt
                               ) {

  double dlnk;
  double out_pk1,out_pk2;

  /* typical step dln(k) on which we believe that out results are not
     dominated by numerical errors and that the P(k,z) is slowly
     varying */

  dlnk = pfo->ln_k[pfo->k_size-1] - pfo->ln_k[pfo->k_size-2];

  class_call(fourier_pk_at_k_and_z(pba,
                                   ppm,
                                   pfo,
                                   pk_output,
                                   k/(1.+dlnk),
                                   z,
                                   index_pk,
                                   &out_pk1,
                                   NULL),
             pfo->error_message,
             pfo->error_message);

  class_call(fourier_pk_at_k_and_z(pba,
                                   ppm,
                                   pfo,
                                   pk_output,
                                   k*(1.+dlnk),
                                   z,
                                   index_pk,
                                   &out_pk2,
                                   NULL),
             pfo->error_message,
             pfo->error_message);

  /* logarithmic derivative: n_eff = (logPk2 - logPk1)/(logk2-logk1) */

  *pk_tilt = (log(out_pk2)-log(out_pk1))/(2.*log(1.+dlnk));

  return _SUCCESS_;

}

/**
 * This routine computes the variance of density fluctuations in a
 * sphere of radius R at redshift z, sigma(R,z), or other similar derived
 * quantitites, for one given pk type (_m, _cb).
 *
 * The integral is performed until the maximum value of k_max defined
 * in the perturbation module. Here there is not automatic checking
 * that k_max is large enough for the result to be well
 * converged. E.g. to get an accurate sigma8 at R = 8 Mpc/h, the user
 * should pass at least about P_k_max_h/Mpc = 1.
 *
 * @param ppr          Input: pointer to precision structure
 * @param pba          Input: pointer to background structure
 * @param pfo          Input: pointer to fourier structure
 * @param R            Input: radius in Mpc
 * @param z            Input: redshift
 * @param index_pk     Input: type of pk (_m, _cb)
 * @param sigma_output Input: quantity to be computed (sigma, sigma', ...)
 * @param result       Output: result
 * @return the error status
 */

int fourier_sigmas_at_z(
                        struct precision * ppr,
                        struct background * pba,
                        struct fourier * pfo,
                        double R,
                        double z,
                        int index_pk,
                        enum out_sigmas sigma_output,
                        double * result
                        ) {

  double * out_pk;
  double * ddout_pk;

  /** - allocate temporary array for P(k,z) as a function of k */

  class_alloc(out_pk, pfo->k_size*sizeof(double), pfo->error_message);
  class_alloc(ddout_pk, pfo->k_size*sizeof(double), pfo->error_message);

  /** - get P(k,z) as a function of k, for the right z */

  class_call(fourier_pk_at_z(pba,
                             pfo,
                             logarithmic,
                             pk_linear,
                             z,
                             index_pk,
                             out_pk,
                             NULL),
             pfo->error_message,
             pfo->error_message);

  /** - spline it along k */

  class_call(array_spline_table_columns(pfo->ln_k,
                                        pfo->k_size,
                                        out_pk,
                                        1,
                                        ddout_pk,
                                        _SPLINE_EST_DERIV_,
                                        pfo->error_message),
             pfo->error_message,
             pfo->error_message);

  /** - calll the function computing the sigmas */

  class_call(fourier_sigmas(pfo,
                            R,
                            out_pk,
                            ddout_pk,
                            pfo->k_size,
                            ppr->sigma_k_per_decade,
                            sigma_output,
                            result),
             pfo->error_message,
             pfo->error_message);

  /** - free allocated arrays */

  free(out_pk);
  free(ddout_pk);

  return _SUCCESS_;
}

/**
 * Return the value of the non-linearity wavenumber k_nl for a given redshift z
 *
 * @param pba     Input: pointer to background structure
 * @param pfo     Input: pointer to fourier structure
 * @param z       Input: redshift
 * @param k_nl    Output: k_nl value
 * @param k_nl_cb Ouput: k_nl value of the cdm+baryon part only, if there is ncdm
 * @return the error status
 */

int fourier_k_nl_at_z(
                      struct background *pba,
                      struct fourier * pfo,
                      double z,
                      double * k_nl,
                      double * k_nl_cb
                      ) {

  double tau;

  /** - convert input redshift into a conformal time */

  class_call(background_tau_of_z(pba,
                                 z,
                                 &tau),
             pba->error_message,
             pfo->error_message);

  /** - interpolate the precomputed k_nl array at the needed valuetime */

  if (pfo->has_pk_m == _TRUE_) {

    if (pfo->tau_size == 1) {
      *k_nl = pfo->k_nl[pfo->index_pk_m][0];
    }
    else {
      class_call(array_interpolate_two(pfo->tau,
                                       1,
                                       0,
                                       pfo->k_nl[pfo->index_pk_m],
                                       1,
                                       pfo->tau_size,
                                       tau,
                                       k_nl,
                                       1,
                                       pfo->error_message),
                 pfo->error_message,
                 pfo->error_message);
    }
  }

  /** - if needed, do the same for the baryon part only */

  if (pfo->has_pk_cb == _TRUE_) {

    if (pfo->tau_size == 1) {
      *k_nl_cb = pfo->k_nl[pfo->index_pk_cb][0];
    }
    else {
      class_call(array_interpolate_two(pfo->tau,
                                       1,
                                       0,
                                       pfo->k_nl[pfo->index_pk_cb],
                                       1,
                                       pfo->tau_size,
                                       tau,
                                       k_nl_cb,
                                       1,
                                       pfo->error_message),
                 pfo->error_message,
                 pfo->error_message);
    }
  }

  /* otherwise, return the same for k_nl_cb as for k_nl */

  else{
    *k_nl_cb = *k_nl;
  }

  return _SUCCESS_;
}

/**
 * Initialize the fourier structure, and in particular the
 * nl_corr_density and k_nl interpolation tables.
 *
 * @param ppr Input: pointer to precision structure
 * @param pba Input: pointer to background structure
 * @param pth Input: pointer to therodynamics structure
 * @param ppt Input: pointer to perturbation structure
 * @param ppm Input: pointer to primordial structure
 * @param pfo Input/Output: pointer to initialized fourier structure
 * @return the error status
 */

int fourier_init(
                 struct precision *ppr,
                 struct background *pba,
                 struct thermodynamics *pth,
                 struct perturbations *ppt,
                 struct primordial *ppm,
                 struct fourier *pfo
                 ) {

  int index_ncdm;
  int index_k;
  int index_tau;
  int index_tau_sources;
  int index_tau_late;
  int index_pk;

  double **pk_nl;
  double **lnpk_l;
  double **ddlnpk_l;

  short nl_corr_not_computable_at_this_k = _FALSE_;

  double * pvecback;
  int last_index;
  double a,z;

  struct fourier_workspace nw;
  struct fourier_workspace * pnw;

  /** - Do we want to compute P(k,z)? Propagate the flag has_pk_matter
      from the perturbations structure to the fourier structure */
  pfo->has_pk_matter = ppt->has_pk_matter;

  /** - preliminary tests */

  /** --> This module only makes sense for dealing with scalar
      perturbations, so it should do nothing if there are no
      scalars */
  if (ppt->has_scalars == _FALSE_) {
    pfo->method = nl_none;
    if (pfo->fourier_verbose > 0)
      printf("No scalar modes requested. Nonlinear module skipped.\n");
    return _SUCCESS_;
  }

  /** --> Nothing to be done if we don't want the matter power spectrum */

  if ((pfo->has_pk_matter == _FALSE_) && (pfo->method == nl_none)) {
    if (pfo->fourier_verbose > 0)
      printf("No Fourier spectra nor nonlinear corrections requested. Nonlinear module skipped.\n");
    return _SUCCESS_;
  }
  else {
    if (pfo->fourier_verbose > 0)
      printf("Computing linear Fourier spectra.\n");
  }

  /** --> check applicability of Halofit and HMcode */
  if (pfo->method > nl_none) {

    if (pba->has_ncdm == _TRUE_) {
      for (index_ncdm=0;index_ncdm < pba->N_ncdm; index_ncdm++){
        if (pba->m_ncdm_in_eV[index_ncdm] >  _M_EV_TOO_BIG_FOR_HALOFIT_)
          fprintf(stdout,"Warning: Halofit and HMcode are proved to work for CDM, and also with a small HDM component. But it sounds like you are running with a WDM component of mass %f eV, which makes the use of Halofit suspicious.\n",pba->m_ncdm_in_eV[index_ncdm]);
      }
    }
    if ((pba->has_idm == _TRUE_) && (ppt->perturbations_verbose > 0)){
      fprintf(stdout,"Warning: Halofit and HMcode are proved to work for CDM, and also with a small HDM component. But you have requested interacting dark matter (idm), which makes the use of Halofit or HMCode unreliable.\n");
    }
  }

  /** - define indices in fourier structure (and allocate some arrays in the structure) */

  class_call(fourier_indices(
                             ppr,
                             pba,
                             ppt,
                             ppm,
                             pfo),
             pfo->error_message,
             pfo->error_message);

  /** - get the linear power spectrum at each time */

  for (index_tau=0; index_tau<pfo->ln_tau_size;index_tau++) {

    /* If the user only wants z=0, then pfo->ln_tau_size=1 and we go
       only through index_tau=0. However we must pick up the last
       value of the source, index_tau_sources = ppt->tau_size-1. If
       the user wants several values of z, they correspond to the last
       ppt->ln_tau_size values of the sources (those that were also
       part of the array ppt->late_sources in the perturbation
       module). In all cases, the following formula gives the
       correspondance between index_tau in the current array and in
       the sources array:
    */

    index_tau_sources = ppt->tau_size-ppt->ln_tau_size+index_tau;

    /** --> loop over required pk types (_m, _cb) */

    for (index_pk=0; index_pk<pfo->pk_size; index_pk++) {

      /** --> get the linear power spectrum for this time and this type */

      class_call(fourier_pk_linear(
                                   pba,
                                   ppt,
                                   ppm,
                                   pfo,
                                   index_pk,
                                   index_tau_sources,
                                   pfo->k_size,
                                   &(pfo->ln_pk_l[index_pk][index_tau * pfo->k_size]),
                                   &(pfo->ln_pk_ic_l[index_pk][index_tau * pfo->k_size * pfo->ic_ic_size])
                                   ),
                 pfo->error_message,
                 pfo->error_message);


      /** --> if interpolation of \f$P(k,\tau)\f$ will be needed (as a
          function of tau), compute array of second derivatives in view of
          spline interpolation */

      if (pfo->ln_tau_size > 1) {

        class_call(array_spline_table_lines(pfo->ln_tau,
                                            pfo->ln_tau_size,
                                            pfo->ln_pk_l[index_pk],
                                            pfo->k_size,
                                            pfo->ddln_pk_l[index_pk],
                                            _SPLINE_EST_DERIV_,
                                            pfo->error_message),
                   pfo->error_message,
                   pfo->error_message);

        class_call(array_spline_table_lines(pfo->ln_tau,
                                            pfo->ln_tau_size,
                                            pfo->ln_pk_ic_l[index_pk],
                                            pfo->k_size*pfo->ic_ic_size,
                                            pfo->ddln_pk_ic_l[index_pk],
                                            _SPLINE_EST_DERIV_,
                                            pfo->error_message),
                   pfo->error_message,
                   pfo->error_message);
      }
    }
  }

  /** - compute and store sigma8 (variance of density fluctuations in
      spheres of radius 8/h Mpc at z=0, always computed by
      convention using the linear power spectrum) */

  for (index_pk=0; index_pk<pfo->pk_size; index_pk++) {

    class_call(fourier_sigmas_at_z(ppr,
                                   pba,
                                   pfo,
                                   8./pba->h,
                                   0.,
                                   index_pk,
                                   out_sigma,
                                   &(pfo->sigma8[index_pk])),
               pfo->error_message,
               pfo->error_message);
  }

  if (pfo->fourier_verbose>0) {

    if (pfo->has_pk_m == _TRUE_)
      fprintf(stdout," -> sigma8=%g for total matter (computed till k = %g h/Mpc)\n",
              pfo->sigma8[pfo->index_pk_m],
              pfo->k[pfo->k_size-1]/pba->h);

    if (pfo->has_pk_cb == _TRUE_)
      fprintf(stdout," -> sigma8=%g for baryons+cdm  (computed till k = %g h/Mpc)\n",
              pfo->sigma8[pfo->index_pk_cb],
              pfo->k[pfo->k_size-1]/pba->h);
  }

  /** - get the non-linear power spectrum at each time */

  /** --> First deal with the case where non non-linear corrections requested */

  if (pfo->method == nl_none) {
    if (pfo->fourier_verbose > 0)
      printf("No non-linear spectra requested. Nonlinear calculations skipped.\n");
  }

  /** --> Then go through common preliminary steps to the HALOFIT and HMcode methods */
  else if ((pfo->method == nl_halofit) || ((pfo->method == nl_HMcode))) {

    if ((pfo->fourier_verbose > 0) && (pfo->method == nl_halofit))
      printf("Computing non-linear matter power spectrum with Halofit (including update Takahashi et al. 2012 and Bird 2014)\n");

	if ((pfo->fourier_verbose > 0) && (pfo->method == nl_HMcode))
      printf("Computing non-linear matter power spectrum with HMcode \n");

    /** --> allocate temporary arrays for spectra at each given time/redshift */

    class_alloc(pk_nl,
                pfo->k_size*sizeof(double),
                pfo->error_message);

    class_alloc(lnpk_l,
                pfo->k_size*sizeof(double),
                pfo->error_message);

    class_alloc(ddlnpk_l,
                pfo->k_size*sizeof(double),
                pfo->error_message);

    for (index_pk=0; index_pk<pfo->pk_size; index_pk++){
      class_alloc(pk_nl[index_pk],pfo->k_size*sizeof(double),pfo->error_message);
      class_alloc(lnpk_l[index_pk],pfo->k_size_extra*sizeof(double),pfo->error_message);
      class_alloc(ddlnpk_l[index_pk],pfo->k_size_extra*sizeof(double),pfo->error_message);
    }

    /** --> Then go through preliminary steps specific to HMcode */

    if (pfo->method == nl_HMcode){

      pnw = &nw;

      class_call(fourier_hmcode_workspace_init(ppr,pba,pfo,pnw),
                 pfo->error_message,
                 pfo->error_message);

      class_call(fourier_hmcode_dark_energy_correction(ppr,pba,pfo,pnw),
                 pfo->error_message,
                 pfo->error_message);

      class_call(fourier_hmcode_baryonic_feedback(pfo),
                 pfo->error_message,
                 pfo->error_message);
    }

    /** --> Loop over decreasing time/growing redhsift. For each
        time/redshift, compute P_NL(k,z) using either Halofit or
        HMcode */

    /* this flag will become _TRUE_ at the minimum redshift such that
       the non-lienar corrections cannot be consistently computed */
    nl_corr_not_computable_at_this_k = _FALSE_;

    /* this index will refer to the value of time corresponding to
       that redhsift */
    pfo->index_tau_min_nl = 0;

    for (index_tau = pfo->tau_size-1; index_tau>=0; index_tau--) {

      /* loop over index_pk, defined such that it is ensured
       * that index_pk starts at index_pk_cb when neutrinos are
       * included. This is necessary for hmcode, since the sigmatable
       * needs to be filled for sigma_cb only. Thus, when HMcode
       * evalutes P_m_nl, it needs both P_m_l and P_cb_l. */

      for (index_pk=0; index_pk<pfo->pk_size; index_pk++) {

        /* get P_L(k) at this time */
        class_call(fourier_pk_linear(
                                     pba,
                                     ppt,
                                     ppm,
                                     pfo,
                                     index_pk,
                                     index_tau,
                                     pfo->k_size_extra,
                                     lnpk_l[index_pk],
                                     NULL
                                     ),
                   pfo->error_message,
                   pfo->error_message);

        /* spline P_L(k) at this time along k */
        class_call(array_spline_table_columns(
                                              pfo->ln_k,
                                              pfo->k_size_extra,
                                              lnpk_l[index_pk],
                                              1,
                                              ddlnpk_l[index_pk],
                                              _SPLINE_NATURAL_,
                                              pfo->error_message),
                   pfo->error_message,
                   pfo->error_message);

        /* if we are still in a range of time where P_NL(k) should be computable */
        if (nl_corr_not_computable_at_this_k == _FALSE_) {

          /* get P_NL(k) at this time with Halofit */
          if (pfo->method == nl_halofit) {

            class_call(fourier_halofit(
                                       ppr,
                                       pba,
                                       ppt,
                                       ppm,
                                       pfo,
                                       index_pk,
                                       pfo->tau[index_tau],
                                       pk_nl[index_pk],
                                       lnpk_l[index_pk],
                                       ddlnpk_l[index_pk],
                                       &(pfo->k_nl[index_pk][index_tau]),
                                       &nl_corr_not_computable_at_this_k),
                       pfo->error_message,
                       pfo->error_message);

          }

          /* get P_NL(k) at this time with HMcode */
          else if (pfo->method == nl_HMcode) {

            /* (preliminary step: fill table of sigma's, only for _cb if there is both _cb and _m) */
            if (index_pk == 0) {
              class_call(fourier_hmcode_fill_sigtab(ppr,
                                                    pba,
                                                    ppt,
                                                    ppm,
                                                    pfo,
                                                    index_tau,
                                                    lnpk_l[index_pk],
                                                    ddlnpk_l[index_pk],
                                                    pnw),
                         pfo->error_message, pfo->error_message);
            }

            class_call(fourier_hmcode(ppr,
                                      pba,
                                      ppt,
                                      ppm,
                                      pfo,
                                      index_pk,
                                      index_tau,
                                      pfo->tau[index_tau],
                                      pk_nl[index_pk],
                                      lnpk_l,
                                      ddlnpk_l,
                                      &(pfo->k_nl[index_pk][index_tau]),
                                      &nl_corr_not_computable_at_this_k,
                                      pnw),
                       pfo->error_message,
                       pfo->error_message);
          }

          /* infer and store R_NL=(P_NL/P_L)^1/2 */
          if (nl_corr_not_computable_at_this_k == _FALSE_) {
            for (index_k=0; index_k<pfo->k_size; index_k++) {
              pfo->nl_corr_density[index_pk][index_tau * pfo->k_size + index_k] = sqrt(pk_nl[index_pk][index_k]/exp(lnpk_l[index_pk][index_k]));
            }
          }

          /* otherwise we met the first problematic value of time */
          else {

            /* store the index of that value */
            pfo->index_tau_min_nl = MIN(pfo->tau_size-1,index_tau+1); //this MIN() ensures that index_tau_min_nl is never out of bounds

            /* store R_NL=1 for that time */
            for (index_k=0; index_k<pfo->k_size; index_k++) {
              pfo->nl_corr_density[index_pk][index_tau * pfo->k_size + index_k] = 1.;
            }

            /* send a warning to inform user about the corresponding value of redshift */
            if (pfo->fourier_verbose > 0) {
              class_alloc(pvecback,pba->bg_size*sizeof(double),pfo->error_message);
              class_call(background_at_tau(pba,pfo->tau[index_tau],short_info,inter_normal,&last_index,pvecback),
                         pba->error_message,
                         pfo->error_message);
              a = pvecback[pba->index_bg_a];
              /* redshift (remeber that a in the code stands for (a/a_0)) */
              z = 1./a-1.;
              fprintf(stdout,
                      " -> [WARNING:] Non-linear corrections could not be computed at redshift z=%5.2f and higher.\n    This is because k_max is too small for the algorithm (Halofit or HMcode) to be able to compute the scale k_NL at this redshift.\n    If non-linear corrections at such high redshift really matter for you,\n    just try to increase the precision parameter nonlinear_min_k_max (currently at %e) until k_NL can be computed at the desired z.\n",z,ppr->nonlinear_min_k_max);

              free(pvecback);
            }
          }
        }

        /* if we are still in a range of time where P_NL(k) should NOT be computable */
        else {
          /* store R_NL=1 for that time */
          for (index_k=0; index_k<pfo->k_size; index_k++) {
            pfo->nl_corr_density[index_pk][index_tau * pfo->k_size + index_k] = 1.;
          }

        }

        /** --> fill the array of nonlinear power spectra (only if we
            are at a late time where P(k) and T(k) are supposed to
            be stored, i.e., such that z(tau < z_max_pk) */

        if (index_tau >= pfo->tau_size - pfo->ln_tau_size) {

          index_tau_late = index_tau - (pfo->tau_size - pfo->ln_tau_size);

          for (index_k=0; index_k<pfo->k_size; index_k++) {
            pfo->ln_pk_nl[index_pk][index_tau_late * pfo->k_size + index_k] = pfo->ln_pk_l[index_pk][index_tau_late * pfo->k_size + index_k] + 2.*log(pfo->nl_corr_density[index_pk][index_tau * pfo->k_size + index_k]);
          }
        }

      } // end loop over index_pk
    } //end loop over index_tau


    /** --> spline the array of nonlinear power spectrum */

    if (pfo->ln_tau_size > 1) {
      for (index_pk=0; index_pk<pfo->pk_size; index_pk++) {

        class_call(array_spline_table_lines(pfo->ln_tau,
                                            pfo->ln_tau_size,
                                            pfo->ln_pk_nl[index_pk],
                                            pfo->k_size,
                                            pfo->ddln_pk_nl[index_pk],
                                            _SPLINE_EST_DERIV_,
                                            pfo->error_message),
                   pfo->error_message,
                   pfo->error_message);
      }
    }

    /* --> free temporary arrays */

    for (index_pk=0; index_pk<pfo->pk_size; index_pk++){
      free(pk_nl[index_pk]);
      free(lnpk_l[index_pk]);
      free(ddlnpk_l[index_pk]);
    }

    free(pk_nl);
    free(lnpk_l);
    free(ddlnpk_l);

    /** --> free the nonlinear workspace */

    if (pfo->method == nl_HMcode) {

      class_call(fourier_hmcode_workspace_free(pfo,pnw),
                 pfo->error_message,
                 pfo->error_message);
    }
  }

  /** - if the nl_method could not be identified */
  else {
    class_stop(pfo->error_message,
               "Your non-linear method variable is set to %d, out of the range defined in fourier.h",pfo->method);
  }

  pfo->is_allocated = _TRUE_;
  return _SUCCESS_;
}

/**
 * Free all memory space allocated by fourier_init().
 *
 *
 * @param pfo Input: pointer to fourier structure (to be freed)
 * @return the error status
 */

int fourier_free(
                 struct fourier *pfo
                 ) {
  int index_pk;

  if ((pfo->has_pk_matter == _TRUE_) || (pfo->method > nl_none)) {

    free(pfo->k);
    free(pfo->ln_k);

    for (index_pk=0; index_pk<pfo->pk_size; index_pk++) {
      free(pfo->ln_pk_ic_l[index_pk]);
      free(pfo->ln_pk_l[index_pk]);
      if (pfo->ln_tau_size>1) {
        free(pfo->ddln_pk_ic_l[index_pk]);
        free(pfo->ddln_pk_l[index_pk]);
      }
    }
    free(pfo->ln_pk_ic_l);
    free(pfo->ln_pk_l);

    free (pfo->sigma8);

    if (pfo->ln_tau_size>1) {
      free(pfo->ddln_pk_ic_l);
      free(pfo->ddln_pk_l);
      free(pfo->ln_tau);
    }

    free(pfo->is_non_zero);
  }

  if (pfo->method > nl_none) {

    free(pfo->tau);
    for (index_pk=0;index_pk<pfo->pk_size;index_pk++){
      free(pfo->nl_corr_density[index_pk]);
      free(pfo->k_nl[index_pk]);
      free(pfo->ln_pk_nl[index_pk]);
      if (pfo->ln_tau_size > 1)
        free(pfo->ddln_pk_nl[index_pk]);
    }
    free(pfo->nl_corr_density);
    free(pfo->k_nl);
    free(pfo->ln_pk_nl);
    if (pfo->ln_tau_size > 1)
      free(pfo->ddln_pk_nl);
  }

  if (pfo->has_pk_eq == _TRUE_) {
    free(pfo->pk_eq_tau);
    free(pfo->pk_eq_w_and_Omega);
    free(pfo->pk_eq_ddw_and_ddOmega);
  }

  pfo->is_allocated = _FALSE_;
  return _SUCCESS_;
}

/**
 * Define indices in the fourier structure, and when possible, allocate
 * arrays in this structure given the index sizes found here
 *
 * @param ppr Input: pointer to precision structure
 * @param pba Input: pointer to background structure
 * @param ppt Input: pointer to perturbation structure
 * @param ppm Input: pointer to primordial structure
 * @param pfo Input/Output: pointer to fourier structure
 * @return the error status
 */

int fourier_indices(
                    struct precision *ppr,
                    struct background *pba,
                    struct perturbations * ppt,
                    struct primordial * ppm,
                    struct fourier * pfo
                    ) {

  int index_ic1_ic2;
  int index_pk;

  /** - define indices for initial conditions (and allocate related arrays) */
  pfo->index_md_scalars = ppt->index_md_scalars;
  pfo->ic_size = ppm->ic_size[pfo->index_md_scalars];
  pfo->ic_ic_size = ppm->ic_ic_size[pfo->index_md_scalars];
  class_alloc(pfo->is_non_zero,sizeof(short)*pfo->ic_ic_size,pfo->error_message);
  for (index_ic1_ic2=0; index_ic1_ic2 < pfo->ic_ic_size; index_ic1_ic2++)
    pfo->is_non_zero[index_ic1_ic2] = ppm->is_non_zero[pfo->index_md_scalars][index_ic1_ic2];

  /** - define flags indices for pk types (_m, _cb). Note: due to some
      dependencies in HMcode, when pfo->index_pk_cb exists, it must
      come first (e.g. the calculation of the non-linear P_m depends on
      sigma_cb so the cb-related quantitites must be evaluated
      first) */

  pfo->has_pk_m = _TRUE_;
  if (pba->has_ncdm == _TRUE_) {
    pfo->has_pk_cb = _TRUE_;
  }
  else {
    pfo->has_pk_cb = _FALSE_;
  }

  index_pk = 0;
  class_define_index(pfo->index_pk_cb, pfo->has_pk_cb, index_pk,1);
  class_define_index(pfo->index_pk_m, pfo->has_pk_m, index_pk,1);
  pfo->pk_size = index_pk;

  /* and two redundent but useful indices: */

  if (pfo->has_pk_cb == _TRUE_) {
    pfo->index_pk_total = pfo->index_pk_m;
    pfo->index_pk_cluster = pfo->index_pk_cb;
  }
  else {
    pfo->index_pk_total = pfo->index_pk_m;
    pfo->index_pk_cluster = pfo->index_pk_m;
  }

  /** - get list of k values */

  class_call(fourier_get_k_list(ppr,ppm,ppt,pfo),
             pfo->error_message,
             pfo->error_message);

  /** - get list of tau values */

  class_call(fourier_get_tau_list(ppt,pfo),
             pfo->error_message,
             pfo->error_message);

  /** - given previous indices, we can allocate the array of linear power spectrum values */

  class_alloc(pfo->ln_pk_ic_l,pfo->pk_size*sizeof(double*),pfo->error_message);
  class_alloc(pfo->ln_pk_l   ,pfo->pk_size*sizeof(double*),pfo->error_message);

  for (index_pk=0; index_pk<pfo->pk_size; index_pk++) {
    class_alloc(pfo->ln_pk_ic_l[index_pk],pfo->ln_tau_size*pfo->k_size*pfo->ic_ic_size*sizeof(double*),pfo->error_message);
    class_alloc(pfo->ln_pk_l[index_pk]   ,pfo->ln_tau_size*pfo->k_size*sizeof(double*),pfo->error_message);
  }

  /** - if interpolation of \f$P(k,\tau)\f$ will be needed (as a function of tau),
      compute also the array of second derivatives in view of spline interpolation */

  if (pfo->ln_tau_size > 1) {

    class_alloc(pfo->ddln_pk_ic_l,pfo->pk_size*sizeof(double*),pfo->error_message);
    class_alloc(pfo->ddln_pk_l   ,pfo->pk_size*sizeof(double*),pfo->error_message);

    for (index_pk=0; index_pk<pfo->pk_size; index_pk++) {
      class_alloc(pfo->ddln_pk_ic_l[index_pk],pfo->ln_tau_size*pfo->k_size*pfo->ic_ic_size*sizeof(double*),pfo->error_message);
      class_alloc(pfo->ddln_pk_l[index_pk]   ,pfo->ln_tau_size*pfo->k_size*sizeof(double*),pfo->error_message);
    }
  }

  /** - array of sigma8 values */

  class_alloc(pfo->sigma8,pfo->pk_size*sizeof(double*),pfo->error_message);

  /** - if non-linear computations needed, allocate array of
      non-linear correction ratio R_nl(k,z), k_nl(z) and P_nl(k,z)
      for each P(k) type */

  if (pfo->method > nl_none) {

    class_alloc(pfo->k_nl,
                pfo->pk_size*sizeof(double *),
                pfo->error_message);

    class_alloc(pfo->nl_corr_density,
                pfo->pk_size*sizeof(double *),
                pfo->error_message);

    class_alloc(pfo->ln_pk_nl,pfo->pk_size*sizeof(double*),pfo->error_message);
    if (pfo->ln_tau_size > 1)
      class_alloc(pfo->ddln_pk_nl,pfo->pk_size*sizeof(double*),pfo->error_message);

    for (index_pk=0; index_pk<pfo->pk_size; index_pk++){
      class_alloc(pfo->k_nl[index_pk],pfo->tau_size*sizeof(double),pfo->error_message);
      class_alloc(pfo->nl_corr_density[index_pk],pfo->tau_size*pfo->k_size*sizeof(double),pfo->error_message);
      class_alloc(pfo->ln_pk_nl[index_pk],pfo->ln_tau_size*pfo->k_size*sizeof(double*),pfo->error_message);
      if (pfo->ln_tau_size > 1)
        class_alloc(pfo->ddln_pk_nl[index_pk],pfo->ln_tau_size*pfo->k_size*sizeof(double*),pfo->error_message);
    }
  }

  return _SUCCESS_;
}

/**
 * Copy list of k from perturbation module, and extended it if
 * necessary to larger k for extrapolation (currently this
 * extrapolation is required only by HMcode)
 *
 * @param ppr Input: pointer to precision structure
 * @param ppt Input: pointer to perturbation structure
 * @param pfo Input/Output: pointer to fourier structure
 * @return the error status
 */

int fourier_get_k_list(
                       struct precision *ppr,
                       struct primordial * ppm,
                       struct perturbations * ppt,
                       struct fourier * pfo
                       ) {

  double k=0;
  double k_max,exponent;
  int index_k;

  pfo->k_size = ppt->k_size[pfo->index_md_scalars];
  pfo->k_size_pk = ppt->k_size_pk;
  k_max = ppt->k[pfo->index_md_scalars][pfo->k_size-1];

  /** - if k extrapolation necessary, compute number of required extra values */
  if (pfo->method == nl_HMcode){
    index_k=0;
    while(k < ppr->hmcode_max_k_extra && index_k < _MAX_NUM_EXTRAPOLATION_){
      index_k++;
      k = k_max * pow(10,(double)index_k/ppr->k_per_decade_for_pk);
    }
    class_test(index_k == _MAX_NUM_EXTRAPOLATION_,
               pfo->error_message,
               "could not reach extrapolated value k = %.10e starting from k = %.10e with k_per_decade of %.10e in _MAX_NUM_INTERPOLATION_=%i steps",
               ppr->hmcode_max_k_extra,k_max,ppr->k_per_decade_for_pk,_MAX_NUM_EXTRAPOLATION_
               );

    pfo->k_size_extra = pfo->k_size+index_k;
  }
  /** - otherwise, same number of values as in perturbation module */
  else {
    pfo->k_size_extra = pfo->k_size;
  }

  /** - allocate array of k */
  class_alloc(pfo->k,   pfo->k_size_extra*sizeof(double),pfo->error_message);
  class_alloc(pfo->ln_k,pfo->k_size_extra*sizeof(double),pfo->error_message);

  /** - fill array of k (not extrapolated) */
  for (index_k=0; index_k<pfo->k_size; index_k++) {
    k = ppt->k[pfo->index_md_scalars][index_k];
    pfo->k[index_k] = k;
    pfo->ln_k[index_k] = log(k);
  }

  /** - fill additional values of k (extrapolated) */
  for (index_k=pfo->k_size; index_k<pfo->k_size_extra; index_k++) {
    exponent = (double)(index_k-(pfo->k_size-1))/ppr->k_per_decade_for_pk;
    pfo->k[index_k] = k * pow(10,exponent);
    pfo->ln_k[index_k] = log(k) + exponent*log(10.);
  }

  class_test(pfo->k[pfo->k_size_extra-1]>exp(ppm->lnk[ppm->lnk_size-1]) && ppm->primordial_spec_type != analytic_Pk,
             pfo->error_message,
             "Setting the output to HMcode with a large 'hmcode_max_k_extra' and using the primordial spectrum to not analytic is incompatible. Either use the analytic power spectrum or set a smaller 'hmcode_max_k_extra' (k_max_hmcode=%.5e , k_max_primordial=%.5e)",
             pfo->k[pfo->k_size_extra-1],
             exp(ppm->lnk[ppm->lnk_size-1])
             )

  return _SUCCESS_;
}

/**
 * Copy list of tau from perturbation module
 *
 * @param ppt Input: pointer to perturbation structure
 * @param pfo Input/Output: pointer to fourier structure
 * @return the error status
 */

int fourier_get_tau_list(
                         struct perturbations * ppt,
                         struct fourier * pfo
                         ) {

  int index_tau;

  /** -> for linear calculations: only late times are considered, given the value z_max_pk inferred from the ionput */
  pfo->ln_tau_size = ppt->ln_tau_size;

  if (ppt->ln_tau_size > 1) {

    class_alloc(pfo->ln_tau,pfo->ln_tau_size*sizeof(double),pfo->error_message);

    for (index_tau=0; index_tau<pfo->ln_tau_size;index_tau++) {
      pfo->ln_tau[index_tau] = ppt->ln_tau[index_tau];
    }
  }

  /** -> for non-linear calculations: we wills store a correction factor for all times */
  if (pfo->method > nl_none) {

    pfo->tau_size = ppt->tau_size;

    class_alloc(pfo->tau,pfo->tau_size*sizeof(double),pfo->error_message);

    for (index_tau=0; index_tau<pfo->tau_size; index_tau++) {
      pfo->tau[index_tau] = ppt->tau_sampling[index_tau];
    }
  }
  return _SUCCESS_;
}

/**
 * Get sources for a given wavenumber (and for a given time, type, ic,
 * mode...) either directly from precomputed valkues (computed ain
 * perturbation module), or by analytic extrapolation
 *
 * @param pba             Input: pointer to background structure
 * @param ppt             Input: pointer to perturbation structure
 * @param pfo             Input: pointer to fourier structure
 * @param index_k         Input: index of required k value
 * @param index_ic        Input: index of required ic value
 * @param index_tp        Input: index of required tp value
 * @param index_tau       Input: index of required tau value
 * @param sources         Input: array containing the original sources
 * @param source          Output: desired value of source
 * @return the error status
 */

int fourier_get_source(
                       struct background * pba,
                       struct perturbations * ppt,
                       struct fourier * pfo,
                       int index_k,
                       int index_ic,
                       int index_tp,
                       int index_tau,
                       double ** sources,
                       double * source
                       ) {

  double k,k_max,k_previous;
  double source_max,source_previous;
  double scaled_factor,log_scaled_factor;

  /** - use precomputed values */
  if (index_k < pfo->k_size) {
    *source = sources[index_ic * ppt->tp_size[pfo->index_md_scalars] + index_tp][index_tau * pfo->k_size + index_k];
  }
  /** - extrapolate **/
  else {

    k = pfo->k[index_k];

    /**
     * --> Get last source and k, which are used in (almost) all methods
     */
    k_max = pfo->k[pfo->k_size-1];
    source_max = sources[index_ic * ppt->tp_size[pfo->index_md_scalars] + index_tp][index_tau * pfo->k_size + pfo->k_size - 1];

    /**
     * --> Get previous source and k, which are used in best methods
     */
    k_previous = pfo->k[pfo->k_size-2];
    source_previous = sources[index_ic * ppt->tp_size[pfo->index_md_scalars] + index_tp][index_tau * pfo->k_size + pfo->k_size - 2];

    switch(pfo->extrapolation_method){
      /**
       * --> Extrapolate by assuming the source to vanish Has terrible
       * discontinuity
       */
    case extrap_zero:
      {
        *source=0.0;
        break;
      }
      /**
       * --> Extrapolate starting from the maximum value, assuming  growth ~ ln(k)
       * Has a terrible bend in log slope, discontinuity only in derivative
       */
    case extrap_only_max:
      {
        *source = source_max*(log(k)/log(k_max));
        break;
      }
      /**
       * --> Extrapolate starting from the maximum value, assuming
       * growth ~ ln(k) Here we use k in h/Mpc instead of 1/Mpc as it
       * is done in the CAMB implementation of HMcode Has a terrible
       * bend in log slope, discontinuity only in derivative
       */
    case extrap_only_max_units:
      {
        *source = source_max*(log(k/pba->h)/log(k_max/pba->h));
        break;
      }
      /**
       * --> Extrapolate assuming source ~ ln(a*k) where a is obtained
       * from the data at k_0 Mostly continuous derivative, quite good
       */
    case extrap_max_scaled:
      {
        log_scaled_factor = (source_previous*log(k_max)-source_max*log(k_previous))/(source_max-source_previous);
        *source = source_max*((log_scaled_factor+log(k))/(log_scaled_factor+log(k_max)));
        break;
      }
      /**
       * --> Extrapolate assuming source ~ ln(e+a*k) where a is
       * estimated like is done in original HMCode
       */
    case extrap_hmcode:
      {
        scaled_factor = 1.8/(13.41*pba->a_eq*pba->H_eq);
        *source = source_max*(log(_E_+scaled_factor*k)/log(_E_+scaled_factor*k_max));
        break;
      }
      /**
       * --> If the user has a complicated model and wants to
       * interpolate differently, they can define their interpolation
       * here and switch to using it instead
       */
    case extrap_user_defined:
      {
        class_stop(pfo->error_message,"Method of source extrapolation 'user_defined' was not yet defined.");
        break;
      }
    }
  }
  return _SUCCESS_;
}

/**
 * This routine computes all the components of the matter power
 * spectrum P(k), given the source functions and the primordial
 * spectra, at a given time within the pre-computed table of sources
 * (= Fourier transfer functions) of the perturbation module, for a
 * given type (total matter _m or baryon+CDM _cb), and for the same
 * array of k values as in the pre-computed table.
 *
 * If the input array of k values pfo->ln_k contains wavemumbers
 * larger than those of the pre-computed table, the sources will be
 * extrapolated analytically.
 *
 * On the opther hand, if the primordial spectrum has sharp features
 * and needs to be sampled on a finer grid than the sources, this
 * function has to be modified to capture the features.
 *
 * There are two output arrays, because we consider:
 *
 * - the total matter (_m) or CDM+baryon (_cb) power spectrum
 *
 * - in the quantitites labelled _ic, the splitting of one of these
 * spectra in different modes for different initial conditions. If the
 * pointer ln_pk_ic is NULL in input, the function will ignore this
 * part; thus, to get the result, one should allocate the array before
 * calling the function. Then the convention is the following:
 *
 * -- the index_ic1_ic2 labels ordered pairs (index_ic1, index_ic2)
 * (since the primordial spectrum is symmetric in (index_ic1,
 * index_ic2)).
 *
 * -- for diagonal elements (index_ic1 = index_ic2) this
 * arrays contains ln[P(k)] where P(k) is positive by construction.
 *
 * -- for non-diagonal elements this arrays contains the k-dependent
 * cosine of the correlation angle, namely P(k)_(index_ic1,
 * index_ic2)/sqrt[P(k)_index_ic1 P(k)_index_ic2]. E.g. for fully
 * correlated or anti-correlated initial conditions, this non-diagonal
 * element is independent on k, and equal to +1 or -1.
 *
 * @param pba           Input: pointer to background structure
 * @param ppt           Input: pointer to perturbation structure
 * @param ppm           Input: pointer to primordial structure
 * @param pfo           Input: pointer to fourier structure
 * @param index_pk      Input: index of required P(k) type (_m, _cb)
 * @param index_tau     Input: index of time
 * @param k_size        Input: wavenumber array size
 * @param lnpk         Output: log of matter power spectrum for given type/time, for all wavenumbers
 * @param lnpk_ic      Output: log of matter power spectrum for given type/time, for all wavenumbers and initial conditions
 * @return the error status
 */

int fourier_pk_linear(
                      struct background *pba,
                      struct perturbations *ppt,
                      struct primordial *ppm,
                      struct fourier *pfo,
                      int index_pk,
                      int index_tau,
                      int k_size,
                      double * lnpk,    //lnpk[index_k]
                      double * lnpk_ic  //lnpk[index_k * pfo->ic_ic_size + index_ic1_ic2]
                      ) {

  int index_k;
  int index_tp;
  int index_ic1,index_ic2,index_ic1_ic1,index_ic1_ic2,index_ic2_ic2;
  double * primordial_pk;
  double pk;
  double * pk_ic;
  double source_ic1;
  double source_ic2;
  double cosine_correlation;

  /** - allocate temporary vector where the primordial spectrum will be stored */

  class_alloc(primordial_pk,pfo->ic_ic_size*sizeof(double),pfo->error_message);

  class_alloc(pk_ic,pfo->ic_ic_size*sizeof(double),pfo->error_message);

  if ((pfo->has_pk_m == _TRUE_) && (index_pk == pfo->index_pk_m)) {
    index_tp = ppt->index_tp_delta_m;
  }
  else if ((pfo->has_pk_cb == _TRUE_) && (index_pk == pfo->index_pk_cb)) {
    index_tp = ppt->index_tp_delta_cb;
  }
  else {
    class_stop(pfo->error_message,"P(k) is set neither to total matter nor to cold dark matter + baryons");
  }

  /** - loop over k values */

  for (index_k=0; index_k<k_size; index_k++) {

    /** --> get primordial spectrum */
    class_call(primordial_spectrum_at_k(ppm,pfo->index_md_scalars,logarithmic,pfo->ln_k[index_k],primordial_pk),
               ppm->error_message,
               pfo->error_message);

    /** --> initialize a local variable for P_m(k) and P_cb(k) to zero */
    pk = 0.;

    /** --> here we recall the relations relevant for the nomalization fo the power spectrum:
        For adiabatic modes, the curvature primordial spectrum thnat we just read was:
        P_R(k) = 1/(2pi^2) k^3 < R R >
        Thus the primordial curvature correlator is given by:
        < R R > = (2pi^2) k^-3 P_R(k)
        So the delta_m correlator reads:
        P(k) = < delta_m delta_m > = (source_m)^2 < R R > = (2pi^2) k^-3 (source_m)^2 P_R(k)

        For isocurvature or cross adiabatic-isocurvature parts,
        one would just replace one or two 'R' by 'S_i's */

    /** --> get contributions to P(k) diagonal in the initial conditions */
    for (index_ic1 = 0; index_ic1 < pfo->ic_size; index_ic1++) {

      index_ic1_ic1 = index_symmetric_matrix(index_ic1,index_ic1,pfo->ic_size);

      class_call(fourier_get_source(pba,
                                    ppt,
                                    pfo,
                                    index_k,
                                    index_ic1,
                                    index_tp,
                                    index_tau,
                                    ppt->sources[pfo->index_md_scalars],
                                    &source_ic1),
                 pfo->error_message,
                 pfo->error_message);

      pk_ic[index_ic1_ic1] = 2.*_PI_*_PI_/exp(3.*pfo->ln_k[index_k])
        *source_ic1*source_ic1
        *exp(primordial_pk[index_ic1_ic1]);

      pk += pk_ic[index_ic1_ic1];

      if (lnpk_ic != NULL) {
        lnpk_ic[index_k * pfo->ic_ic_size + index_ic1_ic1] = log(pk_ic[index_ic1_ic1]);
      }
    }

    /** --> get contributions to P(k) non-diagonal in the initial conditions */
    for (index_ic1 = 0; index_ic1 < pfo->ic_size; index_ic1++) {
      for (index_ic2 = index_ic1+1; index_ic2 < pfo->ic_size; index_ic2++) {

        index_ic1_ic2 = index_symmetric_matrix(index_ic1,index_ic2,pfo->ic_size);
        index_ic1_ic1 = index_symmetric_matrix(index_ic1,index_ic1,pfo->ic_size);
        index_ic2_ic2 = index_symmetric_matrix(index_ic2,index_ic2,pfo->ic_size);

        if (pfo->is_non_zero[index_ic1_ic2] == _TRUE_) {

          class_call(fourier_get_source(pba,
                                        ppt,
                                        pfo,
                                        index_k,
                                        index_ic1,
                                        index_tp,
                                        index_tau,
                                        ppt->sources[pfo->index_md_scalars],
                                        &source_ic1),
                     pfo->error_message,
                     pfo->error_message);

          class_call(fourier_get_source(pba,
                                        ppt,
                                        pfo,
                                        index_k,
                                        index_ic2,
                                        index_tp,
                                        index_tau,
                                        ppt->sources[pfo->index_md_scalars],
                                        &source_ic2),
                     pfo->error_message,
                     pfo->error_message);

          cosine_correlation = primordial_pk[index_ic1_ic2]*SIGN(source_ic1)*SIGN(source_ic2);

          pk_ic[index_ic1_ic2] = cosine_correlation * sqrt(pk_ic[index_ic1_ic1]*pk_ic[index_ic2_ic2]);

          pk += 2.*pk_ic[index_ic1_ic2];

          if (lnpk_ic != NULL) {
            lnpk_ic[index_k * pfo->ic_ic_size + index_ic1_ic2] = cosine_correlation;
          }
        }
        else {
          if (lnpk_ic != NULL) {
            lnpk_ic[index_k * pfo->ic_ic_size + index_ic1_ic2] = 0.;
          }
        }
      }
    }

    lnpk[index_k] = log(pk);
  }

  free(primordial_pk);
  free(pk_ic);

  return _SUCCESS_;

}

/**
 * Calculate intermediate quantities for hmcode (sigma, sigma', ...)
 * for a given scale R and a given input P(k).
 *
 * This function has several differences w.r.t. the standard external
 * function non_linear_sigma (format of input, of output, integration
 * stepsize, management of extrapolation at large k, ...) and is
 * overall more precise for sigma(R).
 *
 * @param pfo          Input: pointer to fourier structure
 * @param R            Input: scale at which to compute sigma
 * @param lnpk_l       Input: array of ln(P(k))
 * @param ddlnpk_l     Input: its spline along k
 * @param k_size       Input: dimension of array lnpk_l, normally pfo->k_size, but inside hmcode it its increased by extrapolation to pfo->k_extra_size
 * @param k_per_decade Input: logarithmic step for the integral (recommended: pass ppr->sigma_k_per_decade)
 * @param sigma_output Input: quantity to be computed (sigma, sigma', ...)
 * @param result       Output: result
 * @return the error status
 */

int fourier_sigmas(
                   struct fourier * pfo,
                   double R,
                   double * lnpk_l,
                   double * ddlnpk_l,
                   int k_size,
                   double k_per_decade,
                   enum out_sigmas sigma_output,
                   double * result
                   ) {
  double pk, lnpk;

  double * array_for_sigma;
  int index_num;
  int index_x;
  int index_y;
  int index_ddy;
  int i=0;
  int integrand_size;
  int last_index=0;

  double k,W,W_prime,x,t;

  /** - allocate temporary array for an integral over y(x) */

  class_define_index(index_x,  _TRUE_,i,1); // index for x
  class_define_index(index_y,  _TRUE_,i,1); // index for integrand
  class_define_index(index_ddy,_TRUE_,i,1); // index for its second derivative (spline method)
  index_num=i;                              // number of columns in the array

  integrand_size=(int)(log(pfo->k[k_size-1]/pfo->k[0])/log(10.)*k_per_decade)+1;
  class_alloc(array_for_sigma,
              integrand_size*index_num*sizeof(double),
              pfo->error_message);

  /** - fill the array with values of k and of the integrand */

  for (i=0; i<integrand_size; i++) {

    k=pfo->k[0]*pow(10.,i/k_per_decade);

    if (i==0) {
      pk = exp(lnpk_l[0]);
    }
    else {
      class_call(array_interpolate_spline(
                                          pfo->ln_k,
                                          k_size,
                                          lnpk_l,
                                          ddlnpk_l,
                                          1,
                                          log(k),
                                          &last_index,
                                          &lnpk,
                                          1,
                                          pfo->error_message),
                 pfo->error_message,
                 pfo->error_message);

      pk = exp(lnpk);
    }

    t = 1./(1.+k);
    if (i == (integrand_size-1)) k *= 0.9999999; // to prevent rounding error leading to k being bigger than maximum value
    x=k*R;

    switch (sigma_output) {

    case out_sigma:
      if (x<0.01)
        W = 1.-x*x/10.;
      else
        W = 3./x/x/x*(sin(x)-x*cos(x));
      array_for_sigma[(integrand_size-1-i)*index_num+index_x] = t;
      array_for_sigma[(integrand_size-1-i)*index_num+index_y] = k*k*k*pk*W*W/(t*(1.-t));
      break;

    case out_sigma_prime:
      if (x<0.01) {
        W = 1.-x*x/10.;
        W_prime = -0.2*x;
      }
      else {
        W = 3./x/x/x*(sin(x)-x*cos(x));
        W_prime = 3./x/x*sin(x)-9./x/x/x/x*(sin(x)-x*cos(x));
      }
      array_for_sigma[(integrand_size-1-i)*index_num+index_x] = t;
      array_for_sigma[(integrand_size-1-i)*index_num+index_y] = k*k*k*pk*2.*k*W*W_prime/(t*(1.-t));
      break;

    case out_sigma_disp:
      if (x<0.01)
        W = 1.-x*x/10.;
      else
        W = 3./x/x/x*(sin(x)-x*cos(x));
      array_for_sigma[(integrand_size-1-i)*index_num+index_x] = k;
      array_for_sigma[(integrand_size-1-i)*index_num+index_y] = -pk*W*W;
      break;
    }
  }

  /** - spline the integrand */

  class_call(array_spline(array_for_sigma,
                          index_num,
                          integrand_size,
                          index_x,
                          index_y,
                          index_ddy,
                          _SPLINE_EST_DERIV_,
                          pfo->error_message),
             pfo->error_message,
             pfo->error_message);

  /** - integrate */

  class_call(array_integrate_all_trapzd_or_spline(array_for_sigma,
                                                  index_num,
                                                  integrand_size,
                                                  0, //integrand_size-1,
                                                  index_x,
                                                  index_y,
                                                  index_ddy,
                                                  result,
                                                  pfo->error_message),
             pfo->error_message,
             pfo->error_message);

  /** - preperly normalize the final result */

  switch (sigma_output) {

  case out_sigma:
    *result = sqrt(*result/(2.*_PI_*_PI_));
    break;

  case out_sigma_prime:
    *result = *result/(2.*_PI_*_PI_);
    break;

  case out_sigma_disp:
    *result = sqrt(*result/(2.*_PI_*_PI_*3.));
    break;
  }

  /** - free allocated array */

  free(array_for_sigma);

  return _SUCCESS_;
}

/**
 * This routine computes the variance of density fluctuations in a
 * sphere of radius R at redshift z, sigma(R,z) for one given pk type (_m, _cb).
 *
 * Try to use instead fourier_sigmas_at_z(). This function is just
 * maintained for compatibility with the deprecated function
 * harmonic_sigma()
 *
 * The integral is performed until the maximum value of k_max defined
 * in the perturbation module. Here there is not automatic checking
 * that k_max is large enough for the result to be well
 * converged. E.g. to get an accurate sigma8 at R = 8 Mpc/h, the user
 * should pass at least about P_k_max_h/Mpc = 1.
 *
 * @param pba          Input: pointer to background structure
 * @param pfo          Input: pointer to fourier structure
 * @param R            Input: radius in Mpc
 * @param z            Input: redshift
 * @param index_pk     Input: type of pk (_m, _cb)
 * @param k_per_decade Input: logarithmic step for the integral (recommended: pass ppr->sigma_k_per_decade)
 * @param result       Output: result
 * @return the error status
 */

int fourier_sigma_at_z(
                       struct background * pba,
                       struct fourier * pfo,
                       double R,
                       double z,
                       int index_pk,
                       double k_per_decade,
                       double * result
                       ) {

  double * out_pk;
  double * ddout_pk;

  /** - allocate temporary array for P(k,z) as a function of k */

  class_alloc(out_pk, pfo->k_size*sizeof(double), pfo->error_message);
  class_alloc(ddout_pk, pfo->k_size*sizeof(double), pfo->error_message);

  /** - get P(k,z) as a function of k, for the right z */

  class_call(fourier_pk_at_z(pba,
                             pfo,
                             logarithmic,
                             pk_linear,
                             z,
                             index_pk,
                             out_pk,
                             NULL),
             pfo->error_message,
             pfo->error_message);

  /** - spline it along k */

  class_call(array_spline_table_columns(pfo->ln_k,
                                        pfo->k_size,
                                        out_pk,
                                        1,
                                        ddout_pk,
                                        _SPLINE_EST_DERIV_,
                                        pfo->error_message),
             pfo->error_message,
             pfo->error_message);

  /** - calll the function computing the sigmas */

  class_call(fourier_sigmas(pfo,
                            R,
                            out_pk,
                            ddout_pk,
                            pfo->k_size,
                            k_per_decade,
                            out_sigma,
                            result),
             pfo->error_message,
             pfo->error_message);

  /** - free allocated arrays */

  free(out_pk);
  free(ddout_pk);

  return _SUCCESS_;
}

/**
 * Calculation of the nonlinear matter power spectrum with Halofit
 * (includes Takahashi 2012 + Bird 2013 revisions).
 *
 * At high redshift it is possible that the non-linear corrections are
 * so small that they can be computed only by going to very large
 * wavenumbers. Thius, for some combination of (z, k_max), the
 * calculation is not possible. In this case a _FALSE_ will be
 * returned in the flag halofit_found_k_max.
 *
 * @param ppr         Input: pointer to precision structure
 * @param pba         Input: pointer to background structure
 * @param ppt         Input: pointer to perturbation structure
 * @param ppm         Input: pointer to primordial structure
 * @param pfo         Input: pointer to fourier structure
 * @param index_pk    Input: index of component are we looking at (total matter or cdm+baryons?)
 * @param tau         Input: conformal time at which we want to do the calculation
 * @param pk_nl       Output: non linear spectrum at the relevant time
 * @param lnpk_l      Input: array of log(P(k)_linear)
 * @param ddlnpk_l    Input: array of second derivative of log(P(k)_linear) wrt k, for spline interpolation
 * @param k_nl        Output: non-linear wavenumber
 * @param nl_corr_not_computable_at_this_k Ouput: flag concerning the status of the calculation (_TRUE_ if not possible)
 * @return the error status
 */

int fourier_halofit(
                    struct precision *ppr,
                    struct background *pba,
                    struct perturbations *ppt,
                    struct primordial *ppm,
                    struct fourier *pfo,
                    int index_pk,
                    double tau,
                    double *pk_nl,
                    double *lnpk_l,
                    double *ddlnpk_l,
                    double *k_nl,
                    short * nl_corr_not_computable_at_this_k
                    ) {

  double Omega_m,Omega_v,fnu,w, dw_over_da_fld, integral_fld;

  /** Determine non linear ratios (from pk) **/

  int index_k;
  double pk_lin,pk_quasi,pk_halo,rk;
  double sigma,rknl,rneff,rncur,d1,d2;
  double diff,xlogr1,xlogr2,rmid;

  double gam,a,b,c,xmu,xnu,alpha,beta,f1,f2,f3;
  double pk_linaa;
  double y;
  double f1a,f2a,f3a,f1b,f2b,f3b,frac;

  double * pvecback;

  int last_index=0;
  int counter;
  double sum1,sum2,sum3;
  double anorm;

  double *integrand_array;
  int integrand_size;
  int index_ia_k;
  int index_ia_pk;
  int index_ia_sum;
  int index_ia_ddsum;
  /*
    int index_ia_sum2;
    int index_ia_ddsum2;
    int index_ia_sum3;
    int index_ia_ddsum3;
  */
  int ia_size;
  int index_ia;

  double k_integrand;
  double lnpk_integrand;

  double R;

  double * w_and_Omega;

  class_alloc(pvecback,pba->bg_size*sizeof(double),pfo->error_message);

  if ((pfo->has_pk_m == _TRUE_) && (index_pk == pfo->index_pk_m)) {
    fnu = pba->Omega0_ncdm_tot/pba->Omega0_m;
  }
  else if ((pfo->has_pk_cb == _TRUE_) && (index_pk == pfo->index_pk_cb)) {
    fnu = 0.;
  }
  else {
    class_stop(pfo->error_message,"P(k) is set neither to total matter nor to cold dark matter + baryons");
  }

  if (pfo->has_pk_eq == _FALSE_) {

    /* default method: compute w(tau) = w_fld(tau), Omega_m(tau) and Omega_v=Omega_DE(tau), all required by HALOFIT fitting formulas */

    class_call(background_at_tau(pba,tau,long_info,inter_normal,&last_index,pvecback),
               pba->error_message,
               pfo->error_message);

    Omega_m = pvecback[pba->index_bg_Omega_m];
    Omega_v = 1.-pvecback[pba->index_bg_Omega_m]-pvecback[pba->index_bg_Omega_r];
    /* until v2.9.3 this function was called at a_0=1 instead of a=pvecback[pba->index_bg_a] */
    class_call(background_w_fld(pba,pvecback[pba->index_bg_a],&w,&dw_over_da_fld,&integral_fld), pba->error_message, pfo->error_message);

  }
  else {

    /* alternative method called Pk_equal, described in 0810.0190 and
       1601.07230, extending the range of validity of
       HALOFIT from constant w to (w0,wa) models. In that
       case, some effective values of w(tau_i) and
       Omega_m(tau_i) have been pre-computed in the
       input module, and we just ned to interpolate
       within tabulated arrays, to get them at the
       current tau value. */

    class_alloc(w_and_Omega,pfo->pk_eq_size*sizeof(double),pfo->error_message);

    class_call(array_interpolate_spline(
                                        pfo->pk_eq_tau,
                                        pfo->pk_eq_tau_size,
                                        pfo->pk_eq_w_and_Omega,
                                        pfo->pk_eq_ddw_and_ddOmega,
                                        pfo->pk_eq_size,
                                        tau,
                                        &last_index,
                                        w_and_Omega,
                                        pfo->pk_eq_size,
                                        pfo->error_message),
               pfo->error_message,
               pfo->error_message);

    w = w_and_Omega[pfo->index_pk_eq_w];
    Omega_m = w_and_Omega[pfo->index_pk_eq_Omega_m];
    Omega_v = 1.-Omega_m;

    free(w_and_Omega);
  }

  anorm    = 1./(2*pow(_PI_,2));

  /*      Until the 17.02.2015 the values of k used for integrating sigma(R) quantities needed by Halofit where the same as in the perturbation module.
          Since then, we sample these integrals on more values, in order to get more precise integrals (thanks Matteo Zennaro for noticing the need for this).

          We create a temporary integrand_array which columns will be:
          - k in 1/Mpc
          - just linear P(k) in Mpc**3
          - 1/(2(pi**2)) P(k) k**2 exp(-(kR)**2) or 1/(2(pi**2)) P(k) k**2 2 (kR) exp(-(kR)**2) or 1/(2(pi**2)) P(k) k**2 4 (kR)(1-kR) exp(-(kR)**2)
          - second derivative of previous line with spline
  */

  index_ia=0;
  class_define_index(index_ia_k,     _TRUE_,index_ia,1);
  class_define_index(index_ia_pk,    _TRUE_,index_ia,1);
  class_define_index(index_ia_sum,   _TRUE_,index_ia,1);
  class_define_index(index_ia_ddsum, _TRUE_,index_ia,1);
  ia_size = index_ia;

  integrand_size=(int)(log(pfo->k[pfo->k_size-1]/pfo->k[0])/log(10.)*ppr->halofit_k_per_decade)+1;

  class_alloc(integrand_array,integrand_size*ia_size*sizeof(double),pfo->error_message);


  /* we fill integrand_array with values of k and P(k) using interpolation */

  last_index=0;

  for (index_k=0; index_k < integrand_size; index_k++) {

    k_integrand=pfo->k[0]*pow(10.,index_k/ppr->halofit_k_per_decade);

    if (index_k ==0 ) {
      lnpk_integrand = lnpk_l[0];
    }
    else {

      class_call(array_interpolate_spline(
                                          pfo->ln_k,
                                          pfo->k_size,
                                          lnpk_l,
                                          ddlnpk_l,
                                          1,
                                          log(k_integrand),
                                          &last_index,
                                          &lnpk_integrand,
                                          1,
                                          pfo->error_message),
                 pfo->error_message,
                 pfo->error_message);
    }

    integrand_array[index_k*ia_size + index_ia_k] = k_integrand;
    integrand_array[index_k*ia_size + index_ia_pk] = exp(lnpk_integrand);

  }

  class_call(background_at_tau(pba,tau,long_info,inter_normal,&last_index,pvecback),
             pba->error_message,
             pfo->error_message);

  Omega_m = pvecback[pba->index_bg_Omega_m];
  Omega_v = 1.-pvecback[pba->index_bg_Omega_m]-pvecback[pba->index_bg_Omega_r];

  // for debugging:
  //printf("Call Halofit at z=%e\n",1./pvecback[pba->index_bg_a]-1.);

  /* minimum value of R such that the integral giving sigma_R is
     converged.  The parameter halofit_sigma_precision should be
     understood as follows: we trust our calculation of sigma(R) as
     long as the integral reaches a value k_max such that the factor
     exp(-(Rk_max)**2) is already as low as halofit_sigma_precisio,
     shoing that the integreal is converged.  In practise this
     condition is tested only for R_max, the highest value of R in our
     bisection algorithm. Hence a smaller value of
     halofit_sigma_precision will lead to a more precise halofit
     result at the *highest* redshift at which halofit can make
     computations, at the expense of requiring a larger k_max; but
     this parameter is not relevant for the precision on P_nl(k,z) at
     other redshifts, so there is normally no need to change i
  */

  R=sqrt(-log(ppr->halofit_sigma_precision))/integrand_array[(integrand_size-1)*ia_size + index_ia_k];

  class_call(fourier_halofit_integrate(
                                       pfo,
                                       integrand_array,
                                       integrand_size,
                                       ia_size,
                                       index_ia_k,
                                       index_ia_pk,
                                       index_ia_sum,
                                       index_ia_ddsum,
                                       R,
                                       halofit_integral_one,
                                       &sum1
                                       ),
             pfo->error_message,
             pfo->error_message);

  sigma  = sqrt(sum1);

  /* the following error should not stop the code: it will arrive
     inevitably at some large redshift, and then the code should not
     stop, but just give up computing P_NL(k,z). This is why we have a
     special error handling here (using class_test_except and free()
     commands to avoid memory leaks, and calling this whole function
     not through a class_call) */

  /*
    class_test_except(sigma < 1.,
    pfo->error_message,
    free(pvecback);free(integrand_array),
    "Your k_max=%g 1/Mpc is too small for Halofit to find the non-linearity scale z_nl at z=%g. Increase input parameter P_k_max_h/Mpc or P_k_max_1/Mpc",
    pfo->k[pfo->k_size-1],
    1./pvecback[pba->index_bg_a]-1.);
  */

  if (sigma < 1.) {
    * nl_corr_not_computable_at_this_k = _TRUE_;
    free(pvecback);
    free(integrand_array);
    return _SUCCESS_;
  }
  else {
    * nl_corr_not_computable_at_this_k = _FALSE_;
  }

  xlogr1 = log(R)/log(10.);

  /* maximum value of R in the bisection algorithm leading to the
     determination of R_nl.  For this value we can make a
     conservaitive guess: 1/halofit_min_k_nonlinear, where
     halofit_min_k_nonlinear is the minimum value of k at which we ask
     halofit to give us an estimate of P_nl(k,z). By assumption we
     treat all smaller k's as linear, so we know that
     sigma(1/halofit_min_k_nonlinear) must be <<1 (and if it is not
     the test below will alert us) */

  R=1./ppr->halofit_min_k_nonlinear;

  /* corresponding value of sigma_R */
  class_call(fourier_halofit_integrate(
                                       pfo,
                                       integrand_array,
                                       integrand_size,
                                       ia_size,
                                       index_ia_k,
                                       index_ia_pk,
                                       index_ia_sum,
                                       index_ia_ddsum,
                                       R,
                                       halofit_integral_one,
                                       &sum1
                                       ),
             pfo->error_message,
             pfo->error_message);

  sigma  = sqrt(sum1);

  class_test(sigma > 1.,
             pfo->error_message,
             "Your input value for the precision parameter halofit_min_k_nonlinear=%e is too large, such that sigma(R=1/halofit_min_k_nonlinear)=% > 1. For self-consistency, it should have been <1. Decrease halofit_min_k_nonlinear",
             ppr->halofit_min_k_nonlinear,sigma);

  xlogr2 = log(R)/log(10.);

  counter = 0;
  do {
    rmid = pow(10,(xlogr2+xlogr1)/2.0);
    counter ++;

    class_call(fourier_halofit_integrate(
                                         pfo,
                                         integrand_array,
                                         integrand_size,
                                         ia_size,
                                         index_ia_k,
                                         index_ia_pk,
                                         index_ia_sum,
                                         index_ia_ddsum,
                                         rmid,
                                         halofit_integral_one,
                                         &sum1
                                         ),
               pfo->error_message,
               pfo->error_message);

    sigma  = sqrt(sum1);

    diff = sigma - 1.0;

    if (diff > ppr->halofit_tol_sigma){
      xlogr1=log10(rmid);
    }
    else if (diff < -ppr->halofit_tol_sigma) {
      xlogr2 = log10(rmid);
    }

    /* The first version of this test woukld let the code continue: */
    /*
      class_test_except(counter > _MAX_IT_,
      pfo->error_message,
      free(pvecback);free(integrand_array),
      "could not converge within maximum allowed number of iterations");
    */
    /* ... but in this situation it sounds better to make it stop and return an error! */
    class_test(counter > _MAX_IT_,
               pfo->error_message,
               "could not converge within maximum allowed number of iterations");

  } while (fabs(diff) > ppr->halofit_tol_sigma);

  /* evaluate all the other integrals at R=rmid */

  class_call(fourier_halofit_integrate(
                                       pfo,
                                       integrand_array,
                                       integrand_size,
                                       ia_size,
                                       index_ia_k,
                                       index_ia_pk,
                                       index_ia_sum,
                                       index_ia_ddsum,
                                       rmid,
                                       halofit_integral_two,
                                       &sum2
                                       ),
             pfo->error_message,
             pfo->error_message);

  class_call(fourier_halofit_integrate(
                                       pfo,
                                       integrand_array,
                                       integrand_size,
                                       ia_size,
                                       index_ia_k,
                                       index_ia_pk,
                                       index_ia_sum,
                                       index_ia_ddsum,
                                       rmid,
                                       halofit_integral_three,
                                       &sum3
                                       ),
             pfo->error_message,
             pfo->error_message);

  sigma  = sqrt(sum1);
  d1 = -sum2/sum1;
  d2 = -sum2*sum2/sum1/sum1 - sum3/sum1;

  rknl  = 1./rmid;
  rneff = -3.-d1;
  rncur = -d2;

  *k_nl = rknl;

  for (index_k = 0; index_k < pfo->k_size; index_k++){

    rk = pfo->k[index_k];

    if (rk > ppr->halofit_min_k_nonlinear) {

      pk_lin = exp(lnpk_l[index_k])*pow(pfo->k[index_k],3)*anorm;

      /* in original halofit, this is the beginning of the function halofit() */

      /*SPB11: Standard halofit underestimates the power on the smallest
       * scales by a factor of two. Add an extra correction from the
       * simulations in Bird, Viel,Haehnelt 2011 which partially accounts for
       * this.*/
      /*SPB14: This version of halofit is an updated version of the fit to the massive neutrinos
       * based on the results of Takahashi 2012, (arXiv:1208.2701).
       */
      gam=0.1971-0.0843*rneff+0.8460*rncur;
      a=1.5222+2.8553*rneff+2.3706*rneff*rneff+0.9903*rneff*rneff*rneff+ 0.2250*rneff*rneff*rneff*rneff-0.6038*rncur+0.1749*Omega_v*(1.+w);
      a=pow(10,a);
      b=pow(10, (-0.5642+0.5864*rneff+0.5716*rneff*rneff-1.5474*rncur+0.2279*Omega_v*(1.+w)));
      c=pow(10, 0.3698+2.0404*rneff+0.8161*rneff*rneff+0.5869*rncur);
      xmu=0.;
      xnu=pow(10,5.2105+3.6902*rneff);
      alpha=fabs(6.0835+1.3373*rneff-0.1959*rneff*rneff-5.5274*rncur);
      beta=2.0379-0.7354*rneff+0.3157*pow(rneff,2)+1.2490*pow(rneff,3)+0.3980*pow(rneff,4)-0.1682*rncur + fnu*(1.081 + 0.395*pow(rneff,2));

      if (fabs(1-Omega_m)>0.01) { /*then omega evolution */
        f1a=pow(Omega_m,(-0.0732));
        f2a=pow(Omega_m,(-0.1423));
        f3a=pow(Omega_m,(0.0725));
        f1b=pow(Omega_m,(-0.0307));
        f2b=pow(Omega_m,(-0.0585));
        f3b=pow(Omega_m,(0.0743));
        frac=Omega_v/(1.-Omega_m);
        f1=frac*f1b + (1-frac)*f1a;
        f2=frac*f2b + (1-frac)*f2a;
        f3=frac*f3b + (1-frac)*f3a;
      }
      else {
        f1=1.;
        f2=1.;
        f3=1.;
      }

      y=(rk/rknl);
      pk_halo = a*pow(y,f1*3.)/(1.+b*pow(y,f2)+pow(f3*c*y,3.-gam));
      pk_halo=pk_halo/(1+xmu*pow(y,-1)+xnu*pow(y,-2))*(1+fnu*0.977);

      /* until v2.9.3 pk_halo did contain an additional correction
         coming from Simeon Bird: the last factor was
         (1+fnu*(0.977-18.015*(pba->Omega0_m-0.3))). It seems that Bird
         gave it up later in his CAMB implementation and thus we also
         removed it. */
      // rk is in 1/Mpc, 47.48and 1.5 in Mpc**-2, so we need an h**2 here (Credits Antonio J. Cuesta)
      pk_linaa=pk_lin*(1+fnu*47.48*pow(rk/pba->h,2)/(1+1.5*pow(rk/pba->h,2)));
      pk_quasi=pk_lin*pow((1+pk_linaa),beta)/(1+pk_linaa*alpha)*exp(-y/4.0-pow(y,2)/8.0);

      pk_nl[index_k] = (pk_halo+pk_quasi)/pow(pfo->k[index_k],3)/anorm;

      /* in original halofit, this is the end of the function halofit() */
    }
    else {
      pk_nl[index_k] = exp(lnpk_l[index_k]);
    }
  }

  free(pvecback);
  free(integrand_array);
  return _SUCCESS_;
}

/**
 * Internal routione of Halofit. In original Halofit, this is
 * equivalent to the function wint(). It performs convolutions of the
 * linear spectrum with two window functions.
 *
 * @param pfo             Input: pointer to non linear structure
 * @param integrand_array Input: array with k, P_L(k) values
 * @param integrand_size  Input: one dimension of that array
 * @param ia_size         Input: other dimension of that array
 * @param index_ia_k      Input: index for k
 * @param index_ia_pk     Input: index for pk
 * @param index_ia_sum    Input: index for the result
 * @param index_ia_ddsum  Input: index for its spline
 * @param R               Input: radius
 * @param type            Input: which window function to use
 * @param sum             Output: result of the integral
 * @return the error status
 */

int fourier_halofit_integrate(
                              struct fourier *pfo,
                              double * integrand_array,
                              int integrand_size,
                              int ia_size,
                              int index_ia_k,
                              int index_ia_pk,
                              int index_ia_sum,
                              int index_ia_ddsum,
                              double R,
                              enum halofit_integral_type type,
                              double * sum
                              ) {

  double k,pk,x2,integrand;
  int index_k;
  double anorm = 1./(2*pow(_PI_,2));

  for (index_k=0; index_k < integrand_size; index_k++) {
    k = integrand_array[index_k*ia_size + index_ia_k];
    pk = integrand_array[index_k*ia_size + index_ia_pk];
    x2 = k*k*R*R;

    integrand = pk*k*k*anorm*exp(-x2);
    if (type == halofit_integral_two) integrand *= 2.*x2;
    if (type == halofit_integral_three) integrand *= 4.*x2*(1.-x2);

    integrand_array[index_k*ia_size + index_ia_sum] = integrand;
  }

  /* fill in second derivatives */
  class_call(array_spline(integrand_array,
                          ia_size,
                          integrand_size,
                          index_ia_k,
                          index_ia_sum,
                          index_ia_ddsum,
                          _SPLINE_NATURAL_,
                          pfo->error_message),
             pfo->error_message,
             pfo->error_message);

  /* integrate */
  class_call(array_integrate_all_spline(integrand_array,
                                        ia_size,
                                        integrand_size,
                                        index_ia_k,
                                        index_ia_sum,
                                        index_ia_ddsum,
                                        sum,
                                        pfo->error_message),
             pfo->error_message,
             pfo->error_message);

  return _SUCCESS_;
}

/**
 * Computes the nonlinear correction on the linear power spectrum via
 * the method presented in Mead et al. 1505.07833
 *
 * @param ppr Input: pointer to precision structure
 * @param pba Input: pointer to background structure
 * @param ppt Input: pointer to perturbation structure
 * @param ppm Input: pointer to primordial structure
 * @param pfo Input: pointer to fourier structure
 * @param index_pk   Input: index of the pk type, either index_m or index_cb
 * @param index_tau  Input: index of tau, at which to compute the nl correction
 * @param tau        Input: tau, at which to compute the nl correction
 * @param pk_nl      Output:nonlinear power spectrum
 * @param lnpk_l     Input: logarithm of the linear power spectrum for both index_m and index_cb
 * @param ddlnpk_l   Input: spline of the logarithm of the linear power spectrum for both index_m and index_cb
 * @param nl_corr_not_computable_at_this_k Ouput: was the computation doable?
 * @param k_nl       Output: nonlinear scale for index_m and index_cb
 * @param pnw        Input/Output: pointer to nonlinear workspace
 * @return the error status
 */

int fourier_hmcode(
                   struct precision *ppr,
                   struct background *pba,
                   struct perturbations *ppt,
                   struct primordial *ppm,
                   struct fourier *pfo,
                   int index_pk,
                   int index_tau,
                   double tau,
                   double *pk_nl,
                   double **lnpk_l,
                   double **ddlnpk_l,
                   double *k_nl,
                   short * nl_corr_not_computable_at_this_k,
                   struct fourier_workspace * pnw
                   ) {

  /* integers */
  int index_mass, i, ng, nsig;
  int index_k, index_ncol;
  int last_index=0;
  int index_pk_cb;
  int counter, index_nl;

  int index_nu, index_cut;
  int index_y;
  int index_ddy;

  /* Background parameters */
  double Omega_m,fnu,Omega0_m;
  double z_at_tau;
  double rho_crit_today_in_msun_mpc3;
  double growth;
  double anorm;

  /* temporary numbers */
  double m, r, nu, sig, sigf;
  double diff, r1, r2;

  /* HMcode parameters */
  double mmin, mmax, nu_min;

  double sigma_disp, sigma_disp100, sigma8;
  double delta_c, Delta_v;
  double fraction;

  double sigma_nl, nu_nl, r_nl;
  double sigma_prime;
  double dlnsigdlnR;
  double n_eff;
  double alpha;

  double z_form, g_form;

  double eta;
  double gst, window_nfw;
  double nu_cut;
  double fac, k_star, fdamp;
  double pk_lin, pk_2h, pk_1h;

  /* data fields */
  double * pvecback;
  double * conc;
  double * mass;
  double * sigma_r;
  double * sigmaf_r;
  double * r_virial;
  double * r_real;
  double * nu_arr;

  double * p1h_integrand;


  /** include precision parameters that control the number of entries in the growth and sigma tables */
  ng = ppr->n_hmcode_tables;
  nsig = ppr->n_hmcode_tables;

  /** Compute background quantitites today */

  Omega0_m = pba->Omega0_m;
  fnu      = pba->Omega0_ncdm_tot/Omega0_m;

  /** If index_pk_cb, choose Omega0_cb as the matter density parameter.
   * If index_pk_m, choose Omega0_cbn as the matter density parameter. */
  if (index_pk==pfo->index_pk_cb){
    Omega0_m = Omega0_m - pba->Omega0_ncdm_tot;
  }

  anorm    = 1./(2*pow(_PI_,2));

  /** Call all the relevant background parameters at this tau */
  class_alloc(pvecback,pba->bg_size*sizeof(double),pfo->error_message);

  class_call(background_at_tau(pba,tau,long_info,inter_normal,&last_index,pvecback),
             pba->error_message,
             pfo->error_message);

  Omega_m = pvecback[pba->index_bg_Omega_m];//TBC (i.e. check if for P_cb here we should use Omega_cb) here the total time varying Omega_m is used for delta_c and for Delta_v according to the Mead fit of the Massara simulations.

  growth = pvecback[pba->index_bg_D];

  z_at_tau = 1./pvecback[pba->index_bg_a]-1.;

  /* The number below is the critical density today, rho_c = 3 * H0^2 / 8*pi*G, in units of M_sun over Mpc^3 */
  rho_crit_today_in_msun_mpc3 = 3.*pow(1.e5*pba->h, 2)/8./_PI_/_G_*_Mpc_over_m_/_M_SUN_;

  free(pvecback);

  /** Test whether pk_cb has to be taken into account (only if we have massive neutrinos)*/
  if (pba->has_ncdm==_TRUE_){
    index_pk_cb = pfo->index_pk_cb;
  }
  else {
    index_pk_cb = index_pk;
  }


  /** Get sigma(R=8 Mpc/h), sigma_disp(R=0), sigma_disp(R=100 Mpc/h) and write them into pfo structure */

  class_call(fourier_sigmas(pfo,
                            8./pba->h,
                            lnpk_l[index_pk],ddlnpk_l[index_pk],
                            pfo->k_size_extra,
                            ppr->sigma_k_per_decade,
                            out_sigma,
                            &sigma8),
             pfo->error_message,
             pfo->error_message);

  class_call(fourier_sigmas(pfo,
                            0.,
                            lnpk_l[index_pk],ddlnpk_l[index_pk],
                            pfo->k_size_extra,
                            ppr->sigma_k_per_decade,
                            out_sigma_disp,
                            &sigma_disp),
             pfo->error_message,
             pfo->error_message);

  class_call(fourier_sigmas(pfo,
                            100./pba->h,
                            lnpk_l[index_pk],ddlnpk_l[index_pk],
                            pfo->k_size_extra,
                            ppr->sigma_k_per_decade,
                            out_sigma_disp,
                            &sigma_disp100),
             pfo->error_message,
             pfo->error_message);

  pnw->sigma_8[index_pk][index_tau] = sigma8;
  pnw->sigma_disp[index_pk][index_tau] = sigma_disp;
  pnw->sigma_disp_100[index_pk][index_tau] = sigma_disp100;

  /** Initialisation steps for the 1-Halo Power Integral */
  mmin=ppr->mmin_for_p1h_integral/pba->h; //Minimum mass for integration; (unit conversion from  m[Msun/h] to m[Msun]  )
  mmax=ppr->mmax_for_p1h_integral/pba->h; //Maximum mass for integration;

  class_alloc(mass,ppr->nsteps_for_p1h_integral*sizeof(double),pfo->error_message);
  class_alloc(r_real,ppr->nsteps_for_p1h_integral*sizeof(double),pfo->error_message);
  class_alloc(r_virial,ppr->nsteps_for_p1h_integral*sizeof(double),pfo->error_message);
  class_alloc(sigma_r,ppr->nsteps_for_p1h_integral*sizeof(double),pfo->error_message);
  class_alloc(sigmaf_r,ppr->nsteps_for_p1h_integral*sizeof(double),pfo->error_message);
  class_alloc(nu_arr,ppr->nsteps_for_p1h_integral*sizeof(double),pfo->error_message);

  // Linear theory density perturbation threshold for spherical collapse
  delta_c = 1.59+0.0314*log(sigma8); //Mead et al. (2015; arXiv 1505.07833)
  delta_c = delta_c*(1.+0.0123*log10(Omega_m)); //Nakamura & Suto (1997) fitting formula for LCDM models (as in Mead 2016)
  delta_c = delta_c*(1.+0.262*fnu); //Mead et al. (2016; arXiv 1602.02154) neutrino addition

  // virialized overdensity
  Delta_v=418.*pow(Omega_m, -0.352); //Mead et al. (2015; arXiv 1505.07833)
  Delta_v=Delta_v*(1.+0.916*fnu); //Mead et al. (2016; arXiv 1602.02154) neutrino addition

  // mass or radius fraction respectively
  fraction = pow(0.01, 1./3.);

  /* Fill the arrays needed for the P1H Integral: mass, r_real, r_virial, nu_arr, sigma_r, sigmaf_r
   * The P1H Integral is an integral over nu=delta_c/sigma(M), where M is connected to R via R=(3M)/(4*pi*rho_m).
   * The Integrand is M*Window^2{nu(M)*k, Rv(M), c(M)}*f(nu) with the window being the fouriertransformed
   * NFW profile, Rv = R/Delta_v^(1/3) and Sheth-Thormen halo mass function f.
   * The halo concentration-mass-relation c(M) will be found later.  */

  for (index_mass=0;index_mass<ppr->nsteps_for_p1h_integral;index_mass++){

    m = exp(log(mmin)+log(mmax/mmin)*(index_mass)/(ppr->nsteps_for_p1h_integral-1));
    r = pow((3.*m/(4.*_PI_*rho_crit_today_in_msun_mpc3*Omega0_m)), (1./3.));
    mass[index_mass] = m;
    r_real[index_mass] = r;
    r_virial[index_mass] = r_real[index_mass]/pow(Delta_v, 1./3.);

    class_call(array_interpolate_spline(pnw->rtab,
                                        nsig,
                                        pnw->stab,
                                        pnw->ddstab,
                                        1,
                                        r,
                                        &last_index,
                                        &sig,
                                        1,
                                        pfo->error_message),
               pfo->error_message, pfo->error_message);

    class_call(array_interpolate_spline(pnw->rtab,
                                        nsig,
                                        pnw->stab,
                                        pnw->ddstab,
                                        1,
                                        r*fraction,
                                        &last_index,
                                        &sigf,
                                        1,
                                        pfo->error_message),
               pfo->error_message, pfo->error_message);

    nu=delta_c/sig;
    sigma_r[index_mass] = sig;
    sigmaf_r[index_mass] = sigf;
    nu_arr[index_mass] = nu;
  }

  /** find nonlinear scales k_nl and r_nl and the effective spectral index n_eff */
  nu_nl = 1.;
  nu_min = nu_arr[0];

  /* stop calculating the nonlinear correction if the nonlinear scale is not reached in the table: */
  if (nu_min > nu_nl) {
    if (pfo->fourier_verbose>0) fprintf(stdout, " -> [WARNING:] the minimum mass in the mass-table is too large to find the nonlinear scale at this redshift.\n   Decrease mmin_for_p1h_integral\n");
    * nl_corr_not_computable_at_this_k = _TRUE_;
    free(mass);
    free(r_real);
    free(r_virial);
    free(sigma_r);
    free(sigmaf_r);
    free(nu_arr);
    return _SUCCESS_;
  }

  /* make a first guess for the nonlinear scale */
  class_call(array_interpolate_two_arrays_one_column(
                                                     nu_arr,
                                                     r_real,
                                                     1,
                                                     0,
                                                     ppr->nsteps_for_p1h_integral,
                                                     nu_nl,
                                                     &r_nl,
                                                     pfo->error_message),
             pfo->error_message, pfo->error_message);

  class_call(array_search_bisect(ppr->nsteps_for_p1h_integral,nu_arr,nu_nl,&index_nl,pfo->error_message), pfo->error_message, pfo->error_message);

  r1 = r_real[index_nl-1];
  r2 = r_real[index_nl+2];

  /* // for debugging: (if it happens that r_nl is not between r1 and r2, which should never be the case)
     fprintf(stdout, "%e %e %e %e\n", r1, nu_arr[index_nl-1], r2, nu_arr[index_nl+2]);
  */

  /* do bisectional iteration between r1 and r2 to find the precise value of r_nl */
  counter = 0;
  do {
    r_nl = (r1+r2)/2.;
    counter ++;

    class_call(fourier_sigmas(pfo,
                              r_nl,
                              lnpk_l[index_pk_cb],ddlnpk_l[index_pk_cb],
                              pfo->k_size_extra,
                              ppr->sigma_k_per_decade,
                              out_sigma,
                              &sigma_nl),
               pfo->error_message, pfo->error_message);

    diff = sigma_nl - delta_c;

    if (diff > ppr->hmcode_tol_sigma){
      r1=r_nl;
    }
    else if (diff < -ppr->hmcode_tol_sigma) {
      r2 = r_nl;
    }

    class_test(counter > _MAX_IT_,
               pfo->error_message,
               "could not converge within maximum allowed number of iterations");

  } while (fabs(diff) > ppr->hmcode_tol_sigma);

  if (pfo->fourier_verbose>5){
    fprintf(stdout, "number of iterations for r_nl at z = %e: %d\n", z_at_tau, counter);
  }
  *k_nl = 1./r_nl;

  if (*k_nl > pfo->k[pfo->k_size-1]) {
    * nl_corr_not_computable_at_this_k = _TRUE_;
    free(mass);
    free(r_real);
    free(r_virial);
    free(sigma_r);
    free(sigmaf_r);
    free(nu_arr);
    return _SUCCESS_;
  }
  else {
    * nl_corr_not_computable_at_this_k = _FALSE_;
  }

  /* call sigma_prime function at r_nl to find the effective spectral index n_eff */

  class_call(fourier_sigmas(pfo,
                            r_nl,
                            lnpk_l[index_pk_cb],ddlnpk_l[index_pk_cb],
                            pfo->k_size_extra,
                            ppr->sigma_k_per_decade,
                            out_sigma_prime,
                            &sigma_prime),
             pfo->error_message,
             pfo->error_message);

  dlnsigdlnR = r_nl*pow(sigma_nl, -2)*sigma_prime;
  n_eff = -3.- dlnsigdlnR;
  alpha = 3.24*pow(1.85, n_eff);

  pnw->sigma_prime[index_pk][index_tau] = sigma_prime;

  /** Calculate halo concentration-mass relation conc(mass) (Bullock et al. 2001) */
  class_alloc(conc,ppr->nsteps_for_p1h_integral*sizeof(double),pfo->error_message);

  for (index_mass=0;index_mass<ppr->nsteps_for_p1h_integral;index_mass++){
    //find growth rate at formation
    g_form = delta_c*growth/sigmaf_r[index_mass];
    if (g_form > 1.) g_form = 1.;

    //
    class_call(array_interpolate_two_arrays_one_column(
                                                       pnw->growtable,
                                                       pnw->ztable,
                                                       1,
                                                       0,
                                                       ng,
                                                       g_form,
                                                       &z_form,
                                                       pfo->error_message),
               pfo->error_message, pfo->error_message);
    if (z_form < z_at_tau){
      conc[index_mass] = pfo->c_min;
    } else {
      conc[index_mass] = pfo->c_min*(1.+z_form)/(1.+z_at_tau)*pnw->dark_energy_correction;
    }
  }


  /** Compute the nonlinear correction */
  eta = pfo->eta_0 - 0.3*sigma8; // halo bloating parameter
  k_star=0.584/sigma_disp;   // Damping wavenumber of the 1-halo term at very large scales;
  fdamp = 0.0095*pow(sigma_disp100*pba->h, 1.37); // Damping factor for 2-halo term
  if (fdamp<1.e-3) fdamp=1.e-3;
  if (fdamp>0.99)  fdamp=0.99;

  /* the 1h integral contains the halo mass function proportional to exp(-nu^2).
   * To save time, the integration loop cuts, when nu exceeds a large value,
   * where the integrand is 0 anyhow. This cut index is found here. */
  nu_cut = 10.;
  if (nu_cut < nu_arr[ppr->nsteps_for_p1h_integral-1]){
    class_call(array_search_bisect(ppr->nsteps_for_p1h_integral,nu_arr,nu_cut,&index_cut,pfo->error_message), pfo->error_message, pfo->error_message);
  }
  else {
    index_cut = ppr->nsteps_for_p1h_integral;
  }

  i=0;
  index_nu=i;
  i++;
  index_y=i;
  i++;
  index_ddy=i;
  i++;
  index_ncol=i;

  for (index_k = 0; index_k < pfo->k_size; index_k++){

    class_alloc(p1h_integrand,index_cut*index_ncol*sizeof(double),pfo->error_message);

    pk_lin = exp(lnpk_l[index_pk][index_k])*pow(pfo->k[index_k],3)*anorm; //convert P_k to Delta_k^2

    for (index_mass=0; index_mass<index_cut; index_mass++){ //Calculates the integrand for the ph1 integral at all nu values
      //get the nu^eta-value of the window
      class_call(fourier_hmcode_window_nfw(
                                           pfo,
                                           pow(nu_arr[index_mass], eta)*pfo->k[index_k],
                                           r_virial[index_mass],
                                           conc[index_mass],
                                           &window_nfw),
                 pfo->error_message, pfo->error_message);
      //get the value of the halo mass function
      class_call(fourier_hmcode_halomassfunction(
                                                 nu_arr[index_mass],
                                                 &gst),
                 pfo->error_message, pfo->error_message);

      p1h_integrand[index_mass*index_ncol+index_nu] = nu_arr[index_mass];

      p1h_integrand[index_mass*index_ncol+index_y] = mass[index_mass]*gst*pow(window_nfw, 2.);
      //if ((tau==pba->conformal_age) && (index_k == 0)) {
      //fprintf(stdout, "%d %e %e\n", index_cut, p1h_integrand[index_mass*index_ncol+index_nu], p1h_integrand[index_mass*index_ncol+index_y]);
      //}
    }
    class_call(array_spline(p1h_integrand,
                            index_ncol,
                            index_cut,
                            index_nu,
                            index_y,
                            index_ddy,
                            _SPLINE_EST_DERIV_,
                            pfo->error_message),
               pfo->error_message,
               pfo->error_message);

    class_call(array_integrate_all_trapzd_or_spline(
                                                    p1h_integrand,
                                                    index_ncol,
                                                    index_cut,
                                                    index_cut-1, //0 or n-1
                                                    index_nu,
                                                    index_y,
                                                    index_ddy,
                                                    &pk_1h,
                                                    pfo->error_message),
               pfo->error_message,
               pfo->error_message);


    if (pow(pfo->k[index_k]/k_star, 2)>7.){
      fac = 0.;     //prevents problems if (k/k*)^2 is large
    }
    else{
      fac=exp(-pow((pfo->k[index_k]/k_star), 2.));
    }

    pk_1h = pk_1h*anorm*pow(pfo->k[index_k],3)*(1.-fac)/(rho_crit_today_in_msun_mpc3*Omega0_m);  // dimensionless power

    if (fdamp==0){
      pk_2h=pk_lin;
    }else{
      pk_2h=pk_lin*(1.-fdamp*pow(tanh(pfo->k[index_k]*sigma_disp/sqrt(fdamp)), 2.)); //dimensionless power
    }
    if (pk_2h<0.) pk_2h=0.;
    pk_nl[index_k] = pow((pow(pk_1h, alpha) + pow(pk_2h, alpha)), (1./alpha))/pow(pfo->k[index_k],3)/anorm; //converted back to P_k

    free(p1h_integrand);
  }

  // print parameter values
  if ((pfo->fourier_verbose > 1 && tau==pba->conformal_age) || pfo->fourier_verbose > 3){
    fprintf(stdout, " -> Parameters at redshift z = %e:\n", z_at_tau);
    fprintf(stdout, "    fnu:		%e\n", fnu);
    fprintf(stdout, "    sigd [Mpc/h]:	%e\n", sigma_disp*pba->h);
    fprintf(stdout, "    sigd100 [Mpc/h]:    %e\n", sigma_disp100*pba->h);
    fprintf(stdout, "    sigma8:		%e\n", sigma8);
    fprintf(stdout, "    nu min:		%e\n", nu_arr[0]);
    fprintf(stdout, "    nu max:		%e\n", nu_arr[ppr->nsteps_for_p1h_integral-1]);
    fprintf(stdout, "    r_v min [Mpc/h]:    %e\n", r_virial[0]*pba->h);
    fprintf(stdout, "    r_v max [Mpc/h]:    %e\n", r_virial[ppr->nsteps_for_p1h_integral-1]*pba->h);
    fprintf(stdout, "    r_nl [Mpc/h]:	%e\n", r_nl*pba->h);
    fprintf(stdout, "    k_nl [h/Mpc]:	%e\n", *k_nl/pba->h);
    fprintf(stdout, "    sigma_nl:		%e\n", sigma_nl/delta_c);
    fprintf(stdout, "    neff:		%e\n", n_eff);
    fprintf(stdout, "    c min:		%e\n", conc[ppr->nsteps_for_p1h_integral-1]);
    fprintf(stdout, "    c max:		%e\n", conc[0]);
    fprintf(stdout, "    Dv:			%e\n", Delta_v);
    fprintf(stdout, "    dc:			%e\n", delta_c);
    fprintf(stdout, "    eta:		%e\n", eta);
    fprintf(stdout, "    k*:			%e\n", k_star/pba->h);
    fprintf(stdout, "    Abary:		%e\n", pfo->c_min);
    fprintf(stdout, "    fdamp:		%e\n", fdamp);
    fprintf(stdout, "    alpha:		%e\n", alpha);
    fprintf(stdout, "    ksize, kmin, kmax:   %d, %e, %e\n", pfo->k_size, pfo->k[0]/pba->h, pfo->k[pfo->k_size-1]/pba->h);

  }

  free(conc);
  free(mass);
  free(r_real);
  free(r_virial);
  free(sigma_r);
  free(sigmaf_r);
  free(nu_arr);

  return _SUCCESS_;
}

/**
 * allocate and fill arrays of nonlinear workspace (currently used only by HMcode)
 *
 * @param ppr         Input: pointer to precision structure
 * @param pba         Input: pointer to background structure
 * @param pfo         Input: pointer to fourier structure
 * @param pnw         Output: pointer to nonlinear workspace
 * @return the error status
 */

int fourier_hmcode_workspace_init(
                                  struct precision *ppr,
                                  struct background *pba,
                                  struct fourier *pfo,
                                  struct fourier_workspace * pnw
                                  ){

  int ng;
  int index_pk;

  /** - allocate arrays of the nonlinear workspace */

  class_alloc(pnw->rtab,ppr->n_hmcode_tables*sizeof(double),pfo->error_message);
  class_alloc(pnw->stab,ppr->n_hmcode_tables*sizeof(double),pfo->error_message);
  class_alloc(pnw->ddstab,ppr->n_hmcode_tables*sizeof(double),pfo->error_message);

  ng = ppr->n_hmcode_tables;

  class_alloc(pnw->growtable,ng*sizeof(double),pfo->error_message);
  class_alloc(pnw->ztable,ng*sizeof(double),pfo->error_message);
  class_alloc(pnw->tautable,ng*sizeof(double),pfo->error_message);

  class_alloc(pnw->sigma_8,pfo->pk_size*sizeof(double *),pfo->error_message);
  class_alloc(pnw->sigma_disp,pfo->pk_size*sizeof(double *),pfo->error_message);
  class_alloc(pnw->sigma_disp_100,pfo->pk_size*sizeof(double *),pfo->error_message);
  class_alloc(pnw->sigma_prime,pfo->pk_size*sizeof(double *),pfo->error_message);

  for (index_pk=0; index_pk<pfo->pk_size; index_pk++){
    class_alloc(pnw->sigma_8[index_pk],pfo->tau_size*sizeof(double),pfo->error_message);
    class_alloc(pnw->sigma_disp[index_pk],pfo->tau_size*sizeof(double),pfo->error_message);
    class_alloc(pnw->sigma_disp_100[index_pk],pfo->tau_size*sizeof(double),pfo->error_message);
    class_alloc(pnw->sigma_prime[index_pk],pfo->tau_size*sizeof(double),pfo->error_message);
  }

  /** - fill table with scale independent growth factor */

  class_call(fourier_hmcode_fill_growtab(ppr,pba,pfo,pnw),
             pfo->error_message,
             pfo->error_message);

  return _SUCCESS_;
}

/**
 * deallocate arrays in the nonlinear worksapce (currently used only
 * by HMcode)
 *
 * @param pfo Input: pointer to fourier structure
 * @param pnw Input: pointer to nonlinear workspace
 * @return the error status
 */

int fourier_hmcode_workspace_free(
                                  struct fourier *pfo,
                                  struct fourier_workspace * pnw
                                  ) {
  int index_pk;

  free(pnw->rtab);
  free(pnw->stab);
  free(pnw->ddstab);

  free(pnw->growtable);
  free(pnw->ztable);
  free(pnw->tautable);

  for (index_pk=0; index_pk<pfo->pk_size; index_pk++){
    free(pnw->sigma_8[index_pk]);
    free(pnw->sigma_disp[index_pk]);
    free(pnw->sigma_disp_100[index_pk]);
    free(pnw->sigma_prime[index_pk]);
  }

  free(pnw->sigma_8);
  free(pnw->sigma_disp);
  free(pnw->sigma_disp_100);
  free(pnw->sigma_prime);

  return _SUCCESS_;
}

/**
 * set the HMcode dark energy correction (if w is not -1)
 *
 * @param ppr         Input: pointer to precision structure
 * @param pba         Input: pointer to background structure
 * @param pfo         Input: pointer to fourier structure
 * @param pnw         Output: pointer to nonlinear workspace
 * @return the error status
 */

int fourier_hmcode_dark_energy_correction(
                                          struct precision *ppr,
                                          struct background *pba,
                                          struct fourier *pfo,
                                          struct fourier_workspace * pnw
                                          ) {

  int last_index;
  double * pvecback;
  double tau_growth;
  double g_lcdm,g_wcdm;
  double w0,dw_over_da_fld,integral_fld;

  /** - if there is dynamical Dark Energy (w is not -1) modeled as a fluid */

  if (pba->has_fld==_TRUE_){

    class_alloc(pvecback,pba->bg_size*sizeof(double),pfo->error_message);

    class_call(background_tau_of_z(
                                   pba,
                                   pfo->z_infinity,
                                   &tau_growth
                                   ),
               pba->error_message,
               pfo->error_message);

    class_call(background_at_tau(pba,tau_growth,long_info,inter_normal,&last_index,pvecback),
               pba->error_message,
               pfo->error_message);

    class_call(background_w_fld(pba,1.,&w0,&dw_over_da_fld,&integral_fld),
               pba->error_message,
               pfo->error_message);

    class_call(fourier_hmcode_growint(ppr,pba,pfo,1./(1.+pfo->z_infinity),-1.,0.,&g_lcdm),
               pfo->error_message, pfo->error_message);

    class_call(fourier_hmcode_growint(ppr,pba,pfo,1./(1.+pfo->z_infinity),w0,dw_over_da_fld*(-1.),&g_wcdm),
               pfo->error_message,
               pfo->error_message);

    free(pvecback);

    pnw->dark_energy_correction = pow(g_wcdm/g_lcdm, 1.5);
  }

  /** - otherwise, we assume no dynamical Dark Energy (w is -1) */

  else {
    pnw->dark_energy_correction = 1.;
  }

  return _SUCCESS_;
}

/**
 * set the HMcode baryonic feedback parameters according to the chosen feedback model
 *
 * @param pfo   Output: pointer to fourier structure
 * @return the error status
 */

int fourier_hmcode_baryonic_feedback(
                                     struct fourier *pfo
                                     ) {

  switch (pfo->feedback) {

  case nl_emu_dmonly:
    {
      pfo->eta_0 = 0.603;
      pfo->c_min = 3.13;
      break;
    }

  case nl_owls_dmonly:
    {
      pfo->eta_0 = 0.64;
      pfo->c_min = 3.43;
      break;
    }

  case nl_owls_ref:
    {
      pfo->eta_0 = 0.68;
      pfo->c_min = 3.91;
      break;
    }

  case nl_owls_agn:
    {
      pfo->eta_0 = 0.76;
      pfo->c_min = 2.32;
      break;
    }

  case nl_owls_dblim:
    {
      pfo->eta_0 = 0.70;
      pfo->c_min = 3.01;
      break;
    }

  case nl_user_defined:
    {
      /* eta_0 and c_min already passed in input */
      break;
    }
  }
  return _SUCCESS_;
}

/**
 * Function that fills pnw->rtab, pnw->stab and pnw->ddstab with (r,
 * sigma, ddsigma) logarithmically spaced in r.  Called by
 * fourier_init at for all tau to account for scale-dependant growth
 * before fourier_hmcode is called
 *
 * @param ppr Input: pointer to precision structure
 * @param pba Input: pointer to background structure
 * @param ppt Input: pointer to perturbation structure
 * @param ppm Input: pointer to primordial structure
 * @param pfo Input: pointer to fourier structure
 * @param index_tau  Input: index of tau, at which to compute the nl correction
 * @param lnpk_l   Input: logarithm of the linear power spectrum for either index_m or index_cb
 * @param ddlnpk_l Input: spline of the logarithm of the linear power spectrum for either index_m or index_cb
 * @param pnw Output: pointer to nonlinear workspace
 * @return the error status
 */

int fourier_hmcode_fill_sigtab(
                               struct precision * ppr,
                               struct background * pba,
                               struct perturbations * ppt,
                               struct primordial * ppm,
                               struct fourier * pfo,
                               int index_tau,
                               double *lnpk_l,
                               double *ddlnpk_l,
                               struct fourier_workspace * pnw
                               ) {

  double r;
  double rmin, rmax;
  double sig;
  double * sigtab;
  int i, index_r, index_sig, index_ddsig, index_n, nsig;

  rmin = ppr->rmin_for_sigtab/pba->h;
  rmax = ppr->rmax_for_sigtab/pba->h;
  nsig = ppr->n_hmcode_tables;

  i=0;
  index_r=i;
  i++;
  index_sig=i;
  i++;
  index_ddsig=i;
  i++;
  index_n=i;

  class_alloc((sigtab),(nsig*index_n*sizeof(double)),pfo->error_message);

  for (i=0;i<nsig;i++){
    r=exp(log(rmin)+log(rmax/rmin)*i/(nsig-1));

    class_call(fourier_sigmas(pfo,
                              r,
                              lnpk_l,
                              ddlnpk_l,
                              pfo->k_size_extra,
                              ppr->sigma_k_per_decade,
                              out_sigma,
                              &sig),
               pfo->error_message,
               pfo->error_message);

    sigtab[i*index_n+index_r]=r;
    sigtab[i*index_n+index_sig]=sig;
  }

  class_call(array_spline(sigtab,
						  index_n,
						  nsig,
						  index_r,
						  index_sig,
						  index_ddsig,
						  _SPLINE_EST_DERIV_,
						  pfo->error_message),
             pfo->error_message,
             pfo->error_message);
  if (index_tau == pfo->tau_size-1){
    for (i=0;i<nsig;i++){
      pnw->rtab[i] = sigtab[i*index_n+index_r];
      pnw->stab[i] = sigtab[i*index_n+index_sig];
      pnw->ddstab[i] = sigtab[i*index_n+index_ddsig];
    }
  }
  else{
    for (i=0;i<nsig;i++){
      pnw->stab[i] = sigtab[i*index_n+index_sig];
      pnw->ddstab[i] = sigtab[i*index_n+index_ddsig];
    }
  }

  free(sigtab);

  return _SUCCESS_;
}


/**
 * Function that fills pnw->tautable and pnw->growtable with (tau, D(tau))
 * linearly spaced in scalefactor a.
 * Called by fourier_init at before the loop over tau
 *
 * @param ppr Input: pointer to precision structure
 * @param pba Input: pointer to background structure (will provide the scale independent growth factor)
 * @param pfo Input/Output: pointer to fourier structure
 * @param pnw Output: pointer to nonlinear workspace
 * @return the error status
 */

int fourier_hmcode_fill_growtab(
                                struct precision * ppr,
                                struct background * pba,
                                struct fourier * pfo,
                                struct fourier_workspace * pnw
                                ){

  double z, ainit, amax, scalefactor, tau_growth;
  int index_scalefactor, last_index, ng;
  double * pvecback;

  ng = ppr->n_hmcode_tables;
  ainit = ppr->ainit_for_growtab;
  amax = ppr->amax_for_growtab;

  last_index = 0;

  class_alloc(pvecback,pba->bg_size*sizeof(double),pfo->error_message);

  for (index_scalefactor=0;index_scalefactor<ng;index_scalefactor++){
    scalefactor = ainit+(amax-ainit)*(index_scalefactor)/(ng-1);
    z = 1./scalefactor-1.;

    pnw->ztable[index_scalefactor] = z;

    class_call(background_tau_of_z(
                                   pba,
                                   z,
                                   &tau_growth
                                   ),
               pba->error_message, pfo->error_message);

    pnw->tautable[index_scalefactor] = tau_growth;

    class_call(background_at_tau(pba,tau_growth,long_info,inter_normal,&last_index,pvecback),
               pba->error_message,
               pfo->error_message);

    pnw->growtable[index_scalefactor] = pvecback[pba->index_bg_D];

  }

  free(pvecback);

  return _SUCCESS_;
}

/**
 * This function finds the scale independent growth factor by
 * integrating the approximate relation d(lnD)/d(lna) =
 * Omega_m(z)^gamma by Linder & Cahn 2007
 *
 * @param ppr Input: pointer to precision structure
 * @param pba Input: pointer to background structure
 * @param pfo Input: pointer to fourier structure
 * @param a   Input: scalefactor
 * @param w0  Input: dark energy equation of state today
 * @param wa  Input: dark energy equation of state varying with a: w=w0+(1-a)wa
 * @param growth Output: scale independent growth factor at a
 * @return the error status
 */

int fourier_hmcode_growint(
                           struct precision * ppr,
                           struct background * pba,
                           struct fourier * pfo,
                           double a,
                           double w0,
                           double wa,
                           double * growth
                           ){

  double z, ainit, amax, scalefactor, gamma, X_de, Hubble2, Omega_m;
  int i, index_scalefactor, index_a, index_growth, index_ddgrowth, index_gcol, ng; // index_scalefactor is a running index while index_a is a column index
  double * pvecback;
  double * integrand;

  ng = 1024; // number of growth values (stepsize of the integral), should not be hardcoded and replaced by a precision parameter
  ainit = a;
  amax = 1.;

  i=0;
  index_a = i;
  i++;
  index_growth = i;
  i++;
  index_ddgrowth = i;
  i++;
  index_gcol = i;

  class_alloc(integrand,ng*index_gcol*sizeof(double),pfo->error_message);
  class_alloc(pvecback,pba->bg_size*sizeof(double),pfo->error_message);

  if (ainit == amax) {
    *growth = 1.;
  }
  else {

    for (index_scalefactor=0;index_scalefactor<ng;index_scalefactor++){

      scalefactor = ainit+(amax-ainit)*(index_scalefactor)/(ng-1);
      z = 1./scalefactor-1.;

      /* This will compute Omega_m(z) for the input values of w0 and wa, to let the user compare the wCDM and LCDM cases. This is why we cannot extract Omega_m(z) fromn the background module in this place. */
      X_de = pow(scalefactor, -3.*(1.+w0+wa))*exp(-3.*wa*(1.-scalefactor));
      Hubble2 = (pba->Omega0_m*pow((1.+z), 3.) + pba->Omega0_k*pow((1.+z), 2.) + pba->Omega0_de*X_de);
      Omega_m = (pba->Omega0_m*pow((1.+z), 3.))/Hubble2;
      /* Samuel brieden: TBC: check that the matching between the
         background quantity and this fitting formula improves by
         using Omega_cb (as it is done in background). Carefull:
         Hubble remains with Omega0_m */

      if (w0 == -1.){
        gamma = 0.55;
      }
      else if (w0 < -1.){
        gamma = 0.55+0.02*(1+w0);
      }
      else {
        gamma = 0.55+0.05*(1+w0);
      }
      integrand[index_scalefactor*index_gcol+index_a] = scalefactor;
      integrand[index_scalefactor*index_gcol+index_growth]= -pow(Omega_m, gamma)/scalefactor;
    }

    class_call(array_spline(integrand,
                            index_gcol,
                            ng,
                            index_a,
                            index_growth,
                            index_ddgrowth,
                            _SPLINE_EST_DERIV_,
                            pfo->error_message),
               pfo->error_message,
               pfo->error_message);

    class_call(array_integrate_all_trapzd_or_spline(integrand,
                                                    index_gcol,
                                                    ng,
                                                    0, //ng-1,
                                                    index_a,
                                                    index_growth,
                                                    index_ddgrowth,
                                                    growth,
                                                    pfo->error_message),
               pfo->error_message,
               pfo->error_message);

    *growth = exp(*growth);

  }
  //fprintf(stdout, "%e %e \n", a, *growth);
  free(pvecback);
  free(integrand);

  return _SUCCESS_;
}

/**
 * This is the fourier transform of the NFW density profile.
 *
 * @param pfo Input: pointer to fourier structure
 * @param k   Input: wave vector
 * @param rv  Input: virial radius
 * @param c   Input: concentration = rv/rs (with scale radius rs)
 * @param window_nfw Output: Window Function of the NFW profile
 * @return the error status
 */

int fourier_hmcode_window_nfw(
                              struct fourier * pfo,
                              double k,
                              double rv,
                              double c,
                              double *window_nfw
                              ){
  double si1, si2, ci1, ci2, ks;
  double p1, p2, p3;

  ks = k*rv/c;

  class_call(sine_integral(
                           ks*(1.+c),
                           &si2,
                           pfo->error_message
                           ),
             pfo->error_message, pfo->error_message);

  class_call(sine_integral(
                           ks,
                           &si1,
                           pfo->error_message
                           ),
             pfo->error_message, pfo->error_message);

  class_call(cosine_integral(
                             ks*(1.+c),
                             &ci2,
                             pfo->error_message
                             ),
             pfo->error_message, pfo->error_message);

  class_call(cosine_integral(
                             ks,
                             &ci1,
                             pfo->error_message
                             ),
             pfo->error_message, pfo->error_message);

  p1=cos(ks)*(ci2-ci1);
  p2=sin(ks)*(si2-si1);
  p3=sin(ks*c)/(ks*(1.+c));

  *window_nfw=p1+p2-p3;
  *window_nfw=*window_nfw/(log(1.+c)-c/(1.+c));

  return _SUCCESS_;
}

/**
 * This is the Sheth-Tormen halo mass function (1999, MNRAS, 308, 119)
 *
 * @param nu   Input: the \f$ \nu \f$ parameter that depends on the halo mass via \f$ \nu(M) = \delta_c/\sigma(M) \f$
 * @param hmf  Output: Value of the halo mass function at this \f$ \nu \f$
 * @return the error status
 */

int fourier_hmcode_halomassfunction(
                                    double nu,
                                    double * hmf
                                    ){

  double p, q, A;

  p=0.3;
  q=0.707;
  A=0.21616;

  *hmf=A*(1.+(pow(q*nu*nu, -p)))*exp(-q*nu*nu/2.);

  return _SUCCESS_;
}

/**
 * Compute sigma8(z)
 *
 * @param pba        Input: pointer to background structure
 * @param pfo        Input: pointer to fourier structure
 * @param z          Input: redshift
 * @param sigma_8    Output: sigma8(z)
 * @param sigma_8_cb Output: sigma8_cb(z)
 * @param pnw        Output: pointer to nonlinear workspace
 * @return the error status
 */

int fourier_hmcode_sigma8_at_z(
                               struct background *pba,
                               struct fourier * pfo,
                               double z,
                               double * sigma_8,
                               double * sigma_8_cb,
                               struct fourier_workspace * pnw
                               ) {

  double tau;

  class_call(background_tau_of_z(pba,
                                 z,
                                 &tau),
             pba->error_message,
             pfo->error_message);

  if (pfo->tau_size == 1) {
    *sigma_8 = pnw->sigma_8[pfo->index_pk_m][0];
  }
  else {
    class_call(array_interpolate_two(pfo->tau,
                                     1,
                                     0,
                                     pnw->sigma_8[pfo->index_pk_m],
                                     1,
                                     pfo->tau_size,
                                     tau,
                                     sigma_8,
                                     1,
                                     pfo->error_message),
               pfo->error_message,
               pfo->error_message);
  }


  if (pba->has_ncdm == _TRUE_){

    if (pfo->tau_size == 1) {
      *sigma_8_cb = pnw->sigma_8[pfo->index_pk_cb][0];
    }
    else {
      class_call(array_interpolate_two(pfo->tau,
                                       1,
                                       0,
                                       pnw->sigma_8[pfo->index_pk_cb],
                                       1,
                                       pfo->tau_size,
                                       tau,
                                       sigma_8_cb,
                                       1,
                                       pfo->error_message),
                 pfo->error_message,
                 pfo->error_message);
    }

  }
  else{
    *sigma_8_cb = *sigma_8;
  }



  return _SUCCESS_;
}

/**
 * Compute sigmadisp(z)
 *
 * @param pba           Input: pointer to background structure
 * @param pfo           Input: pointer to fourier structure
 * @param z             Input: redshift
 * @param sigma_disp    Output: sigmadisp(z)
 * @param sigma_disp_cb Output: sigmadisp_cb(z)
 * @param pnw           Output: pointer to nonlinear workspace
 * @return the error status
 */

int fourier_hmcode_sigmadisp_at_z(
                                  struct background *pba,
                                  struct fourier * pfo,
                                  double z,
                                  double * sigma_disp,
                                  double * sigma_disp_cb,
                                  struct fourier_workspace * pnw
                                  ) {

  double tau;

  class_call(background_tau_of_z(pba,
                                 z,
                                 &tau),
             pba->error_message,
             pfo->error_message);

  if (pfo->tau_size == 1) {
    *sigma_disp = pnw->sigma_disp[pfo->index_pk_m][0];
  }
  else {
    class_call(array_interpolate_two(pfo->tau,
                                     1,
                                     0,
                                     pnw->sigma_disp[pfo->index_pk_m],
                                     1,
                                     pfo->tau_size,
                                     tau,
                                     sigma_disp,
                                     1,
                                     pfo->error_message),
               pfo->error_message,
               pfo->error_message);
  }

  if (pba->has_ncdm == _TRUE_){

    if (pfo->tau_size == 1) {
      *sigma_disp_cb = pnw->sigma_disp[pfo->index_pk_cb][0];
    }
    else {
      class_call(array_interpolate_two(pfo->tau,
                                       1,
                                       0,
                                       pnw->sigma_disp[pfo->index_pk_cb],
                                       1,
                                       pfo->tau_size,
                                       tau,
                                       sigma_disp_cb,
                                       1,
                                       pfo->error_message),
                 pfo->error_message,
                 pfo->error_message);
    }

  }
  else{
    *sigma_disp_cb = *sigma_disp;
  }



  return _SUCCESS_;
}

/**
 * Compute sigmadisp100(z)
 *
 * @param pba               Input: pointer to background structure
 * @param pfo               Input: pointer to fourier structure
 * @param z                 Input: redshift
 * @param sigma_disp_100    Output: sigmadisp100(z)
 * @param sigma_disp_100_cb Output: sigmadisp100_cb(z)
 * @param pnw           Output: pointer to nonlinear workspace
 * @return the error status
 */

int fourier_hmcode_sigmadisp100_at_z(
                                     struct background *pba,
                                     struct fourier * pfo,
                                     double z,
                                     double * sigma_disp_100,
                                     double * sigma_disp_100_cb,
                                     struct fourier_workspace * pnw
                                     ) {

  double tau;

  class_call(background_tau_of_z(pba,
                                 z,
                                 &tau),
             pba->error_message,
             pfo->error_message);

  if (pfo->tau_size == 1) {
    *sigma_disp_100 = pnw->sigma_disp_100[pfo->index_pk_m][0];
  }
  else {
    class_call(array_interpolate_two(pfo->tau,
                                     1,
                                     0,
                                     pnw->sigma_disp_100[pfo->index_pk_m],
                                     1,
                                     pfo->tau_size,
                                     tau,
                                     sigma_disp_100,
                                     1,
                                     pfo->error_message),
               pfo->error_message,
               pfo->error_message);
  }

  if (pba->has_ncdm == _TRUE_){

    if (pfo->tau_size == 1) {
      *sigma_disp_100_cb = pnw->sigma_disp_100[pfo->index_pk_cb][0];
    }
    else {
      class_call(array_interpolate_two(pfo->tau,
                                       1,
                                       0,
                                       pnw->sigma_disp_100[pfo->index_pk_cb],
                                       1,
                                       pfo->tau_size,
                                       tau,
                                       sigma_disp_100_cb,
                                       1,
                                       pfo->error_message),
                 pfo->error_message,
                 pfo->error_message);
    }

  }
  else{
    *sigma_disp_100_cb = *sigma_disp_100;
  }


  return _SUCCESS_;
}

/**
 * Compute sigma'(z)
 *
 * @param pba            Input: pointer to background structure
 * @param pfo            Input: pointer to fourier structure
 * @param z              Input: redshift
 * @param sigma_prime    Output: sigma'(z)
 * @param sigma_prime_cb Output: sigma'_cb(z)
 * @param pnw            Output: pointer to nonlinear workspace
 * @return the error status
 */

int fourier_hmcode_sigmaprime_at_z(
                                   struct background *pba,
                                   struct fourier * pfo,
                                   double z,
                                   double * sigma_prime,
                                   double * sigma_prime_cb,
                                   struct fourier_workspace * pnw
                                   ) {

  double tau;

  class_call(background_tau_of_z(pba,
                                 z,
                                 &tau),
             pba->error_message,
             pfo->error_message);

  if (pfo->tau_size == 1) {
    *sigma_prime = pnw->sigma_prime[pfo->index_pk_m][0];
  }
  else {
    class_call(array_interpolate_two(pfo->tau,
                                     1,
                                     0,
                                     pnw->sigma_prime[pfo->index_pk_m],
                                     1,
                                     pfo->tau_size,
                                     tau,
                                     sigma_prime,
                                     1,
                                     pfo->error_message),
               pfo->error_message,
               pfo->error_message);
  }

  if (pba->has_ncdm == _TRUE_){

    if (pfo->tau_size == 1) {
      *sigma_prime_cb = pnw->sigma_prime[pfo->index_pk_cb][0];
    }
    else {
      class_call(array_interpolate_two(pfo->tau,
                                       1,
                                       0,
                                       pnw->sigma_prime[pfo->index_pk_cb],
                                       1,
                                       pfo->tau_size,
                                       tau,
                                       sigma_prime_cb,
                                       1,
                                       pfo->error_message),
                 pfo->error_message,
                 pfo->error_message);
    }

  }
  else{
    *sigma_prime_cb = *sigma_prime;
  }


  return _SUCCESS_;
}

```

`source/harmonic.c`:

```c
/** @file harmonic.c Documented harmonic module
 *
 * Julien Lesgourgues, 1.11.2019
 *
 * This module computes the harmonic power spectra \f$ C_l^{X} \f$'s
 * given the transfer functions and the primordial spectra.
 *
 * The following functions can be called from other modules:
 *
 * -# harmonic_init() at the beginning (but after transfer_init())
 * -# harmonic_cl_at_l() at any time for computing individual \f$ C_l \f$'s at any l
 * -# harmonic_free() at the end
 */

#include "harmonic.h"
#include "parallel.h"

/**
 * Anisotropy power spectra \f$ C_l\f$'s for all types, modes and initial conditions.
 * This routine evaluates all the \f$C_l\f$'s at a given value of l by
 * interpolating in the pre-computed table. When relevant, it also
 * sums over all initial conditions for each mode, and over all modes.
 *
 * This function can be
 * called from whatever module at whatever time, provided that
 * harmonic_init() has been called before, and harmonic_free() has not
 * been called yet.
 *
 * @param phr        Input: pointer to harmonic structure (containing pre-computed table)
 * @param l          Input: multipole number
 * @param cl_tot     Output: total \f$C_l\f$'s for all types (TT, TE, EE, etc..)
 * @param cl_md      Output: \f$C_l\f$'s for all types (TT, TE, EE, etc..) decomposed mode by mode (scalar, tensor, ...) when relevant
 * @param cl_md_ic   Output: \f$C_l\f$'s for all types (TT, TE, EE, etc..) decomposed by pairs of initial conditions (adiabatic, isocurvatures) for each mode (usually, only for the scalar mode) when relevant
 * @return the error status
 */

int harmonic_cl_at_l(
                     struct harmonic * phr,
                     double l,
                     double * cl_tot,    /* array with argument cl_tot[index_ct] (must be already allocated) */
                     double * * cl_md,   /* array with argument cl_md[index_md][index_ct] (must be already allocated only if several modes) */
                     double * * cl_md_ic /* array with argument cl_md_ic[index_md][index_ic1_ic2*phr->ct_size+index_ct] (must be already allocated for a given mode only if several ic's) */
                     ) {

  /** Summary: */

  /** - define local variables */

  int last_index;
  int index_md;
  int index_ic1,index_ic2,index_ic1_ic2;
  int index_ct;

  /** - (a) treat case in which there is only one mode and one initial condition.
      Then, only cl_tot needs to be filled. */

  if ((phr->md_size == 1) && (phr->ic_size[0] == 1)) {
    index_md = 0;
    if ((int)l <= phr->l[phr->l_size[index_md]-1]) {

      /* interpolate at l */
      class_call(array_interpolate_spline(phr->l,
                                          phr->l_size[index_md],
                                          phr->cl[index_md],
                                          phr->ddcl[index_md],
                                          phr->ct_size,
                                          l,
                                          &last_index,
                                          cl_tot,
                                          phr->ct_size,
                                          phr->error_message),
                 phr->error_message,
                 phr->error_message);

      /* set to zero for the types such that l<l_max */
      for (index_ct=0; index_ct<phr->ct_size; index_ct++)
        if ((int)l > phr->l_max_ct[index_md][index_ct])
          cl_tot[index_ct]=0.;
    }
    else {
      for (index_ct=0; index_ct<phr->ct_size; index_ct++)
        cl_tot[index_ct]=0.;
    }
  }

  /** - (b) treat case in which there is only one mode
      with several initial condition.
      Fill cl_md_ic[index_md=0] and sum it to get cl_tot. */

  if ((phr->md_size == 1) && (phr->ic_size[0] > 1)) {
    index_md = 0;
    for (index_ct=0; index_ct<phr->ct_size; index_ct++)
      cl_tot[index_ct]=0.;
    for (index_ic1 = 0; index_ic1 < phr->ic_size[index_md]; index_ic1++) {
      for (index_ic2 = index_ic1; index_ic2 < phr->ic_size[index_md]; index_ic2++) {
        index_ic1_ic2 = index_symmetric_matrix(index_ic1,index_ic2,phr->ic_size[index_md]);
        if (((int)l <= phr->l[phr->l_size[index_md]-1]) &&
            (phr->is_non_zero[index_md][index_ic1_ic2] == _TRUE_)) {

          class_call(array_interpolate_spline(phr->l,
                                              phr->l_size[index_md],
                                              phr->cl[index_md],
                                              phr->ddcl[index_md],
                                              phr->ic_ic_size[index_md]*phr->ct_size,
                                              l,
                                              &last_index,
                                              cl_md_ic[index_md],
                                              phr->ic_ic_size[index_md]*phr->ct_size,
                                              phr->error_message),
                     phr->error_message,
                     phr->error_message);

          for (index_ct=0; index_ct<phr->ct_size; index_ct++)
            if ((int)l > phr->l_max_ct[index_md][index_ct])
              cl_md_ic[index_md][index_ic1_ic2*phr->ct_size+index_ct]=0.;
        }
        else {
          for (index_ct=0; index_ct<phr->ct_size; index_ct++)
            cl_md_ic[index_md][index_ic1_ic2*phr->ct_size+index_ct]=0.;
        }

        /* compute cl_tot by summing over cl_md_ic */
        for (index_ct=0; index_ct<phr->ct_size; index_ct++) {
          if (index_ic1 == index_ic2)
            cl_tot[index_ct]+=cl_md_ic[index_md][index_ic1_ic2*phr->ct_size+index_ct];
          else
            cl_tot[index_ct]+=2.*cl_md_ic[index_md][index_ic1_ic2*phr->ct_size+index_ct];
        }
      }
    }
  }

  /** - (c) loop over modes */

  if (phr->md_size > 1) {

    for (index_ct=0; index_ct<phr->ct_size; index_ct++)
      cl_tot[index_ct]=0.;

    for (index_md = 0; index_md < phr->md_size; index_md++) {

      /** - --> (c.1.) treat case in which the mode under consideration
          has only one initial condition.
          Fill cl_md[index_md]. */

      if (phr->ic_size[index_md] == 1) {
        if ((int)l <= phr->l[phr->l_size[index_md]-1]) {

          class_call(array_interpolate_spline(phr->l,
                                              phr->l_size[index_md],
                                              phr->cl[index_md],
                                              phr->ddcl[index_md],
                                              phr->ct_size,
                                              l,
                                              &last_index,
                                              cl_md[index_md],
                                              phr->ct_size,
                                              phr->error_message),
                     phr->error_message,
                     phr->error_message);

          for (index_ct=0; index_ct<phr->ct_size; index_ct++)
            if ((int)l > phr->l_max_ct[index_md][index_ct])
              cl_md[index_md][index_ct]=0.;
        }
        else {
          for (index_ct=0; index_ct<phr->ct_size; index_ct++)
            cl_md[index_md][index_ct]=0.;
        }
      }

      /** - --> (c.2.) treat case in which the mode under consideration
          has several initial conditions.
          Fill cl_md_ic[index_md] and sum it to get cl_md[index_md] */

      if (phr->ic_size[index_md] > 1) {

        if ((int)l <= phr->l[phr->l_size[index_md]-1]) {

          /* interpolate all ic and ct */
          class_call(array_interpolate_spline(phr->l,
                                              phr->l_size[index_md],
                                              phr->cl[index_md],
                                              phr->ddcl[index_md],
                                              phr->ic_ic_size[index_md]*phr->ct_size,
                                              l,
                                              &last_index,
                                              cl_md_ic[index_md],
                                              phr->ic_ic_size[index_md]*phr->ct_size,
                                              phr->error_message),
                     phr->error_message,
                     phr->error_message);

          /* set to zero some of the components */
          for (index_ic1 = 0; index_ic1 < phr->ic_size[index_md]; index_ic1++) {
            for (index_ic2 = index_ic1; index_ic2 < phr->ic_size[index_md]; index_ic2++) {
              index_ic1_ic2 = index_symmetric_matrix(index_ic1,index_ic2,phr->ic_size[index_md]);
              for (index_ct=0; index_ct<phr->ct_size; index_ct++) {

                if (((int)l > phr->l_max_ct[index_md][index_ct]) || (phr->is_non_zero[index_md][index_ic1_ic2] == _FALSE_))
                  cl_md_ic[index_md][index_ic1_ic2*phr->ct_size+index_ct]=0.;
              }
            }
          }
        }
        /* if l was too big, set anyway all components to zero */
        else {
          for (index_ic1 = 0; index_ic1 < phr->ic_size[index_md]; index_ic1++) {
            for (index_ic2 = index_ic1; index_ic2 < phr->ic_size[index_md]; index_ic2++) {
              index_ic1_ic2 = index_symmetric_matrix(index_ic1,index_ic2,phr->ic_size[index_md]);
              for (index_ct=0; index_ct<phr->ct_size; index_ct++) {
                cl_md_ic[index_md][index_ic1_ic2*phr->ct_size+index_ct]=0.;
              }
            }
          }
        }

        /* sum up all ic for each mode */

        for (index_ct=0; index_ct<phr->ct_size; index_ct++) {

          cl_md[index_md][index_ct]=0.;

          for (index_ic1 = 0; index_ic1 < phr->ic_size[index_md]; index_ic1++) {
            for (index_ic2 = index_ic1; index_ic2 < phr->ic_size[index_md]; index_ic2++) {
              index_ic1_ic2 = index_symmetric_matrix(index_ic1,index_ic2,phr->ic_size[index_md]);

              if (index_ic1 == index_ic2)
                cl_md[index_md][index_ct]+=cl_md_ic[index_md][index_ic1_ic2*phr->ct_size+index_ct];
              else
                cl_md[index_md][index_ct]+=2.*cl_md_ic[index_md][index_ic1_ic2*phr->ct_size+index_ct];
            }
          }
        }
      }

      /** - --> (c.3.) add contribution of cl_md[index_md] to cl_tot */

      for (index_ct=0; index_ct<phr->ct_size; index_ct++)
        cl_tot[index_ct]+=cl_md[index_md][index_ct];
    }
  }

  return _SUCCESS_;

}

/**
 * This routine initializes the harmonic structure (in particular,
 * computes table of anisotropy and Fourier spectra \f$ C_l^{X}, P(k), ... \f$)
 *
 * @param ppr Input: pointer to precision structure
 * @param pba Input: pointer to background structure (will provide H, Omega_m at redshift of interest)
 * @param ppt Input: pointer to perturbation structure
 * @param ptr Input: pointer to transfer structure
 * @param ppm Input: pointer to primordial structure
 * @param pfo Input: pointer to fourier structure
 * @param phr Output: pointer to initialized harmonic structure
 * @return the error status
 */

int harmonic_init(
                  struct precision * ppr,
                  struct background * pba,
                  struct perturbations * ppt,
                  struct primordial * ppm,
                  struct fourier * pfo,
                  struct transfer * ptr,
                  struct harmonic * phr
                  ) {

  /** Summary: */

  /** - check that we really want to compute at least one spectrum */

  if (ppt->has_cls == _FALSE_) {
    phr->md_size = 0;
    if (phr->harmonic_verbose > 0)
      printf("No spectra requested. Spectra module skipped.\n");
    return _SUCCESS_;
  }
  else {
    if (phr->harmonic_verbose > 0)
      printf("Computing unlensed harmonic spectra\n");
  }

  /** - initialize indices and allocate some of the arrays in the
      harmonic structure */

  class_call(harmonic_indices(pba,ppt,ptr,ppm,phr),
             phr->error_message,
             phr->error_message);

  /** - deal with \f$ C_l\f$'s, if any */

  if (ppt->has_cls == _TRUE_) {

    class_call(harmonic_cls(ppr,pba,ppt,ptr,ppm,phr),
               phr->error_message,
               phr->error_message);

  }
  else {
    phr->ct_size=0;
  }

  /** - a pointer to the fourier structure is stored in the spectra
      structure. This odd, unusual and unelegant feature has been
      introduced in v2.8 in order to keep in use some deprecated
      functions harmonic_pk_...() that are now pointing at new
      function fourier_pk_...(). In the future, if the deprecated
      functions are removed, it will be possible to remove also this
      pointer. */

  phr->pfo = pfo;
  phr->is_allocated = _TRUE_;

  return _SUCCESS_;
}

/**
 * This routine frees all the memory space allocated by harmonic_init().
 *
 * To be called at the end of each run, only when no further calls to
 * harmonic_cls_at_l(), harmonic_pk_at_z(), harmonic_pk_at_k_and_z() are needed.
 *
 * @param phr Input: pointer to harmonic structure (which fields must be freed)
 * @return the error status
 */

int harmonic_free(
                  struct harmonic * phr
                  ) {

  int index_md;

  if (phr->md_size > 0) {
    if (phr->ct_size > 0) {

      for (index_md = 0; index_md < phr->md_size; index_md++) {
        free(phr->l_max_ct[index_md]);
        free(phr->cl[index_md]);
        free(phr->ddcl[index_md]);
      }
      free(phr->l);
      free(phr->l_size);
      free(phr->l_max_ct);
      free(phr->l_max);
      free(phr->cl);
      free(phr->ddcl);
    }

    for (index_md=0; index_md < phr->md_size; index_md++)
      free(phr->is_non_zero[index_md]);

    free(phr->is_non_zero);
    free(phr->ic_size);
    free(phr->ic_ic_size);

  }
  phr->is_allocated = _FALSE_;

  return _SUCCESS_;

}

/**
 * This routine defines indices and allocates tables in the harmonic structure
 *
 * @param pba  Input: pointer to background structure
 * @param ppt  Input: pointer to perturbation structure
 * @param ptr  Input: pointer to transfer structure
 * @param ppm  Input: pointer to primordial structure
 * @param phr  Input/output: pointer to harmonic structure
 * @return the error status
 */

int harmonic_indices(
                     struct background * pba,
                     struct perturbations * ppt,
                     struct transfer * ptr,
                     struct primordial * ppm,
                     struct harmonic * phr
                     ){

  int index_ct;
  int index_md;
  int index_ic1_ic2;

  phr->md_size = ppt->md_size;
  if (ppt->has_scalars == _TRUE_)
    phr->index_md_scalars = ppt->index_md_scalars;

  class_alloc(phr->ic_size,
              sizeof(int)*phr->md_size,
              phr->error_message);

  class_alloc(phr->ic_ic_size,
              sizeof(int)*phr->md_size,
              phr->error_message);

  class_alloc(phr->is_non_zero,
              sizeof(short *)*phr->md_size,
              phr->error_message);

  for (index_md=0; index_md < phr->md_size; index_md++) {
    phr->ic_size[index_md] = ppm->ic_size[index_md];
    phr->ic_ic_size[index_md] = ppm->ic_ic_size[index_md];
    class_alloc(phr->is_non_zero[index_md],
                sizeof(short)*phr->ic_ic_size[index_md],
                phr->error_message);
    for (index_ic1_ic2=0; index_ic1_ic2 < phr->ic_ic_size[index_md]; index_ic1_ic2++)
      phr->is_non_zero[index_md][index_ic1_ic2] = ppm->is_non_zero[index_md][index_ic1_ic2];
  }

  if (ppt->has_cls == _TRUE_) {

    /* types of C_l's relevant for both scalars and tensors: TT, EE, TE */

    index_ct=0;

    if (ppt->has_cl_cmb_temperature == _TRUE_) {
      phr->has_tt = _TRUE_;
      phr->index_ct_tt=index_ct;
      index_ct++;
    }
    else {
      phr->has_tt = _FALSE_;
    }

    if (ppt->has_cl_cmb_polarization == _TRUE_) {
      phr->has_ee = _TRUE_;
      phr->index_ct_ee=index_ct;
      index_ct++;
    }
    else {
      phr->has_ee = _FALSE_;
    }

    if ((ppt->has_cl_cmb_temperature == _TRUE_) &&
        (ppt->has_cl_cmb_polarization == _TRUE_)) {
      phr->has_te = _TRUE_;
      phr->index_ct_te=index_ct;
      index_ct++;
    }
    else {
      phr->has_te = _FALSE_;
    }

    if (ppt->has_cl_cmb_polarization == _TRUE_) {
      phr->has_bb = _TRUE_;
      phr->index_ct_bb=index_ct;
      index_ct++;
    }
    else {
      phr->has_bb = _FALSE_;
    }

    /* types of C_l's relevant only for scalars: phi-phi, T-phi, E-phi, d-d, T-d */

    if ((ppt->has_cl_cmb_lensing_potential == _TRUE_) && (ppt->has_scalars == _TRUE_)) {
      phr->has_pp = _TRUE_;
      phr->index_ct_pp=index_ct;
      index_ct++;
    }
    else {
      phr->has_pp = _FALSE_;
    }

    if ((ppt->has_cl_cmb_temperature == _TRUE_) && (ppt->has_cl_cmb_lensing_potential == _TRUE_) && (ppt->has_scalars == _TRUE_)) {
      phr->has_tp = _TRUE_;
      phr->index_ct_tp=index_ct;
      index_ct++;
    }
    else {
      phr->has_tp = _FALSE_;
    }

    phr->ct_size = index_ct;

    if ((ppt->has_cl_cmb_polarization == _TRUE_) && (ppt->has_cl_cmb_lensing_potential == _TRUE_) && (ppt->has_scalars == _TRUE_)) {
      phr->has_ep = _TRUE_;
      phr->index_ct_ep=index_ct;
      index_ct++;
    }
    else {
      phr->has_ep = _FALSE_;
    }

    if ((ppt->has_scalars == _TRUE_) &&
        ((ppt->has_cl_number_count == _TRUE_) || (ppt->has_cl_lensing_potential == _TRUE_)))
      phr->d_size=ppt->selection_num;
    else
      phr->d_size=0;

    if ((ppt->has_cl_number_count == _TRUE_) && (ppt->has_scalars == _TRUE_)) {
      phr->has_dd = _TRUE_;
      phr->index_ct_dd=index_ct;
      index_ct+=(phr->d_size*(phr->d_size+1)-(phr->d_size-phr->non_diag)*(phr->d_size-1-phr->non_diag))/2;
    }
    else {
      phr->has_dd = _FALSE_;
    }

    /* the computation of C_l^Td would require a very good sampling of
       transfer functions over a wide range, and a huge computation
       time. In the current version, we prefer to switch it off, rather
       than either slowing down the code considerably, or producing
       very inaccurate spectra.

       if ((ppt->has_cl_cmb_temperature == _TRUE_) && (ppt->has_cl_number_count == _TRUE_) && (ppt->has_scalars == _TRUE_)) {
       phr->has_td = _TRUE_;
       phr->index_ct_td=index_ct;
       index_ct+=phr->d_size;
       }
       else {
       phr->has_td = _FALSE_;
       }
    */
    phr->has_td = _FALSE_;

    if ((ppt->has_cl_cmb_lensing_potential == _TRUE_) && (ppt->has_cl_number_count == _TRUE_) && (ppt->has_scalars == _TRUE_)) {
      phr->has_pd = _TRUE_;
      phr->index_ct_pd=index_ct;
      index_ct+=phr->d_size;
    }
    else {
      phr->has_pd = _FALSE_;
    }

    if ((ppt->has_cl_lensing_potential == _TRUE_) && (ppt->has_scalars == _TRUE_)) {
      phr->has_ll = _TRUE_;
      phr->index_ct_ll=index_ct;
      index_ct+=(phr->d_size*(phr->d_size+1)-(phr->d_size-phr->non_diag)*(phr->d_size-1-phr->non_diag))/2;
    }
    else {
      phr->has_ll = _FALSE_;
    }

    /* the computation of C_l^Tl would require a very good sampling of
       transfer functions over a wide range, and a huge computation
       time. In the current version, we prefer to switch it off, rather
       than either slowing down the code considerably, or producing
       very inaccurate spectra.

       if ((ppt->has_cl_cmb_temperature == _TRUE_) && (ppt->has_cl_lensing_potential == _TRUE_) && (ppt->has_scalars == _TRUE_)) {
       phr->has_tl = _TRUE_;
       phr->index_ct_tl=index_ct;
       index_ct+=phr->d_size;
       }
       else {
       phr->has_tl = _FALSE_;
       }
    */
    phr->has_tl = _FALSE_;

    if ((ppt->has_cl_number_count == _TRUE_) && (ppt->has_cl_lensing_potential == _TRUE_) && (ppt->has_scalars == _TRUE_)) {
      phr->has_dl = _TRUE_;
      phr->index_ct_dl=index_ct;
      index_ct += phr->d_size*phr->d_size - (phr->d_size-phr->non_diag)*(phr->d_size-1-phr->non_diag);
    }
    else {
      phr->has_dl = _FALSE_;
    }

    phr->ct_size = index_ct;

    /* infer from input quantities the l_max for each mode and type,
       l_max_ct[index_md][index_type].  Maximize it over index_ct, and
       then over index_md. */

    class_alloc(phr->l_max,sizeof(int*)*phr->md_size,phr->error_message);
    class_alloc(phr->l_max_ct,sizeof(int*)*phr->md_size,phr->error_message);
    for (index_md=0; index_md<phr->md_size; index_md++) {
      class_calloc(phr->l_max_ct[index_md],phr->ct_size,sizeof(int),phr->error_message);
    }

    if (ppt->has_scalars == _TRUE_) {

      /* spectra computed up to l_scalar_max */

      if (phr->has_tt == _TRUE_) phr->l_max_ct[ppt->index_md_scalars][phr->index_ct_tt] = ppt->l_scalar_max;
      if (phr->has_ee == _TRUE_) phr->l_max_ct[ppt->index_md_scalars][phr->index_ct_ee] = ppt->l_scalar_max;
      if (phr->has_te == _TRUE_) phr->l_max_ct[ppt->index_md_scalars][phr->index_ct_te] = ppt->l_scalar_max;
      if (phr->has_pp == _TRUE_) phr->l_max_ct[ppt->index_md_scalars][phr->index_ct_pp] = ppt->l_scalar_max;
      if (phr->has_tp == _TRUE_) phr->l_max_ct[ppt->index_md_scalars][phr->index_ct_tp] = ppt->l_scalar_max;
      if (phr->has_ep == _TRUE_) phr->l_max_ct[ppt->index_md_scalars][phr->index_ct_ep] = ppt->l_scalar_max;

      /* spectra computed up to l_lss_max */

      if (phr->has_dd == _TRUE_)
        for (index_ct=phr->index_ct_dd;
             index_ct<phr->index_ct_dd+(phr->d_size*(phr->d_size+1)-(phr->d_size-phr->non_diag)*(phr->d_size-1-phr->non_diag))/2;
             index_ct++)
          phr->l_max_ct[ppt->index_md_scalars][index_ct] = ppt->l_lss_max;

      if (phr->has_td == _TRUE_)
        for (index_ct=phr->index_ct_td;
             index_ct<phr->index_ct_td+phr->d_size;
             index_ct++)
          phr->l_max_ct[ppt->index_md_scalars][index_ct] = MIN(ppt->l_scalar_max,ppt->l_lss_max);

      if (phr->has_pd == _TRUE_)
        for (index_ct=phr->index_ct_pd;
             index_ct<phr->index_ct_pd+phr->d_size;
             index_ct++)
          phr->l_max_ct[ppt->index_md_scalars][index_ct] = MIN(ppt->l_scalar_max,ppt->l_lss_max);

      if (phr->has_ll == _TRUE_)
        for (index_ct=phr->index_ct_ll;
             index_ct<phr->index_ct_ll+(phr->d_size*(phr->d_size+1)-(phr->d_size-phr->non_diag)*(phr->d_size-1-phr->non_diag))/2;
             index_ct++)
          phr->l_max_ct[ppt->index_md_scalars][index_ct] = ppt->l_lss_max;

      if (phr->has_tl == _TRUE_)
        for (index_ct=phr->index_ct_tl;
             index_ct<phr->index_ct_tl+phr->d_size;
             index_ct++)
          phr->l_max_ct[ppt->index_md_scalars][index_ct] = MIN(ppt->l_scalar_max,ppt->l_lss_max);

      if (phr->has_dl == _TRUE_)
        for (index_ct=phr->index_ct_dl;
             index_ct < phr->index_ct_dl+(phr->d_size*phr->d_size - (phr->d_size-phr->non_diag)*(phr->d_size-1-phr->non_diag));
             index_ct++)
          phr->l_max_ct[ppt->index_md_scalars][index_ct] = ppt->l_lss_max;

    }
    if (ppt->has_tensors == _TRUE_) {

      /* spectra computed up to l_tensor_max */

      if (phr->has_tt == _TRUE_) phr->l_max_ct[ppt->index_md_tensors][phr->index_ct_tt] = ppt->l_tensor_max;
      if (phr->has_ee == _TRUE_) phr->l_max_ct[ppt->index_md_tensors][phr->index_ct_ee] = ppt->l_tensor_max;
      if (phr->has_te == _TRUE_) phr->l_max_ct[ppt->index_md_tensors][phr->index_ct_te] = ppt->l_tensor_max;
      if (phr->has_bb == _TRUE_) phr->l_max_ct[ppt->index_md_tensors][phr->index_ct_bb] = ppt->l_tensor_max;
    }

    /* maximizations */
    phr->l_max_tot = 0.;
    for (index_md=0; index_md < phr->md_size; index_md++) {
      phr->l_max[index_md] = 0.;
      for (index_ct=0.; index_ct<phr->ct_size; index_ct++)
        phr->l_max[index_md] = MAX(phr->l_max[index_md],phr->l_max_ct[index_md][index_ct]);
      phr->l_max_tot = MAX(phr->l_max_tot,phr->l_max[index_md]);
    }
  }

  return _SUCCESS_;

}

/**
 * This routine computes a table of values for all harmonic spectra \f$ C_l \f$'s,
 * given the transfer functions and primordial spectra.
 *
 * @param ppr Input: pointer to precision structure
 * @param pba Input: pointer to background structure
 * @param ppt Input: pointer to perturbation structure
 * @param ptr Input: pointer to transfer structure
 * @param ppm Input: pointer to primordial structure
 * @param phr Input/Output: pointer to harmonic structure
 * @return the error status
 */

int harmonic_cls(
                 struct precision * ppr,
                 struct background * pba,
                 struct perturbations * ppt,
                 struct transfer * ptr,
                 struct primordial * ppm,
                 struct harmonic * phr
                 ) {

  /** Summary: */

  /** - define local variables */

  int index_md;
  int index_ic1,index_ic2,index_ic1_ic2;
  int index_l;
  int index_ct;
  int cl_integrand_num_columns;

  /** - allocate pointers to arrays where results will be stored */

  class_alloc(phr->l_size,sizeof(int)*phr->md_size,phr->error_message);
  class_alloc(phr->cl,sizeof(double *)*phr->md_size,phr->error_message);
  class_alloc(phr->ddcl,sizeof(double *)*phr->md_size,phr->error_message);

  phr->l_size_max = ptr->l_size_max;
  class_alloc(phr->l,sizeof(double)*phr->l_size_max,phr->error_message);

  /** - store values of l */
  for (index_l=0; index_l < phr->l_size_max; index_l++) {
    phr->l[index_l] = (double)ptr->l[index_l];
  }

  /** - loop over modes (scalar, tensors, etc). For each mode: */

  for (index_md = 0; index_md < phr->md_size; index_md++) {

    /** - --> (a) store number of l values for this mode */

    phr->l_size[index_md] = ptr->l_size[index_md];

    /** - --> (b) allocate arrays where results will be stored */

    class_alloc(phr->cl[index_md],sizeof(double)*phr->l_size[index_md]*phr->ct_size*phr->ic_ic_size[index_md],phr->error_message);
    class_alloc(phr->ddcl[index_md],sizeof(double)*phr->l_size[index_md]*phr->ct_size*phr->ic_ic_size[index_md],phr->error_message);
    cl_integrand_num_columns = 1+phr->ct_size*2; /* one for k, ct_size for each type, ct_size for each second derivative of each type */

    /** - --> (c) loop over initial conditions */

    class_setup_parallel();

    for (index_ic1 = 0; index_ic1 < phr->ic_size[index_md]; index_ic1++) {
      for (index_ic2 = index_ic1; index_ic2 < phr->ic_size[index_md]; index_ic2++) {
        index_ic1_ic2 = index_symmetric_matrix(index_ic1,index_ic2,phr->ic_size[index_md]);

        /* non-diagonal coefficients should be computed only if non-zero correlation */
        if (phr->is_non_zero[index_md][index_ic1_ic2] == _TRUE_) {

          /** - ---> loop over l values defined in the transfer module.
              For each l, compute the \f$ C_l\f$'s for all types (TT, TE, ...)
              by convolving primordial spectra with transfer  functions.
              This elementary task is assigned to harmonic_compute_cl() */

          for (index_l=0; index_l < ptr->l_size[index_md]; index_l++) {

            class_run_parallel(=,

              double * cl_integrand; /* array with argument cl_integrand[index_k*cl_integrand_num_columns+1+phr->index_ct] */
              double * cl_integrand_limber; /* similar array with same columns but different number of lines (less k values) */
              double * transfer_ic1; /* array with argument transfer_ic1[index_tt] */
              double * transfer_ic2; /* idem */
              double * primordial_pk;  /* array with argument primordial_pk[index_ic_ic]*/


              class_alloc(cl_integrand,
                          ptr->q_size*cl_integrand_num_columns*sizeof(double),
                          phr->error_message);

              cl_integrand_limber = NULL;
              if (ptr->do_lcmb_full_limber == _TRUE_) {
                class_alloc(cl_integrand_limber,
                            ptr->q_size_limber*cl_integrand_num_columns*sizeof(double),
                            phr->error_message);
              }

              class_alloc(primordial_pk,
                          phr->ic_ic_size[index_md]*sizeof(double),
                          phr->error_message);

              class_alloc(transfer_ic1,
                          ptr->tt_size[index_md]*sizeof(double),
                          phr->error_message);

              class_alloc(transfer_ic2,
                          ptr->tt_size[index_md]*sizeof(double),
                          phr->error_message);

              class_call(harmonic_compute_cl(ppr,
                                             pba,
                                             ppt,
                                             ptr,
                                             ppm,
                                             phr,
                                             index_md,
                                             index_ic1,
                                             index_ic2,
                                             index_l,
                                             cl_integrand_num_columns,
                                             cl_integrand,
                                             cl_integrand_limber,
                                             primordial_pk,
                                             transfer_ic1,
                                             transfer_ic2),
                         phr->error_message,
                         phr->error_message);

              free(cl_integrand);
              if (ptr->do_lcmb_full_limber == _TRUE_) {
                free(cl_integrand_limber);
              }
              free(primordial_pk);
              free(transfer_ic1);
              free(transfer_ic2);

              return _SUCCESS_;
            );
          } /* end of loop over l */

        }
        else {

          /* set non-diagonal coefficients to zero if pair of ic's uncorrelated */

          for (index_l=0; index_l < ptr->l_size[index_md]; index_l++) {
            for (index_ct=0; index_ct<phr->ct_size; index_ct++) {
              phr->cl[index_md]
                [(index_l * phr->ic_ic_size[index_md] + index_ic1_ic2) * phr->ct_size + index_ct]
                = 0.;
            }
          }
        }
      }
    }

    class_finish_parallel();

    /** - --> (d) now that for a given mode, all possible \f$ C_l\f$'s have been computed,
        compute second derivative of the array in which they are stored,
        in view of spline interpolation. */

    class_call(array_spline_table_lines(phr->l,
                                        phr->l_size[index_md],
                                        phr->cl[index_md],
                                        phr->ic_ic_size[index_md]*phr->ct_size,
                                        phr->ddcl[index_md],
                                        _SPLINE_EST_DERIV_,
                                        phr->error_message),
               phr->error_message,
               phr->error_message);
  }

  return _SUCCESS_;

}

/**
 * This routine computes the \f$ C_l\f$'s for a given mode, pair of initial conditions
 * and multipole, but for all types (TT, TE...), by convolving the
 * transfer functions with the primordial spectra.
 *
 * @param ppr           Input: pointer to precision structure
 * @param pba           Input: pointer to background structure
 * @param ppt           Input: pointer to perturbation structure
 * @param ptr           Input: pointer to transfer structure
 * @param ppm           Input: pointer to primordial structure
 * @param phr           Input/Output: pointer to harmonic structure (result stored here)
 * @param index_md      Input: index of mode under consideration
 * @param index_ic1     Input: index of first initial condition in the correlator
 * @param index_ic2     Input: index of second initial condition in the correlator
 * @param index_l       Input: index of multipole under consideration
 * @param cl_integrand_num_columns Input: number of columns in cl_integrand
 * @param cl_integrand  Input: an allocated workspace
 * @param cl_integrand_limber  Input: an allocated workspace for full Limber calculation
 * @param primordial_pk Input: table of primordial spectrum values
 * @param transfer_ic1  Input: table of transfer function values for first initial condition
 * @param transfer_ic2  Input: table of transfer function values for second initial condition
 * @return the error status
 */

int harmonic_compute_cl(
                        struct precision * ppr,
                        struct background * pba,
                        struct perturbations * ppt,
                        struct transfer * ptr,
                        struct primordial * ppm,
                        struct harmonic * phr,
                        int index_md,
                        int index_ic1,
                        int index_ic2,
                        int index_l,
                        int cl_integrand_num_columns,
                        double * cl_integrand,
                        double * cl_integrand_limber,
                        double * primordial_pk,
                        double * transfer_ic1,
                        double * transfer_ic2
                        ) {

  int index_q;
  int index_tt;
  int index_ct;
  int index_d1,index_d2;
  double k;
  double clvalue;
  int index_ic1_ic2;
  double transfer_ic1_temp=0.;
  double transfer_ic2_temp=0.;
  double * transfer_ic1_nc=NULL;
  double * transfer_ic2_nc=NULL;
  double factor;
  int index_q_spline=0;
  double * integrand;
  int num_columns;
  int num_k;
  int column_k;
  int column_integrand;
  int column_derivative;
  int index_spline;
  double q_min;
  double k_min;
  double l;

  l = phr->l[index_l];

  index_ic1_ic2 = index_symmetric_matrix(index_ic1,index_ic2,phr->ic_size[index_md]);

  if (ppt->has_cl_number_count == _TRUE_ && _scalars_) {
    class_alloc(transfer_ic1_nc,phr->d_size*sizeof(double),phr->error_message);
    class_alloc(transfer_ic2_nc,phr->d_size*sizeof(double),phr->error_message);
  }

  /* Technical point: here, we will do a spline integral over the
     whole range of k's, excepted in the closed (K>0) case. In that
     case, it is a bad idea to spline over the values of k
     corresponding to nu<nu_flat_approximation. In this region, nu
     values are integer values, so the steps dq and dk have some
     discrete jumps. This makes the spline routine less accurate than
     a trapezoidal integral with finer sampling. So, in the closed
     case, we set index_q_spline to ptr->index_q_flat_approximation,
     to tell the integration routine that below this index, it should
     treat the integral as a trapezoidal one. For testing, one is free
     to set index_q_spline to 0, to enforce spline integration
     everywhere, or to (ptr->q_size-1), to enforce trapezoidal
     integration everywhere. */

  if (pba->sgnK == 1) {
    index_q_spline = ptr->index_q_flat_approximation;
  }

  for (index_q=0; index_q < ptr->q_size; index_q++) {

    //q = ptr->q[index_q];
    k = ptr->k[index_md][index_q];

    cl_integrand[index_q*cl_integrand_num_columns+0] = k;

    class_call(primordial_spectrum_at_k(ppm,index_md,linear,k,primordial_pk),
               ppm->error_message,
               phr->error_message);

    /* above routine checks that k>0: no possible division by zero below */

    for (index_tt=0; index_tt < ptr->tt_size[index_md]; index_tt++) {

      transfer_ic1[index_tt] =
        ptr->transfer[index_md]
        [((index_ic1 * ptr->tt_size[index_md] + index_tt)
          * ptr->l_size[index_md] + index_l)
         * ptr->q_size + index_q];

      if (index_ic1 == index_ic2) {
        transfer_ic2[index_tt] = transfer_ic1[index_tt];
      }
      else {
        transfer_ic2[index_tt] = ptr->transfer[index_md]
          [((index_ic2 * ptr->tt_size[index_md] + index_tt)
            * ptr->l_size[index_md] + index_l)
           * ptr->q_size + index_q];
      }
    }

    /* define combinations of transfer functions */

    if (ppt->has_cl_cmb_temperature == _TRUE_) {

      if (_scalars_) {

        transfer_ic1_temp = transfer_ic1[ptr->index_tt_t0] + transfer_ic1[ptr->index_tt_t1] + transfer_ic1[ptr->index_tt_t2];
        transfer_ic2_temp = transfer_ic2[ptr->index_tt_t0] + transfer_ic2[ptr->index_tt_t1] + transfer_ic2[ptr->index_tt_t2];

      }

      if (_vectors_) {

        transfer_ic1_temp = transfer_ic1[ptr->index_tt_t1] + transfer_ic1[ptr->index_tt_t2];
        transfer_ic2_temp = transfer_ic2[ptr->index_tt_t1] + transfer_ic2[ptr->index_tt_t2];

      }

      if (_tensors_) {

        transfer_ic1_temp = transfer_ic1[ptr->index_tt_t2];
        transfer_ic2_temp = transfer_ic2[ptr->index_tt_t2];

      }
    }

    if (ppt->has_cl_number_count == _TRUE_ && _scalars_) {

      for (index_d1=0; index_d1<phr->d_size; index_d1++) {

        transfer_ic1_nc[index_d1] = 0.;
        transfer_ic2_nc[index_d1] = 0.;

        if (ppt->has_nc_density == _TRUE_) {
          transfer_ic1_nc[index_d1] += transfer_ic1[ptr->index_tt_density+index_d1];
          transfer_ic2_nc[index_d1] += transfer_ic2[ptr->index_tt_density+index_d1];
        }

        if (ppt->has_nc_rsd     == _TRUE_) {
          transfer_ic1_nc[index_d1]
            += transfer_ic1[ptr->index_tt_rsd+index_d1]
            + transfer_ic1[ptr->index_tt_d0+index_d1]
            + transfer_ic1[ptr->index_tt_d1+index_d1];
          transfer_ic2_nc[index_d1]
            += transfer_ic2[ptr->index_tt_rsd+index_d1]
            + transfer_ic2[ptr->index_tt_d0+index_d1]
            + transfer_ic2[ptr->index_tt_d1+index_d1];
        }

        if (ppt->has_nc_lens == _TRUE_) {
          transfer_ic1_nc[index_d1] +=
            l*(l+1.)*transfer_ic1[ptr->index_tt_nc_lens+index_d1];
          transfer_ic2_nc[index_d1] +=
            l*(l+1.)*transfer_ic2[ptr->index_tt_nc_lens+index_d1];
        }

        if (ppt->has_nc_gr == _TRUE_) {
          transfer_ic1_nc[index_d1]
            += transfer_ic1[ptr->index_tt_nc_g1+index_d1]
            + transfer_ic1[ptr->index_tt_nc_g2+index_d1]
            + transfer_ic1[ptr->index_tt_nc_g3+index_d1]
            + transfer_ic1[ptr->index_tt_nc_g4+index_d1]
            + transfer_ic1[ptr->index_tt_nc_g5+index_d1];
          transfer_ic2_nc[index_d1]
            += transfer_ic2[ptr->index_tt_nc_g1+index_d1]
            + transfer_ic2[ptr->index_tt_nc_g2+index_d1]
            + transfer_ic2[ptr->index_tt_nc_g3+index_d1]
            + transfer_ic2[ptr->index_tt_nc_g4+index_d1]
            + transfer_ic2[ptr->index_tt_nc_g5+index_d1];
        }

      }
    }

    /* integrand of Cl's */

    /* note: we must integrate

       C_l = int [4 pi dk/k calP(k) Delta1_l(q) Delta2_l(q)]

       where calP(k) is the dimensionless
       power spectrum equal to a constant in the scale-invariant case,
       and to P(k) = A_s k^(ns-1) otherwise and q=sqrt(k2+K) (scalars)
       or sqrt(k2+2K) (vectors) or sqrt(k2+3K) (tensors)

       In the literature, people often rewrite the integral in terms
       of q and absorb the Jacobian of the change of variables in a redefinition of the primodial
       spectrum. Let us illustrate this for scalars:

       dk/k = kdk/k2 = qdq/k2 = dq/q * (q/k)^2 = dq/q * [q2/(q2-K)] = q2dq * 1/[q(q2-K)]

       This factor 1/[q(q2-K)] is commonly absorbed in the definition of calP. Then one would have

       C_l = int [4 pi q2 dq {A_s k^(ns-1)/[q(q2-K)]} Delta1_l(q) Delta2_l(q)]

       Sometimes in the literature, the factor (k2-3K)=(q2-4K) present
       in the initial conditions of scalar transfer functions (if
       normalized to curvature R=1) is also absorbed in the definition
       of the power spectrum. Then the curvature power spectrum reads

       calP = (q2-4K)/[q(q2-K)] * (k/k)^ns

       In CLASS we prefer to define calP = (k/k)^ns like in the flat
       case, to have the factor (q2-4K) in the initialk conditions,
       and the factor 1/[q(q2-K)] doesn't need to be there since we
       integrate over dk/k.

       For tensors, the change of variable described above gives a slightly different result:

       dk/k = kdk/k2 = qdq/k2 = dq/q * (q/k)^2 = dq/q * [q2/(q2-3K)] = q2dq * 1/[q(q2-3K)]

       But for tensors there are extra curvature-related correction factors to
       take into account. See the comments in the perturbation module,
       related to initial conditions for tensors.

    */

    factor = 4. * _PI_ / k;

    if (phr->has_tt == _TRUE_)
      cl_integrand[index_q*cl_integrand_num_columns+1+phr->index_ct_tt]=
        primordial_pk[index_ic1_ic2]
        * transfer_ic1_temp
        * transfer_ic2_temp
        * factor;

    if (phr->has_ee == _TRUE_)
      cl_integrand[index_q*cl_integrand_num_columns+1+phr->index_ct_ee]=
        primordial_pk[index_ic1_ic2]
        * transfer_ic1[ptr->index_tt_e]
        * transfer_ic2[ptr->index_tt_e]
        * factor;

    if (phr->has_te == _TRUE_)
      cl_integrand[index_q*cl_integrand_num_columns+1+phr->index_ct_te]=
        primordial_pk[index_ic1_ic2]
        * 0.5*(transfer_ic1_temp * transfer_ic2[ptr->index_tt_e] +
               transfer_ic1[ptr->index_tt_e] * transfer_ic2_temp)
        * factor;

    if (_tensors_ && (phr->has_bb == _TRUE_))
      cl_integrand[index_q*cl_integrand_num_columns+1+phr->index_ct_bb]=
        primordial_pk[index_ic1_ic2]
        * transfer_ic1[ptr->index_tt_b]
        * transfer_ic2[ptr->index_tt_b]
        * factor;

    if (_scalars_ && (phr->has_pp == _TRUE_))
      cl_integrand[index_q*cl_integrand_num_columns+1+phr->index_ct_pp]=
        primordial_pk[index_ic1_ic2]
        * transfer_ic1[ptr->index_tt_lcmb]
        * transfer_ic2[ptr->index_tt_lcmb]
        * factor;

    if (_scalars_ && (phr->has_tp == _TRUE_))
      cl_integrand[index_q*cl_integrand_num_columns+1+phr->index_ct_tp]=
        primordial_pk[index_ic1_ic2]
        * 0.5*(transfer_ic1_temp * transfer_ic2[ptr->index_tt_lcmb] +
               transfer_ic1[ptr->index_tt_lcmb] * transfer_ic2_temp)
        * factor;

    if (_scalars_ && (phr->has_ep == _TRUE_))
      cl_integrand[index_q*cl_integrand_num_columns+1+phr->index_ct_ep]=
        primordial_pk[index_ic1_ic2]
        * 0.5*(transfer_ic1[ptr->index_tt_e] * transfer_ic2[ptr->index_tt_lcmb] +
               transfer_ic1[ptr->index_tt_lcmb] * transfer_ic2[ptr->index_tt_e])
        * factor;

    if (_scalars_ && (phr->has_dd == _TRUE_)) {
      index_ct=0;
      for (index_d1=0; index_d1<phr->d_size; index_d1++) {
        for (index_d2=index_d1; index_d2<=MIN(index_d1+phr->non_diag,phr->d_size-1); index_d2++) {
          cl_integrand[index_q*cl_integrand_num_columns+1+phr->index_ct_dd+index_ct]=
            primordial_pk[index_ic1_ic2]
            * transfer_ic1_nc[index_d1]
            * transfer_ic2_nc[index_d2]
            * factor;
          index_ct++;
        }
      }
    }

    if (_scalars_ && (phr->has_td == _TRUE_)) {
      for (index_d1=0; index_d1<phr->d_size; index_d1++) {
        cl_integrand[index_q*cl_integrand_num_columns+1+phr->index_ct_td+index_d1]=
          primordial_pk[index_ic1_ic2]
          * 0.5*(transfer_ic1_temp * transfer_ic2_nc[index_d1] +
                 transfer_ic1_nc[index_d1] * transfer_ic2_temp)
          * factor;
      }
    }

    if (_scalars_ && (phr->has_pd == _TRUE_)) {
      for (index_d1=0; index_d1<phr->d_size; index_d1++) {
        cl_integrand[index_q*cl_integrand_num_columns+1+phr->index_ct_pd+index_d1]=
          primordial_pk[index_ic1_ic2]
          * 0.5*(transfer_ic1[ptr->index_tt_lcmb] * transfer_ic2_nc[index_d1] +
                 transfer_ic1_nc[index_d1] * transfer_ic2[ptr->index_tt_lcmb])
          * factor;
      }
    }

    if (_scalars_ && (phr->has_ll == _TRUE_)) {
      index_ct=0;
      for (index_d1=0; index_d1<phr->d_size; index_d1++) {
        for (index_d2=index_d1; index_d2<=MIN(index_d1+phr->non_diag,phr->d_size-1); index_d2++) {
          cl_integrand[index_q*cl_integrand_num_columns+1+phr->index_ct_ll+index_ct]=
            primordial_pk[index_ic1_ic2]
            * transfer_ic1[ptr->index_tt_lensing+index_d1]
            * transfer_ic2[ptr->index_tt_lensing+index_d2]
            * factor;
          index_ct++;
        }
      }
    }

    if (_scalars_ && (phr->has_tl == _TRUE_)) {
      for (index_d1=0; index_d1<phr->d_size; index_d1++) {
        cl_integrand[index_q*cl_integrand_num_columns+1+phr->index_ct_tl+index_d1]=
          primordial_pk[index_ic1_ic2]
          * 0.5*(transfer_ic1_temp * transfer_ic2[ptr->index_tt_lensing+index_d1] +
                 transfer_ic1[ptr->index_tt_lensing+index_d1] * transfer_ic2_temp)
          * factor;
      }
    }

    if (_scalars_ && (phr->has_dl == _TRUE_)) {
      index_ct=0;
      for (index_d1=0; index_d1<phr->d_size; index_d1++) {
        for (index_d2=MAX(index_d1-phr->non_diag,0); index_d2<=MIN(index_d1+phr->non_diag,phr->d_size-1); index_d2++) {
          cl_integrand[index_q*cl_integrand_num_columns+1+phr->index_ct_dl+index_ct]=
            primordial_pk[index_ic1_ic2]
            * transfer_ic1_nc[index_d1] * transfer_ic2[ptr->index_tt_lensing+index_d2]
            * factor;
          index_ct++;
        }
      }
    }
  }

  /* do also a full limber calculation for some types (actually, only pp) */

  if ((ptr->do_lcmb_full_limber == _TRUE_)  && (l>ppr->l_switch_limber)) {

    for (index_q=0; index_q < ptr->q_size_limber; index_q++) {

      //q = ptr->q_limber[index_q];
      k = ptr->k_limber[index_md][index_q];

      cl_integrand_limber[index_q*cl_integrand_num_columns+0] = k;

      class_call(primordial_spectrum_at_k(ppm,index_md,linear,k,primordial_pk),
                 ppm->error_message,
                 phr->error_message);

      /* This is where we define for which types of Cl's we want a
         full Limber version. If we wanted it for more than phiphi, we
         would add other if statements below. */

      if (_scalars_ && (phr->has_pp == _TRUE_)) {

        index_tt = ptr->index_tt_lcmb;
        index_ct = phr->index_ct_pp;

        transfer_ic1[index_tt] =
          ptr->transfer_limber[index_md]
          [((index_ic1 * ptr->tt_size[index_md] + ptr->index_tt_lcmb)
            * ptr->l_size[index_md] + index_l)
           * ptr->q_size_limber + index_q];

        if (index_ic1 == index_ic2) {
          transfer_ic2[index_tt] = transfer_ic1[ptr->index_tt_lcmb];
        }
        else {
          transfer_ic2[index_tt] = ptr->transfer_limber[index_md]
            [((index_ic2 * ptr->tt_size[index_md] + ptr->index_tt_lcmb)
              * ptr->l_size[index_md] + index_l)
             * ptr->q_size_limber + index_q];
        }

        factor = 4. * _PI_ / k;

        cl_integrand_limber[index_q*cl_integrand_num_columns+1+phr->index_ct_pp]=
          primordial_pk[index_ic1_ic2]
          * transfer_ic1[index_tt]
          * transfer_ic2[index_tt]
          * factor;
      }
    }
  }

  for (index_ct=0; index_ct<phr->ct_size; index_ct++) {

    /* treat null spectra (C_l^BB of scalars, C_l^pp of tensors, etc. */

    if ((_scalars_ && (phr->has_bb == _TRUE_) && (index_ct == phr->index_ct_bb)) ||
        (_tensors_ && (phr->has_pp == _TRUE_) && (index_ct == phr->index_ct_pp)) ||
        (_tensors_ && (phr->has_tp == _TRUE_) && (index_ct == phr->index_ct_tp)) ||
        (_tensors_ && (phr->has_ep == _TRUE_) && (index_ct == phr->index_ct_ep)) ||
        (_tensors_ && (phr->has_dd == _TRUE_) && (index_ct == phr->index_ct_dd)) ||
        (_tensors_ && (phr->has_td == _TRUE_) && (index_ct == phr->index_ct_td)) ||
        (_tensors_ && (phr->has_pd == _TRUE_) && (index_ct == phr->index_ct_pd)) ||
        (_tensors_ && (phr->has_ll == _TRUE_) && (index_ct == phr->index_ct_ll)) ||
        (_tensors_ && (phr->has_tl == _TRUE_) && (index_ct == phr->index_ct_tl)) ||
        (_tensors_ && (phr->has_dl == _TRUE_) && (index_ct == phr->index_ct_dl))
        ) {

      phr->cl[index_md]
        [(index_l * phr->ic_ic_size[index_md] + index_ic1_ic2) * phr->ct_size + index_ct] = 0.;

    }
    /* for non-zero spectra, integrate over q */
    else {

      /* spline the integrand over the whole range of k's. This is
         where we decide which of the normal or full Limber scheme
         will be used at the end. */

      if (_scalars_ && (ptr->do_lcmb_full_limber == _TRUE_) && (phr->has_pp == _TRUE_) && (index_ct == phr->index_ct_pp) && (l>ppr->l_switch_limber)) {
        integrand = cl_integrand_limber;
        num_columns = cl_integrand_num_columns;
        num_k = ptr->q_size_limber;
        index_spline = 0;
        q_min = ptr->q_limber[0];
        k_min = ptr->k_limber[0][0];
      }
      else{
        integrand = cl_integrand;
        num_columns = cl_integrand_num_columns;
        num_k = ptr->q_size;
        index_spline = index_q_spline;
        q_min = ptr->q[0];
        k_min = ptr->k[0][0];
      }

      column_k = 0;
      column_integrand = 1+index_ct;
      column_derivative = 1+phr->ct_size+index_ct;

      class_call(array_spline(integrand,
                              num_columns,
                              num_k,
                              column_k,
                              column_integrand,
                              column_derivative,
                              _SPLINE_EST_DERIV_,
                              phr->error_message),
                 phr->error_message,
                 phr->error_message);

      class_call(array_integrate_all_trapzd_or_spline(integrand,
                                                      num_columns,
                                                      num_k,
                                                      index_spline,
                                                      column_k,
                                                      column_integrand,
                                                      column_derivative,
                                                      &clvalue,
                                                      phr->error_message),
                 phr->error_message,
                 phr->error_message);

      /* in the closed case, instead of an integral, we have a
         discrete sum. In practice, this does not matter: the previous
         routine does give a correct approximation of the discrete
         sum, both in the trapezoidal and spline regions. The only
         error comes from the first point: the previous routine
         assumes a weight for the first point which is too small
         compared to what it would be in the an actual discrete
         sum. The line below correct this problem in an exact way.
      */

      if (pba->sgnK == 1) {
        clvalue += integrand[1+index_ct] * q_min/k_min*sqrt(pba->K)/2.;
      }

      /* we have the correct C_l now. We can store it in the transfer structure. */

      phr->cl[index_md]
        [(index_l * phr->ic_ic_size[index_md] + index_ic1_ic2) * phr->ct_size + index_ct]
        = clvalue;

    }
  }

  if (ppt->has_cl_number_count == _TRUE_ && _scalars_) {
    free(transfer_ic1_nc);
    free(transfer_ic2_nc);
  }

  return _SUCCESS_;

}

/* deprecated functions (since v2.8) */

/**
 * Matter power spectrum for arbitrary redshift and for all initial conditions.
 *
 * This function is deprecated since v2.8. Try using fourier_pk_at_z() instead.
 *
 * @param pba           Input: pointer to background structure (used for converting z into tau)
 * @param phr           Input: pointer to harmonic structure (containing pre-computed table)
 * @param mode          Input: linear or logarithmic
 * @param z             Input: redshift
 * @param output_tot    Output: total matter power spectrum P(k) in \f$ Mpc^3 \f$ (linear mode), or its logarithms (logarithmic mode)
 * @param output_ic     Output: for each pair of initial conditions, matter power spectra P(k) in \f$ Mpc^3 \f$ (linear mode), or their logarithms and cross-correlation angles (logarithmic mode)
 * @param output_cb_tot Output: CDM+baryon power spectrum P_cb(k) in \f$ Mpc^3 \f$ (linear mode), or its logarithms (logarithmic mode)
 * @param output_cb_ic  Output: for each pair of initial conditions, CDM+baryon power spectra P_cb(k) in \f$ Mpc^3 \f$ (linear mode), or their logarithms and cross-correlation angles (logarithmic mode)
 * @return the error status
 */

int harmonic_pk_at_z(
                     struct background * pba,
                     struct harmonic * phr,
                     enum linear_or_logarithmic mode,
                     double z,
                     double * output_tot,    /* array with argument output_tot[index_k] (must be already allocated) */
                     double * output_ic,     /* array with argument output_tot[index_k * phr->ic_ic_size[index_md] + index_ic1_ic2] (must be already allocated only if more than one initial condition) */
                     double * output_cb_tot, /* same as output_tot for the baryon+CDM only */
                     double * output_cb_ic   /* same as output_ic  for the baryon+CDM only */
                     ) {

  fprintf(stderr," -> [WARNING:] You are calling the function harmonic_pk_at_z() which is deprecated since v2.8. It will soon be removed. Use fourier_pk_at_z() instead.\n");

  class_call(fourier_pks_at_z(
                              pba,
                              phr->pfo,
                              mode,
                              pk_linear,
                              z,
                              output_tot,
                              output_ic,
                              output_cb_tot,
                              output_cb_ic
                              ),
             phr->pfo->error_message,
             phr->error_message);

  return _SUCCESS_;

}

/**
 * Matter power spectrum for arbitrary wavenumber, redshift and initial condition.
 *
 * This function is deprecated since v2.8. Try using fourier_pk_linear_at_k_and_z() instead.
 *
 * @param pba        Input: pointer to background structure (used for converting z into tau)
 * @param ppm        Input: pointer to primordial structure (used only in the case 0 < k < kmin)
 * @param phr        Input: pointer to harmonic structure (containing pre-computed table)
 * @param k          Input: wavenumber in 1/Mpc
 * @param z          Input: redshift
 * @param pk_tot     Output: total matter power spectrum P(k) in \f$ Mpc^3 \f$
 * @param pk_ic      Output: for each pair of initial conditions, matter power spectra P(k) in \f$ Mpc^3\f$
 * @param pk_cb_tot  Output: b+CDM power spectrum P(k) in \f$ Mpc^3 \f$
 * @param pk_cb_ic   Output: for each pair of initial conditions, b+CDM power spectra P(k) in \f$ Mpc^3\f$
 * @return the error status
 */

int harmonic_pk_at_k_and_z(
                           struct background * pba,
                           struct primordial * ppm,
                           struct harmonic * phr,
                           double k,
                           double z,
                           double * pk_tot,    /* pointer to a single number (must be already allocated) */
                           double * pk_ic,     /* array of argument pk_ic[index_ic1_ic2]
                                                  (must be already allocated only if several initial conditions) */
                           double * pk_cb_tot, /* same as pk_tot for baryon+CDM part only */
                           double * pk_cb_ic   /* same as pk_ic  for baryon+CDM part only */
                           ) {

  fprintf(stderr," -> [WARNING:] You are calling the function harmonic_pk_at_k_and_z() which is deprecated since v2.8. It will soon be removed. Use fourier_pk_linear_at_k_and_z() instead.\n");

  class_call(fourier_pks_at_k_and_z(pba,
                                    ppm,
                                    phr->pfo,
                                    pk_linear,
                                    k,
                                    z,
                                    pk_tot,
                                    pk_ic,
                                    pk_cb_tot,
                                    pk_cb_ic),
             phr->pfo->error_message,
             phr->error_message);

  return _SUCCESS_;
}

/**
 * Non-linear total matter power spectrum for arbitrary redshift.
 *
 * This function is deprecated since v2.8. Try using fourier_pk_at_z() instead.
 *
 * @param pba           Input: pointer to background structure (used for converting z into tau)
 * @param phr           Input: pointer to harmonic structure (containing pre-computed table)
 * @param mode          Input: linear or logarithmic
 * @param z             Input: redshift
 * @param output_tot    Output: total matter power spectrum P(k) in \f$ Mpc^3\f$ (linear mode), or its logarithms (logarithmic mode)
 * @param output_cb_tot Output: b+CDM power spectrum P(k) in \f$ Mpc^3\f$ (linear mode), or its logarithms (logarithmic mode)
 * @return the error status
 */

int harmonic_pk_nl_at_z(
                        struct background * pba,
                        struct harmonic * phr,
                        enum linear_or_logarithmic mode,
                        double z,
                        double * output_tot,   /* array with argument output_tot[index_k] (must be already allocated) */
                        double * output_cb_tot
                        ) {

  fprintf(stderr," -> [WARNING:] You are calling the function harmonic_pk_nl_at_z() which is deprecated since v2.8. It will soon be removed. Use fourier_pk_at_z() instead.\n");

  class_call(fourier_pks_at_z(pba,
                              phr->pfo,
                              mode,
                              pk_nonlinear,
                              z,
                              output_tot,
                              NULL,
                              output_cb_tot,
                              NULL
                              ),
             phr->pfo->error_message,
             phr->error_message);

  return _SUCCESS_;

}

/**
 * Non-linear total matter power spectrum for arbitrary wavenumber and redshift.
 *
 * This function is deprecated since v2.8. Try using fourier_pk_at_k_and_z() instead.
 *
 * @param pba        Input: pointer to background structure (used for converting z into tau)
 * @param ppm        Input: pointer to primordial structure (used only in the case 0 < k < kmin)
 * @param phr        Input: pointer to harmonic structure (containing pre-computed table)
 * @param k          Input: wavenumber in 1/Mpc
 * @param z          Input: redshift
 * @param pk_tot     Output: total matter power spectrum P(k) in \f$ Mpc^3\f$
 * @param pk_cb_tot  Output: b+CDM power spectrum P(k) in \f$ Mpc^3\f$
 * @return the error status
 */

int harmonic_pk_nl_at_k_and_z(
                              struct background * pba,
                              struct primordial * ppm,
                              struct harmonic * phr,
                              double k,
                              double z,
                              double * pk_tot,   /* pointer to a single number (must be already allocated) */
                              double * pk_cb_tot /* same as pk_tot for baryon+CDM only */
                              ) {

  fprintf(stderr," -> [WARNING:] You are calling the function harmonic_pk_nl_at_k_and_z() which is deprecated since v2.8. It will soon be removed. Use fourier_pk_at_k_and_z() instead.\n");

  class_call(fourier_pks_at_k_and_z(pba,
                                    ppm,
                                    phr->pfo,
                                    pk_nonlinear,
                                    k,
                                    z,
                                    pk_tot,
                                    NULL,
                                    pk_cb_tot,
                                    NULL
                                    ),
             phr->pfo->error_message,
             phr->error_message);

  return _SUCCESS_;

}

/**
 * Return the P(k,z) for a grid of (k_i,z_j) passed in input,
 * for all available pk types (_m, _cb),
 * either linear or nonlinear depending on input.
 *
 * This function is deprecated since v2.8. Try using fourier_pks_at_kvec_and_zvec() instead.
 *
 * @param pba            Input: pointer to background structure
 * @param phr            Input: pointer to harmonic structure
 * @param kvec           Input: array of wavenumbers in ascending order (in 1/Mpc)
 * @param kvec_size      Input: size of array of wavenumbers
 * @param zvec           Input: array of redshifts in arbitrary order
 * @param zvec_size      Input: size of array of redshifts
 * @param pk_tot_out     Output: P(k_i,z_j) for total matter (if available) in Mpc**3
 * @param pk_cb_tot_out  Output: P_cb(k_i,z_j) for cdm+baryons (if available) in Mpc**3
 * @param nonlinear      Input: _TRUE_ or _FALSE_ (to output nonlinear or linear P(k,z))
 * @return the error status
 */

int harmonic_fast_pk_at_kvec_and_zvec(
                                      struct background * pba,
                                      struct harmonic * phr,
                                      double * kvec,
                                      int kvec_size,
                                      double * zvec,
                                      int zvec_size,
                                      double * pk_tot_out, // pk_tot_out[index_zvec*kvec_size+index_kvec],
                                                           // already allocated
                                                           //(or NULL if user knows there is no _m output)
                                      double * pk_cb_tot_out, // idem
                                      int nonlinear
                                      ) {
  enum pk_outputs pk_output;

  fprintf(stderr," -> [WARNING:] You are calling the function harmonic_fast_pks_at_kvec_and_zvec() which is deprecated since v2.8. It will soon be removed. Use fourier_pk_at_kvec_and_zvec() instead.\n");

  if (nonlinear == _TRUE_)
    pk_output = pk_nonlinear;
  else
    pk_output = pk_linear;

  class_call(fourier_pks_at_kvec_and_zvec(
                                          pba,
                                          phr->pfo,
                                          pk_output,
                                          kvec,
                                          kvec_size,
                                          zvec,
                                          zvec_size,
                                          pk_tot_out,
                                          pk_cb_tot_out),
             phr->pfo->error_message,
             phr->error_message);

  return _SUCCESS_;
}

/**
 * This routine computes sigma(R) given P(k) for total matter power
 * spectrum (does not check that k_max is large enough)
 *
 * This function is deprecated since v2.8. Try using fourier_sigmas_at_z() instead.
 *
 * @param pba   Input: pointer to background structure
 * @param ppm   Input: pointer to primordial structure
 * @param phr   Input: pointer to harmonic structure
 * @param R     Input: radius in Mpc
 * @param z     Input: redshift
 * @param sigma Output: variance in a sphere of radius R (dimensionless)
 * @return the error status
 */

int harmonic_sigma(
                   struct background * pba,
                   struct primordial * ppm,
                   struct harmonic * phr,
                   double R,
                   double z,
                   double * sigma
                   ) {

  fprintf(stderr," -> [WARNING:] You are calling the function harmonic_sigma() which is deprecated since v2.8. It will soon be removed. Use fourier_sigmas_at_z() instead.\n");

  if (phr->pfo->has_pk_m) {

    class_call(fourier_sigma_at_z(pba,
                                  phr->pfo,
                                  R,
                                  z,
                                  phr->pfo->index_pk_m,
                                  80., // hardcoded, yes, but the function is deprecated...
                                  sigma),
               phr->pfo->error_message,
               phr->error_message);

  }

  return _SUCCESS_;
}

/**
 * This routine computes sigma(R) given P(k) for baryon+cdm power
 * spectrum (does not check that k_max is large enough)
 *
 * This function is deprecated since v2.8. Try using fourier_sigmas_at_z() instead.
 *
 * @param pba      Input: pointer to background structure
 * @param ppm      Input: pointer to primordial structure
 * @param phr      Input: pointer to harmonic structure
 * @param R        Input: radius in Mpc
 * @param z        Input: redshift
 * @param sigma_cb Output: variance in a sphere of radius R (dimensionless)
 * @return the error status
 */

int harmonic_sigma_cb(
                      struct background * pba,
                      struct primordial * ppm,
                      struct harmonic * phr,
                      double R,
                      double z,
                      double * sigma_cb
                      ) {

  fprintf(stderr," -> [WARNING:] You are calling the function harmonic_sigma_cb() which is deprecated since v2.8. It will soon be removed. Use fourier_sigmas_at_z() instead.\n");

  if (phr->pfo->has_pk_cb) {

    class_call(fourier_sigma_at_z(pba,
                                  phr->pfo,
                                  R,
                                  z,
                                  phr->pfo->index_pk_cb,
                                  80., // hardcoded, yes, but the function is deprecated...
                                  sigma_cb),
               phr->pfo->error_message,
               phr->error_message);
  }

  return _SUCCESS_;
}

/* deprecated functions (since v2.1) */

/**
 * Obsolete function, superseeded by perturbations_sources_at_tau()
 * (at the time of the switch, this function was anyway never used anywhere)
 *
 * @param pba        Input: pointer to background structure (used for converting z into tau)
 * @param phr        Input: pointer to harmonic structure (containing pre-computed table)
 * @param z          Input: redshift
 * @param output     Output: matter transfer functions
 * @return the error status
 */

int harmonic_tk_at_z(
                     struct background * pba,
                     struct harmonic * phr,
                     double z,
                     double * output /* array with argument output[(index_k*phr->ic_size[index_md]+index_ic)*phr->tr_size+index_tr] (must be already allocated) */
                     ) {


  class_stop(phr->error_message,
             "The function harmonic_tk_at_z() is obsolete, use instead perturbations_sources_at_z(), it does the same");

  return _SUCCESS_;

}

/**
 * Obsolete function, superseeded by perturbations_sources_at_tau()
 * (at the time of the switch, this function was anyway never used anywhere)
 *
 * @param pba        Input: pointer to background structure (used for converting z into tau)
 * @param phr        Input: pointer to harmonic structure (containing pre-computed table)
 * @param k          Input: wavenumber in 1/Mpc
 * @param z          Input: redshift
 * @param output     Output: matter transfer functions
 * @return the error status
 */

int harmonic_tk_at_k_and_z(
                           struct background * pba,
                           struct harmonic * phr,
                           double k,
                           double z,
                           double * output  /* array with argument output[index_ic*phr->tr_size+index_tr] (must be already allocated) */
                           ) {

  class_stop(phr->error_message,
             "The function harmonic_tk_at_k_and_z() is obsolete, use instead perturbations_sources_at_k_and_z(), it does the same");

  return _SUCCESS_;

}

/* end deprecated functions */

```

`source/input.c`:

```c
/** @file input.c Documented input module.
 *
 * Julien Lesgourgues, 27.08.2010
 * * internal organization of the module structured and improved by Nils Schoeneberg and Matteo Lucca, 07.03.2019
 *
 */

#include "input.h"

/* The input module fills variables belonging to the structures of
   essentially all other modules. Thus we need to include all the
   headers. New in v3.0: These #include fit better here than in
   input.h, to avoid complictaed dependencies slowing down
   compilation. */

#include "quadrature.h"
#include "background.h"
#include "thermodynamics.h"
#include "perturbations.h"
#include "transfer.h"
#include "primordial.h"
#include "harmonic.h"
#include "fourier.h"
#include "lensing.h"
#include "distortions.h"
#include "output.h"

/**
 * Initialize input parameters from external file.
 *
 * @param argc    Input: Number of command line arguments
 * @param argv    Input: Command line argument strings
 * @param ppr     Input: pointer to precision structure
 * @param pba     Input: pointer to background structure
 * @param pth     Input: pointer to thermodynamics structure
 * @param ppt     Input: pointer to perturbation structure
 * @param ptr     Input: pointer to transfer structure
 * @param ppm     Input: pointer to primordial structure
 * @param phr     Input: pointer to harmonic structure
 * @param pfo     Input: pointer to fourier structure
 * @param ple     Input: pointer to lensing structure
 * @param psd     Input: pointer to distorsion structure
 * @param pop     Input: pointer to output structure
 * @param errmsg  Input/Output: Error message
 * @return the error status
 */

int input_init(int argc,
               char **argv,
               struct precision * ppr,
               struct background *pba,
               struct thermodynamics *pth,
               struct perturbations *ppt,
               struct transfer *ptr,
               struct primordial *ppm,
               struct harmonic *phr,
               struct fourier * pfo,
               struct lensing *ple,
               struct distortions *psd,
               struct output *pop,
               ErrorMsg errmsg){

  /** Summary: */

  /** Define local variables */
  struct file_content fc;        // Structure with all parameters

  /** Find and read input file */
  class_call(input_find_file(argc,
                             argv,
                             &fc,
                             errmsg),
             errmsg,
             errmsg);

  /** Initialize all parameters given the input 'file_content' structure.
      If its size is null, all parameters take their default values. */
  class_call(input_read_from_file(&fc,ppr,pba,pth,ppt,ptr,ppm,phr,pfo,ple,psd,pop,
                                  errmsg),
             errmsg,
             errmsg);

  /** Free local struture */
  class_call(parser_free(&fc),
             errmsg,
             errmsg);

  return _SUCCESS_;

}


/**
 * Find and read external file (xxx.ini or xxx.pre) containing the input
 * parameters. All data is stored in the local structure 'file_content'.
 *
 * @param argc    Input: Number of command line arguments
 * @param argv    Input: Command line argument strings
 * @param fc      Output: file_content structure
 * @param errmsg  Input/Output: Error message
 * @return the error status
 */

int input_find_file(int argc,
                    char **argv,
                    struct file_content * fc,
                    ErrorMsg errmsg){

  /** Summary: */

  /** Define local variables */
  struct file_content fc_input;       // Temporary structure with all input parameters
  struct file_content fc_precision;   // Temporary structure with all precision parameters
  struct file_content * pfc_input;    // Pointer to either fc_root or fc_inputroot
  struct file_content fc_setroot;     // Temporary structure for setroot

  int i;
  char extension[5];
  char input_file[_ARGUMENT_LENGTH_MAX_];
  char precision_file[_ARGUMENT_LENGTH_MAX_];

  pfc_input = &fc_input;

  /** Initialize the two file_content structures (for input parameters and
      precision parameters) to some null content. If no arguments are passed,
      they will remain null and inform input_init that all parameters take
      default values. */
  fc->size = 0;
  fc_input.size = 0;
  fc_precision.size = 0;
  input_file[0]='\0';
  precision_file[0]='\0';

  /** If some arguments are passed, identify eventually some 'xxx.ini' and
      'xxx.pre' files, and store their name. */
  if (argc > 1) {
    for (i=1; i<argc; i++) {
      strncpy(extension,(argv[i]+strlen(argv[i])-4),4);
      extension[4]='\0';
      if (strcmp(extension,".ini") == 0) {
        class_test(input_file[0] != '\0',
                   errmsg,
                   "You have passed more than one input file with extension '.ini', choose one.");
        strcpy(input_file,argv[i]);
      }
      else if (strcmp(extension,".pre") == 0) {
        class_test(precision_file[0] != '\0',
                   errmsg,
                   "You have passed more than one precision with extension '.pre', choose one.");
        strcpy(precision_file,argv[i]);
      }
      else {
        fprintf(stdout,"Warning: the file '%s' has an extension different from .ini and .pre, so it has been ignored\n",argv[i]);
      }
    }
  }

  /** If there is an 'xxx.ini' file, read it and store its content. */
  if (input_file[0] != '\0'){
    class_call(parser_read_file(input_file,&fc_input,errmsg),
               errmsg,
               errmsg);

    /* *
     * Set correctly the pfc_input within the set_root function,
     * including the adjusted 'root' field.
     * It is either set to a pointer to fc_input,
     * or when a new filecontent is created with root appended,
     * it is set as the pointer to fc_setroot.
     * */
    class_call(input_set_root(input_file,&pfc_input,&fc_setroot,errmsg),
               errmsg,
               errmsg);
  }

  /** If there is an 'xxx.pre' file, read it and store its content. */
  if (precision_file[0] != '\0'){
    class_call(parser_read_file(precision_file,&fc_precision,errmsg),
               errmsg,
               errmsg);
  }

  /** If one or two files were read, merge their contents in a single 'file_content'
      structure. */
  if ((input_file[0]!='\0') || (precision_file[0]!='\0')){
    class_call(parser_cat(pfc_input,
                          &fc_precision,
                          fc,
                          errmsg),
               errmsg,
               errmsg);
  }

  /** Free local strutures */
  class_call(parser_free(pfc_input),
             errmsg,
             errmsg);
  class_call(parser_free(&fc_precision),
             errmsg,
             errmsg);

  return _SUCCESS_;

}

/**
 * Sets the 'root' variable in the input file content (this will be
 * the beginning of the name of all output files for the current CLASS
 * run)
 *
 * @param input_file      Input: filename of the input file
 * @param ppfc_input      Input/Output: pointer to (pointer to input file structure)
 * @param pfc_setroot     Input: pointer to an allocated temporary file content that will be used here
 * @param errmsg          Input/Output: the error message
 * @return the error status
 */

int input_set_root(char* input_file,
                   struct file_content** ppfc_input,
                   struct file_content * pfc_setroot,
                   ErrorMsg errmsg) {

  /** Define local variables */
  int flag1, filenum, iextens;
  int index_root_in_fc_input = -1;
  int overwrite_root;
  int found_filenum;

  /* The filename of the output root INCLUDING 'output/' */
  FileArg outfname;

  /* Temporary variables for parser reading etc. */
  char tmp_file[_ARGUMENT_LENGTH_MAX_+26]; // 26 is enough to extend the file name [...] with the
                                           // characters "output/[...]%02d_parameters.ini" (as done below)
  struct file_content fc_root;             // Temporary structure with only the root name

  FileArg string1;                         //Is ignored

  int n_extensions = 7;                    //Keep this as the length of the below list
  char* output_extensions[7] = {"cl.dat","pk.dat","tk.dat","parameters.ini","background.dat","thermodynamics.dat","perturbations_k0.dat"};

  /* Shorthand notation */
  struct file_content * pfc = *ppfc_input;


  /** Check whether a root name has been set, and wether overwrite_root is true */
  class_call(parser_read_string(pfc,"root",&string1,&flag1,errmsg),
             errmsg, errmsg);

  /* Set overwrite_root */
  overwrite_root = _FALSE_;
  class_read_flag("overwrite_root",overwrite_root);

  /** If root has not been set, use the default of 'output/<this-filename>' */
  if (flag1 == _FALSE_){
    memcpy(outfname, "output/", 7);
    memcpy(outfname+7, input_file, strlen(input_file)-4);
    outfname[7+strlen(input_file)-4] = '\0';
  }
  /* Check here for the index of the 'root' field in case it was set in fc_input */
  else{
    for (index_root_in_fc_input=0;index_root_in_fc_input<pfc->size;++index_root_in_fc_input){
      if (strcmp(pfc->name[index_root_in_fc_input],"root") == 0){
        strcpy(outfname,pfc->value[index_root_in_fc_input]);
        break;
      }
    }
  }

  /** If we don't want to overwrite the root name, check now for the existence of output for the given root name + N */
  if (overwrite_root == _FALSE_){

    /* Assume files exist, until proven otherwise */
    found_filenum = _TRUE_;
    /** For each 'filenum', test if it exists. Only stop if it has not been found. */
    for (filenum = 0; filenum < _N_FILEROOT_ && found_filenum; filenum++){
      /* No file has been found yet */
      found_filenum = _FALSE_;
      for (iextens = 0; iextens < n_extensions; ++iextens){
        class_sprintf(tmp_file,"%s%02d_%s", outfname, filenum, output_extensions[iextens]);
        if (file_exists(tmp_file) == _TRUE_){
          /* Found a file, the outer loop is forced to keep searching */
          found_filenum = _TRUE_;
        }
      }
      /* Didn't find a file. This is the correct number. Break the loop. */
      if (found_filenum == _FALSE_){
        break;
      }
    }
    /* If no root was found, add root through the parser routine */
    if (flag1 == _FALSE_){
      class_call(parser_init(&fc_root,
                             1,
                             pfc->filename,
                             errmsg),
                 errmsg,errmsg);
      class_sprintf(fc_root.name[0],"root");
      class_sprintf(fc_root.value[0],"%s%02d_",outfname,filenum);
      fc_root.read[0] = _FALSE_;
      class_call(parser_cat(pfc,
                            &fc_root,
                            pfc_setroot,
                            errmsg),
                 errmsg,
                 errmsg);
      class_call(parser_free(pfc),
                 errmsg,
                 errmsg);
      class_call(parser_free(&fc_root),
                 errmsg,
                 errmsg);
      (*ppfc_input) = pfc_setroot;
    }
    /* If root was found, set the index in the fc_input struct */
    else{
      class_sprintf(pfc->value[index_root_in_fc_input],"%s%02d_",outfname,filenum);
      (*ppfc_input) = pfc;
    }
  }

  /** If we do want to overwrite, just take the given root name */
  else{
    /* If no root was found, add root through the parser routine */
    if (flag1 == _FALSE_){
      class_call(parser_init(&fc_root,
                             1,
                             pfc->filename,
                             errmsg),
                 errmsg,errmsg);
      class_sprintf(fc_root.name[0],"root");
      class_sprintf(fc_root.value[0],"%s_",outfname);
      fc_root.read[0] = _FALSE_;
      class_call(parser_cat(pfc,
                            &fc_root,
                            pfc_setroot,
                            errmsg),
                 errmsg,
                 errmsg);
      class_call(parser_free(pfc),
                 errmsg,
                 errmsg);
      class_call(parser_free(&fc_root),
                 errmsg,
                 errmsg);
      (*ppfc_input) = pfc_setroot;
    }
    /* If root was found, set the index in the fc_input struct */
    else{
      class_sprintf(pfc->value[index_root_in_fc_input],"%s_",outfname);
      (*ppfc_input) = pfc;
    }
  }

  return _SUCCESS_;
}



/**
 * Initialize each parameter, first to its default values, and then
 * from what can be interpreted from the values passed in the input
 * 'file_content' structure. If its size is null, all parameters keep
 * their default values.
 *
 * @param pfc     Input: pointer to local structure
 * @param ppr     Input: pointer to precision structure
 * @param pba     Input: pointer to background structure
 * @param pth     Input: pointer to thermodynamics structure
 * @param ppt     Input: pointer to perturbation structure
 * @param ptr     Input: pointer to transfer structure
 * @param ppm     Input: pointer to primordial structure
 * @param phr     Input: pointer to harmonic structure
 * @param pfo     Input: pointer to fourier structure
 * @param ple     Input: pointer to lensing structure
 * @param psd     Input: pointer to distorsion structure
 * @param pop     Input: pointer to output structure
 * @param errmsg  Input/Output: Error message
 * @return the error status
 */

int input_read_from_file(struct file_content * pfc,
                         struct precision * ppr,
                         struct background *pba,
                         struct thermodynamics *pth,
                         struct perturbations *ppt,
                         struct transfer *ptr,
                         struct primordial *ppm,
                         struct harmonic *phr,
                         struct fourier * pfo,
                         struct lensing *ple,
                         struct distortions *psd,
                         struct output *pop,
                         ErrorMsg errmsg) {


  /** Summary: */

  /** - Define local variables */
  int input_verbose = 0;
  int has_shooting;

  /** Set default values
      Before getting into the assignment of parameters and the shooting, we want
      to already fix our precision parameters. No precision parameter should
      depend on any input parameter  */
  class_call(input_read_precisions(pfc,ppr,pba,pth,ppt,ptr,ppm,phr,pfo,ple,psd,pop,
                                   errmsg),
             errmsg,
             errmsg);

  class_read_int("input_verbose",input_verbose);
  if (input_verbose >0) printf("Reading input parameters\n");

  /** -- Special setting of parameter, before anything else: did shooting fail? */
  pba->shooting_failed = _FALSE_;

  /** Find out if shooting necessary and, eventually, shoot and initialize
      read parameters */
  class_call(input_shooting(pfc,ppr,pba,pth,ppt,ptr,ppm,phr,pfo,ple,psd,pop,
                            input_verbose,
                            &has_shooting,
                            errmsg),
             errmsg,
             errmsg);

  /** Update structs with input that is potentially updated after shooting */
  class_call(input_read_parameters(pfc,ppr,pba,pth,ppt,ptr,ppm,phr,pfo,ple,psd,pop,
                                    errmsg),
              errmsg,
              errmsg);

  if (has_shooting == _TRUE_ && pba->shooting_failed == _TRUE_) {
    // Shooting failed, but error must be thrown in background in order to trigger a
    // runtime error, so here we skip the rest and go straight to background
    return _SUCCESS_;
  }

  /** Write info on the read/unread parameters. This is the correct place to do it,
      since we want it to happen after all the shooting business,
      and after the final reading of all parameters */
  class_call(input_write_info(pfc,pop,
                              errmsg),
             errmsg,
             errmsg);

  if (pfo->has_pk_eq == _TRUE_) {

    if (input_verbose > 0) {
      printf(" -> since you want to use Halofit with a non-zero wa_fld and the Pk_equal method,\n");
      printf("    calling background module to extract the effective w(tau), Omega_m(tau) parameters");
      printf("    required by this method\n");
    }
    class_call(input_prepare_pk_eq(ppr,pba,pth,pfo,input_verbose,errmsg),
               errmsg,
               errmsg);
  }

  return _SUCCESS_;

}


/**
 * In CLASS, we call 'shooting' the process of doing preliminary runs
 * of parts of the code in order to find numerically the value of an
 * input variable which cannot be inferred analytically from other
 * input variables passed by the user.
 *
 * A typical example is when the user passes theta_s, the angular
 * scale of the sound horizon at decoupling. This quantity be passed
 * instead of the hubble parameter h, but only if we run CLASS until
 * the thermodynamics module to figure out how h and theta_s relate
 * numerically. The code starts from a guess for h, and runs to find
 * the corresponding theta_s. It adjusts h, shoots again, and repeats
 * this process until it finds some h giving the correct theta_s
 * within some tolerance.
 *
 * This function contains the overall structure to handle these steps.
 *
 * @param pfc               Input/Output: pointer to file content, with input parameters before/after the shooting
 * @param ppr               Input: pointer to precision structure
 * @param pba               Input: pointer to background structure
 * @param pth               Input: pointer to thermodynamics structure
 * @param ppt               Input: pointer to perturbation structure
 * @param ptr               Input: pointer to transfer structure
 * @param ppm               Input: pointer to primordial structure
 * @param phr               Input: pointer to harmonic structure
 * @param pfo               Input: pointer to fourier structure
 * @param ple               Input: pointer to lensing structure
 * @param psd               Input: pointer to distorsion structure
 * @param pop               Input: pointer to output structure
 * @param input_verbose     Input: Verbosity of input
 * @param has_shooting      Output: do we need shooting?
 * @param errmsg            Input/Output: Error message
 * @return the error status
 */

int input_shooting(struct file_content * pfc,
                   struct precision * ppr,
                   struct background *pba,
                   struct thermodynamics *pth,
                   struct perturbations *ppt,
                   struct transfer *ptr,
                   struct primordial *ppm,
                   struct harmonic *phr,
                   struct fourier * pfo,
                   struct lensing *ple,
                   struct distortions *psd,
                   struct output *pop,
                   int input_verbose,
                   int * has_shooting,
                   ErrorMsg errmsg){

  /** Summary: */

  /** Define local variables */
  int flag1, flag2;
  double param1, param2;
  double * unknown_parameter;
  int unknown_parameters_size;
  int counter, index_target, i;
  int fevals=0;
  double xzero;
  double *dxdF, *x_inout;
  int target_indices[_NUM_TARGETS_];
  int needs_shooting;
  int shooting_failed=_FALSE_;

  /* array of parameters passed by the user for which we need shooting (= target parameters) */
  char * const target_namestrings[] = {"100*theta_s",
                                       "theta_s_100",
                                       "Neff",
                                       "Omega_dcdmdr",
                                       "omega_dcdmdr",
                                       "Omega_scf",
                                       "Omega_ini_dcdm",
                                       "omega_ini_dcdm"};

  /* array of corresponding parameters that must be adjusted in order to meet the target (= unknown parameters) */
  char * const unknown_namestrings[] = {"h",                        /* unknown param for target '100*theta_s' */
                                        "h",                        /* unknown param for target 'theta_s_100' */
                                        "N_ur",                     /* unknown param for target 'Neff' */
                                        "Omega_ini_dcdm",           /* unknown param for target 'Omega_dcdmd' */
                                        "omega_ini_dcdm",           /* unknown param for target 'omega_dcdmdr' */
                                        "scf_shooting_parameter",   /* unknown param for target 'Omega_scf' */
                                        "Omega_dcdmdr",             /* unknown param for target 'Omega_ini_dcdm' */
                                        "omega_dcdmdr"};             /* unknown param for target 'omega_ini_dcdm' */

  /* for each target, module up to which we need to run CLASS in order
     to compute the targetted quantities (not running the whole code
     each time to saves a lot of time) */
  enum computation_stage target_cs[] = {cs_thermodynamics, /* computation stage for target '100*theta_s' */
                                        cs_thermodynamics, /* computation stage for target 'theta_s_100' */
                                        cs_background,     /* computation stage for target 'Neff' */
                                        cs_background,     /* computation stage for target 'Omega_dcdmdr' */
                                        cs_background,     /* computation stage for target 'omega_dcdmdr' */
                                        cs_background,     /* computation stage for target 'Omega_scf' */
                                        cs_background,     /* computation stage for target 'Omega_ini_dcdm' */
                                        cs_background};     /* computation stage for target 'omega_ini_dcdm' */

  struct fzerofun_workspace fzw;

  *has_shooting=_FALSE_;

  /** Do we need to fix unknown parameters? */
  unknown_parameters_size = 0;
  fzw.required_computation_stage = 0;
  for (index_target = 0; index_target < _NUM_TARGETS_; index_target++){
    class_call(parser_read_double(pfc,target_namestrings[index_target],&param1,&flag1,errmsg),
               errmsg,
               errmsg);
    if (flag1 == _TRUE_){
      /* input_needs_shoting_for_target takes care of the case where, for
         instance, Omega_dcdmdr is set to 0.0, and we don't need shooting */
      class_call(input_needs_shooting_for_target(pfc,
                                                 index_target,
                                                 param1,
                                                 &needs_shooting,
                                                 errmsg),
                 errmsg,
                 errmsg);

      if (needs_shooting == _TRUE_){
        target_indices[unknown_parameters_size] = index_target;
        fzw.required_computation_stage = MAX(fzw.required_computation_stage,target_cs[index_target]);
        unknown_parameters_size++;
      }

    }
  }

  /** In the case of unknown parameters, start shooting... */
  if (unknown_parameters_size > 0) {

    /* We need to remember that we shot so we can clean up properly */
    *has_shooting=_TRUE_;

    /* Create file content structure with additional entries */
    class_call(parser_extend(pfc, unknown_parameters_size, errmsg),
               errmsg,errmsg);

    class_call(parser_init_from_pfc(pfc, &(fzw.fc), errmsg),
               errmsg,errmsg);

    class_alloc(unknown_parameter,
                unknown_parameters_size*sizeof(double),
                errmsg);
    class_alloc(fzw.unknown_parameters_index,
                unknown_parameters_size*sizeof(int),
                errmsg);

    fzw.target_size = unknown_parameters_size;
    class_alloc(fzw.target_name,
                fzw.target_size*sizeof(enum target_names),
                errmsg);
    class_alloc(fzw.target_value,
                fzw.target_size*sizeof(double),
                errmsg);

    /** Go through all cases with unknown parameters */
    for (counter = 0; counter < unknown_parameters_size; counter++){
      index_target = target_indices[counter];
      class_call(parser_read_double(pfc,
                                    target_namestrings[index_target],
                                    &param1,
                                    &flag1,
                                    errmsg),
                 errmsg,
                 errmsg);

      /* store name of target parameter */
      fzw.target_name[counter] = index_target;
      /* store target value of target parameter */
      fzw.target_value[counter] = param1;
      fzw.unknown_parameters_index[counter]=pfc->size+counter-unknown_parameters_size;
      /* substitute the name of the target parameter with the name of the
         corresponding unknown parameter */
      strcpy(fzw.fc.name[fzw.unknown_parameters_index[counter]],unknown_namestrings[index_target]);
    }

    /** If there is only one parameter, we use a more efficient Newton method for 1D cases */
    if (unknown_parameters_size == 1){

      /* We can do 1 dimensional root finding */
      if (input_verbose > 0) {
        printf("Computing unknown input parameter '%s' using input parameter '%s'\n",
               fzw.fc.name[fzw.unknown_parameters_index[0]],
               target_namestrings[fzw.target_name[0]]);
      }

      /* If shooting fails, postpone error to background module to play nice with MontePython. */
      class_call_try(input_find_root(&xzero,
                                     &fevals,
                                     ppr->tol_shooting_deltax_rel,
                                     &fzw,
                                     errmsg),
                     errmsg,
                     pba->shooting_error,
                     shooting_failed=_TRUE_);

      /* Store xzero */
      // This needs to be done with enough accuracy. A standard double has a relative
      // precision of around 1e-16, so 1e-20 should be good enough for the shooting
      class_sprintf(fzw.fc.value[fzw.unknown_parameters_index[0]],"%.20e",xzero);
      if (input_verbose > 0) {
        if (shooting_failed == _FALSE_){
          printf(" -> found '%s = %s'\n",
                  fzw.fc.name[fzw.unknown_parameters_index[0]],
                  fzw.fc.value[fzw.unknown_parameters_index[0]]);
        }
        else{
          printf("Shooting failed! Aborting...\n");
        }
      }

    }
    /** Otherwise we do multidimensional shooting */
    else{

      /* We need to do multidimensional root finding */
      if (input_verbose > 0) {
        printf("Computing unknown input parameters\n");
      }

      /* Allocate local variables */
      class_alloc(x_inout,
                  sizeof(double)*unknown_parameters_size,
                  errmsg);
      class_alloc(dxdF,
                  sizeof(double)*unknown_parameters_size,
                  errmsg);

      /* Get the guess for the initial variables */
      class_call(input_get_guess(x_inout, dxdF, &fzw, errmsg),
                 errmsg,
                 errmsg);

      /* Use multi-dimensional Newton method */
      class_call_try(fzero_Newton(input_try_unknown_parameters,
                                  x_inout,
                                  dxdF,
                                  unknown_parameters_size,
                                  ppr->tol_shooting_deltax,
                                  ppr->tol_shooting_deltaF,
                                  &fzw,
                                  &fevals,
                                  errmsg),
                     errmsg,
                     pba->shooting_error,
                     shooting_failed=_TRUE_);

      /* Store xzero */
      // This needs to be done with enough accuracy. A standard double has a relative
      // precision of around 1e-16, so 1e-20 should be good enough for the shooting
      for (counter = 0; counter < unknown_parameters_size; counter++){
        class_sprintf(fzw.fc.value[fzw.unknown_parameters_index[counter]],
                "%.20e",x_inout[counter]);
        if (input_verbose > 0) {
          if (shooting_failed == _FALSE_){
            printf(" -> found '%s = %s'\n",
                    fzw.fc.name[fzw.unknown_parameters_index[counter]],
                    fzw.fc.value[fzw.unknown_parameters_index[counter]]);
          }
          else{
            printf("Shooting failed! Aborting...\n");
          }
        }
      }

      /* Free local variables */
      free(x_inout);
      free(dxdF);
    }

    if (input_verbose > 1 && shooting_failed == _FALSE_) {
      printf("Shooting completed using %d function evaluations\n",fevals);
    }

    /** Set status of shooting */
    pba->shooting_failed = shooting_failed;

    parser_copy(&(fzw.fc), pfc, pfc->size - unknown_parameters_size, pfc->size);

    /** Free arrays allocated */
    class_call(parser_free(&(fzw.fc)),
               errmsg, errmsg);
    free(unknown_parameter);
    free(fzw.unknown_parameters_index);
    free(fzw.target_name);
    free(fzw.target_value);
  }


  /** After the 'normal' shooting is done, do special shooting just for sigma8 if needed*/
  class_call(parser_read_double(pfc,"sigma8",&param1,&flag1,errmsg),
             errmsg,
             errmsg);
  class_call(parser_read_double(pfc,"S8",&param2,&flag2,errmsg),
             errmsg,
             errmsg);
  class_test((flag1 == _TRUE_) && (flag2 == _TRUE_),
             errmsg,
             "You can only enter one of 'sigma8' or 'S8'.");
  if (flag1 == _TRUE_ || flag2 == _TRUE_) {
    /* Tell the main function that shooting indeed has occured */
    *has_shooting=_TRUE_;

    /* Create file content structure with additional entries */
    class_call(parser_extend(pfc, 1, errmsg),
               errmsg,errmsg);

    class_call(parser_init_from_pfc(pfc, &(fzw.fc), errmsg),
               errmsg,errmsg);

    fzw.target_size = 1;
    class_alloc(fzw.unknown_parameters_index,
                1*sizeof(int),
                errmsg);
    class_alloc(fzw.target_name,
                1*sizeof(enum target_names),
                errmsg);
    class_alloc(fzw.target_value,
                1*sizeof(double),
                errmsg);

    /* store name of target parameter */
    if (flag1 == _TRUE_) {
      fzw.target_name[0] = sigma8;
      fzw.target_value[0] = param1;
    }
    else if (flag2 == _TRUE_) {
      fzw.target_name[0] = S8;
      fzw.target_value[0] = param2;
    }
    /* store target value of target parameter */
    fzw.unknown_parameters_index[0]=pfc->size - 1;
    fzw.required_computation_stage = cs_nonlinear;
    /* substitute the name of the target parameter with the name of the
       corresponding unknown parameter */
    strcpy(fzw.fc.name[pfc->size - 1],"A_s");

    /* Print to the user */
    if (input_verbose > 0) {
      printf("Computing unknown input parameter '%s' using input parameter '%s'\n",
             (flag1 ==_TRUE_?"sigma8":"S8"),
             "A_s");
    }

    /* Set a guess for A_s from LCDM (doesn't need to be super accurate) */
    double A_s;
    if (flag1 == _TRUE_) {
      A_s = param1 * 2.43e-9/0.87659;
    }
    else if (flag2 == _TRUE_) {
      A_s = param2 *2.43e-9/0.891;
    }
    double sigma8_or_S8;

    /* Now run for a single time, get the value of sigma8 (or S8) for the guess*/
    class_call(input_try_unknown_parameters(&A_s,
                                            1,
                                            &fzw,
                                            &sigma8_or_S8,
                                            errmsg),
               errmsg,
               errmsg);

    A_s = (fzw.target_value[0]/sigma8_or_S8) *(fzw.target_value[0]/sigma8_or_S8) * A_s; //(truesigma/sigma_for_guess)^2 *A_s_for_guess

    /* Store the derived value with high enough accuracy */
    class_sprintf(fzw.fc.value[pfc->size - 1],"%.20e",A_s);
    if (input_verbose > 0) {
      printf(" -> found '%s = %s'\n",
             fzw.fc.name[pfc->size - 1],
             fzw.fc.value[pfc->size - 1]);
    }

    parser_copy(&(fzw.fc), pfc, pfc->size - 1, pfc->size);

    /** Free arrays allocated */
    class_call(parser_free(&(fzw.fc)),
               errmsg, errmsg);
    free(fzw.unknown_parameters_index);
    free(fzw.target_name);
    free(fzw.target_value);
  }

  return _SUCCESS_;

}


/**
 * Related to 'shooting': for each target, check whether it is
 * sufficient to stick to the default value of the unkown parameter
 * (for instance: if the target parameter is a density and the target
 * value is zero, the unkown parameter should remain zero like in the
 * default)
 *
 * @param pfc             Input: pointer to local structure
 * @param target_name     Input: list of possible target names
 * @param target_value    Input: list of possible target values
 * @param needs_shooting  Output: needs shooting?
 * @param errmsg          Input/Output: Error message
 * @return the error status
 */

int input_needs_shooting_for_target(struct file_content * pfc,
                                    enum target_names target_name,
                                    double target_value,
                                    int * needs_shooting,
                                    ErrorMsg errmsg){

  *needs_shooting = _TRUE_;
  switch (target_name){
  case Omega_dcdmdr:
  case omega_dcdmdr:
  case Omega_scf:
  case Omega_ini_dcdm:
  case omega_ini_dcdm:
    /* Check that Omega's or omega's are nonzero: */
    if (target_value == 0.)
      *needs_shooting = _FALSE_;
    break;
  default:
    /* Default is no additional checks */
    *needs_shooting = _TRUE_;
    break;
  }

  return _SUCCESS_;

}

/**
 * Related to 'shooting': Find the root of a one-dimensional
 * function. This function starts from a first guess, then uses a few
 * steps to bracket the root, and then calls another function to
 * actually get the root.
 *
 * @param xzero     Output: root x such that f(x)=0 up to tolerance (f(x) = input_fzerofun_1d)
 * @param fevals    Output: number of iterations (that is, of CLASS runs) needed to find the root
 * @param tol_x_rel Input : Relative tolerance compared to bracket of root that is used to find root.
 * @param pfzw      Input : pointer to workspace containing targets, unkown parameters and other relevant information
 * @param errmsg    Input/Output: Error message
 * @return the error status
 */

int input_find_root(double *xzero,
                    int *fevals,
                    double tol_x_rel,
                    struct fzerofun_workspace *pfzw,
                    ErrorMsg errmsg){

  /** Summary: */

  /** Define local variables */
  double x1, x2, f1, f2, dxdy, dx;
  int iter, iter2;
  int return_function;

  /** Fisrt we do our guess */
  class_call(input_get_guess(&x1, &dxdy, pfzw, errmsg),
             errmsg,
             errmsg);

  class_call(input_fzerofun_1d(x1, pfzw, &f1, errmsg),
             errmsg,
             errmsg);

  (*fevals)++;
  dx = 1.5*f1*dxdy;

  /** Then we do a linear hunt for the boundaries */
  /* Try fifteen times to go above and below the root (i.e. where shooting succeeds) */
  for (iter=1; iter<=15; iter++){
    x2 = x1 - dx;
    /* Try three times to get a 'reasonable' value, i.e. no CLASS error */
    for (iter2=1; iter2 <= 3; iter2++) {
      return_function = input_fzerofun_1d(x2, pfzw, &f2, errmsg);
      (*fevals)++;
      if (return_function ==_SUCCESS_) {
        break;
      }
      else if (iter2 < 3) {
        dx*=0.5;
        x2 = x1-dx;
      }
      else {
        class_stop(errmsg,errmsg);
      }
    }
    if (f1*f2<0.0){
      /* Root has been bracketed */
      break;
    }
    x1 = x2;
    f1 = f2;
  }

  /** Find root using Ridders method (Exchange for bisection if you are old-school) */
  class_call(input_fzero_ridder(input_fzerofun_1d,
                                x1,
                                x2,
                                tol_x_rel*MAX(fabs(x1),fabs(x2)),
                                pfzw,
                                &f1,
                                &f2,
                                xzero,
                                fevals,
                                errmsg),
             errmsg,errmsg);

  return _SUCCESS_;

}

/**
 * Related to 'shooting': defines 1d function of which we want to find
 * the root during the shooting.  The function is simply: "prediction
 * of CLASS for a target parameter y given a parameter x - targeted
 * value of y"
 *
 * @param input         Input: value of x
 * @param pfzw          Input: pointer to workspace containing targets, unkown parameters and other relevant information
 * @param output        Ouput: f(x) = y - y_targeted
 * @param error_message Input/Output: Error message
 * @return the error status
 */

int input_fzerofun_1d(double input,
                      void* pfzw,
                      double *output,
                      ErrorMsg error_message){

  class_call(input_try_unknown_parameters(&input,
                                          1,
                                          pfzw,
                                          output,
                                          error_message),
             error_message,
             error_message);

  return _SUCCESS_;

}


/**
 * Related to 'shooting': using Ridders' method, return the root x of
 * a function f(x) known to lie between x1 and x2, up to some
 * tolerance. Note that this function is very generic and could easily
 * be moved to the tools (and be used in other modules).
 *
 * @param func   Input: function y=f(x), with arguments: x, pointer to y, and another pointer containing several fixed parameters
 * @param x1            Input: lower boundary x1<x
 * @param x2            Input: upper boundary x<x2
 * @param xtol          Input: tolerance: |x- true root|<xtol
 * @param param         Input: fixed parameters passed to f(x)
 * @param Fx1           Input: f(x1)
 * @param Fx2           Input: f(x2)
 * @param xzero         Output: root x
 * @param fevals        Output: number of iterations (that is, of CLASS runs) needed to find the root
 * @param error_message Input/Output: Error message
 * @return the error status
 */

int input_fzero_ridder(int (*func)(double x,
                                   void *param,
                                   double *y,
                                   ErrorMsg error_message),
                       double x1,
                       double x2,
                       double xtol,
                       void *param,
                       double *Fx1,
                       double *Fx2,
                       double *xzero,
                       int *fevals,
                       ErrorMsg error_message){

  /** Summary: */

  /** Define local variables */
  int j,MAXIT=1000;
  double ans,fh,fl,fm,fnew,s,xh,xl,xm,xnew;

  if ((Fx1!=NULL)&&(Fx2!=NULL)){
    fl = *Fx1;
    fh = *Fx2;
  }
  else{
    class_call((*func)(x1, param, &fl, error_message),
               error_message, error_message);
    class_call((*func)(x2, param, &fh, error_message),
               error_message, error_message);

    *fevals = (*fevals)+2;
  }
  if ((fl > 0.0 && fh < 0.0) || (fl < 0.0 && fh > 0.0)) {
    xl=x1;
    xh=x2;
    ans=-1.11e11;
    for (j=1;j<=MAXIT;j++) {
      xm=0.5*(xl+xh);
      class_call((*func)(xm, param, &fm, error_message),
                 error_message, error_message);
      *fevals = (*fevals)+1;
      s=sqrt(fm*fm-fl*fh);
      if (s == 0.0){
        *xzero = ans;
        return _SUCCESS_;
      }
      xnew=xm+(xm-xl)*((fl >= fh ? 1.0 : -1.0)*fm/s);
      if (fabs(xnew-ans) <= xtol) {
        *xzero = ans;
        return _SUCCESS_;
      }

      ans=xnew;
      class_call((*func)(ans, param, &fnew, error_message),
                 error_message, error_message);
      *fevals = (*fevals)+1;
      if (fnew == 0.0){
        *xzero = ans;
        return _SUCCESS_;
      }

      if (NRSIGN(fm,fnew) != fm) {
        xl=xm;
        fl=fm;
        xh=ans;
        fh=fnew;
      }
      else if (NRSIGN(fl,fnew) != fl) {
        xh=ans;
        fh=fnew;
      }
      else if (NRSIGN(fh,fnew) != fh) {
        xl=ans;
        fl=fnew;
      }
      else{
        return _FAILURE_;
      }
      if (fabs(xh-xl) <= xtol) {
        *xzero = ans;
        return _SUCCESS_;
      }
    }
    class_stop(error_message,"zriddr exceed maximum iterations");
  }

  else {
    if (fl == 0.0) return x1;
    if (fh == 0.0) return x2;
    class_stop(error_message,"root must be bracketed in zriddr.");
  }
  class_stop(error_message,"Failure in int.");
}


/**
 * Related to 'shooting': we define here a reasonable analytic guess
 * for each unknown parameter as a function of its target
 * parameter. We must also estimate dxdy, i.e. how the unknown
 * parameter responds to the target parameter.  This can simply be
 * estimated as the derivative of the guess formula.
 *
 * @param xguess Output: guess for unkown parameter x given target parameter y
 * @param dxdy   Output: guess for derivative dx/dy
 * @param pfzw   Input : pointer to workspace containing targets, unkown parameters and other relevant information
 * @param errmsg Input/Output: Error message
 * @return the error status
 */

int input_get_guess(double *xguess,
                    double *dxdy,
                    struct fzerofun_workspace * pfzw,
                    ErrorMsg errmsg){

  /** Summary: */

  /** Define local variables */
  struct precision pr;        /* for precision parameters */
  struct background ba;       /* for cosmological background */
  struct thermodynamics th;           /* for thermodynamics */
  struct perturbations pt;         /* for source functions */
  struct transfer tr;        /* for transfer functions */
  struct primordial pm;       /* for primordial spectra */
  struct harmonic hr;          /* for output spectra */
  struct fourier fo;        /* for non-linear spectra */
  struct lensing le;          /* for lensed spectra */
  struct distortions sd;      /* for spectral distortions */
  struct output op;           /* for output files */
  int i;
  double Omega_M, a_decay, gamma, Omega0_dcdmdr=1.0;
  int index_guess;
  int index_ncdm; double N_nonur_guess = 0.0;

  /* Cheat to read only known parameters: */
  pfzw->fc.size -= pfzw->target_size;

  /* Assume for now shooting did not fail */
  ba.shooting_failed = _FALSE_;

  class_call(input_read_precisions(&(pfzw->fc),&pr,&ba,&th,&pt,&tr,&pm,&hr,&fo,&le,&sd,&op,
                                   errmsg),
             errmsg,
             errmsg);
  class_call(input_read_parameters(&(pfzw->fc),&pr,&ba,&th,&pt,&tr,&pm,&hr,&fo,&le,&sd,&op,
                                   errmsg),
             errmsg,
             errmsg);

  pfzw->fc.size += pfzw->target_size;

  /** Estimate dxdy */
  for (index_guess=0; index_guess < pfzw->target_size; index_guess++) {
    switch (pfzw->target_name[index_guess]) {
    case theta_s:
    case theta_s_100:
      xguess[index_guess] = 3.54*pow(pfzw->target_value[index_guess],2)-5.455*pfzw->target_value[index_guess]+2.548;
      dxdy[index_guess] = (7.08*pfzw->target_value[index_guess]-5.455);
      /** Update pb to reflect guess */
      ba.h = xguess[index_guess];
      ba.H0 = ba.h *  1.e5 / _c_;
      break;
    case Neff:
      for(index_ncdm=0;index_ncdm<ba.N_ncdm;++index_ncdm){
        N_nonur_guess += ba.deg_ncdm[index_ncdm]* 1.0132;
      }
      N_nonur_guess += ba.Omega0_idr/ba.Omega0_g/(7./8.)*pow(11./4.,(4./3.));
      xguess[index_guess] = pfzw->target_value[index_guess] - N_nonur_guess;
      dxdy[index_guess] = 1.;
      break;
    case Omega_dcdmdr:
      Omega_M = ba.Omega0_cdm+ba.Omega0_idm+ba.Omega0_dcdmdr+ba.Omega0_b;
      /* *
       * This formula is exact in a Matter + Lambda Universe, but only for Omega_dcdm,
       * not the combined.
       * sqrt_one_minus_M = sqrt(1.0 - Omega_M);
       * xguess[index_guess] = pfzw->target_value[index_guess]*
       *                       exp(2./3.*ba.Gamma_dcdm/ba.H0*
       *                       atanh(sqrt_one_minus_M)/sqrt_one_minus_M);
       * dxdy[index_guess] = 1.0;//exp(2./3.*ba.Gamma_dcdm/ba.H0*atanh(sqrt_one_minus_M)/sqrt_one_minus_M);
       * */
      gamma = ba.Gamma_dcdm/ba.H0;
      if (gamma < 1)
        a_decay = 1.0;
      else
        a_decay = pow(1+(gamma*gamma-1.)/Omega_M,-1./3.);
      xguess[index_guess] = pfzw->target_value[index_guess]/a_decay;
      dxdy[index_guess] = 1./a_decay;
      break;
    case omega_dcdmdr:
      Omega_M = ba.Omega0_cdm+ba.Omega0_idm+ba.Omega0_dcdmdr+ba.Omega0_b;
      gamma = ba.Gamma_dcdm/ba.H0;
      if (gamma < 1)
        a_decay = 1.0;
      else
        a_decay = pow(1+(gamma*gamma-1.)/Omega_M,-1./3.);
      xguess[index_guess] = pfzw->target_value[index_guess]/ba.h/ba.h/a_decay;
      dxdy[index_guess] = 1./a_decay/ba.h/ba.h;
      break;
    case Omega_scf:
      /* *
       * This guess is arbitrary, something nice using WKB should be implemented.
       * Version 2 uses a fit
       * xguess[index_guess] = 1.77835*pow(ba.Omega0_scf,-2./7.);
       * dxdy[index_guess] = -0.5081*pow(ba.Omega0_scf,-9./7.)`;
       * Version 3: use attractor solution
       * */
      if (ba.scf_tuning_index == 0){
        xguess[index_guess] = sqrt(3.0/ba.Omega0_scf);
        dxdy[index_guess] = -0.5*sqrt(3.0)*pow(ba.Omega0_scf,-1.5);
      }
      else{
        /* Default: take the passed value as xguess and set dxdy to 1. */
        xguess[index_guess] = ba.scf_parameters[ba.scf_tuning_index];
        dxdy[index_guess] = 1.;
      }
      break;
    case omega_ini_dcdm:
      Omega0_dcdmdr = 1./(ba.h*ba.h);
    case Omega_ini_dcdm:
      /* This works since correspondence is Omega_ini_dcdm -> Omega_dcdmdr and
         omega_ini_dcdm -> omega_dcdmdr */
      Omega0_dcdmdr *=pfzw->target_value[index_guess];
      Omega_M = ba.Omega0_cdm+ba.Omega0_idm+Omega0_dcdmdr+ba.Omega0_b;
      gamma = ba.Gamma_dcdm/ba.H0;
      if (gamma < 1)
        a_decay = 1.0;
      else
        a_decay = pow(1+(gamma*gamma-1.)/Omega_M,-1./3.);
      xguess[index_guess] = pfzw->target_value[index_guess]*a_decay;
      dxdy[index_guess] = a_decay;
      if (gamma > 100)
        dxdy[index_guess] *= gamma/100;
      break;

    case sigma8:
      /* Assume linear relationship between A_s and sigma8 and fix coefficient
         according to vanilla LambdaCDM. Should be good enough... */
      xguess[index_guess] = 2.43e-9/0.87659*pfzw->target_value[index_guess];
      dxdy[index_guess] = 2.43e-9/0.87659;
      break;
    case S8:
      /* Assume linear relationship between A_s and S8 and fix coefficient
         according to vanilla LambdaCDM. Should be good enough... */
      xguess[index_guess] = 2.43e-9/0.891*pfzw->target_value[index_guess];
      dxdy[index_guess] = 2.43e-9/0.891;
      break;
    }
  }

  for (i=0; i<pfzw->fc.size; i++) {
    pfzw->fc.read[i] = _FALSE_;
  }

  /** - Deallocate everything allocated by input_read_parameters */
  background_free_input(&ba);
  thermodynamics_free_input(&th);
  perturbations_free_input(&pt);

  return _SUCCESS_;

}

/**
 * Related to 'shooting': when there is one or more targets, call
 * CLASS up to the highest needed computation stage, for a given set
 * of unknown parameters; obtain the corresponding target parameters;
 * and return the vector of each [target - targeted_value].
 *
 * @param unknown_parameter       Input: vector of unkownn parameters x
 * @param unknown_parameters_size Input: size of this vector
 * @param voidpfzw                Input: pointer to workspace containing targets, unkown parameters and other relevant information
 * @param output                  Output: vector of target parameters y
 * @param errmsg                  Input/Output: Error message
 * @return the error status
 */

int input_try_unknown_parameters(double * unknown_parameter,
                                 int unknown_parameters_size,
                                 void * voidpfzw,
                                 double * output,
                                 ErrorMsg errmsg){
  /** Summary */

  /** Define local variables */
  struct precision pr;        /* for precision parameters */
  struct background ba;       /* for cosmological background */
  struct thermodynamics th;           /* for thermodynamics */
  struct perturbations pt;         /* for source functions */
  struct transfer tr;        /* for transfer functions */
  struct primordial pm;       /* for primordial spectra */
  struct harmonic hr;          /* for output spectra */
  struct fourier fo;        /* for non-linear spectra */
  struct lensing le;          /* for lensed spectra */
  struct distortions sd;      /* for spectral distortions */
  struct output op;           /* for output files */

  int i;
  double rho_dcdm_today, rho_dr_today;
  struct fzerofun_workspace * pfzw;
  int input_verbose;
  int flag;
  int param;
  short compute_sigma8 = _FALSE_;

  /* Assume for now shooting did not fail */
  ba.shooting_failed = _FALSE_;

  pfzw = (struct fzerofun_workspace *) voidpfzw;
  /** Read input parameters */
  // This needs to be done with enough accuracy. A standard double has a relative
  // precision of around 1e-16, so 1e-20 should be good enough for the shooting
  for (i=0; i < unknown_parameters_size; i++) {
    class_sprintf(pfzw->fc.value[pfzw->unknown_parameters_index[i]],"%.20e",unknown_parameter[i]);
  }

  class_call(input_read_precisions(&(pfzw->fc),&pr,&ba,&th,&pt,&tr,&pm,&hr,&fo,&le,&sd,&op,
                                   errmsg),
             errmsg,
             errmsg);

  class_call(input_read_parameters(&(pfzw->fc),&pr,&ba,&th,&pt,&tr,&pm,&hr,&fo,&le,&sd,&op,
                                   errmsg),
             errmsg,
             errmsg);

  class_call(parser_read_int(&(pfzw->fc),"input_verbose",&param,&flag,errmsg),
             errmsg,
             errmsg);

  if (flag == _TRUE_)
    input_verbose = param;
  else
    input_verbose = 0;

  /** Optimise flags for sigma8 calculation.*/
  for (i=0; i < unknown_parameters_size; i++) {
    if (pfzw->target_name[i] == sigma8) {
      compute_sigma8 = _TRUE_;
    }
    if (pfzw->target_name[i] == S8) {
      compute_sigma8 = _TRUE_;
    }
  }

  /* Sigma8 depends on linear P(k), so no need to run anything except linear P(k) during shooting */
  if (compute_sigma8 == _TRUE_) {
    /* In June 2020 the k_max_for_pk was increased for higher precision,
       and in February 2022 the value was converted into a set of two precision parameters */
    pt.k_max_for_pk=
      MIN(MAX(pr.k_max_for_pk_sigma8_min, pt.k_max_for_pk),
          pr.k_max_for_pk_sigma8_max);
    pt.has_pk_matter=_TRUE_;
    pt.has_perturbations = _TRUE_;
    pt.has_cl_cmb_temperature = _FALSE_;
    pt.has_cls = _FALSE_;
    pt.has_cl_cmb_polarization = _FALSE_;
    pt.has_cl_cmb_lensing_potential = _FALSE_;
    pt.has_cl_number_count = _FALSE_;
    pt.has_cl_lensing_potential=_FALSE_;
    pt.has_density_transfers=_FALSE_;
    pt.has_velocity_transfers=_FALSE_;
    fo.has_pk_eq=_FALSE_;
    fo.method=nl_none;
  }

  /** Shoot forward into class up to required stage */
  if (pfzw->required_computation_stage >= cs_background){
    if (input_verbose>2)
      printf("Stage 1: background\n");
    ba.background_verbose = 0;
    class_call_except(background_init(&pr,&ba), ba.error_message, errmsg, background_free_input(&ba);thermodynamics_free_input(&th);perturbations_free_input(&pt););
  }

  if (pfzw->required_computation_stage >= cs_thermodynamics){
    if (input_verbose>2)
      printf("Stage 2: thermodynamics\n");
    pr.thermo_Nz_lin = 10000;
    pr.thermo_Nz_log = 500;
    th.thermodynamics_verbose = 0;
    th.hyrec_verbose = 0;
    class_call_except(thermodynamics_init(&pr,&ba,&th), th.error_message, errmsg, background_free(&ba);thermodynamics_free_input(&th);perturbations_free_input(&pt););
  }

  if (pfzw->required_computation_stage >= cs_perturbations){
    if (input_verbose>2)
      printf("Stage 3: perturbations\n");
    pt.perturbations_verbose = 0;
    class_call_except(perturbations_init(&pr,&ba,&th,&pt), pt.error_message, errmsg, thermodynamics_free(&th);background_free(&ba);perturbations_free_input(&pt););
  }

  if (pfzw->required_computation_stage >= cs_primordial){
    if (input_verbose>2)
      printf("Stage 4: primordial\n");
    pm.primordial_verbose = 0;
    class_call_except(primordial_init(&pr,&ba,&pt,&pm), pm.error_message, errmsg, perturbations_free(&pt);thermodynamics_free(&th);background_free(&ba));
  }

  if (pfzw->required_computation_stage >= cs_nonlinear){
    if (input_verbose>2)
      printf("Stage 5: nonlinear\n");
    fo.fourier_verbose = 0;
    class_call_except(fourier_init(&pr,&ba,&th,&pt,&pm,&fo), fo.error_message, errmsg, primordial_free(&pm);perturbations_free(&pt);thermodynamics_free(&th);background_free(&ba));
  }

  if (pfzw->required_computation_stage >= cs_transfer){
    if (input_verbose>2)
      printf("Stage 6: transfer\n");
    tr.transfer_verbose = 0;
    class_call_except(transfer_init(&pr,&ba,&th,&pt,&fo,&tr), tr.error_message, errmsg, fourier_free(&fo);primordial_free(&pm);perturbations_free(&pt);thermodynamics_free(&th);background_free(&ba));
  }

  if (pfzw->required_computation_stage >= cs_spectra){
    if (input_verbose>2)
      printf("Stage 7: spectra\n");
    hr.harmonic_verbose = 0;
    class_call_except(harmonic_init(&pr,&ba,&pt,&pm,&fo,&tr,&hr),hr.error_message, errmsg, transfer_free(&tr);fourier_free(&fo);primordial_free(&pm);perturbations_free(&pt);thermodynamics_free(&th);background_free(&ba));
  }

  /** Get the corresponding shoot variable and put into output */
  for (i=0; i < pfzw->target_size; i++) {
    switch (pfzw->target_name[i]) {
    case theta_s:
    case theta_s_100:
      output[i] = 100.*th.rs_rec/th.ra_rec-pfzw->target_value[i];
      break;
    case Neff:
      output[i] = ba.Neff-pfzw->target_value[i];
      break;
    case Omega_dcdmdr:
      rho_dcdm_today = ba.background_table[(ba.bt_size-1)*ba.bg_size+ba.index_bg_rho_dcdm];
      if (ba.has_dr == _TRUE_)
        rho_dr_today = ba.background_table[(ba.bt_size-1)*ba.bg_size+ba.index_bg_rho_dr];
      else
        rho_dr_today = 0.;
      output[i] = (rho_dcdm_today+rho_dr_today)/(ba.H0*ba.H0)-pfzw->target_value[i];
      break;
    case omega_dcdmdr:
      rho_dcdm_today = ba.background_table[(ba.bt_size-1)*ba.bg_size+ba.index_bg_rho_dcdm];
      if (ba.has_dr == _TRUE_)
        rho_dr_today = ba.background_table[(ba.bt_size-1)*ba.bg_size+ba.index_bg_rho_dr];
      else
        rho_dr_today = 0.;
      output[i] = (rho_dcdm_today+rho_dr_today)/(ba.H0*ba.H0)-pfzw->target_value[i]/ba.h/ba.h;
      break;
    case Omega_scf:
      /** In case scalar field is used to fill, pba->Omega0_scf is not equal to pfzw->target_value[i].*/
      output[i] = ba.background_table[(ba.bt_size-1)*ba.bg_size+ba.index_bg_rho_scf]/(ba.H0*ba.H0)-ba.Omega0_scf;
      break;
    case Omega_ini_dcdm:
    case omega_ini_dcdm:
      rho_dcdm_today = ba.background_table[(ba.bt_size-1)*ba.bg_size+ba.index_bg_rho_dcdm];
      if (ba.has_dr == _TRUE_)
        rho_dr_today = ba.background_table[(ba.bt_size-1)*ba.bg_size+ba.index_bg_rho_dr];
      else
        rho_dr_today = 0.;
      output[i] = -(rho_dcdm_today+rho_dr_today)/(ba.H0*ba.H0)+ba.Omega0_dcdmdr;
      break;
    case sigma8:
      output[i] = fo.sigma8[fo.index_pk_m];
      break;
    case S8:
      output[i] = fo.sigma8[fo.index_pk_m]*sqrt(ba.Omega0_m/0.3);
      break;
    }
  }

  /** Free structures */
  if (pfzw->required_computation_stage >= cs_spectra){
    class_call(harmonic_free(&hr), hr.error_message, errmsg);
  }
  if (pfzw->required_computation_stage >= cs_transfer){
    class_call(transfer_free(&tr), tr.error_message, errmsg);
  }
  if (pfzw->required_computation_stage >= cs_nonlinear){
    class_call(fourier_free(&fo), fo.error_message, errmsg);
  }
  if (pfzw->required_computation_stage >= cs_primordial){
    class_call(primordial_free(&pm), pm.error_message, errmsg);
  }
  if (pfzw->required_computation_stage >= cs_perturbations){
    class_call(perturbations_free(&pt), pt.error_message, errmsg);
  }
  if (pfzw->required_computation_stage >= cs_thermodynamics){
    class_call(thermodynamics_free(&th), th.error_message, errmsg);
  }
  if (pfzw->required_computation_stage >= cs_background){
    class_call(background_free(&ba), ba.error_message, errmsg);
  }

  /** Set filecontent to unread */
  for (i=0; i<pfzw->fc.size; i++) {
    pfzw->fc.read[i] = _FALSE_;
  }

  /** Free pointers allocated on input if neccessary */
  if (pfzw->required_computation_stage < cs_perturbations) {
    /** Some pointers in ppt may not be allocated if has_perturbations is _FALSE_, but this is handled in perturbations_free_input as neccessary. */
    perturbations_free_input(&pt);
  }
  if (pfzw->required_computation_stage < cs_thermodynamics) {
    thermodynamics_free_input(&th);
  }
  if (pfzw->required_computation_stage < cs_background) {
    background_free_input(&ba);
  }
  return _SUCCESS_;

}

/**
 * Initialize the precision parameter structure.
 *
 * All precision parameters used in the other modules are listed here
 * and assigned here a default value.
 *
 * @param pfc     Input: pointer to local structure
 * @param ppr     Input: pointer to precision structure
 * @param pba     Input: pointer to background structure
 * @param pth     Input: pointer to thermodynamics structure
 * @param ppt     Input: pointer to perturbations structure
 * @param ptr     Input: pointer to transfer structure
 * @param ppm     Input: pointer to primordial structure
 * @param phr     Input: pointer to harmonic structure
 * @param pfo     Input: pointer to non-linear structure
 * @param ple     Input: pointer to lensing structure
 * @param pop     Input: pointer to output structure
 * @param psd     Input: pointer to distorsion structure
 * @param errmsg  Input: Error message
 * @return the error status
 */

int input_read_precisions(struct file_content * pfc,
                          struct precision * ppr,
                          struct background *pba,
                          struct thermodynamics *pth,
                          struct perturbations *ppt,
                          struct transfer *ptr,
                          struct primordial *ppm,
                          struct harmonic *phr,
                          struct fourier * pfo,
                          struct lensing *ple,
                          struct distortions *psd,
                          struct output *pop,
                          ErrorMsg errmsg){

  /** Summary: */

  /** - Define local variables */

  /** - Automatic estimate of machine precision */
  ppr->smallest_allowed_variation = DBL_EPSILON;

  class_test(ppr->smallest_allowed_variation < 0,
             ppr->error_message,
             "smallest_allowed_variation = %e < 0",
             ppr->smallest_allowed_variation);

  /* Assign the default precision settings (these very concise lines
     assign all precision parameters thanks to the macros defined in
     macros_precision.h) */
#define __ASSIGN_DEFAULT_PRECISION__
#include "precisions.h"
#undef __ASSIGN_DEFAULT_PRECISION__

  /** Read all precision parameters from input (these very concise
      lines parse all precision parameters thanks to the macros
      defined in macros_precision.h) */
#define __PARSE_PRECISION_PARAMETER__
#include "precisions.h"
#undef __PARSE_PRECISION_PARAMETER__

  return _SUCCESS_;

}


/**
 * If entries are passed in file_content structure, carefully read and
 * interpret each of them, and tune the relevant input parameters
 * accordingly
 *
 * @param pfc     Input: pointer to local structure
 * @param ppr     Input: pointer to precision structure
 * @param pba     Input: pointer to background structure
 * @param pth     Input: pointer to thermodynamics structure
 * @param ppt     Input: pointer to perturbation structure
 * @param ptr     Input: pointer to transfer structure
 * @param ppm     Input: pointer to primordial structure
 * @param phr     Input: pointer to harmonic structure
 * @param pfo     Input: pointer to fourier structure
 * @param ple     Input: pointer to lensing structure
 * @param psd     Input: pointer to distorsion structure
 * @param pop     Input: pointer to output structure
 * @param errmsg  Input: Error message
 * @return the error status
 */

int input_read_parameters(struct file_content * pfc,
                          struct precision * ppr,
                          struct background *pba,
                          struct thermodynamics *pth,
                          struct perturbations *ppt,
                          struct transfer *ptr,
                          struct primordial *ppm,
                          struct harmonic *phr,
                          struct fourier * pfo,
                          struct lensing *ple,
                          struct distortions *psd,
                          struct output *pop,
                          ErrorMsg errmsg){

  /** Summary: */

  /** Define local variables */
  int input_verbose=0;

  /** Set all input parameters to default values */
  class_call(input_default_params(pba,pth,ppt,ptr,ppm,phr,pfo,ple,psd,pop),
             errmsg,
             errmsg);

  /** Read verbose for input structure */
  class_read_int("input_verbose",input_verbose);

  /**
   * Read the general parameters of the
   *  background, thermodynamics, and perturbation structures
   * This function is exclusively for those parameters, NOT
   *  related to any physical species
   * */
  class_call(input_read_parameters_general(pfc,pba,pth,ppt,psd,
                                           errmsg),
             errmsg,
             errmsg);

  /** Read the parameters for each physical species (has to be called after the general read) */
  class_call(input_read_parameters_species(pfc,ppr,pba,pth,ppt,
                                           input_verbose,
                                           errmsg),
             errmsg,
             errmsg);

  /** Read parameters for exotic energy injection quantities */
  class_call(input_read_parameters_injection(pfc,ppr,pth,
                                             errmsg),
             errmsg,
             errmsg);

  /** Read parameters for nonlinear quantities */
  class_call(input_read_parameters_nonlinear(pfc,ppr,pba,pth,ppt,pfo,
                                             input_verbose,
                                             errmsg),
             errmsg,
             errmsg);

  /** Read parameters for primordial quantities */
  class_call(input_read_parameters_primordial(pfc,ppt,ppm,
                                              errmsg),
             errmsg,
             errmsg);

  /** Read parameters for spectra quantities */
  class_call(input_read_parameters_spectra(pfc,ppr,pba,ppm,ppt,ptr,phr,pop,
                                           errmsg),
             errmsg,
             errmsg);

  /** Read parameters for lensing quantities */
  class_call(input_read_parameters_lensing(pfc,ppr,ppt,ptr,ple,
                                           errmsg),
             errmsg,
             errmsg);

  /** Read parameters for distortions quantities */
  class_call(input_read_parameters_distortions(pfc,ppr,psd,
                                               errmsg),
             errmsg,
             errmsg);

  /** Read obsolete parameters */
  class_call(input_read_parameters_additional(pfc,ppr,pba,pth,
                                              errmsg),
             errmsg,
             errmsg);

  /** Read parameters for output quantities */
  class_call(input_read_parameters_output(pfc,pba,pth,ppt,ptr,ppm,phr,pfo,ple,psd,pop,
                                          errmsg),
             errmsg,
             errmsg);

  return _SUCCESS_;

}


/**
 * Read general parameters related to class, including
 *   - background, thermo, and perturbation quantities NOT associated to
 *     any particular species
 *   - calculationary quantities like the gauge/recombination code
 *   - output options
 *
 * @param pfc     Input: pointer to local structure
 * @param pba     Input: pointer to background structure
 * @param pth     Input: pointer to thermodynamics structure
 * @param ppt     Input: pointer to perturbation structure
 * @param psd     Input: pointer to distorsion structure
 * @param errmsg  Input: Error message
 * @return the error status
 */

int input_read_parameters_general(struct file_content * pfc,
                                  struct background * pba,
                                  struct thermodynamics * pth,
                                  struct perturbations * ppt,
                                  struct distortions * psd,
                                  ErrorMsg errmsg){

  /** Summary: */

  /** - Define local variables */
  int flag1,flag2;
  double param1,param2;
  char string1[_ARGUMENT_LENGTH_MAX_];
  char * options_output[33] =  {"tCl","pCl","lCl","nCl","dCl","sCl","mPk","mTk","dTk","vTk","sd",
                                "TCl","PCl","LCl","NCl","DCl","SCl","MPk","MTk","DTk","VTk","Sd",
                                "TCL","PCL","LCL","NCL","DCL","SCL","MPK","MTK","DTK","VTK","SD"};
  char * options_temp_contributions[10] = {"tsw","eisw","lisw","dop","pol","TSW","EISW","LISW","Dop","Pol"};
  char * options_number_count[8] = {"density","dens","rsd","RSD","lensing","lens","gr","GR"};
  char * options_modes[6] = {"s","v","t","S","V","T"};
  char * options_ics[10] = {"ad","bi","cdi","nid","niv","AD","BI","CDI","NID","NIV"};

  /* Set local default values */
  ppt->has_perturbations = _FALSE_;
  ppt->has_cls = _FALSE_;
  psd->has_distortions = _FALSE_;

  /** 1) List of output spectra requested */
  /* Read */
  class_call(parser_read_string(pfc,"output",&string1,&flag1,errmsg),
             errmsg,
             errmsg);
  /* Complete set of parameters */
  if (flag1 == _TRUE_) {
    if ((strstr(string1,"tCl") != NULL) || (strstr(string1,"TCl") != NULL) || (strstr(string1,"TCL") != NULL)) {
      ppt->has_cl_cmb_temperature = _TRUE_;
      ppt->has_perturbations = _TRUE_;
      ppt->has_cls = _TRUE_;
    }
    if ((strstr(string1,"pCl") != NULL) || (strstr(string1,"PCl") != NULL) || (strstr(string1,"PCL") != NULL)) {
      ppt->has_cl_cmb_polarization = _TRUE_;
      ppt->has_perturbations = _TRUE_;
      ppt->has_cls = _TRUE_;
    }
    if ((strstr(string1,"lCl") != NULL) || (strstr(string1,"LCl") != NULL) || (strstr(string1,"LCL") != NULL)) {
      ppt->has_cl_cmb_lensing_potential = _TRUE_;
      ppt->has_perturbations = _TRUE_;
      ppt->has_cls = _TRUE_;
    }
    if ((strstr(string1,"nCl") != NULL) || (strstr(string1,"NCl") != NULL) || (strstr(string1,"NCL") != NULL) ||
        (strstr(string1,"dCl") != NULL) || (strstr(string1,"DCl") != NULL) || (strstr(string1,"DCL") != NULL)) {
      ppt->has_cl_number_count = _TRUE_;
      ppt->has_perturbations = _TRUE_;
      ppt->has_cls = _TRUE_;
    }
    if ((strstr(string1,"sCl") != NULL) || (strstr(string1,"SCl") != NULL) || (strstr(string1,"SCL") != NULL)) {
      ppt->has_cl_lensing_potential=_TRUE_;
      ppt->has_perturbations = _TRUE_;
      ppt->has_cls = _TRUE_;
    }
    if ((strstr(string1,"mPk") != NULL) || (strstr(string1,"MPk") != NULL) || (strstr(string1,"MPK") != NULL)) {
      ppt->has_pk_matter=_TRUE_;
      ppt->has_perturbations = _TRUE_;
    }
    if ((strstr(string1,"mTk") != NULL) || (strstr(string1,"MTk") != NULL) || (strstr(string1,"MTK") != NULL) ||
        (strstr(string1,"dTk") != NULL) || (strstr(string1,"DTk") != NULL) || (strstr(string1,"DTK") != NULL)) {
      ppt->has_density_transfers=_TRUE_;
      ppt->has_perturbations = _TRUE_;
    }
    if ((strstr(string1,"vTk") != NULL) || (strstr(string1,"VTk") != NULL) || (strstr(string1,"VTK") != NULL)) {
      ppt->has_velocity_transfers=_TRUE_;
      ppt->has_perturbations = _TRUE_;
    }
    if ((strstr(string1,"Sd") != NULL) || (strstr(string1,"sd") != NULL) || (strstr(string1,"SD") != NULL)) {
      ppt->has_perturbations = _TRUE_;
      psd->has_distortions=_TRUE_;
      pth->compute_damping_scale=_TRUE_;
    }

    /* Test */
    class_call(parser_check_options(string1, options_output, 33, &flag1),
               errmsg,
               errmsg);
    class_test(flag1==_FALSE_,
               errmsg, "The options for output are {'tCl','pCl','lCl','nCl','dCl','sCl','mPk','mTk','dTk','vTk','Sd'}, you entered '%s'",string1);
  }

  /** 1.a) Terms contributing to the temperature spectrum */
  if (ppt->has_cl_cmb_temperature == _TRUE_) {
    /* Read */
    class_call(parser_read_string(pfc,"temperature_contributions",&string1,&flag1,errmsg),
               errmsg,
               errmsg);
    /* Compatibility code BEGIN */
    if (flag1 == _FALSE_){
      class_call(parser_read_string(pfc,"temperature contributions",&string1,&flag1,errmsg),
                 errmsg,
                 errmsg);
    }
    /* Compatibility code END */
    /* Complete set of parameters */
    if (flag1 == _TRUE_){
      ppt->switch_sw = 0;
      ppt->switch_eisw = 0;
      ppt->switch_lisw = 0;
      ppt->switch_dop = 0;
      ppt->switch_pol = 0;
      if ((strstr(string1,"tsw") != NULL) || (strstr(string1,"TSW") != NULL)){
        ppt->switch_sw = 1;
      }
      if ((strstr(string1,"eisw") != NULL) || (strstr(string1,"EISW") != NULL)){
        ppt->switch_eisw = 1;
      }
      if ((strstr(string1,"lisw") != NULL) || (strstr(string1,"LISW") != NULL)){
        ppt->switch_lisw = 1;
      }
      if ((strstr(string1,"dop") != NULL) || (strstr(string1,"Dop") != NULL)){
        ppt->switch_dop = 1;
      }
      if ((strstr(string1,"pol") != NULL) || (strstr(string1,"Pol") != NULL)){
        ppt->switch_pol = 1;
      }
      /* Test */
      class_call(parser_check_options(string1, options_temp_contributions, 10, &flag1),
                 errmsg,
                 errmsg);
      class_test(flag1==_FALSE_,
                 errmsg, "The options for 'temperature_contributions' are {'tsw','eisw','lisw','dop','pol'}, you entered '%s'",string1);
      class_test((ppt->switch_sw == 0) && (ppt->switch_eisw == 0) && (ppt->switch_lisw == 0) && (ppt->switch_dop == 0) && (ppt->switch_pol == 0),
                 errmsg,
                 "You specified 'temperature_contributions' as '%s'. It has to contain some of {'tsw','eisw','lisw','dop','pol'}.",string1);

      /** 1.a.1) Split value of redshift z at which the isw is considered as late or early */
      /* Read */
      class_read_double("early/late isw redshift",ppt->eisw_lisw_split_z); //Deprecated parameter
      class_read_double("early_late_isw_redshift",ppt->eisw_lisw_split_z);
    }
  }

  /** 1.b) Obsevable number count fluctuation spectrum */
  if (ppt->has_cl_number_count == _TRUE_){
    /* Read */
    class_call(parser_read_string(pfc,"number_count_contributions",&string1,&flag1,errmsg),
               errmsg,
               errmsg);
    /* Compatibility code BEGIN */
    if (flag1 == _FALSE_){
      class_call(parser_read_string(pfc,"number count contributions",&string1,&flag1,errmsg),
                 errmsg,
                 errmsg);
    }
    /* Compatibility code END */
    /* Complete set of parameters */
    if (flag1 == _TRUE_) {
      if (strstr(string1,"density") != NULL || strstr(string1,"dens") != NULL){
        ppt->has_nc_density = _TRUE_;
      }
      if (strstr(string1,"rsd") != NULL || strstr(string1,"RSD") != NULL){
        ppt->has_nc_rsd = _TRUE_;
      }
      if (strstr(string1,"lensing") != NULL || strstr(string1,"lens") != NULL){
        ppt->has_nc_lens = _TRUE_;
      }
      if (strstr(string1,"gr") != NULL || strstr(string1,"GR") != NULL){
        ppt->has_nc_gr = _TRUE_;
      }
      /* Test */
      class_call(parser_check_options(string1, options_number_count, 8, &flag1),
                 errmsg,
                 errmsg);
      class_test(flag1==_FALSE_,
                 errmsg, "The options for 'number_count_contributions' are {'density','rsd','lensing','gr'}, you entered '%s'",string1);
      class_test((ppt->has_nc_density == _FALSE_) && (ppt->has_nc_rsd == _FALSE_) && (ppt->has_nc_lens == _FALSE_) && (ppt->has_nc_gr == _FALSE_),
                 errmsg,
                 "You specified 'number_count_contributions' as '%s'. It has to contain some of {'density','rsd','lensing','gr'}.",string1);
    }
    else {
      /* Set default value */
      ppt->has_nc_density = _TRUE_;
    }
  }

  /** 1.c) Transfer function of additional metric fluctuations */
  if (ppt->has_density_transfers == _TRUE_) {
    /* Read */
    class_read_flag_or_deprecated("extra_metric_transfer_functions","extra metric transfer functions",ppt->has_metricpotential_transfers);
  }

  if (ppt->has_perturbations == _TRUE_) {

    /** 2) Perturbed recombination */
    /* Read */
    class_read_flag_or_deprecated("perturbed_recombination","perturbed recombination",ppt->has_perturbed_recombination);

    /** 3) Modes */
    /* Read */
    class_call(parser_read_string(pfc,"modes",&string1,&flag1,errmsg),
               errmsg,
               errmsg);
    /* Complete set of parameters */
    if (flag1 == _TRUE_) {
      /* if no modes are specified, the default is has_scalars=_TRUE_;
         but if they are specified we should reset has_scalars to _FALSE_ before reading */
      ppt->has_scalars=_FALSE_;
      if ((strstr(string1,"s") != NULL) || (strstr(string1,"S") != NULL)){
        ppt->has_scalars=_TRUE_;
      }
      if ((strstr(string1,"v") != NULL) || (strstr(string1,"V") != NULL)){
        ppt->has_vectors=_TRUE_;
      }
      if ((strstr(string1,"t") != NULL) || (strstr(string1,"T") != NULL)){
        ppt->has_tensors=_TRUE_;
      }
      /* Test */
      class_call(parser_check_options(string1, options_modes, 6, &flag1),
                 errmsg,
                 errmsg);
      class_test(flag1==_FALSE_,
                 errmsg, "The options for 'modes' are {'s','v','t'}, you entered '%s'",string1);
      class_test(class_none_of_three(ppt->has_scalars,ppt->has_vectors,ppt->has_tensors),
                 errmsg,
                 "You specified 'modes' as '%s'. It has to contain some of {'s','v','t'}.",string1);
    }
    /* Test */
    if (ppt->has_vectors == _TRUE_){
      class_test((ppt->has_cl_cmb_temperature == _FALSE_) && (ppt->has_cl_cmb_polarization == _FALSE_),
                 errmsg,
                 "Inconsistent input: you asked for vectors, so you should have at least one non-zero tensor source type (temperature or polarization). Please adjust your input.");
    }
    if (ppt->has_tensors == _TRUE_){
      class_test((ppt->has_cl_cmb_temperature == _FALSE_) && (ppt->has_cl_cmb_polarization == _FALSE_),
                 errmsg,
                 "Inconsistent input: you asked for tensors, so you should have at least one non-zero tensor source type (temperature or polarization). Please adjust your input.");
    }

    /** 3.a) List of initial conditions for scalars */
    if (ppt->has_scalars == _TRUE_) {
      /* Read */
      class_call(parser_read_string(pfc,"ic",&string1,&flag1,errmsg),
                 errmsg,
                 errmsg);
      /* Complete set of parameters */
      if (flag1 == _TRUE_) {
        /* if no initial conditions are specified, the default is has_ad=_TRUE_;
           but if they are specified we should reset has_ad to _FALSE_ before reading */
        ppt->has_ad=_FALSE_;
        if ((strstr(string1,"ad") != NULL) || (strstr(string1,"AD") != NULL)){
          ppt->has_ad=_TRUE_;
        }
        if ((strstr(string1,"bi") != NULL) || (strstr(string1,"BI") != NULL)){
          ppt->has_bi=_TRUE_;
        }
        if ((strstr(string1,"cdi") != NULL) || (strstr(string1,"CDI") != NULL)){
          ppt->has_cdi=_TRUE_;
        }
        if ((strstr(string1,"nid") != NULL) || (strstr(string1,"NID") != NULL)){
          ppt->has_nid=_TRUE_;
        }
        if ((strstr(string1,"niv") != NULL) || (strstr(string1,"NIV") != NULL)){
          ppt->has_niv=_TRUE_;
        }
        /* Test */
        class_call(parser_check_options(string1, options_ics, 10, &flag1),
                   errmsg,
                   errmsg);
        class_test(flag1==_FALSE_,
                   errmsg, "The options for 'ic' are {'ad','bi','cdi','nid','niv'}, you entered '%s'",string1);
        class_test(ppt->has_ad==_FALSE_ && ppt->has_bi ==_FALSE_ && ppt->has_cdi ==_FALSE_ && ppt->has_nid ==_FALSE_ && ppt->has_niv ==_FALSE_,
                   errmsg,
                   "You specified 'ic' as '%s'. It has to contain some of {'ad','bi','cdi','nid','niv'}.",string1);
      }
    }
    else {
      /* Test */
      class_test(ppt->has_cl_cmb_lensing_potential == _TRUE_,
                 errmsg,
                 "Inconsistency: you want C_l's for cmb lensing potential, but no scalar modes\n");
      class_test(ppt->has_cl_number_count == _TRUE_,
                 errmsg,
                 "Inconsistency: you want C_l's for number count, but no scalar modes\n");
      class_test(ppt->has_cl_lensing_potential == _TRUE_,
                 errmsg,
                 "Inconsistency: you want C_l's for cosmic shear, but no scalar modes\n");
      class_test(ppt->has_pk_matter == _TRUE_,
                 errmsg,
                 "Inconsistency: you want P(k) of matter, but no scalar modes\n");
      class_test(ppt->has_density_transfers == _TRUE_,
                 errmsg,
                 "Inconsistency: you want density transfer functions, but no scalar modes\n");
      class_test(ppt->has_velocity_transfers == _TRUE_,
                 errmsg,
                 "Inconsistency: you want density transfer functions, but no scalar modes\n");
    }

    /** 3.b) List of initial conditions for scalars */
    if (ppt->has_tensors == _TRUE_) {
      /* Read */
      class_call(parser_read_string(pfc,"tensor_method",&string1,&flag1,errmsg),
                 errmsg,
                 errmsg);
      /* Compatibility code BEGIN */
      if (flag1 == _FALSE_){
        class_call(parser_read_string(pfc,"tensor method",&string1,&flag1,errmsg),
                   errmsg,
                   errmsg);
      }
      /* Compatibility code END */
      /* Complete set of parameters */
      if (flag1 == _TRUE_) {
        if (strstr(string1,"photons") != NULL){
          ppt->tensor_method = tm_photons_only;
        }
        else if (strstr(string1,"massless") != NULL){
          ppt->tensor_method = tm_massless_approximation;
        }
        else if (strstr(string1,"exact") != NULL){
          ppt->tensor_method = tm_exact;
        }
        else{
          class_stop(errmsg,"incomprehensible input '%s' for the field 'tensor_method'",string1);
        }
      }
    }
  }


  /** 4) Gauge */
  /** 4.a) Set gauge */
  /* Read */
  class_call(parser_read_string(pfc,"gauge",&string1,&flag1,errmsg),
             errmsg,
             errmsg);
  /* Complete set of parameters */
  if (flag1 == _TRUE_) {
    if ((strstr(string1,"newtonian") != NULL) || (strstr(string1,"Newtonian") != NULL) || (strstr(string1,"new") != NULL)) {
      ppt->gauge = newtonian;
    }
    else if ((strstr(string1,"synchronous") != NULL) || (strstr(string1,"sync") != NULL) || (strstr(string1,"Synchronous") != NULL)) {
      ppt->gauge = synchronous;
    }
    else{
      class_stop(errmsg,
                 "You specified the gauge as '%s'. It has to be one of {'newtonian','synchronous'}.");
    }
  }

  /** 4.b) Do we want density and velocity transfer functions in Nbody gauge? */
  if ((ppt->has_density_transfers == _TRUE_) || (ppt->has_velocity_transfers == _TRUE_)){

    /* Read */
    class_read_flag_or_deprecated("nbody_gauge_transfer_functions","Nbody gauge transfer functions",ppt->has_Nbody_gauge_transfers);

  }

  /** 4.c) Do we want matter and baryon+CDM sources in current gauge, instead of automatic conversion to gauge-invariant variables? */
  class_read_flag("matter_source_in_current_gauge",ppt->has_matter_source_in_current_gauge);

  /** 5) h in [-] and H_0/c in [1/Mpc = h/2997.9 = h*10^5/c] */
  /* Read */
  class_call(parser_read_double(pfc,"H0",&param1,&flag1,errmsg),
             errmsg,
             errmsg);
  class_call(parser_read_double(pfc,"h",&param2,&flag2,errmsg),
             errmsg,
             errmsg);
  /* Test */
  class_test((flag1 == _TRUE_) && (flag2 == _TRUE_),
             errmsg,
             "You can only enter one of 'h' or 'H0'.");
  /* Complete set of parameters */
  if (flag1 == _TRUE_){
    pba->H0 = param1*1.e3/_c_;
    pba->h = param1/100.;
  }
  if (flag2 == _TRUE_){
    pba->H0 = param2*1.e5/_c_;
    pba->h = param2;
  }


  /** 6) Primordial helium fraction */
  /* Read */
  class_call(parser_read_string(pfc,"YHe",&string1,&flag1,errmsg),
             errmsg,
             errmsg);
  /* Complete set of parameters */
  if (flag1 == _TRUE_) {
    if ((strstr(string1,"BBN") != NULL) || (strstr(string1,"bbn") != NULL)){
      pth->YHe = _YHE_BBN_;
    }
    else {
      class_read_double("YHe",pth->YHe);
    }
  }


  /** 7) Recombination parameters */
  /* Read */
  class_call(parser_read_string(pfc,"recombination",&string1,&flag1,errmsg),
             errmsg,
             errmsg);
  /* Complete set of parameters */
  if (flag1 == _TRUE_){
    if ((strstr(string1,"RECFAST") != NULL) || (strstr(string1,"recfast") != NULL) || (strstr(string1,"Recfast") != NULL)){
      pth->recombination = recfast;
    }
    else if ((strstr(string1,"HYREC") != NULL) || (strstr(string1,"hyrec") != NULL) || (strstr(string1,"HyRec") != NULL)){
      pth->recombination = hyrec;
    }
    else{
      class_stop(errmsg,
                 "You specified 'recombination' as '%s'. It has to be one of {'recfast','hyrec'}.",string1);
    }
  }

  /** 7.a) Photo-ionization dependence for recfast */
  /* Read */
  if (pth->recombination == recfast){
    class_call(parser_read_string(pfc,"recfast_photoion_dependence",&string1,&flag1,errmsg),
               errmsg,
               errmsg);
    if (flag1 == _TRUE_){
      if ((strstr(string1,"Tmat") != NULL) || (strstr(string1,"tmat") != NULL ) || (strstr(string1,"TMAT") !=NULL)){
        pth->recfast_photoion_mode = recfast_photoion_Tmat;
      }
      else if ((strstr(string1,"Trad") != NULL) || (strstr(string1,"trad") != NULL ) || (strstr(string1,"TRAD") !=NULL)){
        pth->recfast_photoion_mode = recfast_photoion_Trad;
      }
      else{
        class_stop(errmsg,
                   "You specified 'recfast_photoion_dependence' as '%s'. It has to be one of {'Tmat','Trad'}.",string1);
      }
    }
  }

  /** 8) Reionization parametrization */
  /* Read */
  class_call(parser_read_string(pfc,"reio_parametrization",&string1,&flag1,errmsg),
             errmsg,
             errmsg);
  /* Complete set of parameters */
  if (flag1 == _TRUE_){
    if (strcmp(string1,"reio_none") == 0){
      pth->reio_parametrization = reio_none;
    }
    else if (strcmp(string1,"reio_camb") == 0){
      pth->reio_parametrization = reio_camb;
    }
    else if (strcmp(string1,"reio_bins_tanh") == 0){
      pth->reio_parametrization = reio_bins_tanh;
    }
    else if (strcmp(string1,"reio_half_tanh") == 0){
      pth->reio_parametrization = reio_half_tanh;
    }
    else if (strcmp(string1,"reio_many_tanh") == 0){
      pth->reio_parametrization = reio_many_tanh;
    }
    else if (strcmp(string1,"reio_inter") == 0){
      pth->reio_parametrization = reio_inter;
    }
    else{
      class_stop(errmsg,
                 "You specified 'reio_parametrization' as '%s'. It has to be one of {'reio_none','reio_camb','reio_bins_tanh','reio_half_tanh','reio_many_tanh','reio_inter'}.",string1);
    }
  }

  switch (pth->reio_parametrization) {

  case reio_none:
    /* nothing to be read*/
    break;

    /** 8.a) Reionization parameters if reio_parametrization=reio_camb */
  case reio_camb:
  case reio_half_tanh:
    /* Read */
    class_call(parser_read_double(pfc,"z_reio",&param1,&flag1,errmsg),
               errmsg,
               errmsg);
    class_call(parser_read_double(pfc,"tau_reio",&param2,&flag2,errmsg),
               errmsg,
               errmsg);
    class_read_double("reionization_exponent",pth->reionization_exponent);
    class_read_double("reionization_width",pth->reionization_width);
    class_read_double("helium_fullreio_redshift",pth->helium_fullreio_redshift);
    class_read_double("helium_fullreio_width",pth->helium_fullreio_width);
    /* Test */
    class_test(((flag1 == _TRUE_) && (flag2 == _TRUE_)),
               errmsg,
               "You can only enter one of 'z_reio' or 'tau_reio'.");
    /* Complete set of parameters */
    if (flag1 == _TRUE_){
      pth->z_reio=param1;
      pth->reio_z_or_tau=reio_z;
    }
    if (flag2 == _TRUE_){
      pth->tau_reio=param2;
      pth->reio_z_or_tau=reio_tau;
    }
    break;

    /** 8.b) Reionization parameters if reio_parametrization=reio_bins_tanh */
  case reio_bins_tanh:
    /* Read */
    class_read_int("binned_reio_num",pth->binned_reio_num);
    class_read_list_of_doubles("binned_reio_z",pth->binned_reio_z,pth->binned_reio_num);
    class_read_list_of_doubles("binned_reio_xe",pth->binned_reio_xe,pth->binned_reio_num);
    class_read_double("binned_reio_step_sharpness",pth->binned_reio_step_sharpness);
    break;

    /** 8.c) reionization parameters if reio_parametrization=reio_many_tanh */
  case reio_many_tanh:
    /* Read */
    class_read_int("many_tanh_num",pth->many_tanh_num);
    class_read_list_of_doubles("many_tanh_z",pth->many_tanh_z,pth->many_tanh_num);
    class_read_list_of_doubles("many_tanh_xe",pth->many_tanh_xe,pth->many_tanh_num);
    class_read_double("many_tanh_width",pth->many_tanh_width);
    break;

    /** 8.d) reionization parameters if reio_parametrization=reio_many_tanh */
  case reio_inter:
    /* Read */
    class_read_int("reio_inter_num",pth->reio_inter_num);
    class_read_list_of_doubles("reio_inter_z",pth->reio_inter_z,pth->reio_inter_num);
    class_read_list_of_doubles("reio_inter_xe",pth->reio_inter_xe,pth->reio_inter_num);
    break;

  default:
    class_stop(pth->error_message,"pth->recombination=%d different from all known cases",pth->recombination);
    break;
  }

  /** 9) Damping scale */
  /* Read */
  class_read_flag_or_deprecated("compute_damping_scale","compute damping scale",pth->compute_damping_scale);

  /** 10) Varying fundamental constants */
  class_call(parser_read_string(pfc,"varying_fundamental_constants",&string1,&flag1,errmsg),
             errmsg,
             errmsg);
  /* Complete set of parameters */
  if (flag1 == _TRUE_){
    if (strstr(string1,"none") != NULL){
      pba->varconst_dep = varconst_none;
    }
    else if (strstr(string1,"instant") != NULL){
      pba->varconst_dep = varconst_instant;
    }
    else{
      class_stop(errmsg,
                 "You specified 'varying_fundamental_constants' as '%s'. It has to be one of {'none','instantaneous'}.",string1);
    }
  }
  switch(pba->varconst_dep){
  case varconst_none:
    /* nothing to be read*/
    break;
    /* 10.a) Instantaneous transition from specified values to unity at given transition redshift */
  case varconst_instant:
    class_read_double("varying_alpha",pba->varconst_alpha);
    class_read_double("varying_me",pba->varconst_me);
    class_read_double("varying_transition_redshift",pba->varconst_transition_redshift);
    break;
  }

  if (pba->varconst_dep!=varconst_none){
    /* 10.b) Sensitivity of bbn to a variation of the fine structure constant */
    class_read_double("bbn_alpha_sensitivity",pth->bbn_alpha_sensitivity);
  }

  return _SUCCESS_;

}


/**
 * Read the parameters for each physical species
 *
 * @param pfc            Input: pointer to local structure
 * @param ppr            Input: pointer to precision structure
 * @param pba            Input: pointer to background structure
 * @param pth            Input: pointer to thermodynamics structure
 * @param ppt            Input: pointer to perturbation structure
 * @param input_verbose  Input: verbosity of input
 * @param errmsg         Input: Error message
 * @return the error status
 */

int input_read_parameters_species(struct file_content * pfc,
                                  struct precision * ppr,
                                  struct background * pba,
                                  struct thermodynamics * pth,
                                  struct perturbations * ppt,
                                  int input_verbose,
                                  ErrorMsg errmsg){

  /** Summary: */

  /** - Define local variables */
  int flag1, flag2, flag3;
  double param1, param2, param3;
  char string1[_ARGUMENT_LENGTH_MAX_];
  int fileentries;
  int N_ncdm=0, n, entries_read;
  double rho_ncdm;
  double scf_lambda;
  double fnu_factor;
  double Omega_tot;
  double sigma_B; // Stefan-Boltzmann constant
  double stat_f_idr = 7./8.;
  double f_cdm=1., f_idm=0.;
  short has_m_budget = _FALSE_, has_cdm_userdefined = _FALSE_;
  double Omega_m_remaining = 0.;


  sigma_B = 2.*pow(_PI_,5.)*pow(_k_B_,4.)/15./pow(_h_P_,3.)/pow(_c_,2);  // [W/(m^2 K^4) = Kg/(K^4 s^3)]

  /** 1) Omega_0_g (photons) and T_cmb */
  /* Read */
  class_call(parser_read_double(pfc,"T_cmb",&param1,&flag1,errmsg),
             errmsg,
             errmsg);
  class_call(parser_read_double(pfc,"Omega_g",&param2,&flag2,errmsg),
             errmsg,
             errmsg);
  class_call(parser_read_double(pfc,"omega_g",&param3,&flag3,errmsg),
             errmsg,
             errmsg);
  class_test(class_at_least_two_of_three(flag1,flag2,flag3),
             errmsg,
             "You can only enter one of 'T_cmb', 'Omega_g' or 'omega_g'.");
  /* Complete set of parameters
     Note:  Omega0_g = rho_g/rho_c0, each of them expressed in [Kg/(m s^2)]
     rho_g = (4 sigma_B/c) T^4
     rho_c0 = 3 c^2 H_0^2/(8 \pi G) */
  if (class_none_of_three(flag1,flag2,flag3)){
    pba->Omega0_g = (4.*sigma_B/_c_*pow(pba->T_cmb,4.))/(3.*_c_*_c_*1.e10*pba->h*pba->h/_Mpc_over_m_/_Mpc_over_m_/8./_PI_/_G_);
  }
  else {
    if (flag1 == _TRUE_){
      pba->Omega0_g = (4.*sigma_B/_c_*pow(param1,4.))/(3.*_c_*_c_*1.e10*pba->h*pba->h/_Mpc_over_m_/_Mpc_over_m_/8./_PI_/_G_);
      pba->T_cmb=param1;
    }
    if (flag2 == _TRUE_){
      pba->Omega0_g = param2;
      pba->T_cmb = pow(pba->Omega0_g*(3.*_c_*_c_*1.e10*pba->h*pba->h/_Mpc_over_m_/_Mpc_over_m_/8./_PI_/_G_)/(4.*sigma_B/_c_),0.25);
    }
    if (flag3 == _TRUE_){
      pba->Omega0_g = param3/pba->h/pba->h;
      pba->T_cmb = pow(pba->Omega0_g*(3.*_c_*_c_*1.e10*pba->h*pba->h/_Mpc_over_m_/_Mpc_over_m_/8./_PI_/_G_)/(4.*sigma_B/_c_),0.25);
    }
  }
  class_test(pba->Omega0_g<0,errmsg,"You cannot set the photon density to negative values.");


  /** 2) Omega_0_b (baryons) */
  /* Read */
  class_call(parser_read_double(pfc,"Omega_b",&param1,&flag1,errmsg),
             errmsg,
             errmsg);
  class_call(parser_read_double(pfc,"omega_b",&param2,&flag2,errmsg),
             errmsg,
             errmsg);
  /* Test */
  class_test(((flag1 == _TRUE_) && (flag2 == _TRUE_)),
             errmsg,
             "You can only enter one of 'Omega_b' or 'omega_b'.");
  /* Complete set of parameters */
  if (flag1 == _TRUE_){
    pba->Omega0_b = param1;
  }
  if (flag2 == _TRUE_){
    pba->Omega0_b = param2/pba->h/pba->h;
  }
  class_test(pba->Omega0_b<0,errmsg,"You cannot set the baryon density to negative values.");


  /** 3) Omega_0_ur (ultra-relativistic species / massless neutrino) */
  /* Read */
  class_call(parser_read_double(pfc,"N_ur",&param1,&flag1,errmsg),
             errmsg,
             errmsg);
  /* Compability code END */
  class_call(parser_read_double(pfc,"Omega_ur",&param2,&flag2,errmsg),
             errmsg,
             errmsg);
  class_call(parser_read_double(pfc,"omega_ur",&param3,&flag3,errmsg),
             errmsg,
             errmsg);
  /* Test */
  class_test(class_at_least_two_of_three(flag1,flag2,flag3),
             errmsg,
             "You can only enter one of 'N_ur', 'Omega_ur' or 'omega_ur'.");
  /* Complete set of parameters assuming as default value N_eff=3.044
     (see 2008.01074 and 2012.02726. This value is more accurate than
     the previous default value of 3.046) */
  if (class_none_of_three(flag1,flag2,flag3)) {
    pba->Omega0_ur = 3.044*7./8.*pow(4./11.,4./3.)*pba->Omega0_g;
  }
  else {
    if (flag1 == _TRUE_) {
      pba->Omega0_ur = param1*7./8.*pow(4./11.,4./3.)*pba->Omega0_g;
    }
    if (flag2 == _TRUE_) {
      pba->Omega0_ur = param2;
    }
    if (flag3 == _TRUE_) {
      pba->Omega0_ur = param3/pba->h/pba->h;
    }
  }
  class_test(pba->Omega0_ur<0,errmsg,"You cannot set the density of ultra-relativistic relics (dark radiation/neutrinos) to negative values. You might have input a total Neff smaller than what your massive neutrinos require minimally (around 1.02 * N_ncdm * deg_ncdm).");

  /** 3.a) Case of non-standard properties */
  /* Read */
  class_call(parser_read_double(pfc,"ceff2_ur",&param1,&flag1,errmsg),
             errmsg,
             errmsg);
  class_call(parser_read_double(pfc,"cvis2_ur",&param2,&flag2,errmsg),
             errmsg,
             errmsg);
  /* Complete set of parameters */
  if (flag1 == _TRUE_){
    ppt->three_ceff2_ur = 3.*param1;
  }
  if (flag2 == _TRUE_){
    ppt->three_cvis2_ur = 3.*param2;
  }


  /** 4) Omega_0_cdm (CDM) */
  /* Read */
  class_call(parser_read_double(pfc,"Omega_cdm",&param1,&flag1,errmsg),
             errmsg,
             errmsg);
  class_call(parser_read_double(pfc,"omega_cdm",&param2,&flag2,errmsg),
             errmsg,
             errmsg);
  /* Test */
  class_test(((flag1 == _TRUE_) && (flag2 == _TRUE_)),
             errmsg,
             "You can only enter one of 'Omega_cdm' or 'omega_cdm'.");
  /* Complete set of parameters */
  if (flag1 == _TRUE_){
    pba->Omega0_cdm = param1;
    has_cdm_userdefined = _TRUE_;
  }
  if (flag2 == _TRUE_){
    pba->Omega0_cdm = param2/pba->h/pba->h;
    has_cdm_userdefined = _TRUE_;
  }
  class_test(pba->Omega0_cdm<0,errmsg, "You cannot set the cold dark matter density to negative values.");

  /** 4) (Second part) Omega_0_m (total non-relativistic) */
  class_call(parser_read_double(pfc,"Omega_m",&param1,&flag1,errmsg),
             errmsg,
             errmsg);
  class_call(parser_read_double(pfc,"omega_m",&param2,&flag2,errmsg),
             errmsg,
             errmsg);
  /* Read */
  class_test(((flag1 == _TRUE_) && (flag2 == _TRUE_)),
             errmsg,
             "You can only enter one of 'Omega_m' or 'omega_m'.");
  /* Complete set of parameters */
  if (flag1 == _TRUE_){
    Omega_m_remaining = param1;
    has_m_budget = _TRUE_;
  }
  if (flag2 == _TRUE_){
    Omega_m_remaining = param2/pba->h/pba->h;
    has_m_budget = _TRUE_;
  }
  class_test(Omega_m_remaining<0,errmsg, "You cannot set the total matter density to negative values.");
  class_test(has_cdm_userdefined == _TRUE_ && has_m_budget == _TRUE_, errmsg, "If you want to use 'Omega_m' you cannot fix 'Omega_cdm' simultaneously. Please remove either 'Omega_cdm' or 'Omega_m' from the input file.");
  if (has_m_budget == _TRUE_) {
    class_test(Omega_m_remaining < pba->Omega0_b, errmsg, "Too much energy density from matter species. At this point only %e is left for Omega_m, but requested 'Omega_b = %e'",Omega_m_remaining, pba->Omega0_b);
    Omega_m_remaining-= pba->Omega0_b;
  }

  /** 5) Non-cold relics (ncdm) */
  /** 5.a) Number of non-cold relics */
  /* Read */
  class_read_int("N_ncdm",N_ncdm);
  /* Complete set of parameters */
  if (N_ncdm > 0){
    pba->N_ncdm = N_ncdm;
    if (ppt->gauge == synchronous){
      ppr->tol_ncdm = ppr->tol_ncdm_synchronous;
    }
    if (ppt->gauge == newtonian){
      ppr->tol_ncdm = ppr->tol_ncdm_newtonian;
    }

    /** 5.b) Check if filenames for interpolation tables are given */
    /* Read */
    class_read_list_of_integers_or_default("use_ncdm_psd_files",pba->got_files,_FALSE_,N_ncdm);
    /* Complete set of parameters */
    for (n=0,fileentries=0; n<N_ncdm; n++){
      if (pba->got_files[n] == _TRUE_){
        fileentries++;
      }
    }
    if (fileentries > 0) {

      /** 5.b.1) Check if filenames for interpolation tables are given */
      /* Read */
      class_call(parser_read_list_of_strings(pfc,"ncdm_psd_filenames",&entries_read,&(pba->ncdm_psd_files),&flag1,errmsg),
                 errmsg,
                 errmsg);
      /* Test */
      class_test(flag1 == _FALSE_,errmsg,
                 "Entry 'use_ncdm_files' is found, but no corresponding 'ncdm_psd_filenames' were found.");
      class_test(entries_read != fileentries,errmsg,
                 "Number of filenames found (%d) does not match number of _TRUE_ values in use_ncdm_files (%d).",
                 entries_read,fileentries);
    }

    /** 5.c) (optional) p.s.d.-parameters */
    /* Read */
    class_call(parser_read_list_of_doubles(pfc,"ncdm_psd_parameters",&entries_read,&(pba->ncdm_psd_parameters),&flag1,errmsg),
               errmsg,
               errmsg);

    /** 5.d) Mass and/or Omega of each ncdm species */
    /* Read */
    class_read_list_of_doubles_or_default("m_ncdm",pba->m_ncdm_in_eV,0.0,N_ncdm);
    for (n=0; n<N_ncdm; n++){
      class_test(pba->m_ncdm_in_eV[n]<0,
                 errmsg,
                 "You entered a negative non-CDM mass m_ncdm[%d], which makes no sense. This error was not caught in previous CLASS versions because the mass is always squared in the code, so CLASS returned the exact same results form +m_ncdm and -m_ncdm. If you want to define an 'effective negative neutrino mass' in the sense of e.g. 2405.00836 or 2407.10965, you can implement it in a python script following e.g. eq.(3) of 2407.10965",n);
    }

    class_read_list_of_doubles_or_default("Omega_ncdm",pba->Omega0_ncdm,0.0,N_ncdm);
    // the name M_ncdm is borrowed temporarily to store omega_ncdm
    class_read_list_of_doubles_or_default("omega_ncdm",pba->M_ncdm,0.0,N_ncdm);
    for (n=0; n<N_ncdm; n++){
      if (pba->M_ncdm[n]!=0.0){
        /* Test */
        class_test(pba->Omega0_ncdm[n]!=0,errmsg,
                   "You can only enter one of 'Omega_ncdm' or 'omega_ncdm' for ncdm species %d.",n);
        /* Complete set of parameters: if the user passed either
           Omega_ncdm or omega_ncdm, now it's stored anyway as
           Omega_0_ncdm */
        pba->Omega0_ncdm[n] = pba->M_ncdm[n]/pba->h/pba->h;
        // the name M_ncdm is now available for its real destination
      }
      /* Set default value
         this is the right place for passing the default value of the mass
         (all parameters must have a default value; most of them are defined
         in input_default_params, but the ncdm mass is a bit special and
         there is no better place for setting its default value). We put an
         arbitrary value m << 10^-3 eV, i.e. the ultra-relativistic limit. */
      if ((pba->Omega0_ncdm[n]==0.0) && (pba->m_ncdm_in_eV[n]==0.0)) {
        pba->m_ncdm_in_eV[n]=1.e-5;
      }
    }

    /** 5.e) Temperatures */
    /* Read */
    class_read_list_of_doubles_or_default("T_ncdm",pba->T_ncdm,pba->T_ncdm_default,N_ncdm);

    /** 5.f) Chemical potentials */
    /* Read */
    class_read_list_of_doubles_or_default("ksi_ncdm",pba->ksi_ncdm,pba->ksi_ncdm_default,N_ncdm);

    /** 5.g) Degeneracy of each ncdm species */
    /* Read */
    class_read_list_of_doubles_or_default("deg_ncdm",pba->deg_ncdm,pba->deg_ncdm_default,N_ncdm);

    /** 5.h) Quadrature modes, 0 is qm_auto */
    /* Read */
    class_call(parser_read_list_of_integers(pfc, "Quadrature strategy", &entries_read, &(pba->ncdm_quadrature_strategy), &flag1, errmsg),
               errmsg, errmsg); //Deprecated parameter, still read to keep compatibility
    if (flag1 == _TRUE_) {
      class_test(entries_read != N_ncdm, errmsg, "Number of entries in Quadrature strategy, %d, is different from the number of N_cdm species, %d", entries_read, N_ncdm);
    }
    else {
      class_read_list_of_integers_or_default("ncdm_quadrature_strategy", pba->ncdm_quadrature_strategy, 0, N_ncdm);
    }

    /** 5.h.1) qmax, if relevant */
    /* Read */
    class_call(parser_read_list_of_doubles(pfc, "Maximum_q", &entries_read, &(pba->ncdm_qmax), &flag1, errmsg),
               errmsg, errmsg); //Deprecated parameter, still read to keep compatibility
    if (flag1 == _TRUE_) {
      class_test(entries_read != N_ncdm, errmsg, "Number of entries in Maximum_q, %d, is different from the number of N_cdm species, %d", entries_read, N_ncdm);
    }
    else {
      class_read_list_of_doubles_or_default("ncdm_maximum_q", pba->ncdm_qmax, 15, N_ncdm);
    }

    /** 5.h.2) Number of momentum bins */
    class_call(parser_read_list_of_integers(pfc, "Number of momentum bins", &entries_read, &(pba->ncdm_input_q_size), &flag1, errmsg),
               errmsg, errmsg); //Deprecated parameter, still read to keep compatibility
    if (flag1 == _TRUE_) {
      class_test(entries_read != N_ncdm, errmsg, "Number of entries in Number of momentum bins, %d, is different from the number of N_cdm species, %d", entries_read, N_ncdm);
    }
    else {
      class_read_list_of_integers_or_default("ncdm_N_momentum_bins", pba->ncdm_input_q_size, 150, N_ncdm);
    }

    /** Last step of 5) (i.e. NCDM) -- Calculate the masses and momenta */
    class_call(background_ncdm_init(ppr,pba),
               pba->error_message,
               errmsg);
    /* Complete set of parameters
       We must calculate M from omega or vice versa if one of them is missing.
       If both are present, we must update the degeneracy parameter to
       reflect the implicit normalization of the distribution function. */
    for (n=0; n < N_ncdm; n++){
      if (pba->m_ncdm_in_eV[n] != 0.0){
        /* Case of only mass or mass and Omega/omega: */
        pba->M_ncdm[n] = pba->m_ncdm_in_eV[n]/_k_B_*_eV_/pba->T_ncdm[n]/pba->T_cmb;
        class_call(background_ncdm_momenta(pba->q_ncdm_bg[n],
                                           pba->w_ncdm_bg[n],
                                           pba->q_size_ncdm_bg[n],
                                           pba->M_ncdm[n],
                                           pba->factor_ncdm[n],
                                           0.,
                                           NULL,
                                           &rho_ncdm,
                                           NULL,
                                           NULL,
                                           NULL),
                   pba->error_message,
                   errmsg);
        if (pba->Omega0_ncdm[n] == 0.0){
          pba->Omega0_ncdm[n] = rho_ncdm/pba->H0/pba->H0;
        }
        else{
          fnu_factor = (pba->H0*pba->H0*pba->Omega0_ncdm[n]/rho_ncdm);
          pba->factor_ncdm[n] *= fnu_factor;
          /* dlnf0dlnq is already computed, but it is independent of any
             normalization of f0. We don't need the factor anymore, but we
             store it nevertheless */
          pba->deg_ncdm[n] *=fnu_factor;
        }
      }
      else{
        /* Case of only Omega/omega: */
        class_call(background_ncdm_M_from_Omega(ppr,pba,n),
                   pba->error_message,
                   errmsg);
        pba->m_ncdm_in_eV[n] = _k_B_/_eV_*pba->T_ncdm[n]*pba->M_ncdm[n]*pba->T_cmb;
      }
      pba->Omega0_ncdm_tot += pba->Omega0_ncdm[n];
    }

  }
  class_test(pba->Omega0_ncdm_tot<0,errmsg,"You cannot set the NCDM density to negative values.");
  if (has_m_budget == _TRUE_) {
    class_test(Omega_m_remaining < pba->Omega0_ncdm_tot, errmsg, "Too much energy density from massive species. At this point only %e is left for Omega_m, but requested 'Omega_ncdm = %e' (summed over all species)",Omega_m_remaining, pba->Omega0_ncdm_tot);
    Omega_m_remaining-= pba->Omega0_ncdm_tot;
  }

  /** 6) Omega_0_k (effective fractional density of curvature) */
  /* Read */
  class_read_double("Omega_k",pba->Omega0_k);
  /* Complete set of parameters */
  pba->K = -pba->Omega0_k*pow(pba->H0,2);
  if (pba->K > 0.){
    pba->sgnK = 1;
  }
  else if (pba->K < 0.){
    pba->sgnK = -1;
  }
  class_read_int("nu_spacing",pba->nu_spacing);


  /* 7) ** ADDITIONAL SPECIES ** --> Add your species here */

  /** 7.1) Decaying DM into DR */
  /** 7.1.a) Omega_0_dcdmdr (DCDM, i.e. decaying CDM) */
  /* Read */
  class_call(parser_read_double(pfc,"Omega_dcdmdr",&param1,&flag1,errmsg),
             errmsg,
             errmsg);
  class_call(parser_read_double(pfc,"omega_dcdmdr",&param2,&flag2,errmsg),
             errmsg,
             errmsg);
  class_test(((flag1 == _TRUE_) && (flag2 == _TRUE_)),
             errmsg,
             "You can only enter one of 'Omega_dcdmdr' or 'omega_dcdmdr'.");

  /* ---> if user passes directly the density of dcdmdr */
  if (flag1 == _TRUE_)
    pba->Omega0_dcdmdr = param1;
  if (flag2 == _TRUE_)
    pba->Omega0_dcdmdr = param2/pba->h/pba->h;
  class_test(pba->Omega0_dcdmdr<0,errmsg,"You cannot set the dcdmdr density to negative values.");

  /** 7.1.b) Omega_ini_dcdm or omega_ini_dcdm */
  /* Read */
  class_call(parser_read_double(pfc,"Omega_ini_dcdm",&param1,&flag1,errmsg),
             errmsg,
             errmsg);
  class_call(parser_read_double(pfc,"omega_ini_dcdm",&param2,&flag2,errmsg),
             errmsg,
             errmsg);
  /* Test */
  class_test(((flag1 == _TRUE_) && (flag2 == _TRUE_)),
             errmsg,
             "You can only enter one of 'Omega_ini_dcdm' or 'omega_ini_dcdm'.");
  /* Complete set of parameters */
  if (flag1 == _TRUE_){
    pba->Omega_ini_dcdm = param1;
  }
  if (flag2 == _TRUE_){
    pba->Omega_ini_dcdm = param2/pba->h/pba->h;
  }
  class_test(pba->Omega_ini_dcdm<0,errmsg,"You cannot set the initial dcdm density to negative values.");

  if (pba->Omega0_dcdmdr > 0 || (pba->Omega_ini_dcdm > 0.)) {

    /** 7.1.c) Gamma in same units as H0, i.e. km/(s Mpc)*/
    /* Read */
    class_call(parser_read_double(pfc,"Gamma_dcdm",&param1,&flag1,errmsg),                          // [km/(s Mpc)]
               errmsg,
               errmsg);
    class_call(parser_read_double(pfc,"tau_dcdm",&param2,&flag2,errmsg),                            // [s]
               errmsg,
               errmsg);
    /* Test */
    class_test(((flag1 == _TRUE_) && (flag2 == _TRUE_)),
               errmsg,
               "In input file, you can only enter one of Gamma_dcdm or tau_dcdm, choose one");
    /* Complete set of parameters */
    if (flag1 == _TRUE_){
      pba->Gamma_dcdm = param1*(1.e3/_c_);                                                          // [Mpc]
      pba->tau_dcdm = _Mpc_over_m_*1e-3/param1;                                                     // [s]
    }
    if (flag2 == _TRUE_){
      pba->Gamma_dcdm = _Mpc_over_m_/(param2*_c_);                                                  // [Mpc]
      pba->tau_dcdm = param2;                                                                       // [s]
    }
    /* Test */
    class_test(pba->tau_dcdm<0.,
               errmsg,
               "You need to enter a lifetime for the decaying DM 'tau_dcdm > 0.'");
    class_test(pba->Gamma_dcdm<0.,
               errmsg,
               "You need to enter a decay constant for the decaying DM 'Gamma_dcdm > 0.'");
  }
  if (has_m_budget == _TRUE_) {
    class_test(Omega_m_remaining < pba->Omega0_dcdmdr, errmsg, "Too much energy density from massive species. At this point only %e is left for Omega_m, but requested 'Omega_dcdmdr = %e'",Omega_m_remaining, pba->Omega0_dcdmdr);
    Omega_m_remaining-= pba->Omega0_dcdmdr;
  }

  /** 7.2) Multi-interacting dark matter (idm) */
  /** 7.2.1) Global parameters for all interacting Dark Matter components */

  /** 7.2.1.a) Amount of interacting dark matter*/
  /* Read fraction or density */
  class_call(parser_read_double(pfc,"Omega_idm",&param1,&flag1,errmsg),
             errmsg,
             errmsg);
  class_call(parser_read_double(pfc,"omega_idm",&param2,&flag2,errmsg),
             errmsg,
             errmsg);
  class_call(parser_read_double(pfc,"f_idm",&param3,&flag3,errmsg),
             errmsg,
             errmsg);
  class_test(class_at_least_two_of_three(flag1,flag2,flag3),
             errmsg,
             "In input file, you can only enter one of {Omega_idm, omega_idm, f_idm}, choose one");

  /* ---> if user passes directly the density of idm */
  if (flag1 == _TRUE_)
    pba->Omega0_idm = param1;
  if (flag2 == _TRUE_)
    pba->Omega0_idm = param2/pba->h/pba->h;
  if (flag3 == _TRUE_)
    f_idm = param3;

  /* ---> if user passes density of idm as a fraction of the CDM one */
  /* Find Omega_idm from Omega_cdm and f_idm */
  if (flag3 == _TRUE_) {
    class_test((f_idm < 0.) || (f_idm > 1.),
               errmsg,
               "The fraction of interacting DM must be between 0 and 1, you asked for f_idm=%e",param3);

    /* Test if there is enough dark matter left to be converted into idm */
    class_test(f_idm > f_cdm,
               errmsg,
               "There is not enough cold dark matter left (f_cdm = %.10e) that should be treated as idm, is the sum of the {f_idm=%.10e} parameters less or equal to 1?", f_cdm, f_idm);

    f_cdm -= f_idm;
  }

  /** 7.2.1.b) Mass of interacting dark matter*/
  /* Read */
  if (pba->Omega0_idm > 0.  || f_idm > 0) {
    class_read_double("m_idm",pth->m_idm);

    class_test(pth->m_idm <= 0.,
               errmsg,
               "m_idm must be positive.");
    class_test(pth->m_idm < 1.e6,
               errmsg,
               "Note that the idm formalism assumes the DM to be cold. You have chosen a low mass of m_idm=%e, which is beyond the regime in which the code has been tested.", pth->m_idm);

    ppt->has_idm_soundspeed = _TRUE_;

    class_read_flag("idm_soundspeed",ppt->has_idm_soundspeed);
  }

  /** 7.2.2) Dark Matter interacting with Dark Radiation, ETHOS-parametrization/NADM parametrization, see explanatory.ini */

  /** 7.2.2.a) Amount of idr  */
  /* Read */
  class_call(parser_read_double(pfc,"N_idr",&param1,&flag1,errmsg),
             errmsg,
             errmsg);
  class_call(parser_read_double(pfc,"N_dg",&param2,&flag2,errmsg),
             errmsg,
             errmsg);
  class_call(parser_read_double(pfc,"xi_idr",&param3,&flag3,errmsg),
             errmsg,
             errmsg);
  class_test(class_at_least_two_of_three(flag1,flag2,flag3),
             errmsg,
             "In input file, you can only enter one of {N_idr, N_dg, xi_idr}, choose one");

  /** 7.2.2.b) stat_f_idr  */
  class_read_double("stat_f_idr",stat_f_idr);

  if (flag1 == _TRUE_) {
    pba->T_idr = pow(param1/stat_f_idr*(7./8.)/pow(11./4.,(4./3.)),(1./4.)) * pba->T_cmb;
    if (input_verbose > 1)
      printf("You passed N_idr = N_dg = %e, this is equivalent to xi_idr = %e in the ETHOS notation. \n", param1, pba->T_idr/pba->T_cmb);
  }
  else if (flag2 == _TRUE_) {
    pba->T_idr = pow(param2/stat_f_idr*(7./8.)/pow(11./4.,(4./3.)),(1./4.)) * pba->T_cmb;
    if (input_verbose > 2)
      printf("You passed N_dg = N_idr = %e, this is equivalent to xi_idr = %e in the ETHOS notation. \n", param2, pba->T_idr/pba->T_cmb);
  }
  else if (flag3 == _TRUE_) {
    pba->T_idr = param3 * pba->T_cmb;
    if (input_verbose > 1)
      printf("You passed xi_idr = %e, this is equivalent to N_idr = N_dg = %e in the NADM notation. \n", param3, stat_f_idr*pow(param3,4.)/(7./8.)*pow(11./4.,(4./3.)));
  }
  if (flag1 == _TRUE_ || flag2 == _TRUE_ || flag3 == _TRUE_)
    pba->Omega0_idr = stat_f_idr*pow(pba->T_idr/pba->T_cmb,4.)*pba->Omega0_g;

  /** 7.2.2.c) idm_dr coupling */
  /* Read */
  if (pba->Omega0_idm > 0. || f_idm > 0) {
    class_call(parser_read_double(pfc,"a_idm_dr",&param1,&flag1,errmsg),
               errmsg,
               errmsg);
    /* Deprecated input parameter, read for backwards compatibility) */
    class_call(parser_read_double(pfc,"a_dark",&param2,&flag2,errmsg),
               errmsg,
               errmsg);
    class_call(parser_read_double(pfc,"Gamma_0_nadm",&param3,&flag3,errmsg),
               errmsg,
               errmsg);
    class_test(class_at_least_two_of_three(flag1,flag2,flag3),
               errmsg,
               "In input file, you can only enter one of {a_idm_dr, a_dark, Gamma_0_nadm}, choose one");

    /* Consistency checks */
    if (flag1 == _TRUE_){
      pth->a_idm_dr = param1;
      if (input_verbose > 1)
        printf("You passed a_idm_dr = a_dark = %e, this is equivalent to Gamma_0_nadm = %e in the NADM notation. \n", param1, param1*(4./3.)*(pba->h*pba->h*pba->Omega0_idr));
    }
    else if (flag2 == _TRUE_){
      pth->a_idm_dr = param2;
      if (input_verbose > 1)
        printf("You passed a_dark = a_idm_dr = %e, this is equivalent to Gamma_0_nadm = %e in the NADM notation. \n", param2, param2*(4./3.)*(pba->h*pba->h*pba->Omega0_idr));
    }
    else if (flag3 == _TRUE_){
      pth->a_idm_dr = param3*(3./4.)/(pba->h*pba->h*pba->Omega0_idr);
      if (input_verbose > 1)
        printf("You passed Gamma_0_nadm = %e, this is equivalent to a_idm_dr = a_dark = %e in the ETHOS notation. \n", param3, pth->a_idm_dr);
    }

    class_test(pth->a_idm_dr > 0 && pba->Omega0_idr == 0.0,
               errmsg,
               "You have requested interacting DM ith DR, this requires a non-zero density of interacting DR. Please set either N_idr or xi_idr");

    /* If the user passed Gamma_0_nadm, assume they want nadm parameterisation*/
    if (flag3 == _TRUE_){
      /* Set 7.2.2.d and 7.2.2.e */
      pth->n_index_idm_dr = 0;
      ppt->idr_nature = idr_fluid;
      if (input_verbose > 1)
        printf("NADM requested. Defaulting on n_index_idm_dr = %e and idr_nature = fluid \n", pth->n_index_idm_dr);
    }

    /* If the user passed something else, assume they want ETHOS parameterisation*/
    else{
      /** 7.2.2.d) n_index_idm_dr */
      class_call(parser_read_double(pfc,"n_index_idm_dr",&param1,&flag1,errmsg),
                 errmsg,
                 errmsg);
      /* Deprecated input parameters, read for backwards compatibility) */
      class_call(parser_read_double(pfc,"nindex_idm_dr",&param3,&flag3,errmsg),
                 errmsg,
                 errmsg);
      class_call(parser_read_double(pfc,"nindex_dark",&param2,&flag2,errmsg),
                 errmsg,
                 errmsg);
      class_test(class_at_least_two_of_three(flag1,flag2,flag3),
                 errmsg,
                 "In input file, you can only enter one of {n_index_idm_dr, nindex_idm_dr, nindex_dark}, choose one");
      if (flag1 == _TRUE_){
        pth->n_index_idm_dr = param1;
      }
      if (flag2 == _TRUE_){
        pth->n_index_idm_dr = param2;
      }
      if (flag3 == _TRUE_){
        pth->n_index_idm_dr = param3;
      }

    }

    /** 7.2.2.e) Strength of self interactions */
    class_read_double_one_of_two("b_dark","b_idr",pth->b_idr);

    /** 7.2.2.f) Read alpha_idm_dr or alpha_dark */
    class_call(parser_read_list_of_doubles(pfc,"alpha_idm_dr",&entries_read,&(ppt->alpha_idm_dr),&flag1,errmsg),
               errmsg,
               errmsg);
    /* try with the other syntax */
    if (flag1 == _FALSE_) {
      class_call(parser_read_list_of_doubles(pfc,"alpha_dark",&entries_read,&(ppt->alpha_idm_dr),&flag1,errmsg),
                 errmsg,
                 errmsg);
    }

    /* At this point these quantities may or may not be allocated */
    /* If we have perturbations, everything is alright, go ahead and allocate default values */
    if (ppt->has_perturbations) {
      if (flag1 == _TRUE_){
        if (ppt->perturbations_verbose > 0) {
          class_test(entries_read > ppr->l_max_idr-1,
                     errmsg,
                     "The number of alpha_idm_dr parameters passed (%d) is bigger than l_max_idr-1=%d", entries_read, ppr->l_max_idr-1);
        }
        /* If less input than expected -> fill up with last value, otherwise nothing to do */
        if (entries_read < (ppr->l_max_idr-1)){
          if (ppt->perturbations_verbose > 0) {
            printf("WARNING: only %i entries of alpha_idm_dr were provided for %i moments, filling up the rest with the last entry provided\n", entries_read, ppr->l_max_idr-1);
          }
          class_realloc(ppt->alpha_idm_dr,(ppr->l_max_idr-1)*sizeof(double),errmsg);
          for (n=entries_read; n<(ppr->l_max_idr-1); n++) ppt->alpha_idm_dr[n] = ppt->alpha_idm_dr[entries_read-1];
        }
      }
      else{
        /* Allocate default values if we have idm, but the user doesn't provide input */
        class_alloc(ppt->alpha_idm_dr,(ppr->l_max_idr-1)*sizeof(double),errmsg);
        for (n=0; n<(ppr->l_max_idr-1); n++) ppt->alpha_idm_dr[n] = 1.5;
      }
    }
    /* If we don't have perturbations, we should free the arrays again if necessary */
    else if (ppt->alpha_idm_dr != NULL) {
      free(ppt->alpha_idm_dr);
    }
  }

  /** 7.2.2.g) idr_nature */
  if (pba->T_idr > 0) {
    class_call(parser_read_string(pfc,"idr_nature",&string1,&flag1,errmsg),
               errmsg,
               errmsg);
    if (flag1 == _TRUE_) {
      if ((strstr(string1,"free_streaming") != NULL) || (strstr(string1,"Free_Streaming") != NULL) || (strstr(string1,"Free_streaming") != NULL) || (strstr(string1,"FREE_STREAMING") != NULL)) {
        ppt->idr_nature = idr_free_streaming;
      }
      else if ((strstr(string1,"fluid") != NULL) || (strstr(string1,"Fluid") != NULL) || (strstr(string1,"FLUID") != NULL)) {
        ppt->idr_nature = idr_fluid;
      }
      else {
        class_stop(errmsg, "idr_nature has to be either free_streaming or fluid, but you entered %s.", string1);
      }
    }
  }

  /** 7.2.2.h) beta_idr */
  if ((pba->Omega0_idm > 0 || f_idm > 0) && pba->Omega0_idr > 0) {
    /* Read */
    class_call(parser_read_list_of_doubles(pfc,"beta_idr",&entries_read,&(ppt->beta_idr),&flag1,errmsg),
               errmsg,
               errmsg);
    /* try with the other syntax */
    if (flag1 == _FALSE_) {
      class_call(parser_read_list_of_doubles(pfc,"beta_dark",&entries_read,&(ppt->beta_idr),&flag1,errmsg),
                 errmsg,
                 errmsg);
    }

    /* At this point these quantities might or might not be allocated */
    /* If we have perturbations, everything is alright, go ahead and allocate default values */
    if (ppt->has_perturbations == _TRUE_) {
      if (flag1 == _TRUE_){
        /* If less input than expected -> fill up with last value, otherwise nothing to do */
        if (ppt->perturbations_verbose > 0) {
          class_test(entries_read > ppr->l_max_idr-1,
                     errmsg,
                     "The number of beta_idr parameters passed (%d) is bigger than l_max_idr-1=%d", entries_read, ppr->l_max_idr-1);
        }
        if (entries_read < (ppr->l_max_idr-1)){
          if (ppt->perturbations_verbose > 0) {
            printf("WARNING: only %i entries of beta_idr were provided for %i moments, filling up the rest with the last entry provided\n", entries_read, ppr->l_max_idr-1);
          }
          class_realloc(ppt->beta_idr,(ppr->l_max_idr-1)*sizeof(double),errmsg);
          for (n=entries_read; n<(ppr->l_max_idr-1); n++)
            ppt->beta_idr[n] = ppt->beta_idr[entries_read-1];
        }
      }
      else {
        /* Allocate default values if we have idm, but the user doesn't provide input */
        class_alloc(ppt->beta_idr,(ppr->l_max_idr-1)*sizeof(double),errmsg);
        for (n=0; n<(ppr->l_max_idr-1); n++)
          ppt->beta_idr[n] = 1.5;
      }
    }
    /* If we don't have perturbations, we should free the arrays again if necessary */
    else if (ppt->beta_idr != NULL) {
      free(ppt->beta_idr);
    }
  }

  /** 7.2.3) Dark Matter interacting with baryons */
  /** 7.2.3.a) idm_b coupling stregth */
  if (pba->Omega0_idm > 0 || f_idm > 0) {
    class_read_double("cross_idm_b",pth->cross_idm_b);

    /** 7.2.3.b) idm_b temperature dependence */
    /* Read */
    if (pth->cross_idm_b > 0) {
      class_read_int("n_index_idm_b",pth->n_index_idm_b);

      /* Consistency checks */
      class_test(((pth->n_index_idm_b > 4)||(pth->n_index_idm_b < -4)),
                 errmsg,
                 "The index for the DM-baryon interaction must be an integer between -4 and 4, you passed n_index_idm_b = %d.", pth->n_index_idm_b);
      /* The following formula is taken from Dvorkin et al. (2013) */
      pth->n_coeff_idm_b = (pow(2.,(pth->n_index_idm_b+5.)/2.)*tgamma(3.+pth->n_index_idm_b/2.))/(3.*sqrt(_PI_));
    }
  }

  /** 7.2.4) Dark Matter interacting with photons */
  /** 7.2.4.a) idm_g coupling stregth */
  if (pba->Omega0_idm > 0.0 || f_idm > 0){
    /* Read */
    class_call(parser_read_double(pfc,"u_idm_g",&param1,&flag1,errmsg),
               errmsg,
               errmsg);
    class_call(parser_read_double(pfc,"cross_idm_g",&param2,&flag2,errmsg),
               errmsg,
               errmsg);
    class_test((flag1 ==_TRUE_) && (flag2 == _TRUE_),
               errmsg,
               "Only one of two idm_g parameters {u_idm_g, cross_idm_g} can be specified at the same time");

    /* Set values */
    if (flag1 == _TRUE_){
      pth->u_idm_g = param1;
      pth->cross_idm_g = pth->u_idm_g * _sigma_ * pth->m_idm/1e11 ;
    }
    if (flag2 == _TRUE_) {
      pth->cross_idm_g = param2;
      pth->u_idm_g = pth->cross_idm_g / _sigma_ * (1e11/pth->m_idm);
    }

    /** 7.2.4.b) idm_g temperature dependence */
    if (pth->u_idm_g > 0) {
      class_read_double("n_index_idm_g",pth->n_index_idm_g);
    }
  }
  /* Checks on budget equation */
  if (has_m_budget == _TRUE_) {
    class_test(Omega_m_remaining < pba->Omega0_idm, errmsg, "Too much energy density from massive species. At this point only %e is left for Omega_m, but requested 'Omega_idm = %e'",Omega_m_remaining, pba->Omega0_idm);
    Omega_m_remaining -= pba->Omega0_idm;
  }

  /* We enforce the tight coupling approximation to be first order whenever idm interacts with baryons */
  if (pth->cross_idm_b >0 && (ppr->tight_coupling_approximation != (int)first_order_CLASS)) {
    if (ppt->perturbations_verbose > 0)
      printf("Warning: Setting the tight_coupling_approximation = first_order_CLASS, since you selected idm-b!\n");
    ppr->tight_coupling_approximation = first_order_CLASS;
  }
  else if (pth->u_idm_g > 0 && (ppr->tight_coupling_approximation != (int)first_order_CLASS && ppr->tight_coupling_approximation != (int)compromise_CLASS)) {
    if (ppt->perturbations_verbose > 0)
      printf("Warning: Setting the tight_coupling_approximation = compromise_CLASS, since you selected idm-g!\n");
    ppr->tight_coupling_approximation = compromise_CLASS;
  }

  /* ** ADDITIONAL SPECIES ** */


  /** 7.3) Final consistency checks for dark matter species */

  class_test(fabs(f_cdm + f_idm - 1.) > 1e-10,
             errmsg,
             "The dark matter species do not add up to the expected value");

  /* After all the other possibly non-relativistic species have been determined, we can fianlly compute the CDM density */
  if (has_m_budget == _TRUE_) {
    pba->Omega0_cdm = Omega_m_remaining;
  }

  /* When the CDM density is determined we can use the previously collected fractions to determine the corresponding densities. First, make sure everything is reasonable*/
  class_test((f_idm > 0.) && (pba->Omega0_cdm == 0.),
             errmsg,
             "If you want a fraction of interacting, to be consistent, you should not set the fraction of CDM to zero");
  class_test(fabs(f_cdm + f_idm - 1.) > ppr->tol_fraction_accuracy,
             errmsg,
             "The dark matter species do not add up to the expected value");
  if ( f_idm > 0. )
    pba->Omega0_idm = f_idm * pba->Omega0_cdm;
  if ( f_cdm < 1. )
    pba->Omega0_cdm = f_cdm * pba->Omega0_cdm;

  /* When the fraction f_idm is about one, Omega0_cdm can
     be close to zero, but due to rounding errors it could be slightly
     negative; correct for this: */
  if (pba->Omega0_cdm < 0.)
    pba->Omega0_cdm = 0.;

  /* avoid Omega0_cdm exactly zero in synchronous gauge */
  if ((ppt->gauge == synchronous) && (pba->Omega0_cdm < ppr->Omega0_cdm_min_synchronous)) {
    pba->Omega0_cdm = ppr->Omega0_cdm_min_synchronous;
  }

  /* At this point all the species should be set, and used for the budget equation below */

  /** 8) Dark energy
      Omega_0_lambda (cosmological constant), Omega0_fld (dark energy
      fluid), Omega0_scf (scalar field) */
  /* Read */
  class_call(parser_read_double(pfc,"Omega_Lambda",&param1,&flag1,errmsg),
             errmsg,
             errmsg);
  class_call(parser_read_double(pfc,"Omega_fld",&param2,&flag2,errmsg),
             errmsg,
             errmsg);
  class_call(parser_read_double(pfc,"Omega_scf",&param3,&flag3,errmsg),
             errmsg,
             errmsg);
  /* Test */
  class_test((flag1 == _TRUE_) && (flag2 == _TRUE_) && ((flag3 == _FALSE_) || (param3 >= 0.)),
             errmsg,
             "'Omega_Lambda' or 'Omega_fld' must be left unspecified, except if 'Omega_scf' is set and < 0.");
  class_test(((flag1 == _FALSE_)||(flag2 == _FALSE_)) && ((flag3 == _TRUE_) && (param3 < 0.)),
             errmsg,
             "You have entered 'Omega_scf' < 0 , so you have to specify both 'Omega_lambda' and 'Omega_fld'.");
  /* Complete set of parameters
     Case of (flag3 == _FALSE_) || (param3 >= 0.) means that either we have not
     read Omega_scf so we are ignoring it (unlike lambda and fld!) OR we have
     read it, but it had a positive value and should not be used for filling.
     We now proceed in two steps:
     1) set each Omega0 and add to the total for each specified component.
     2) go through the components in order {lambda, fld, scf} and fill using
     first unspecified component. */

  /* ** BUDGET EQUATION ** -> Add your species here */
  /* Compute Omega_tot */
  Omega_tot = pba->Omega0_g;
  Omega_tot += pba->Omega0_b;
  Omega_tot += pba->Omega0_ur;
  Omega_tot += pba->Omega0_cdm;
  Omega_tot += pba->Omega0_idm;
  Omega_tot += pba->Omega0_dcdmdr;
  Omega_tot += pba->Omega0_idr;
  Omega_tot += pba->Omega0_ncdm_tot;
  /* Step 1 */
  if (flag1 == _TRUE_){
    pba->Omega0_lambda = param1;
    Omega_tot += pba->Omega0_lambda;
  }
  if (flag2 == _TRUE_){
    pba->Omega0_fld = param2;
    Omega_tot += pba->Omega0_fld;
  }
  if ((flag3 == _TRUE_) && (param3 >= 0.)){
    pba->Omega0_scf = param3;
    Omega_tot += pba->Omega0_scf;
  }
  /* Step 2 */
  if (flag1 == _FALSE_) {
    /* Fill with Lambda */
    pba->Omega0_lambda= 1. - pba->Omega0_k - Omega_tot;
    if (input_verbose > 0){
      printf(" -> matched budget equations by adjusting Omega_Lambda = %g\n",pba->Omega0_lambda);
    }
  }
  else if (flag2 == _FALSE_) {
    /* Fill up with fluid */
    pba->Omega0_fld = 1. - pba->Omega0_k - Omega_tot;
    if (input_verbose > 0){
      printf(" -> matched budget equations by adjusting Omega_fld = %g\n",pba->Omega0_fld);
    }
  }
  else if ((flag3 == _TRUE_) && (param3 < 0.)){
    /* Fill up with scalar field */
    pba->Omega0_scf = 1. - pba->Omega0_k - Omega_tot;
    if (input_verbose > 0){
      printf(" -> matched budget equations by adjusting Omega_scf = %g\n",pba->Omega0_scf);
    }
  }

  /* ** END OF BUDGET EQUATION ** */

  /** 8.a) If Omega fluid is different from 0 */
  if (pba->Omega0_fld != 0.) {
    /** 8.a.1) PPF approximation */
    /* Read */
    class_call(parser_read_string(pfc,"use_ppf",&string1,&flag1,errmsg),
               errmsg,
               errmsg);
    if (flag1 == _TRUE_){
      if (string_begins_with(string1,'y') || string_begins_with(string1,'Y')){
        pba->use_ppf = _TRUE_;
        class_read_double("c_gamma_over_c_fld",pba->c_gamma_over_c_fld);
      }
      else {
        pba->use_ppf = _FALSE_;
      }
    }

    /** 8.a.2) Equation of state */
    /* Read */
    class_call(parser_read_string(pfc,"fluid_equation_of_state",&string1,&flag1,errmsg),
               errmsg,
               errmsg);
    /* Complete set of parameters */
    if (flag1 == _TRUE_) {
      if ((strstr(string1,"CLP") != NULL) || (strstr(string1,"clp") != NULL)) {
        pba->fluid_equation_of_state = CLP;
      }
      else if ((strstr(string1,"EDE") != NULL) || (strstr(string1,"ede") != NULL)) {
        pba->fluid_equation_of_state = EDE;
      }
      else {
        class_stop(errmsg,"incomprehensible input '%s' for the field 'fluid_equation_of_state'",string1);
      }
    }

    if (pba->fluid_equation_of_state == CLP) {
      /** 8.a.2.2) Equation of state of the fluid in 'CLP' case */
      /* Read */
      class_read_double("w0_fld",pba->w0_fld);
      class_read_double("wa_fld",pba->wa_fld);
      class_read_double("cs2_fld",pba->cs2_fld);
    }
    if (pba->fluid_equation_of_state == EDE) {
      /** 8.a.2.3) Equation of state of the fluid in 'EDE' case */
      /* Read */
      class_read_double("w0_fld",pba->w0_fld);
      class_read_double("Omega_EDE",pba->Omega_EDE);
      class_read_double("cs2_fld",pba->cs2_fld);
    }
  }

  /** 8.b) If Omega scalar field (SCF) is different from 0 */
  if (pba->Omega0_scf != 0.){

    /** 8.b.1) Additional SCF parameters */
    /* Read */
    class_call(parser_read_list_of_doubles(pfc,
                                           "scf_parameters",
                                           &(pba->scf_parameters_size),
                                           &(pba->scf_parameters),
                                           &flag1,
                                           errmsg),
               errmsg,errmsg);

    /** 8.b.2) SCF initial conditions from attractor solution */
    /* Read */
    class_call(parser_read_string(pfc,
                                  "attractor_ic_scf",
                                  &string1,
                                  &flag1,
                                  errmsg),
               errmsg,
               errmsg);
    /* Complete set of parameters */
    if (flag1 == _TRUE_){
      if (string_begins_with(string1,'y') || string_begins_with(string1,'Y')){
        pba->attractor_ic_scf = _TRUE_;
      }
      else {
        pba->attractor_ic_scf = _FALSE_;
        /* Test */
        class_test(pba->scf_parameters_size<2,
                   errmsg,
                   "Since you are not using attractor initial conditions, you must specify phi and its derivative phi' as the last two entries in scf_parameters. See explanatory.ini for more details.");
        pba->phi_ini_scf = pba->scf_parameters[pba->scf_parameters_size-2];
        pba->phi_prime_ini_scf = pba->scf_parameters[pba->scf_parameters_size-1];
      }
    }

    /** 8.b.3) SCF tuning parameter */
    /* Read */
    class_read_int("scf_tuning_index",pba->scf_tuning_index);
    /* Test */
    class_test(pba->scf_tuning_index >= pba->scf_parameters_size,
               errmsg,
               "Tuning index 'scf_tuning_index' (%d) is larger than the number of entries (%d) in 'scf_parameters'.",
               pba->scf_tuning_index,pba->scf_parameters_size);

    /** 8.b.4) Shooting parameter */
    /* Read */
    class_read_double("scf_shooting_parameter",pba->scf_parameters[pba->scf_tuning_index]);
    /* Complete set of parameters */
    scf_lambda = pba->scf_parameters[0];
    if ((fabs(scf_lambda) < 3.)&&(pba->background_verbose>1)){
      printf("'scf_lambda' = %e < 3 won't be tracking (for exp quint) unless overwritten by tuning function.",scf_lambda);
    }
  }

  return _SUCCESS_;

}


/**
 * Read the parameters of injection structure
 * (These are all exotic processes of energy injection)
 *
 * @param pfc     Input: pointer to local structure
 * @param ppr     Input: pointer to precision structure
 * @param pth     Input: pointer to thermodynamics structure
 * @param errmsg  Input: Error message
 * @return the error status
 */

int input_read_parameters_injection(struct file_content * pfc,
                                    struct precision * ppr,
                                    struct thermodynamics * pth,
                                    ErrorMsg errmsg){

  /** Summary: */

  /** - Define local variables */
  struct injection* pin = &(pth->in);
  int flag1;
  char string1[_ARGUMENT_LENGTH_MAX_];
  string1[0]='\0';

  /** 1) DM annihilation */
  /** 1.a) Annihilation efficiency */
  /* Read */
  class_read_double("DM_annihilation_efficiency",pin->DM_annihilation_efficiency);
  class_read_double("DM_annihilation_cross_section",pin->DM_annihilation_cross_section);
  class_read_double("DM_annihilation_mass",pin->DM_annihilation_mass);
  class_read_double("DM_annihilation_fraction",pin->DM_annihilation_fraction);

  /* Test consistency of this input */
  class_test(pin->DM_annihilation_efficiency<0,
             errmsg,
             "annihilation efficiency cannot be negative");
  class_test(pin->DM_annihilation_efficiency>1.e-4,
             errmsg,
             "annihilation parameter suspiciously large (%e, while typical bounds are in the range of 1e-7 to 1e-6)",pin->DM_annihilation_efficiency);
  class_test(pin->DM_annihilation_mass<0. || pin->DM_annihilation_cross_section <0,
             errmsg,
             "Both mass and cross section for your dark matter particle must be positive.");
  class_test(pin->DM_annihilation_mass ==0 && pin->DM_annihilation_cross_section >0,
             errmsg,
             "you have annihilation_cross_section > 0 but DM_mass = 0. That is weird, please check your param file and set 'DM_mass' [GeV] to a non-zero value.\n");
  class_test((pin->DM_annihilation_cross_section !=0 || pin->DM_annihilation_mass !=0 || pin->DM_annihilation_fraction !=0) && pin->DM_annihilation_efficiency != 0,
             errmsg,
             "You can only enter one of {'DM_annihilation_cross_section', 'DM_annihilation_mass', 'DM_annihilation_fraction'} or 'annihilation_efficiency'.");
  if ((pin->DM_annihilation_efficiency >0) && (pth->reio_parametrization == reio_none) && (ppr->recfast_Heswitch >= 3) && (pth->recombination==recfast) && (pth->thermodynamics_verbose > 0)) {
    printf("Warning: if you have DM annihilation and you use recfast with option recfast_Heswitch >= 3, then the expression for CfHe_t and dy[1] becomes undefined at late times, producing nan's. This is however masked by reionization if you are not in reio_none mode.");
  }

  /* Complete set of parameters */
  if (pin->DM_annihilation_mass > 0 && pin->DM_annihilation_cross_section > 0.){
    pin->DM_annihilation_efficiency = pin->DM_annihilation_cross_section*1.e-6/(pin->DM_annihilation_mass*_eV_*1.e9)*pow(pin->DM_annihilation_fraction,2);
  }

  if (pin->DM_annihilation_efficiency > 0){
    pth->has_exotic_injection = _TRUE_;
  }

  if (pin->DM_annihilation_efficiency > 0.) {
    /** 1.a.1) Model energy fraction absorbed by the gas as a function of redhsift */
    /* Read */
    class_read_double("DM_annihilation_variation",pin->DM_annihilation_variation);
    class_read_double("DM_annihilation_z",pin->DM_annihilation_z);
    class_read_double("DM_annihilation_zmax",pin->DM_annihilation_zmax);
    class_read_double("DM_annihilation_zmin",pin->DM_annihilation_zmin);
    class_read_double("DM_annihilation_f_halo",pin->DM_annihilation_f_halo);
    class_read_double("DM_annihilation_z_halo",pin->DM_annihilation_z_halo);
    /* Test */
    class_test(pin->DM_annihilation_variation>0,
               errmsg,
               "annihilation variation parameter must be negative (decreasing annihilation rate)");
    class_test(pin->DM_annihilation_z<0,
               errmsg,
               "characteristic annihilation redshift cannot be negative");
    class_test(pin->DM_annihilation_zmin<0,
               errmsg,
               "characteristic annihilation redshift cannot be negative");
    class_test(pin->DM_annihilation_zmax<0,
               errmsg,
               "characteristic annihilation redshift cannot be negative");
    class_test(pin->DM_annihilation_f_halo<0,
               errmsg,
               "Parameter for DM annihilation in halos cannot be negative");
    class_test(pin->DM_annihilation_z_halo<0,
               errmsg,
               "Parameter for DM annihilation in halos cannot be negative");
  }

  /** 2) DM decay */
  /** 2.a) Fraction */
  /* Read */
  class_read_double("DM_decay_fraction",pin->DM_decay_fraction);
  if (pin->DM_decay_fraction!=0){
    pth->has_exotic_injection = _TRUE_;
  }
  /* Test */
  class_test(pin->DM_decay_fraction<0,
             errmsg,
             "You need to enter a positive fraction of decaying DM. Please adjust your param file.");

  /** 2.b) Decay width */
  /* Read */
  class_read_double("DM_decay_Gamma",pin->DM_decay_Gamma);


  /** 3) PBH evaporation */
  /** 3.a) Fraction */
  /* Read */
  class_read_double("PBH_evaporation_fraction",pin->PBH_evaporation_fraction);
  if (pin->PBH_evaporation_fraction!=0){
    pth->has_exotic_injection = _TRUE_;
  }
  /* Test */
  class_test(pin->PBH_evaporation_fraction <0.,
             errmsg,
             "You need to enter a positive fraction of evaporating PBH. Please adjust your param file.");

  /** 3.b) Mass */
  /* Read */
  class_read_double("PBH_evaporation_mass",pin->PBH_evaporation_mass);
  /* Test */
  class_test(pin->PBH_evaporation_mass<0.,
             errmsg,
             "You need to enter a positive mass for your PBH.");
  class_test(pin->PBH_evaporation_mass>0. && pin->PBH_evaporation_fraction == 0,
             errmsg,
             "You have 'PBH_evaporation_mass > 0.' but 'PBH_evaporation_fraction = 0'. Please adjust your param file.");
  class_test(pin->PBH_evaporation_fraction>0. && pin->PBH_evaporation_mass == 0.,
             errmsg,
             "You have asked for a fraction of PBH being DM but you have zero mass. Please adjust your param file.");


  /** 4) PBH matter accretion */
  /** 4.a) Fraction */
  /* Read */
  class_read_double("PBH_accretion_fraction",pin->PBH_accretion_fraction);
  if (pin->PBH_accretion_fraction!=0){
    pth->has_exotic_injection = _TRUE_;
  }
  /* Test */
  class_test(pin->PBH_accretion_fraction < 0.,
             errmsg,
             "You need to enter a positive fraction of accreting PBH. Please adjust your param file.");

  /** 4.b) Mass */
  /* Read */
  class_read_double("PBH_accretion_mass",pin->PBH_accretion_mass);
  /* Test */
  class_test(pin->PBH_accretion_mass<0.,
             errmsg,
             "You need to enter a positive mass for your PBH.");
  class_test(pin->PBH_accretion_mass>0. && pin->PBH_accretion_fraction == 0,
             errmsg,
             "You have 'PBH_accretion_mass > 0.' but 'PBH_accretion_fraction = 0'. Please adjust your param file.");
  class_test(pin->PBH_accretion_fraction>0. && pin->PBH_accretion_mass == 0.,
             errmsg,
             "You have asked for a fraction of PBH being DM but you have zero mass. Please adjust your param file.");

  /** 4.c) Recipe */
  /* Read */
  class_call(parser_read_string(pfc,"PBH_accretion_recipe",&string1,&flag1,errmsg),
             errmsg,
             errmsg);
  /* Complete set of parameters */
  if (flag1 == _TRUE_){
    if (strcmp(string1,"spherical_accretion") == 0) {
      pin->PBH_accretion_recipe=spherical_accretion;
    }
    else if (strcmp(string1,"disk_accretion") == 0) {
      pin->PBH_accretion_recipe=disk_accretion;
    }
    else{
      class_stop(errmsg,
                 "You specified 'PBH_accretion_recipe' as '%s'. It has to be one of {'spherical_accretion','disk_accretion'}.",string1);
    }
  }

  /** 4.c.1) Additional parameters specific for spherical accretion */
  if (pin->PBH_accretion_recipe == spherical_accretion){
    /* Read */
    class_read_double("PBH_accretion_relative_velocities",pin->PBH_accretion_relative_velocities);
  }

  /** 4.c.2) Additional parameters specific for disk accretion */
  if (pin->PBH_accretion_recipe == disk_accretion){
    /* Read */
    class_read_double("PBH_accretion_ADAF_delta",pin->PBH_accretion_ADAF_delta);
    class_read_double("PBH_accretion_eigenvalue",pin->PBH_accretion_eigenvalue);
    /* Test */
    class_test(pin->PBH_accretion_ADAF_delta != 1e-3 && pin->PBH_accretion_ADAF_delta != 0.5  && pin->PBH_accretion_ADAF_delta != 0.1,
               errmsg,
               "The parameter 'pth->PBH_ADAF_delta' can currently only be set to 1e-3, 0.1 or 0.5.");
  }


  /** 5) Injection efficiency */
  /* Read */
  class_call(parser_read_string(pfc,"f_eff_type",&string1,&flag1,errmsg),
             errmsg,
             errmsg);
  /* Complete set of parameters */
  if (flag1 == _TRUE_){
    if (strcmp(string1,"on_the_spot") == 0){
      pin->f_eff_type = f_eff_on_the_spot;
      class_read_double("f_eff",pin->f_eff);
    }
    else if (strcmp(string1,"from_file") == 0){
      pin->f_eff_type = f_eff_from_file;
      /* Read */
      class_call(parser_read_string(pfc,"f_eff_file",&string1,&flag1,errmsg),
                 errmsg,
                 errmsg);
      /* Test */
      class_test(flag1 == _FALSE_,
                 errmsg,
                 "for the option 'from_file' for 'f_eff_type' the option 'f_eff_file' is required.");
      /* Complete set of parameters */
      strcpy(pin->f_eff_file, string1);
    }
    else{
      class_stop(errmsg,
                 "You specified 'f_eff_type' as '%s'. It has to be one of {'on_the_spot','from_file'}.",string1);
    }
  }

  /** 6) deposition function */
  /* Read */
  class_call(parser_read_string(pfc,"chi_type",&string1,&flag1,errmsg),
             errmsg,
             errmsg);
  /* Complete set of parameters */
  if (flag1 == _TRUE_){
    if (strcmp(string1,"CK_2004") == 0){
      pin->chi_type = chi_CK;
    }
    else if (strcmp(string1,"PF_2005") == 0){
      pin->chi_type = chi_PF;
    }
    else if (strcmp(string1,"Galli_2013_file") == 0){
      pin->chi_type = chi_Galli_file;
    }
    else if (strcmp(string1,"Galli_2013_analytic") == 0){
      pin->chi_type = chi_Galli_analytic;
    }
    else if (strcmp(string1,"heat") == 0){
      pin->chi_type = chi_full_heating;
    }
    else if (strcmp(string1,"from_x_file") == 0){
      pin->chi_type = chi_from_x_file;
    }
    else if (strcmp(string1,"from_z_file") == 0){
      pin->chi_type = chi_from_z_file;
    }
    else{
      class_stop(errmsg,
                 "You specified 'chi_type' as '%s'. It has to be one of {'CK_2004','PF_2005','Galli_2013_file','Galli_2013_analytic','heat','from_x_file','from_z_file'}.",string1);
    }
  }

  if (pin->chi_type == chi_from_x_file || pin->chi_type == chi_from_z_file){
    /** 6.a) External file */
    /* Read */
    class_call(parser_read_string(pfc,"chi_file",&string1,&flag1,errmsg),
               errmsg,
               errmsg);
    /* Test */
    class_test(flag1 == _FALSE_,
               errmsg,
               "for the option 'from_x_file' or 'from_z_file' for 'chi_type' the option 'chi_file' is required.");
    /* Complete set of parameters */
    strcpy(pin->chi_z_file, string1);
    strcpy(pin->chi_x_file, string1);
  }

  return _SUCCESS_;

}


/**
 * Read the parameters of fourier structure.
 *
 * @param pfc            Input: pointer to local structure
 * @param ppr            Input: pointer to precision structure
 * @param pba            Input: pointer to background structure
 * @param pth            Input: pointer to thermodynamics structure
 * @param ppt            Input: pointer to perturbations structure
 * @param pfo            Input: pointer to fourier structure
 * @param input_verbose  Input: verbosity of input
 * @param errmsg         Input: Error message
 * @return the error status
 */

int input_read_parameters_nonlinear(struct file_content * pfc,
                                    struct precision * ppr,
                                    struct background * pba,
                                    struct thermodynamics * pth,
                                    struct perturbations * ppt,
                                    struct fourier * pfo,
                                    int input_verbose,
                                    ErrorMsg errmsg){

  /** Define local variables */
  int flag1,flag2,flag3;
  double param1,param2,param3;
  char string1[_ARGUMENT_LENGTH_MAX_];

  /** 1) Non-linearity */
  /* Read */
  class_call(parser_read_string(pfc,"non_linear",&string1,&flag1,errmsg),
             errmsg,
             errmsg);
  /* Compatibility code BEGIN */
  if (flag1 == _FALSE_){
    class_call(parser_read_string(pfc,"non linear",&string1,&flag1,errmsg),
               errmsg,
               errmsg);
  }
  /* Compatibility code END */

  if (flag1 == _TRUE_) {
    /* Test */
    class_test(ppt->has_perturbations == _FALSE_,
               errmsg,
               "You requested non-linear computation but no perturbations. You must set the 'output' field.");
    /* Complete set of parameters */
    if ((strstr(string1,"halofit") != NULL) || (strstr(string1,"Halofit") != NULL) || (strstr(string1,"HALOFIT") != NULL)) {
      pfo->method=nl_halofit;
      ppt->has_nl_corrections_based_on_delta_m = _TRUE_;

      /* Compatibility code BEGIN */
      class_call(parser_read_double(pfc,"halofit_min_k_max",&param1,&flag1,errmsg),
                 errmsg,
                 errmsg);
      if (flag1 == _TRUE_) {
        ppr->nonlinear_min_k_max = MAX(ppr->nonlinear_min_k_max,param1);
      }
      /* Compatibility code END */
    }
    else if ((strstr(string1,"hmcode") != NULL) || (strstr(string1,"HMCODE") != NULL) || (strstr(string1,"HMcode") != NULL) || (strstr(string1,"Hmcode") != NULL)) {
      pfo->method=nl_HMcode;

      /* Compatibility code BEGIN */
      class_call(parser_read_double(pfc,"hmcode_min_k_max",&param1,&flag1,errmsg),
                 errmsg,
                 errmsg);
      if (flag1 == _TRUE_) {
        ppr->nonlinear_min_k_max = MAX(ppr->nonlinear_min_k_max,param1);
      }
      /* Compatibility code END */

      ppt->has_nl_corrections_based_on_delta_m = _TRUE_;
      class_read_int("extrapolation_method",pfo->extrapolation_method);

      class_call(parser_read_string(pfc,
                                    "feedback model",
                                    &(string1),
                                    &(flag1),
                                    errmsg),
                 errmsg,
                 errmsg);

      if (flag1 == _TRUE_) {

        if (strstr(string1,"emu_dmonly") != NULL) {
          pfo->feedback = nl_emu_dmonly;
        }
        if (strstr(string1,"owls_dmonly") != NULL) {
          pfo->feedback = nl_owls_dmonly;
        }
        if (strstr(string1,"owls_ref") != NULL) {
          pfo->feedback = nl_owls_ref;
        }
        if (strstr(string1,"owls_agn") != NULL) {
          pfo->feedback = nl_owls_agn;
        }
        if (strstr(string1,"owls_dblim") != NULL) {
          pfo->feedback = nl_owls_dblim;
        }
      }

      class_call(parser_read_double(pfc,"eta_0",&param2,&flag2,errmsg),
                 errmsg,
                 errmsg);
      class_call(parser_read_double(pfc,"c_min",&param3,&flag3,errmsg),
                 errmsg,
                 errmsg);

      class_test(((flag1 == _TRUE_) && ((flag2 == _TRUE_) || (flag3 == _TRUE_))),
                 errmsg,
                 "In input file, you cannot enter both a baryonic feedback model and a choice of baryonic feedback parameters, choose one of both methods");

      if ((flag2 == _TRUE_) && (flag3 == _TRUE_)) {
        pfo->feedback = nl_user_defined;
        class_read_double("eta_0", pfo->eta_0);
        class_read_double("c_min", pfo->c_min);
      }
      else if ((flag2 == _TRUE_) && (flag3 == _FALSE_)) {
        pfo->feedback = nl_user_defined;
        class_read_double("eta_0", pfo->eta_0);
        pfo->c_min = (0.98 - pfo->eta_0)/0.12;
      }
      else if ((flag2 == _FALSE_) && (flag3 == _TRUE_)) {
        pfo->feedback = nl_user_defined;
        class_read_double("c_min", pfo->c_min);
        pfo->eta_0 = 0.98 - 0.12*pfo->c_min;
      }

      class_read_double("z_infinity", pfo->z_infinity);
    }
    else if (strstr(string1,"no")!=NULL){
      pfo->method=nl_none;
      ppt->has_nl_corrections_based_on_delta_m = _FALSE_;
    }
    else {
      class_stop(errmsg,
                 "You specified 'non_linear' = '%s'. It has to be one of {'halofit','hmcode','none'}.",string1);
    }
  }

  /** - special steps if we want Halofit with wa_fld non-zero:
      so-called "Pk_equal method" of 0810.0190 and 1601.07230 */

  if (pfo->method == nl_halofit) {

    class_call(parser_read_string(pfc,"pk_eq",&string1,&flag1,errmsg),
               errmsg,
               errmsg);

    if ((flag1 == _TRUE_) && ((strstr(string1,"y") != NULL) || (strstr(string1,"Y") != NULL))) {

      if ((pba->Omega0_fld != 0.) && (pba->wa_fld != 0.)){

        pfo->has_pk_eq = _TRUE_;
      }
    }
  }

  return _SUCCESS_;
}


/**
 * Perform preliminary steps fur using the method called Pk_equal,
 * described in 0810.0190 and 1601.07230, extending the range of
 * validity of HALOFIT from constant w to (w0,wa) models. In that
 * case, one must compute here some effective values of w0_eff(z_i)
 * and Omega_m_eff(z_i), that will be interpolated later at arbitrary
 * redshift in the non-linear module.
 *
 * Returns table of values [z_i, tau_i, w0_eff_i, Omega_m_eff_i]
 * stored in fourier structure.
 *
 * @param ppr           Input: pointer to precision structure
 * @param pba           Input: pointer to background structure
 * @param pth           Input: pointer to thermodynamics structure
 * @param pfo           Input/Output: pointer to fourier structure
 * @param input_verbose Input: verbosity of this input module
 * @param errmsg        Input/Ouput: error message
 * @return the error status
 */

int input_prepare_pk_eq(struct precision * ppr,
                        struct background *pba,
                        struct thermodynamics *pth,
                        struct fourier *pfo,
                        int input_verbose,
                        ErrorMsg errmsg) {

  /** Summary: */

  /** Define local variables */
  double tau_of_z;
  double delta_tau;
  double error;
  double delta_tau_eq;
  double * pvecback;
  int last_index=0;
  int index_pk_eq_z;
  int index_eq;
  int true_background_verbose;
  int true_thermodynamics_verbose;
  int true_hyrec_verbose;
  double true_w0_fld;
  double true_wa_fld;
  double * z;

  /** Store the true cosmological parameters (w0, wa) somwhere before using temporarily some fake ones in this function */
  true_background_verbose = pba->background_verbose;
  true_thermodynamics_verbose = pth->thermodynamics_verbose;
  true_hyrec_verbose = pth->hyrec_verbose;
  true_w0_fld = pba->w0_fld;
  true_wa_fld = pba->wa_fld;

  /** The fake calls of the background and thermodynamics module will be done in non-verbose mode */
  pba->background_verbose = 0;
  pth->thermodynamics_verbose = 0;
  pth->hyrec_verbose = 0;

  /** Allocate indices and arrays for storing the results */
  pfo->pk_eq_tau_size = ppr->pk_eq_Nzlog;
  class_alloc(pfo->pk_eq_tau,
              pfo->pk_eq_tau_size*sizeof(double),
              errmsg);
  class_alloc(z,
              pfo->pk_eq_tau_size*sizeof(double),
              errmsg);

  index_eq = 0;
  class_define_index(pfo->index_pk_eq_w,_TRUE_,index_eq,1);
  class_define_index(pfo->index_pk_eq_Omega_m,_TRUE_,index_eq,1);
  pfo->pk_eq_size = index_eq;
  class_alloc(pfo->pk_eq_w_and_Omega,
              pfo->pk_eq_tau_size*pfo->pk_eq_size*sizeof(double),
              errmsg);
  class_alloc(pfo->pk_eq_ddw_and_ddOmega,
              pfo->pk_eq_tau_size*pfo->pk_eq_size*sizeof(double),
              errmsg);

  /** Call the background module in order to fill a table of tau_i[z_i] */
  class_call(background_init(ppr,pba), pba->error_message, errmsg);
  for (index_pk_eq_z=0; index_pk_eq_z<pfo->pk_eq_tau_size; index_pk_eq_z++) {
    z[index_pk_eq_z] = exp(log(1.+ppr->pk_eq_z_max)/(pfo->pk_eq_tau_size-1)*index_pk_eq_z)-1.;
    class_call(background_tau_of_z(pba,
                                   z[index_pk_eq_z],
                                   &tau_of_z),
               pba->error_message,
               errmsg);
    pfo->pk_eq_tau[index_pk_eq_z] = tau_of_z;
  }
  class_call(background_free_noinput(pba),
             pba->error_message,
             errmsg);

  /** Loop over z_i values. For each of them, we will call the
      background and thermodynamics module for fake models. The goal is
      to find, for each z_i, and effective w0_eff[z_i] and
      Omega_m_eff{z_i], such that: the true model with (w0,wa) and the
      equivalent model with (w0_eff[z_i],0) have the same conformal
      distance between z_i and z_recombination, namely chi = tau[z_i] -
      tau_rec. It is thus necessary to call both the background and
      thermodynamics module for each fake model and to re-compute
      tau_rec for each of them. Once the eqauivalent model is found we
      compute and store Omega_m_effa(z_i) of the equivalent model */
  for (index_pk_eq_z=0; index_pk_eq_z<pfo->pk_eq_tau_size; index_pk_eq_z++) {

    if (input_verbose > 2)
      printf("    * computing Pk_equal parameters at z=%e\n",z[index_pk_eq_z]);
    /* get chi = (tau[z_i] - tau_rec) in true model */
    pba->w0_fld = true_w0_fld;
    pba->wa_fld = true_wa_fld;
    class_call(background_init(ppr,pba),
               pba->error_message,
               errmsg);
    class_call(thermodynamics_init(ppr,pba,pth),
               pth->error_message,
               errmsg);
    delta_tau = pfo->pk_eq_tau[index_pk_eq_z] - pth->tau_rec;
    /* launch iterations in order to coverge to effective model with wa=0 but the same chi = (tau[z_i] - tau_rec) */
    pba->wa_fld=0.;

    do {
      class_call(background_free_noinput(pba),
                 pba->error_message,
                 errmsg);
      class_call(thermodynamics_free(pth),
                 pth->error_message,
                 errmsg);

      class_call(background_init(ppr,pba),
                 pba->error_message,
                 errmsg);
      class_call(background_tau_of_z(pba,
                                     z[index_pk_eq_z],
                                     &tau_of_z),
                 pba->error_message,
                 errmsg);
      class_call(thermodynamics_init(ppr,pba,pth),
                 pth->error_message,
                 errmsg);

      delta_tau_eq = tau_of_z - pth->tau_rec;

      error = 1.-delta_tau_eq/delta_tau;
      pba->w0_fld = pba->w0_fld*pow(1.+error,10.);

    }
    while(fabs(error) > ppr->pk_eq_tol);

    /* Equivalent model found. Store w0(z) in that model. Find Omega_m(z) in that model and store it. */
    pfo->pk_eq_w_and_Omega[pfo->pk_eq_size*index_pk_eq_z+pfo->index_pk_eq_w] = pba->w0_fld;
    class_alloc(pvecback,
                pba->bg_size*sizeof(double),
                pba->error_message);
    class_call(background_at_tau(pba,
                                 tau_of_z,
                                 long_info,
                                 inter_normal,
                                 &last_index,
                                 pvecback),
               pba->error_message, errmsg);
    pfo->pk_eq_w_and_Omega[pfo->pk_eq_size*index_pk_eq_z+pfo->index_pk_eq_Omega_m] = pvecback[pba->index_bg_Omega_m];
    free(pvecback);

    class_call(background_free_noinput(pba),
               pba->error_message,
               errmsg);
    class_call(thermodynamics_free(pth),
               pth->error_message,
               errmsg);
  }

  /** Restore cosmological parameters (w0, wa) to their true values before main call to CLASS modules */
  pba->background_verbose = true_background_verbose;
  pth->thermodynamics_verbose = true_thermodynamics_verbose;
  pth->hyrec_verbose = true_hyrec_verbose;

  pba->w0_fld = true_w0_fld;
  pba->wa_fld = true_wa_fld;

  /* in verbose mode, report the results */

  if (input_verbose > 1) {
    fprintf(stdout,"    Effective parameters for Pk_equal:\n");

    for (index_pk_eq_z=0; index_pk_eq_z<pfo->pk_eq_tau_size; index_pk_eq_z++) {
      fprintf(stdout,"    * at z=%e, tau=%e w=%e Omega_m=%e\n",
              z[index_pk_eq_z],
              pfo->pk_eq_tau[index_pk_eq_z],
              pfo->pk_eq_w_and_Omega[pfo->pk_eq_size*index_pk_eq_z+pfo->index_pk_eq_w],
              pfo->pk_eq_w_and_Omega[pfo->pk_eq_size*index_pk_eq_z+pfo->index_pk_eq_Omega_m]);
    }
  }
  free(z);

  /** Spline the table for later interpolation */
  class_call(array_spline_table_lines(pfo->pk_eq_tau,
                                      pfo->pk_eq_tau_size,
                                      pfo->pk_eq_w_and_Omega,
                                      pfo->pk_eq_size,
                                      pfo->pk_eq_ddw_and_ddOmega,
                                      _SPLINE_NATURAL_,
                                      errmsg),
             errmsg,
             errmsg);

  return _SUCCESS_;

}


/**
 * Read the parameters of primordial structure.
 *
 * @param pfc     Input: pointer to local structure
 * @param ppt     Input: pointer to perturbations structure
 * @param ppm     Input: pointer to primordial structure
 * @param errmsg  Input: Error message
 * @return the error status
 */

int input_read_parameters_primordial(struct file_content * pfc,
                                     struct perturbations * ppt,
                                     struct primordial * ppm,
                                     ErrorMsg errmsg){

  /** Summary: */

  /** Define local variables */
  int flag1, flag2, flag3;
  double param1, param2, param3;
  char string1[_ARGUMENT_LENGTH_MAX_];
  char string2[_ARGUMENT_LENGTH_MAX_];
  double R0,R1,R2,R3,R4;
  double PSR0,PSR1,PSR2,PSR3,PSR4;
  double HSR0,HSR1,HSR2,HSR3,HSR4;
  double k1=0.;
  double k2=0.;
  double prr1=0.;
  double prr2=0.;
  double pii1=0.;
  double pii2=0.;
  double pri1=0.;
  double pri2=0.;
  double n_iso=0.;
  double f_iso=0.;
  double n_cor=0.;
  double c_cor=0.;

  /** 1) Primordial spectrum type */
  /* Read */
  class_call(parser_read_string(pfc,"Pk_ini_type",&string1,&flag1,errmsg),
             errmsg,
             errmsg);
  /* Compatibility code BEGIN */
  if (flag1 == _FALSE_){
    class_call(parser_read_string(pfc,"P_k_ini type",&string1,&flag1,errmsg),
               errmsg,
               errmsg);
  }
  /* Compatibility code END */
  /* Complete set of parameters */
  if (flag1 == _TRUE_) {
    if (strcmp(string1,"analytic_Pk") == 0){
      ppm->primordial_spec_type = analytic_Pk;
    }
    else if (strcmp(string1,"inflation_V") == 0){
      ppm->primordial_spec_type = inflation_V;
    }
    else if (strcmp(string1,"inflation_H") == 0){
      ppm->primordial_spec_type = inflation_H;
    }
    else if (strcmp(string1,"inflation_V_end") == 0){
      ppm->primordial_spec_type = inflation_V_end;
    }
    else if (strcmp(string1,"two_scales") == 0){
      ppm->primordial_spec_type = two_scales;
    }
    else if (strcmp(string1,"external_Pk") == 0){
      ppm->primordial_spec_type = external_Pk;
    }
    else{
      class_stop(errmsg,
                 "You specified 'P_k_ini_type' as '%s'. It has to be one of {'analytic_Pk','inflation_V','inflation_V_end','two_scales','external_Pk'}.",string1);
    }
  }

  /** 1.a) Pivot scale in Mpc-1 */
  /* Read */
  class_read_double("k_pivot",ppm->k_pivot);

  /** 1.b) For type 'analytic_Pk' */
  if (ppm->primordial_spec_type == analytic_Pk) {

    /** 1.b.1) For scalar perturbations */
    if (ppt->has_scalars == _TRUE_) {
      /* Read */
      class_call(parser_read_double(pfc,"A_s",&param1,&flag1,errmsg),
                 errmsg,
                 errmsg);
      class_call(parser_read_double(pfc,"ln_A_s_1e10",&param2,&flag2,errmsg),
                 errmsg,
                 errmsg);
      /* Deprecated input parameters, read for backwards compatibility) */
      class_call(parser_read_double(pfc,"ln10^{10}A_s",&param3,&flag3,errmsg),
                 errmsg,
                 errmsg);
      class_test(class_at_least_two_of_three(flag1,flag2,flag3),
                 errmsg,
                 "In input file, you can only enter one of {'A_s', 'ln_A_s_1e10', or 'ln10^{10}A_s' (deprecated)}, choose one");
      /* Complete set of parameters */
      if (flag1 == _TRUE_){
        ppm->A_s = param1;
      }
      else if (flag2 == _TRUE_){
        ppm->A_s = exp(param2)*1.e-10;
      }
      else if (flag3 == _TRUE_){
        ppm->A_s = exp(param3)*1.e-10;
      }

      /** 1.b.1.1) Adiabatic perturbations */
      if (ppt->has_ad == _TRUE_) {
        /* Read */
        class_read_double("n_s",ppm->n_s);
        class_read_double("alpha_s",ppm->alpha_s);
      }

      /** 1.b.1.2) Isocurvature/entropy perturbations */
      /* Read */
      if (ppt->has_bi == _TRUE_) {
        class_read_double("f_bi",ppm->f_bi);
        class_read_double("n_bi",ppm->n_bi);
        class_read_double("alpha_bi",ppm->alpha_bi);
      }
      if (ppt->has_cdi == _TRUE_) {
        class_read_double("f_cdi",ppm->f_cdi);
        class_read_double("n_cdi",ppm->n_cdi);
        class_read_double("alpha_cdi",ppm->alpha_cdi);
      }
      if (ppt->has_nid == _TRUE_) {
        class_read_double("f_nid",ppm->f_nid);
        class_read_double("n_nid",ppm->n_nid);
        class_read_double("alpha_nid",ppm->alpha_nid);
      }
      if (ppt->has_niv == _TRUE_) {
        class_read_double("f_niv",ppm->f_niv);
        class_read_double("n_niv",ppm->n_niv);
        class_read_double("alpha_niv",ppm->alpha_niv);
      }

      /** 1.b.1.3) Cross-correlation between different adiabatic/entropy mode */
      /* Read */
      if ((ppt->has_ad == _TRUE_) && (ppt->has_bi == _TRUE_)) {
        class_read_double_one_of_two("c_ad_bi","c_bi_ad",ppm->c_ad_bi);
        class_read_double_one_of_two("n_ad_bi","n_bi_ad",ppm->n_ad_bi);
        class_read_double_one_of_two("alpha_ad_bi","alpha_bi_ad",ppm->alpha_ad_bi);
      }
      if ((ppt->has_ad == _TRUE_) && (ppt->has_cdi == _TRUE_)) {
        class_read_double_one_of_two("c_ad_cdi","c_cdi_ad",ppm->c_ad_cdi);
        class_read_double_one_of_two("n_ad_cdi","n_cdi_ad",ppm->n_ad_cdi);
        class_read_double_one_of_two("alpha_ad_cdi","alpha_cdi_ad",ppm->alpha_ad_cdi);
      }
      if ((ppt->has_ad == _TRUE_) && (ppt->has_nid == _TRUE_)) {
        class_read_double_one_of_two("c_ad_nid","c_nid_ad",ppm->c_ad_nid);
        class_read_double_one_of_two("n_ad_nid","n_nid_ad",ppm->n_ad_nid);
        class_read_double_one_of_two("alpha_ad_nid","alpha_nid_ad",ppm->alpha_ad_nid);
      }
      if ((ppt->has_ad == _TRUE_) && (ppt->has_niv == _TRUE_)) {
        class_read_double_one_of_two("c_ad_niv","c_niv_ad",ppm->c_ad_niv);
        class_read_double_one_of_two("n_ad_niv","n_niv_ad",ppm->n_ad_niv);
        class_read_double_one_of_two("alpha_ad_niv","alpha_niv_ad",ppm->alpha_ad_niv);
      }
      if ((ppt->has_bi == _TRUE_) && (ppt->has_cdi == _TRUE_)) {
        class_read_double_one_of_two("c_bi_cdi","c_cdi_bi",ppm->c_bi_cdi);
        class_read_double_one_of_two("n_bi_cdi","n_cdi_bi",ppm->n_bi_cdi);
        class_read_double_one_of_two("alpha_bi_cdi","alpha_cdi_bi",ppm->alpha_bi_cdi);
      }
      if ((ppt->has_bi == _TRUE_) && (ppt->has_nid == _TRUE_)) {
        class_read_double_one_of_two("c_bi_nid","c_nid_bi",ppm->c_bi_nid);
        class_read_double_one_of_two("n_bi_nid","n_nid_bi",ppm->n_bi_nid);
        class_read_double_one_of_two("alpha_bi_nid","alpha_nid_bi",ppm->alpha_bi_nid);
      }
      if ((ppt->has_bi == _TRUE_) && (ppt->has_niv == _TRUE_)) {
        class_read_double_one_of_two("c_bi_niv","c_niv_bi",ppm->c_bi_niv);
        class_read_double_one_of_two("n_bi_niv","n_niv_bi",ppm->n_bi_niv);
        class_read_double_one_of_two("alpha_bi_niv","alpha_niv_bi",ppm->alpha_bi_niv);
      }
      if ((ppt->has_cdi == _TRUE_) && (ppt->has_nid == _TRUE_)) {
        class_read_double_one_of_two("c_cdi_nid","c_nid_cdi",ppm->c_cdi_nid);
        class_read_double_one_of_two("n_cdi_nid","n_nid_cdi",ppm->n_cdi_nid);
        class_read_double_one_of_two("alpha_cdi_nid","alpha_nid_cdi",ppm->alpha_cdi_nid);
      }
      if ((ppt->has_cdi == _TRUE_) && (ppt->has_niv == _TRUE_)) {
        class_read_double_one_of_two("c_cdi_niv","c_niv_cdi",ppm->c_cdi_niv);
        class_read_double_one_of_two("n_cdi_niv","n_niv_cdi",ppm->n_cdi_niv);
        class_read_double_one_of_two("alpha_cdi_niv","alpha_niv_cdi",ppm->alpha_cdi_niv);
      }
      if ((ppt->has_nid == _TRUE_) && (ppt->has_niv == _TRUE_)) {
        class_read_double_one_of_two("c_nid_niv","c_niv_nid",ppm->c_nid_niv);
        class_read_double_one_of_two("n_nid_niv","n_niv_nid",ppm->n_nid_niv);
        class_read_double_one_of_two("alpha_nid_niv","alpha_niv_nid",ppm->alpha_nid_niv);
      }
    }

    /** 1.b.2) For tensor perturbations */
    if (ppt->has_tensors == _TRUE_){
      /* Read */
      class_read_double("r",ppm->r);
      if (ppt->has_scalars == _FALSE_){
        class_read_double("A_s",ppm->A_s);
      }
      if (ppm->r <= 0) {
        ppt->has_tensors = _FALSE_;
      }
      else {
        class_call(parser_read_string(pfc,"n_t",&string1,&flag1,errmsg),
                   errmsg,
                   errmsg);
        class_call(parser_read_string(pfc,"alpha_t",&string2,&flag2,errmsg),
                   errmsg,
                   errmsg);
        /* Complete set of parameters */
        if ((flag1 == _TRUE_) && !((strstr(string1,"SCC") != NULL) || (strstr(string1,"scc") != NULL))){
          class_read_double("n_t",ppm->n_t);
        }
        else {
          ppm->n_t = -ppm->r/8.*(2.-ppm->r/8.-ppm->n_s);        // enforce single slow-roll self-consistency condition (order 2 in slow-roll)
        }
        if ((flag2 == _TRUE_) && !((strstr(string2,"SCC") != NULL) || (strstr(string2,"scc") != NULL))) {
          class_read_double("alpha_t",ppm->alpha_t);
        }
        else {
          ppm->alpha_t = ppm->r/8.*(ppm->r/8.+ppm->n_s-1.);     // enforce single slow-roll self-consistency condition (order 2 in slow-roll)
        }
      }
    }
  }

  else if ((ppm->primordial_spec_type == inflation_V) || (ppm->primordial_spec_type == inflation_H)) {

    /** 1.c) For type 'inflation_V' */
    if (ppm->primordial_spec_type == inflation_V) {

      /** 1.c.1) Type of potential */
      /* Read */
      class_call(parser_read_string(pfc,"potential",&string1,&flag1,errmsg),    // only polynomial coded so far:
                 errmsg,                                                        // no need to interpret string1
                 errmsg);

      /** 1.c.2) Coefficients of the Taylor expansion */
      /* Read */
      class_call(parser_read_string(pfc,"PSR_0",&string1,&flag1,errmsg),
                 errmsg,
                 errmsg);
      if (flag1 == _TRUE_){
        PSR0=0.;
        PSR1=0.;
        PSR2=0.;
        PSR3=0.;
        PSR4=0.;
        class_read_double("PSR_0",PSR0);
        class_read_double("PSR_1",PSR1);
        class_read_double("PSR_2",PSR2);
        class_read_double("PSR_3",PSR3);
        class_read_double("PSR_4",PSR4);
        /* Test */
        class_test(PSR0 <= 0.,
                   errmsg,
                   "inconsistent parametrization of polynomial inflation potential");
        class_test(PSR1 <= 0.,
                   errmsg,
                   "inconsistent parametrization of polynomial inflation potential");
        /* Complete set of parameters */
        R0 = PSR0;
        R1 = PSR1*16.*_PI_;
        R2 = PSR2*8.*_PI_;
        R3 = PSR3*pow(8.*_PI_,2);
        R4 = PSR4*pow(8.*_PI_,3);
        ppm->V0 = R0*R1*3./128./_PI_;
        ppm->V1 = -sqrt(R1)*ppm->V0;
        ppm->V2 = R2*ppm->V0;
        ppm->V3 = R3*ppm->V0*ppm->V0/ppm->V1;
        ppm->V4 = R4*ppm->V0/R1;
      }
      else {
        /* Read */
        class_call(parser_read_string(pfc,"R_0",&string1,&flag1,errmsg),
                   errmsg,
                   errmsg);
        if (flag1 == _TRUE_) {
          R0=0.;
          R1=0.;
          R2=0.;
          R3=0.;
          R4=0.;
          class_read_double("R_0",R0);
          class_read_double("R_1",R1);
          class_read_double("R_2",R2);
          class_read_double("R_3",R3);
          class_read_double("R_4",R4);
          /* Test */
          class_test(R0 <= 0.,
                     errmsg,
                     "inconsistent parametrization of polynomial inflation potential");
          class_test(R1 <= 0.,
                     errmsg,
                     "inconsistent parametrization of polynomial inflation potential");
          /* Complete set of parameters */
          ppm->V0 = R0*R1*3./128./_PI_;
          ppm->V1 = -sqrt(R1)*ppm->V0;
          ppm->V2 = R2*ppm->V0;
          ppm->V3 = R3*ppm->V0*ppm->V0/ppm->V1;
          ppm->V4 = R4*ppm->V0/R1;
        }
        else {
          /* Read */
          class_read_double("V_0",ppm->V0);
          class_read_double("V_1",ppm->V1);
          class_read_double("V_2",ppm->V2);
          class_read_double("V_3",ppm->V3);
          class_read_double("V_4",ppm->V4);
        }
      }
    }

    /** 1.d) For type 'inflation_H' */
    else {
      /* Read */
      class_call(parser_read_string(pfc,"HSR_0",&string1,&flag1,errmsg),
                 errmsg,
                 errmsg);
      if (flag1 == _TRUE_) {
        HSR0=0.;
        HSR1=0.;
        HSR2=0.;
        HSR3=0.;
        HSR4=0.;
        class_read_double("HSR_0",HSR0);
        class_read_double("HSR_1",HSR1);
        class_read_double("HSR_2",HSR2);
        class_read_double("HSR_3",HSR3);
        class_read_double("HSR_4",HSR4);
        /* Complete set of parameters */
        ppm->H0 = sqrt(HSR0*HSR1*_PI_);
        ppm->H1 = -sqrt(4.*_PI_*HSR1)*ppm->H0;
        ppm->H2 = 4.*_PI_*HSR2*ppm->H0;
        ppm->H3 = 4.*_PI_*HSR3*ppm->H0*ppm->H0/ppm->H1;
        ppm->H4 = 4.*_PI_*HSR4*ppm->H0*ppm->H0*ppm->H0/ppm->H1/ppm->H1;

      }
      else {
        /* Read */
        class_read_double("H_0",ppm->H0);
        class_read_double("H_1",ppm->H1);
        class_read_double("H_2",ppm->H2);
        class_read_double("H_3",ppm->H3);
        class_read_double("H_4",ppm->H4);
      }
      /* Test */
      class_test(ppm->H0 <= 0.,
                 errmsg,
                 "inconsistent parametrization of polynomial inflation potential");
    }
  }

  /** 1.e) For type 'inflation_V_end' */
  else if (ppm->primordial_spec_type == inflation_V_end) {

    /** 1.e.1) Value of the field at the minimum of the potential */
    /* Read */
    class_read_double("phi_end",ppm->phi_end);

    /** 1.e.2) Shape of the potential */
    /* Read */
    class_call(parser_read_string(pfc,"full_potential",&string1,&flag1,errmsg),
               errmsg,
               errmsg);
    /* Complete set of parameters */
    if (flag1 == _TRUE_) {
      if (strcmp(string1,"polynomial") == 0){
        ppm->potential = polynomial;
      }
      else if (strcmp(string1,"higgs_inflation") == 0){
        ppm->potential = higgs_inflation;
      }
      else{
        class_stop(errmsg,"You specified 'full_potential' as '%s'. It has to be one of {'polynomial','higgs_inflation'}.",string1);
      }
    }

    /** 1.e.3) Parameters of the potential */
    /* Read */
    class_read_double("Vparam0",ppm->V0);
    class_read_double("Vparam1",ppm->V1);
    class_read_double("Vparam2",ppm->V2);
    class_read_double("Vparam3",ppm->V3);
    class_read_double("Vparam4",ppm->V4);

    /** 1.e.4) How much the scale factor a or the product (aH) increases between
        Hubble crossing for the pivot scale (during inflation) and the
        end of inflation */
    /* Read */
    class_call(parser_read_string(pfc,"ln_aH_ratio",&string1,&flag1,errmsg),
               errmsg,
               errmsg);
    class_call(parser_read_string(pfc,"N_star",&string2,&flag2,errmsg),
               errmsg,
               errmsg);
    /* Test */
    class_test((flag1 == _TRUE_) && (flag2 == _TRUE_),
               errmsg,
               "You can only enter one of 'ln_aH_ratio' or 'N_star'.");
    /* Complete set of parameters */
    if (flag1 == _TRUE_) {
      if ((strstr(string1,"auto") != NULL) || (strstr(string1,"AUTO") != NULL)){
        ppm->phi_pivot_method = ln_aH_ratio_auto;
      }
      else {
        ppm->phi_pivot_method = ln_aH_ratio;
        class_read_double("ln_aH_ratio",ppm->phi_pivot_target);
      }
    }
    if (flag2 == _TRUE_) {
      ppm->phi_pivot_method = N_star;
      class_read_double("N_star",ppm->phi_pivot_target);
    }

    /** 1.e.5) Should the inflation module do its nomral job of numerical
        integration ('numerical') or use analytical slow-roll formulas
        to infer the primordial spectrum from the potential
        ('analytical')? */
    /* Read */
    class_call(parser_read_string(pfc,"inflation_behavior",&string1,&flag1,errmsg),
               errmsg,
               errmsg);
    /* Complete set of parameters */
    if (flag1 == _TRUE_) {
      if (strstr(string1,"numerical") != NULL){
        ppm->behavior = numerical;
      }
      else if (strstr(string1,"analytical") != NULL){
        ppm->behavior = analytical;
      }
      else{
        class_stop(errmsg,"You specified 'inflation_behavior' as '%s'. It has to be one of {'numerical','analytical'}.",string1);
      }
    }
  }

  /** 1.f) For type 'two_scales' */
  else if (ppm->primordial_spec_type == two_scales) {

    /** 1.f.1) Wavenumbers */
    /* Read */
    class_read_double("k1",k1);
    class_read_double("k2",k2);
    /* Test */
    class_test(k1<=0.,errmsg,"enter strictly positive scale k1");
    class_test(k2<=0.,errmsg,"enter strictly positive scale k2");

    if (ppt->has_scalars == _TRUE_){

      /** 1.f.2) Amplitudes for the adiabatic primordial spectrum */
      /* Read */
      class_read_double("P_{RR}^1",prr1);
      class_read_double("P_{RR}^2",prr2);
      /* Test */
      class_test(prr1<=0.,errmsg,"enter strictly positive scale P_{RR}^1");
      class_test(prr2<=0.,errmsg,"enter strictly positive scale P_{RR}^2");
      /* Complete set of parameters */
      ppm->n_s = log(prr2/prr1)/log(k2/k1)+1.;
      ppm->A_s = prr1*exp((ppm->n_s-1.)*log(ppm->k_pivot/k1));

      /** 1.f.3) Isocurvature amplitudes */
      if ((ppt->has_bi == _TRUE_) || (ppt->has_cdi == _TRUE_) || (ppt->has_nid == _TRUE_) || (ppt->has_niv == _TRUE_)){
        /* Read */
        class_read_double("P_{II}^1",pii1);
        class_read_double("P_{II}^2",pii2);
        class_read_double("P_{RI}^1",pri1);
        class_read_double("|P_{RI}^2|",pri2);
        /* Test */
        class_test(pii1 <= 0.,
                   errmsg,
                   "since you request iso modes, you should have P_{ii}^1 strictly positive");
        class_test(pii2 < 0.,
                   errmsg,
                   "since you request iso modes, you should have P_{ii}^2 positive or eventually null");
        class_test(pri2 < 0.,
                   errmsg,
                   "by definition, you should have |P_{ri}^2| positive or eventually null");


        /** 1.f.4) Uncorrelated or anti-correlated? */
        /* Read */
        class_call(parser_read_string(pfc,"special iso",&string1,&flag1,errmsg),
                   errmsg,
                   errmsg);
        /* Complete set of parameters */
        if ((flag1 == _TRUE_) && (strstr(string1,"axion") != NULL)){    // Axion case, only one iso parameter: piir1
          n_iso = 1.;
          n_cor = 0.;
          c_cor = 0.;
        }
        else if ((flag1 == _TRUE_) && (strstr(string1,"anticurvaton") != NULL)){      // Curvaton case, only one iso parameter: piir1
          n_iso = ppm->n_s;
          n_cor = 0.;
          c_cor = 1.;
        }
        else if ((flag1 == _TRUE_) && (strstr(string1,"curvaton") != NULL)){      // inverted-correlation-curvaton case, only one iso parameter: piir1
          n_iso = ppm->n_s;
          n_cor = 0.;
          c_cor = -1.;
        }
        else{          // general case, but if pii2 or pri2=0, the code interprets it as a request for n_iso=n_ad or n_cor=0 respectively
          if (pii2 == 0.){
            n_iso = ppm->n_s;
          }
          else{
            class_test((pii1==0.) || (pii2 == 0.) || (pii1*pii2<0.),errmsg,"should NEVER happen");
            n_iso = log(pii2/pii1)/log(k2/k1)+1.;
          }
          class_test(pri1==0,errmsg,"the general isocurvature case requires a non-zero P_{RI}^1");
          if (pri2 == 0.){
            n_cor = 0.;
          }
          else{
            class_test((pri1==0.) || (pri2 <= 0.) || (pii1*pii2<0),errmsg,"should NEVER happen");
            n_cor = log(pri2/fabs(pri1))/log(k2/k1)-0.5*(ppm->n_s+n_iso-2.);
          }
          c_cor = -pri1/sqrt(pii1*prr1)*exp(n_cor*log(ppm->k_pivot/k1));
          /* Test */
          class_test((pii1*prr1<=0.),errmsg,"should NEVER happen");
          class_test(fabs(pri1)/sqrt(pii1*prr1)>1,errmsg,"too large ad-iso cross-correlation in k1");
          class_test(fabs(pri1)/sqrt(pii1*prr1)*exp(n_cor*log(k2/k1))>1,errmsg,"too large ad-iso cross-correlation in k2");
        }
        /* Complete set of parameters */
        class_test((pii1==0.) || (prr1 == 0.) || (pii1*prr1<0.),errmsg,"should NEVER happen");
        f_iso = sqrt(pii1/prr1)*exp(0.5*(n_iso-ppm->n_s)*log(ppm->k_pivot/k1));
      }
      if (ppt->has_bi == _TRUE_){
        ppm->f_bi = f_iso;
        ppm->n_bi = n_iso;
        ppm->c_ad_bi = c_cor;
        ppm->n_ad_bi = n_cor;
      }
      if (ppt->has_cdi == _TRUE_){
        ppm->f_cdi = f_iso;
        ppm->n_cdi = n_iso;
        ppm->c_ad_cdi = c_cor;
        ppm->n_ad_cdi = n_cor;
      }
      if (ppt->has_nid == _TRUE_){
        ppm->f_nid = f_iso;
        ppm->n_nid = n_iso;
        ppm->c_ad_nid = c_cor;
        ppm->n_ad_nid = n_cor;
      }
      if (ppt->has_niv == _TRUE_){
        ppm->f_niv = f_iso;
        ppm->n_niv = n_iso;
        ppm->c_ad_niv = c_cor;
        ppm->n_ad_niv = n_cor;
      }
    }
    ppm->primordial_spec_type = analytic_Pk;
  }

  /** 1.g) For type 'external_Pk' */
  else if (ppm->primordial_spec_type == external_Pk){

    /** 1.g.1) Command generating the table */
    /* Read */
    class_call(parser_read_string(pfc, "command", &string1, &flag1, errmsg),
               errmsg, errmsg);
    /* Test */
    class_test(strlen(string1) == 0,
               errmsg,
               "You omitted to write a command for the external Pk");
    /* Complete set of parameters */
    ppm->command = (char *) malloc (strlen(string1) + 1);
    strcpy(ppm->command, string1);

    /** 1.g.2) Command generating the table */
    /* Read */
    class_read_double("custom1",ppm->custom1);
    class_read_double("custom2",ppm->custom2);
    class_read_double("custom3",ppm->custom3);
    class_read_double("custom4",ppm->custom4);
    class_read_double("custom5",ppm->custom5);
    class_read_double("custom6",ppm->custom6);
    class_read_double("custom7",ppm->custom7);
    class_read_double("custom8",ppm->custom8);
    class_read_double("custom9",ppm->custom9);
    class_read_double("custom10",ppm->custom10);
  }

  /* Final tests */
  if ((ppm->primordial_spec_type == inflation_V) || (ppm->primordial_spec_type == inflation_H) || (ppm->primordial_spec_type == inflation_V_end)) {
    class_test(ppt->has_scalars == _FALSE_,
               errmsg,
               "inflationary module cannot work if you do not ask for scalar modes");
    class_test(ppt->has_vectors == _TRUE_,
               errmsg,
               "inflationary module cannot work if you ask for vector modes");
    class_test(ppt->has_tensors == _FALSE_,
               errmsg,
               "inflationary module cannot work if you do not ask for tensor modes");
    class_test(ppt->has_bi == _TRUE_ || ppt->has_cdi == _TRUE_ || ppt->has_nid == _TRUE_ || ppt->has_niv == _TRUE_,
               errmsg,
               "inflationary module cannot work if you ask for isocurvature modes");
  }

  return _SUCCESS_;

}


/**
 * Read the parameters of harmonic structure.
 *
 * @param pfc     Input: pointer to local structure
 * @param ppr     Input: pointer to precision structure
 * @param pba     Input: pointer to background structure
 * @param ppm     Input: pointer to primordial structure
 * @param ppt     Input: pointer to perturbations structure
 * @param ptr     Input: pointer to transfer structure
 * @param phr     Input: pointer to harmonic structure
 * @param pop     Input: pointer to output structure
 * @param errmsg  Input: Error message
 * @return the error status
 */

int input_read_parameters_spectra(struct file_content * pfc,
                                  struct precision * ppr,
                                  struct background * pba,
                                  struct primordial * ppm,
                                  struct perturbations * ppt,
                                  struct transfer * ptr,
                                  struct harmonic *phr,
                                  struct output * pop,
                                  ErrorMsg errmsg){

  /** Summary: */

  /** Define local variables */
  int flag1, flag2;
  double param1, param2;
  char string1[_ARGUMENT_LENGTH_MAX_];
  int int1;
  double * pointer1;
  int i;
  double z_max=0.;
  int bin;

  /** 1) Maximum l for CLs */
  /* Read */
  if (ppt->has_cls == _TRUE_) {
    if (ppt->has_scalars == _TRUE_) {
      if ((ppt->has_cl_cmb_temperature == _TRUE_) || (ppt->has_cl_cmb_polarization == _TRUE_) || (ppt->has_cl_cmb_lensing_potential == _TRUE_)){
        class_read_double("l_max_scalars",ppt->l_scalar_max);
      }
      if ((ppt->has_cl_lensing_potential == _TRUE_) || (ppt->has_cl_number_count == _TRUE_)){
        class_read_double("l_max_lss",ppt->l_lss_max);
      }
    }
    if (ppt->has_vectors == _TRUE_){
      class_read_double("l_max_vectors",ppt->l_vector_max);
    }
    if (ppt->has_tensors == _TRUE_) {
      class_read_double("l_max_tensors",ppt->l_tensor_max);
    }
  }


  /** 2) Parameters for the the matter density number count */
  if ((ppt->has_cl_number_count == _TRUE_) || (ppt->has_cl_lensing_potential == _TRUE_)) {

    /** 2.a) Selection functions W(z) of each redshift bin */
    /* Read */
    class_call(parser_read_string(pfc,"selection",&string1,&flag1,errmsg),
               errmsg,
               errmsg);
    /* Complete set of parameters */
    if (flag1 == _TRUE_) {
      if (strstr(string1,"gaussian") != NULL){
        ppt->selection=gaussian;
      }
      else if (strstr(string1,"tophat") != NULL){
        ppt->selection=tophat;
      }
      else if (strstr(string1,"dirac") != NULL){
        ppt->selection=dirac;
      }
      else {
        class_stop(errmsg,"You specified 'selection' as '%s'. It has to be one of {'gaussian','tophat','dirac'}.",string1);
      }
    }

    /* Read */
    class_call(parser_read_list_of_doubles(pfc,"selection_mean",&(int1),&(pointer1),&flag1,errmsg),
               errmsg,
               errmsg);
    if ((flag1 == _TRUE_) && (int1>0)) {
      /* Test */
      class_test(int1 > _SELECTION_NUM_MAX_,errmsg,
                 "you want to compute density Cl's for %d different bins, hence you should increase _SELECTION_NUM_MAX_ in include/perturbations.h to at least this number.",int1);
      /* Complete set of parameters */
      ppt->selection_num = int1;
      for (i=0; i<int1; i++) {
        /* Test */
        class_test((pointer1[i] < 0.) || (pointer1[i] > 1000.),errmsg,
                   "input of selection functions: you asked for a mean redshift equal to %e, is this a mistake?",pointer1[i]);
        /* Complete set of parameters */
        ppt->selection_mean[i] = pointer1[i];
      }
      free(pointer1);
      for (i=1; i<int1; i++) {       // first set all widths to default; correct eventually later
        /* Test */
        class_test(ppt->selection_mean[i]<=ppt->selection_mean[i-1],
                   errmsg,
                   "input of selection functions: the list of mean redshifts must be passed in growing order; you entered %e before %e.",ppt->selection_mean[i-1],ppt->selection_mean[i]);
        /* Complete set of parameters */
        ppt->selection_width[i] = ppt->selection_width[0];
        ptr->selection_bias[i] = ptr->selection_bias[0];
        ptr->selection_magnification_bias[i] = ptr->selection_magnification_bias[0];
      }

      /* Read */
      class_call(parser_read_list_of_doubles(pfc,"selection_width",&int1,&pointer1,&flag1,errmsg),
                 errmsg,
                 errmsg);
      /* Complete set of parameters */
      if ((flag1 == _TRUE_) && (int1>0)) {
        if (int1==1) {
          for (i=0; i<ppt->selection_num; i++) {
            ppt->selection_width[i] = pointer1[0];
          }
        }
        else if (int1==ppt->selection_num) {
          for (i=0; i<int1; i++) {
            ppt->selection_width[i] = pointer1[i];
          }
        }
        else {
          class_stop(errmsg,
                     "In input for selection function, you asked for %d bin centers and %d bin widths; number of bins unclear; you should pass either one bin width (common to all bins) or %d bin widths.",ppt->selection_num,int1,ppt->selection_num);
        }
        free(pointer1);
      }

      /* Read */
      class_call(parser_read_list_of_doubles(pfc,"selection_bias",&int1,&pointer1,&flag1,errmsg),
                 errmsg,
                 errmsg);
      /* Complete set of parameters */
      if ((flag1 == _TRUE_) && (int1>0)) {
        if (int1==1) {
          for (i=0; i<ppt->selection_num; i++) {
            ptr->selection_bias[i] = pointer1[0];
          }
        }
        else if (int1==ppt->selection_num) {
          for (i=0; i<int1; i++) {
            ptr->selection_bias[i] = pointer1[i];
          }
        }
        else {
          class_stop(errmsg,
                     "In input for selection function, you asked for %d bin centers and %d bin biases; number of bins unclear; you should pass either one bin bias (common to all bins) or %d bin biases.",
                     ppt->selection_num,int1,ppt->selection_num);
        }
        free(pointer1);
      }

      /* Read */
      class_call(parser_read_list_of_doubles(pfc,"selection_magnification_bias",&int1,&pointer1,&flag1,errmsg),
                 errmsg,
                 errmsg);
      /* Complete set of parameters */
      if ((flag1 == _TRUE_) && (int1>0)) {
        if (int1==1) {
          for (i=0; i<ppt->selection_num; i++) {
            ptr->selection_magnification_bias[i] = pointer1[0];
          }
        }
        else if (int1==ppt->selection_num) {
          for (i=0; i<int1; i++) {
            ptr->selection_magnification_bias[i] = pointer1[i];
          }
        }
        else {
          class_stop(errmsg,
                     "In input for selection function, you asked for %d bin centers and %d bin biases; number of bins unclear; you should pass either one bin bias (common to all bins) or %d bin biases.",
                     ppt->selection_num,int1,ppt->selection_num);
        }
        free(pointer1);
      }
    }

    /* Read */
    if (ppt->selection_num > 1) {
      class_read_int("non_diagonal",phr->non_diag);
      if ((phr->non_diag<0) || (phr->non_diag>=ppt->selection_num))
        class_stop(errmsg,"Input for non_diagonal is %d, while it is expected to be between 0 and %d\n",
                   phr->non_diag,ppt->selection_num-1);
    }

    /** 2.b) Selection function */
    /* Read */
    class_call(parser_read_string(pfc,"dNdz_selection",&string1,&flag1,errmsg),
               errmsg,
               errmsg);
    /* Complete set of parameters */
    if (flag1 == _TRUE_) {
      if ((strstr(string1,"analytic") != NULL)){
        ptr->has_nz_analytic = _TRUE_;
      }
      else{
        ptr->has_nz_file = _TRUE_;
        class_read_string("dNdz_selection",ptr->nz_file_name);
      }
    }

    /** 2.c) Source number counts evolution */
    class_call(parser_read_string(pfc,"dNdz_evolution",&string1,&flag1,errmsg),
               errmsg,
               errmsg);
    /* Complete set of parameters */
    if (flag1 == _TRUE_) {
      if ((strstr(string1,"analytic") != NULL)){
        ptr->has_nz_evo_analytic = _TRUE_;
      }
      else{
        ptr->has_nz_evo_file = _TRUE_;
        class_read_string("dNdz_evolution",ptr->nz_evo_file_name);
      }
    }

  }


  /** 3) Power spectrum P(k) */
  if ((ppt->has_pk_matter == _TRUE_) || (ppt->has_density_transfers == _TRUE_) || (ppt->has_velocity_transfers == _TRUE_)){

    /** 3.a) Maximum k in P(k) */
    /* Read */
    class_call(parser_read_double(pfc,"P_k_max_h/Mpc",&param1,&flag1,errmsg),
               errmsg,
               errmsg);
    class_call(parser_read_double(pfc,"P_k_max_1/Mpc",&param2,&flag2,errmsg),
               errmsg,
               errmsg);
    /* Test */
    class_test((flag1 == _TRUE_) && (flag2 == _TRUE_),
               errmsg,
               "You can only enter one of 'P_k_max_h/Mpc' or 'P_k_max_1/Mpc'.");
    /* Complete set of parameters */
    if (flag1 == _TRUE_){
      ppt->k_max_for_pk = param1*pba->h;
    }
    if (flag2 == _TRUE_){
      ppt->k_max_for_pk = param2;
    }

    /** 3.a.1) Maximum k in primordial P(k) */
    /* Read */
    class_call(parser_read_double(pfc,"primordial_P_k_max_h/Mpc",&param1,&flag1,errmsg),
               errmsg,
               errmsg);
    class_call(parser_read_double(pfc,"primordial_P_k_max_1/Mpc",&param2,&flag2,errmsg),
               errmsg,
               errmsg);
    /* Test */
    class_test((flag1 == _TRUE_) && (flag2 == _TRUE_),
               errmsg,
               "You can only enter one of 'primordial_P_k_max_h/Mpc' or 'primordial_P_k_max_1/Mpc'.");
    /* Complete set of parameters */
    if (flag1 == _TRUE_){
      ppm->k_max_for_primordial_pk=param1*pba->h;
      ppm->has_k_max_for_primordial_pk = _TRUE_;
    }
    if (flag2 == _TRUE_){
      ppm->k_max_for_primordial_pk=param2;
      ppm->has_k_max_for_primordial_pk = _TRUE_;
    }

    /** 3.b) Redshift values */
    /* Read */
    class_call(parser_read_list_of_doubles(pfc,"z_pk",&int1,&pointer1,&flag1,errmsg),
               errmsg,
               errmsg);
    /* Test */
    if (flag1 == _TRUE_) {
      class_test(int1 > _Z_PK_NUM_MAX_,
                 errmsg,
                 "you want to write some output for %d different values of z, hence you should increase _Z_PK_NUM_MAX_ in include/output.h to at least this number",
                 int1);
      /* Complete set of parameters */
      pop->z_pk_num = int1;
      for (i=0; i<int1; i++) {
        pop->z_pk[i] = pointer1[i];
      }
      free(pointer1);
    }

  }

  /** 3.c) Maximum redshift */
  if ((ppt->has_pk_matter == _TRUE_) || (ppt->has_density_transfers == _TRUE_) || (ppt->has_velocity_transfers == _TRUE_) || (ppt->has_cl_number_count == _TRUE_) || (ppt->has_cl_lensing_potential == _TRUE_)) {
    /* Read */
    class_call(parser_read_double(pfc,"z_max_pk",&param1,&flag1,errmsg),
               errmsg,
               errmsg);

    /* Complete set of parameters */
    if (flag1==_TRUE_) {
      ppt->z_max_pk = param1;
    }
    /* *
     * If we could not read a z_max, we need to define one.
     * The limit could come from any of the contributions.
     * We test here, which contribution requires the largest z_max
     * */
    else {
      ppt->z_max_pk = 0.;
      /* For the z_pk related quantities, test here the z_pk requirements */
      if ((ppt->has_pk_matter == _TRUE_) || (ppt->has_density_transfers == _TRUE_) || (ppt->has_velocity_transfers == _TRUE_)) {
        for (i=0; i<pop->z_pk_num; i++) {
          ppt->z_max_pk = MAX(ppt->z_max_pk,pop->z_pk[i]);
        }
      }
      /* For the number count / shear related quantities, test the selection function z_max */
      if ((ppt->has_cl_number_count == _TRUE_) || (ppt->has_cl_lensing_potential == _TRUE_)){
        for (bin=0; bin<ppt->selection_num; bin++) {
          /* the few lines below should be consistent with their counterpart in transfer.c, in transfer_selection_times */
          if (ppt->selection==gaussian) {
            z_max = ppt->selection_mean[bin]+ppt->selection_width[bin]*ppr->selection_cut_at_sigma;
          }
          if (ppt->selection==tophat) {
            z_max = ppt->selection_mean[bin]+(1.+ppr->selection_cut_at_sigma*ppr->selection_tophat_edge)*ppt->selection_width[bin];
          }
          if (ppt->selection==dirac) {
            z_max = ppt->selection_mean[bin];
          }
          ppt->z_max_pk = MAX(ppt->z_max_pk,z_max);
        }
      }
      /* Now we have checked all contributions that could change z_max_pk */
    }
  }

  return _SUCCESS_;

}


/**
 * Read the parameters of perturbations, transfer and lensing
 * structures that are relevant for lensing.
 *
 * @param pfc     Input: pointer to local structure
 * @param ppr     Input: pointer to precision structure
 * @param ppt     Input: pointer to perturbations structure
 * @param ptr     Input: pointer to transfer structure
 * @param ple     Input: pointer to lensing structure
 * @param errmsg  Input: Error message
 * @return the error status
 */

int input_read_parameters_lensing(struct file_content * pfc,
                                  struct precision * ppr,
                                  struct perturbations * ppt,
                                  struct transfer * ptr,
                                  struct lensing *ple,
                                  ErrorMsg errmsg){

  /** Summary: */

  /** Define local variables */
  int flag1,flag2;
  double param1,param2;
  char string1[_ARGUMENT_LENGTH_MAX_];

  /** 1) Lensed spectra? */
  /* Read */
  class_call(parser_read_string(pfc,"lensing",&string1,&flag1,errmsg),
             errmsg,
             errmsg);
  /* Complete set of parameters */
  if ((flag1 == _TRUE_) && (string_begins_with(string1,'y') || string_begins_with(string1,'Y'))){
    if ((ppt->has_scalars == _TRUE_) && ((ppt->has_cl_cmb_temperature == _TRUE_) || (ppt->has_cl_cmb_polarization == _TRUE_)) && (ppt->has_cl_cmb_lensing_potential == _TRUE_)){
      ple->has_lensed_cls = _TRUE_;
      /* Slightly increase precision by delta_l_max for more precise lensed Cl's*/
      ppt->l_scalar_max += ppr->delta_l_max;
    }
    else {
      class_stop(errmsg,"you asked for lensed CMB Cls, but this requires a minimal number of options: 'modes' should include 's', 'output' should include 'tCl' and/or 'pCl', and also, importantly, 'lCl', the CMB lensing potential spectrum.");
    }
  }


  /** 2) Should the lensed spectra be rescaled (either with just A_L, or otherwise with amplitude, and tilt and pivot scale in k space) */
  /* Read */
  if ((ppt->has_scalars == _TRUE_) && (ppt->has_cl_cmb_lensing_potential == _TRUE_)) {

    class_call(parser_read_double(pfc,"A_L",&param1,&flag1,errmsg),
               errmsg,
               errmsg);
    class_call(parser_read_double(pfc,"lcmb_rescale",&param2,&flag2,errmsg),
               errmsg,
               errmsg);

    if ((flag1 == _TRUE_) && (flag2 == _TRUE_)) {
      class_stop(errmsg,"You cannot pass both A_l and lcdmb_rescale, choose one");
    }
    else {
      if (flag1 == _TRUE_) {
        ptr->lcmb_rescale = sqrt(param1);
      }
      if (flag2 == _TRUE_) {
        ptr->lcmb_rescale = param2;
      }
    }
    class_read_double("lcmb_tilt",ptr->lcmb_tilt);
    class_read_double("lcmb_pivot",ptr->lcmb_pivot);
  }

  /** 3) In general, do we want to use the full Limber scheme introduced in v3.2.2? With this full Limber scheme, the calculation of the CMB lensing potential spectrum C_l^phiphi for l > ppr->l_switch_limber is based on a new integration scheme. Compared to the previous scheme, which can be recovered by switching this parameter to _FALSE_, the new scheme uses a larger k_max and a coarser k-grid (or q-grid) than the CMB transfer function. The new scheme is used by default, because the old one is inaccurate at large l due to the too small k_max. */

  class_read_flag("want_lcmb_full_limber",ppt->want_lcmb_full_limber);

  return _SUCCESS_;

}


/**
 * Read free parameters of distortions structure.
 *
 * @param pfc     Input: pointer to local structure
 * @param ppr     Input: pointer to precision structure
 * @param psd     Input: pointer to distortions structure
 * @param errmsg  Input: Error message
 * @return the error status
 */

int input_read_parameters_distortions(struct file_content * pfc,
                                      struct precision * ppr,
                                      struct distortions * psd,
                                      ErrorMsg errmsg){

  /** Summary: */

  /** Define local variables */
  int flag1, flag2;
  char string1[_ARGUMENT_LENGTH_MAX_];
  double param1, param2;
  double updated_nu_max;

  /** 1) Branching ratio approximation */
  /* Read */
  class_call(parser_read_string(pfc,"sd_branching_approx",&string1,&flag1,errmsg),
             errmsg,
             errmsg);
  /* Complete set of parameters */

  if (flag1 == _TRUE_){
    if ( (strstr(string1,"sharp_sharp") != NULL) || (strstr(string1,"sharp sharp") != NULL) ) {
      psd->sd_branching_approx = bra_sharp_sharp;
      psd->sd_PCA_size = 0;
    }
    else if ( (strstr(string1,"sharp_soft") != NULL) || (strstr(string1,"sharp soft") != NULL) ) {
      psd->sd_branching_approx = bra_sharp_soft;
      psd->sd_PCA_size = 0;
    }
    else if ( (strstr(string1,"soft_soft") != NULL) || (strstr(string1,"soft soft") != NULL) ) {
      psd->sd_branching_approx = bra_soft_soft;
      psd->sd_PCA_size = 0;
    }
    else if ( (strstr(string1,"soft_soft_cons") != NULL) || (strstr(string1,"soft soft cons") != NULL) ) {
      psd->sd_branching_approx = bra_soft_soft_cons;
      psd->sd_PCA_size = 0;
    }
    else if ( (strstr(string1,"exact") != NULL) ) {
      psd->sd_branching_approx = bra_exact;
    }
    else{
      class_stop(errmsg,"You specified 'branching_approx' as '%s'. It has to be one of {'sharp_sharp','sharp_soft','soft_soft','soft_soft_cons','exact'}.",string1);
    }
  }

  /* Only read these if 'bra_exact' has been set (could also be set from default) */
  if (psd->sd_branching_approx == bra_exact){

    /** 1.a.1) Number of multipoles in PCA expansion */
    /* Read */
    class_read_int("sd_PCA_size",psd->sd_PCA_size);
    /* Test */
    if (psd->sd_PCA_size < 0 || psd->sd_PCA_size > 6){
      psd->sd_PCA_size = 6;
    }

    /** 1.a.2) Detector name */
    /* Read */
    class_call(parser_read_string(pfc,"sd_detector_name",&string1,&flag1,errmsg),
               errmsg,
               errmsg);
    /* Complete set of parameters */
    if (flag1 == _TRUE_){
      strcpy(psd->sd_detector_name,string1);
      psd->has_user_defined_name = _TRUE_;
    }

    /** 1.a.3) Detector specifics */
    /** 1.a.3.1) From file */
    /* Read */
    class_call(parser_read_string(pfc,"sd_detector_file",&string1,&flag1,errmsg),
               errmsg,
               errmsg);
    /* Complete set of parameters */
    if (flag1 == _TRUE_){
      strcpy(psd->sd_detector_file_name,string1);
      psd->has_detector_file = _TRUE_;
    }

    /** 1.a.3.2) User defined */
    /* Read */
    class_call(parser_read_double(pfc,"sd_detector_nu_min",&param1,&flag1,errmsg),
               errmsg,
               errmsg);
    /* Complete set of parameters */
    if (flag1 == _TRUE_){
      psd->sd_detector_nu_min = param1;
      psd->has_user_defined_detector = _TRUE_;
    }
    /* Read */
    class_call(parser_read_double(pfc,"sd_detector_nu_max",&param1,&flag1,errmsg),
               errmsg,
               errmsg);
    /* Complete set of parameters */
    if (flag1 == _TRUE_){
      psd->sd_detector_nu_max = param1;
      psd->has_user_defined_detector = _TRUE_;
    }
    /* Read */
    class_call(parser_read_double(pfc,"sd_detector_nu_delta",&param1,&flag1,errmsg),
               errmsg,
               errmsg);
    class_call(parser_read_double(pfc,"sd_detector_bin_number",&param2,&flag2,errmsg),
               errmsg,
               errmsg);
    /* Test */
    class_test((flag1 == _TRUE_) && (flag2 == _TRUE_),
               errmsg,
               "You can only enter one of 'sd_detector_nu_delta' or 'sd_detector_bin_number'.",
               psd->sd_detector_nu_delta,psd->sd_detector_bin_number);
    /* Complete set of parameters */
    if (flag1 == _TRUE_){
      psd->sd_detector_nu_delta = param1;
      psd->sd_detector_bin_number = ((int)ceil((psd->sd_detector_nu_max-psd->sd_detector_nu_min)/param1));
      psd->has_user_defined_detector = _TRUE_;
    }
    if (flag2 == _TRUE_){
      psd->sd_detector_nu_delta = (psd->sd_detector_nu_max-psd->sd_detector_nu_min)/param2;
      psd->sd_detector_bin_number = param2;
      psd->has_user_defined_detector = _TRUE_;
    }
    /* Update value of nu_max, given the number of bins */
    updated_nu_max = psd->sd_detector_nu_min+psd->sd_detector_nu_delta*psd->sd_detector_bin_number;
    if (fabs(updated_nu_max-psd->sd_detector_nu_max) > ppr->tol_sd_detector){
      printf(" -> WARNING: The value of 'sd_detector_nu_max' has been updated to %7.3e to accommodate the binning of your detector.\n",updated_nu_max);
      psd->sd_detector_nu_max = updated_nu_max;
    }
    /* Read */
    class_call(parser_read_double(pfc,"sd_detector_delta_Ic",&param1,&flag1,errmsg),
               errmsg,
               errmsg);
    /* Complete set of parameters */
    if (flag1 == _TRUE_){
      psd->sd_detector_delta_Ic = 1.0e-26*param1;
      psd->has_user_defined_detector = _TRUE_;
    }
  }

  /* Final tests */
  class_test(psd->sd_branching_approx != bra_exact && psd->sd_PCA_size > 0,
             errmsg,
             "The PCA expansion is possible only for 'branching_approx = exact'");
  class_test(psd->has_detector_file && psd->has_user_defined_detector,
             errmsg,
             "You can only enter the noise file {'%s'} or the specifications {'%s','%s'/'%s','%s'}.",
             "sd_detector_file","sd_detector_nu_min","sd_detector_nu_max",
             "sd_detector_nu_delta","sd_detector_bin_number","sd_detector_delta_Ic");


  /** 2) Only calculate exotic energy injections and no LCDM processes for spectral distortions ? */
  class_read_flag("sd_only_exotic",psd->include_only_exotic);

  /** 3) Include g distortions? */
  class_read_flag("sd_include_g_distortion",psd->include_g_distortion);


  /** 4) Set g-distortions to zero? */
  class_call(parser_read_double(pfc,"sd_add_y",&psd->sd_add_y,&flag1,errmsg),
             errmsg,
             errmsg);
  class_call(parser_read_double(pfc,"sd_add_mu",&psd->sd_add_mu,&flag1,errmsg),
             errmsg,
             errmsg);


  /** 5) Include SZ effect from reionization? */
  class_read_flag("include_SZ_effect",psd->has_SZ_effect);

  if (psd->has_SZ_effect == _TRUE_){
    /** 5.a) Type of calculation */
    /* Read */
    class_call(parser_read_string(pfc,"sd_reio_type",&string1,&flag1,errmsg),
               errmsg,
               errmsg);
    /* Complete set of parameters */
    if (flag1 == _TRUE_){
      if (strcmp(string1,"Nozawa_2005") == 0){
        psd->sd_reio_type = sd_reio_Nozawa;
      }
      else if (strcmp(string1,"Chluba_2012") == 0){
        psd->sd_reio_type = sd_reio_Chluba;
      }
      else {
        class_stop(errmsg,
                   "You specified 'sd_reio_type' as '%s'. It has to be one of {'Nozawa_2005','Chluba_2012'}.",string1);
      }
    }
  }

  return _SUCCESS_;

}


/**
 * Read obsolete/additional parameters that are not assigned to a specific structure
 *
 * @param pfc     Input: pointer to local structure
 * @param ppr     Input: pointer to precision structure
 * @param pba     Input: pointer to background structure
 * @param pth     Input: pointer to thermodynamics structure
 * @param errmsg  Input: Error message
 * @return the error status
 */

int input_read_parameters_additional(struct file_content* pfc,
                                     struct precision* ppr,
                                     struct background* pba,
                                     struct thermodynamics* pth,
                                     ErrorMsg errmsg){

  /** Summary: */

  /** Define local variables */
  int flag1;
  double param1;
  char string1[_ARGUMENT_LENGTH_MAX_];

  /**
   * Here we can place all obsolete (deprecated) names for the precision parameters
   * that will still be read as of the current version.
   * There is however, no guarantee that this will be true for future versions as well.
   * The new parameter names should be used preferrably.
   * */
  class_read_double("k_scalar_min_tau0",ppr->k_min_tau0);
  class_read_double("k_scalar_max_tau0_over_l_max",ppr->k_max_tau0_over_l_max);
  class_read_double("k_scalar_step_sub",ppr->k_step_sub);
  class_read_double("k_scalar_step_super",ppr->k_step_super);
  class_read_double("k_scalar_step_transition",ppr->k_step_transition);
  class_read_double("k_scalar_k_per_decade_for_pk",ppr->k_per_decade_for_pk);
  class_read_double("k_scalar_k_per_decade_for_bao",ppr->k_per_decade_for_bao);
  class_read_double("k_scalar_bao_center",ppr->k_bao_center);
  class_read_double("k_scalar_bao_width",ppr->k_bao_width);

  class_read_double("k_step_trans_scalars",ppr->q_linstep);
  class_read_double("k_step_trans_tensors",ppr->q_linstep);
  class_read_double("k_step_trans",ppr->q_linstep);
  class_read_double("q_linstep_trans",ppr->q_linstep);
  class_read_double("q_logstep_trans",ppr->q_logstep_spline);

  /** Here are slgihtly more obsolete parameters, these will not even be read, only give an error message */
  class_call(parser_read_double(pfc,"bias",&param1,&flag1,errmsg),
             errmsg,
             errmsg);
  class_test(flag1 == _TRUE_,
             errmsg,
             "the input parameter 'bias' is obsolete, because you can now pass an independent light-to-mass bias for each bin/selection function. The new input name is 'selection_bias'. It can be set to a single number (common bias for all bins) or as many numbers as the number of bins");

  class_call(parser_read_double(pfc,"s_bias",&param1,&flag1,errmsg),
             errmsg,
             errmsg);
  class_test(flag1 == _TRUE_,
             errmsg,
             "the input parameter 's_bias' is obsolete, because you can now pass an independent magnitude bias for each bin/selection function. The new input name is 'selection_magnitude_bias'. It can be set to a single number (common magnitude bias for all bins) or as many numbers as the number of bins");

  class_call(parser_read_string(pfc,"l_switch_limber_for_cl_density_over_z",&string1,&flag1,errmsg),
             errmsg,
             errmsg);
  class_test(flag1 == _TRUE_,
             errmsg,
             "You passed in input a precision parameter called l_switch_limber_for_cl_density_over_z. This syntax is deprecated since v2.5.0. Please use instead the two precision parameters l_switch_limber_for_nc_local_over_z, l_switch_limber_for_nc_los_over_z, defined in include/common.h, and allowing for better performance.");

  /*
    class_call(parser_read_double(pfc,"annihilation",&param1,&flag1,errmsg),
    errmsg,
    errmsg);
    class_test(flag1 == _TRUE_,
    errmsg,
    "the input parameter 'annihilation' (that is, f_eff <sigma_DM v> / m_DM in units m^3/s/Kg) is obsolete and replaced by 'DM_annihilation_efficiency' (that is, <sigma_DM v> / m_DM in units m^3/s/J). If 'f_eff_type' is set to 'on_the_spot', f_eff is assumed to be one and the old/new parameters only differ by a factor c^2 in m2/s2 = 9.e16. For instance, annihilation=1.e-6 is the same as DM_annihilation_efficiency=9.e-22".
  */


  /** Test additional input parameters related to precision parameters */
  if ((ppr->tight_coupling_approximation == (int)first_order_CLASS) || (ppr->tight_coupling_approximation == (int)second_order_CLASS)) {
    pth->compute_cb2_derivatives = _TRUE_;
  }

  class_test(ppr->ur_fluid_trigger_tau_over_tau_k==ppr->radiation_streaming_trigger_tau_over_tau_k,
             errmsg,
             "please choose different values for precision parameters ur_fluid_trigger_tau_over_tau_k and radiation_streaming_trigger_tau_over_tau_k, in order to avoid switching two approximation schemes at the same time");

  if (pba->N_ncdm>0) {
    class_test(ppr->ncdm_fluid_trigger_tau_over_tau_k==ppr->radiation_streaming_trigger_tau_over_tau_k,
               errmsg,
               "please choose different values for precision parameters ncdm_fluid_trigger_tau_over_tau_k and radiation_streaming_trigger_tau_over_tau_k, in order to avoid switching two approximation schemes at the same time");

    class_test(ppr->ncdm_fluid_trigger_tau_over_tau_k==ppr->ur_fluid_trigger_tau_over_tau_k,
               errmsg,
               "please choose different values for precision parameters ncdm_fluid_trigger_tau_over_tau_k and ur_fluid_trigger_tau_over_tau_k, in order to avoid switching two approximation schemes at the same time");
  }

  if (pba->Omega0_idr != 0.){
    class_test(ppr->idr_streaming_trigger_tau_over_tau_k==ppr->radiation_streaming_trigger_tau_over_tau_k,
               errmsg,
               "please choose different values for precision parameters dark_radiation_trigger_tau_over_tau_k and radiation_streaming_trigger_tau_over_tau_k, in order to avoid switching two approximation schemes at the same time");

    class_test(ppr->idr_streaming_trigger_tau_over_tau_k==ppr->ur_fluid_trigger_tau_over_tau_k,
               errmsg,
               "please choose different values for precision parameters dark_radiation_trigger_tau_over_tau_k and ur_fluid_trigger_tau_over_tau_k, in order to avoid switching two approximation schemes at the same time");

    class_test(ppr->idr_streaming_trigger_tau_over_tau_k==ppr->ncdm_fluid_trigger_tau_over_tau_k,
               errmsg,
               "please choose different values for precision parameters dark_radiation_trigger_tau_over_tau_k and ncdm_fluid_trigger_tau_over_tau_k, in order to avoid switching two approximation schemes at the same time");
  }

  return _SUCCESS_;

}


/**
 * Read the parameters of output structure.
 *
 * @param pfc     Input: pointer to local structure
 * @param pba     Input: pointer to background structure
 * @param pth     Input: pointer to thermodynamics structure
 * @param ppt     Input: pointer to perturbations structure
 * @param ptr     Input: pointer to transfer structure
 * @param ppm     Input: pointer to primordial structure
 * @param phr     Input: pointer to harmonic structure
 * @param pfo     Input: pointer to non-linear structure
 * @param ple     Input: pointer to lensing structure
 * @param psd     Input: pointer to distorsion structure
 * @param pop     Input: pointer to output structure
 * @param errmsg  Input: Error message
 * @return the error status
 */

int input_read_parameters_output(struct file_content * pfc,
                                 struct background *pba,
                                 struct thermodynamics *pth,
                                 struct perturbations *ppt,
                                 struct transfer *ptr,
                                 struct primordial *ppm,
                                 struct harmonic *phr,
                                 struct fourier * pfo,
                                 struct lensing *ple,
                                 struct distortions *psd,
                                 struct output *pop,
                                 ErrorMsg errmsg){

  /** Summary: */

  /** Define local variables */
  int flag1;
  char string1[_ARGUMENT_LENGTH_MAX_];
  int int1;
  double * pointer1;
  int i;

  /** 1) Output for external files */
  /** 1.a) File name */
  /* Read */
  class_call(parser_read_string(pfc,"root",&string1,&flag1,errmsg),
             errmsg,
             errmsg);
  /* Complete set of parameters */
  if (flag1 == _TRUE_){
    class_test(strlen(string1)>_FILENAMESIZE_-32,errmsg,"Root directory name is too long. Please install in other directory, or increase _FILENAMESIZE_ in common.h");
    strcpy(pop->root,string1);
  }

  /** 1.b) Headers */
  /* Read */
  class_read_flag("headers",pop->write_header);

  /** 1.c) Format */
  /* Read */
  class_call(parser_read_string(pfc,"format",&string1,&flag1,errmsg),
             errmsg,
             errmsg);
  /* Complete set of parameters */
  if (flag1 == _TRUE_){
    if ((strstr(string1,"class") != NULL) || (strstr(string1,"CLASS") != NULL)){
      pop->output_format = class_format;
    }
    else if ((strstr(string1,"camb") != NULL) || (strstr(string1,"CAMB") != NULL)){
      pop->output_format = camb_format;
    }
    else{
      class_stop(errmsg,"You specified 'format' as '%s'. It has to be one of {'class','camb'}.",string1);
    }
  }

  /** 1.d) Background quantities */
  /* Read */
  class_read_flag_or_deprecated("write_background","write background",pop->write_background);

  /** 1.e) Thermodynamics quantities */
  /* Read */
  class_read_flag_or_deprecated("write_thermodynamics","write thermodynamics",pop->write_thermodynamics);

  /** 1.f) Table of perturbations for certain wavenumbers k */
  /* Read */
  class_call(parser_read_list_of_doubles(pfc,"k_output_values",&int1,&pointer1,&flag1,errmsg),
             errmsg,
             errmsg);
  if (flag1 == _TRUE_) {
    /* Test */
    class_test(int1 > _MAX_NUMBER_OF_K_FILES_,
               errmsg,
               "you want to write some output for %d different values of k, hence you should increase _MAX_NUMBER_OF_K_FILES_ in include/perturbations.h to at least this number",
               int1);
    /* Complete set of parameters */
    ppt->k_output_values_num = int1;
    for (i=0; i<int1; i++) {
      ppt->k_output_values[i] = pointer1[i];
    }
    free(pointer1);
    qsort (ppt->k_output_values, ppt->k_output_values_num, sizeof(double), compare_doubles);     // Sort the k_array using qsort
    ppt->store_perturbations = _TRUE_;
    pop->write_perturbations = _TRUE_;
  }

  /** 1.g) Primordial spectra */
  /* Read */
  class_read_flag_or_deprecated("write_primordial","write primordial",pop->write_primordial);

  /** 1.h) Exotic energy injection output */
  /* Read */
  class_read_flag_or_deprecated("write_exotic_injection","write exotic injection",pop->write_exotic_injection);

  /** 1.i) Non-injected photon injection */
  /* Read */
  class_read_flag_or_deprecated("write_noninjection","write noninjection",pop->write_noninjection);

  /** 1.k) Spectral Distortions */
  /* Read */
  class_read_flag_or_deprecated("write_distortions","write distortions",pop->write_distortions);

  /** 2) Verbosity */
  /* Read */
  class_read_int("background_verbose",pba->background_verbose);
  class_read_int("thermodynamics_verbose",pth->thermodynamics_verbose);
  class_read_int("hyrec_verbose",pth->hyrec_verbose);
  class_read_int("perturbations_verbose",ppt->perturbations_verbose);
  class_read_int("transfer_verbose",ptr->transfer_verbose);
  class_read_int("primordial_verbose",ppm->primordial_verbose);
  class_read_int("harmonic_verbose",phr->harmonic_verbose);
  class_read_int("fourier_verbose",pfo->fourier_verbose);
  class_read_int("lensing_verbose",ple->lensing_verbose);
  class_read_int("distortions_verbose",psd->distortions_verbose);
  class_read_int("output_verbose",pop->output_verbose);

  return _SUCCESS_;

}

/**
 * Write the info related to the used and unused parameters
 * Additionally, write the warnings for unused parameters
 *
 * @param pfc     Input: pointer to local structure
 * @param pop     Input: pointer to output structure
 * @param errmsg  Input: Error message
 * @return the error status
 */

int input_write_info(struct file_content * pfc,
                     struct output * pop,
                     ErrorMsg errmsg){

  /** Summary: */

  /** Define local variables */
  int i;
  int flag1, flag2;
  FILE * param_output;
  FILE * param_unused;
  char param_output_name[_LINE_LENGTH_MAX_];
  char param_unused_name[_LINE_LENGTH_MAX_];

  /* We want to read both flags at once, such that the pfc->read is set correctly */
  flag1 = _FALSE_;
  flag2 = _FALSE_;
  class_read_flag_or_deprecated("write_parameters","write parameters",flag1);
  class_read_flag_or_deprecated("write_warnings","write warnings",flag2);

  /* Now that all variables are read, we can print the warnings */
  if (flag2 == _TRUE_){
    for (i=0; i<pfc->size; i++) {
      if (pfc->read[i] == _FALSE_)
        fprintf(stdout,"[WARNING: input line not used: '%s=%s']\n",pfc->name[i],pfc->value[i]);
    }
  }

  /* Finally, since all variables are read, we can also print the parameters.ini and unused_parameters files */
  if (flag1 == _TRUE_) {
    class_sprintf(param_output_name,"%s%s",pop->root,"parameters.ini");
    class_open(param_output,param_output_name,"w",errmsg);
    fprintf(param_output,"# List of input/precision parameters actually read\n");
    fprintf(param_output,"# (all other parameters set to default values)\n");
    fprintf(param_output,"# Obtained with CLASS %s (for developers: svn version %s)\n",_VERSION_,_SVN_VERSION_);
    fprintf(param_output,"#\n");
    fprintf(param_output,"# This file can be used as the input file of another run\n");
    fprintf(param_output,"#\n");

    class_sprintf(param_unused_name,"%s%s",pop->root,"unused_parameters");
    class_open(param_unused,param_unused_name,"w",errmsg);
    fprintf(param_unused,"# List of input/precision parameters passed\n");
    fprintf(param_unused,"# but not used (just for info)\n");
    fprintf(param_unused,"#\n");

    for (i=0; i<pfc->size; i++) {
      if (pfc->read[i] == _TRUE_){
        fprintf(param_output,"%s = %s\n",pfc->name[i],pfc->value[i]);
      }
      else{
        fprintf(param_unused,"%s = %s\n",pfc->name[i],pfc->value[i]);
      }
    }

    fprintf(param_output,"#\n");

    fclose(param_output);
    fclose(param_unused);
  }

  return _SUCCESS_;

}

/**
 * All default parameter values (for input parameters)
 *
 * @param pba Input: pointer to background structure
 * @param pth Input: pointer to thermodynamics structure
 * @param ppt Input: pointer to perturbation structure
 * @param ptr Input: pointer to transfer structure
 * @param ppm Input: pointer to primordial structure
 * @param phr Input: pointer to harmonic structure
 * @param pfo Input: pointer to fourier structure
 * @param ple Input: pointer to lensing structure
 * @param psd     Input: pointer to distorsion structure
 * @param pop Input: pointer to output structure
 * @return the error status
 * @return the error status
 */

int input_default_params(struct background *pba,
                         struct thermodynamics *pth,
                         struct perturbations *ppt,
                         struct transfer *ptr,
                         struct primordial *ppm,
                         struct harmonic *phr,
                         struct fourier * pfo,
                         struct lensing *ple,
                         struct distortions *psd,
                         struct output *pop) {

  /** Summary: */

  /** - Define local variables */
  struct injection* pin = &(pth->in);
  double sigma_B; /* Stefan-Boltzmann constant in \f$ W/m^2/K^4 = Kg/K^4/s^3 \f$*/

  sigma_B = 2. * pow(_PI_,5) * pow(_k_B_,4) / 15. / pow(_h_P_,3) / pow(_c_,2);

  /* 24.02.2021: default parameters.
     If you want to use exactly the Planck 2018 bestfit model, you can always use one of our
     suggested input files, e.g., base_2018_plikHM_TTTEEE_lowl_lowE_lensing.ini.
     The default values implemented here are an approximation to this LambdaCDM model
     with the same values for
     omega_b=0.02238280,
     omega_c=0.1201075,
     theta_s=1.041783 (this is not theta_MC nor theta*),
     tau_reio=0.05430842,
     As=2.100549e-09,
     ns=0.9660499,
     but a few differences:
     only massless neutrinos,
     N_eff=3.044 instead of 3.046 (3.044 is a more accurate and updated estimate of the
     effective neutrino number in LCDM),
     non-linear corrections neglected */

  /**
   * Default to any module: not allocated yet
   */
  pba->is_allocated = _FALSE_;
  pth->is_allocated = _FALSE_;
  ppt->is_allocated = _FALSE_;
  pfo->is_allocated = _FALSE_;
  ptr->is_allocated = _FALSE_;
  phr->is_allocated = _FALSE_;
  ppm->is_allocated = _FALSE_;
  ple->is_allocated = _FALSE_;
  psd->is_allocated = _FALSE_;

  /**
   * Default to input_read_parameters_general
   */

  /** 1) Output spectra */
  ppt->has_cl_cmb_temperature = _FALSE_;
  ppt->has_cl_cmb_polarization = _FALSE_;
  ppt->has_cl_cmb_lensing_potential = _FALSE_;
  ppt->has_cl_number_count = _FALSE_;
  ppt->has_cl_lensing_potential = _FALSE_;
  ppt->has_pk_matter = _FALSE_;
  ppt->has_density_transfers = _FALSE_;
  ppt->has_velocity_transfers = _FALSE_;
  /** 1.a) 'tCl' case */
  ppt->switch_sw = 1;
  ppt->switch_eisw = 1;
  ppt->switch_lisw = 1;
  ppt->switch_dop = 1;
  ppt->switch_pol = 1;
  /** 1.a.1) Split value of redshift z at which the isw is considered as late or early */
  ppt->eisw_lisw_split_z = 120;
  /** 1.b) 'nCl' (or 'dCl') case */
  ppt->has_nc_density = _FALSE_;
  ppt->has_nc_rsd = _FALSE_;
  ppt->has_nc_lens = _FALSE_;
  ppt->has_nc_gr = _FALSE_;
  /** 1.c) 'dTk' (or 'mTk') case */
  ppt->has_metricpotential_transfers = _FALSE_;

  /** 2) Perturbed recombination */
  ppt->has_perturbed_recombination=_FALSE_;
  /** 3) Modes */
  ppt->has_scalars=_TRUE_;
  ppt->has_vectors=_FALSE_;
  ppt->has_tensors=_FALSE_;
  /** 3.a) Initial conditions for scalars */
  ppt->has_ad=_TRUE_;
  ppt->has_bi=_FALSE_;
  ppt->has_cdi=_FALSE_;
  ppt->has_nid=_FALSE_;
  ppt->has_niv=_FALSE_;
  /** 3.b) Initial conditions for tensors */
  ppt->tensor_method = tm_massless_approximation;
  ppt->evolve_tensor_ur = _FALSE_;
  ppt->evolve_tensor_ncdm = _FALSE_;

  /** 4.a) Gauge */
  ppt->gauge=synchronous;
  /** 4.b) N-body gauge */
  ppt->has_Nbody_gauge_transfers = _FALSE_;
  /** 4.c) keep delta_m, theta_m, delta_cb, theta_cb in current gauge */
  ppt->has_matter_source_in_current_gauge = _FALSE_;

  /** 5) Hubble parameter */
  pba->h = 0.67810;
  pba->H0 = pba->h*1.e5/_c_;

  /** 6) Primordial Helium fraction */
  pth->YHe = _YHE_BBN_;

  /** 7) Recombination algorithm */
  pth->recombination=hyrec;
  pth->recfast_photoion_mode=recfast_photoion_Tmat;

  /** 8) Parametrization of reionization */
  pth->reio_parametrization=reio_camb;
  /** 8.a) 'reio_camb' or 'reio_half_tanh' case */
  pth->reio_z_or_tau=reio_z;
  pth->z_reio=7.6711;
  pth->tau_reio=0.05430842;
  pth->reionization_exponent=1.5;
  pth->reionization_width=0.5;
  pth->helium_fullreio_redshift=3.5;
  pth->helium_fullreio_width=0.5;

  /** 8.b) 'reio_bins_tanh' case */
  pth->binned_reio_num=0;
  pth->binned_reio_z=NULL;
  pth->binned_reio_xe=NULL;
  pth->binned_reio_step_sharpness = 0.3;
  /** 8.c) 'reio_many_tanh' case */
  pth->many_tanh_num=0;
  pth->many_tanh_z=NULL;
  pth->many_tanh_xe=NULL;
  pth->many_tanh_width = 0.5;
  /** 8.d) 'reio_inter' case */
  pth->reio_inter_num = 0;
  pth->reio_inter_z = NULL;
  pth->reio_inter_xe = NULL;

  /** 9) Damping scale */
  pth->compute_damping_scale = _FALSE_;

  /** 10) Varying fundamental constants */
  pba->varconst_dep = varconst_none;
  pba->varconst_alpha = 1.;
  pba->varconst_me = 1.;
  pth->bbn_alpha_sensitivity = 1.;
  pba->varconst_transition_redshift = 50.;

  /**
   * Default to input_read_parameters_species
   */

  /** 1) Photon density */
  pba->T_cmb = 2.7255;
  pba->Omega0_g = (4.*sigma_B/_c_*pow(pba->T_cmb,4.)) / (3.*_c_*_c_*1.e10*pba->h*pba->h/_Mpc_over_m_/_Mpc_over_m_/8./_PI_/_G_);

  /** 2) Baryon density */
  pba->Omega0_b = 0.02238280/pow(pba->h,2);

  /** 3) Ultra-relativistic species / massless neutrino density,
      assuming as default value N_eff=3.044 (see 2008.01074 and
      2012.02726. This value is more accurate than the previous
      default value of 3.046) */
  pba->Omega0_ur = 3.044*7./8.*pow(4./11.,4./3.)*pba->Omega0_g;

  /** 3.a) Effective squared sound speed and viscosity parameter */
  ppt->three_ceff2_ur=1.;
  ppt->three_cvis2_ur=1.;

  /** 4) CDM density */
  pba->Omega0_cdm = 0.1201075/pow(pba->h,2);

  /** 5) ncdm sector */
  /** 5.a) Number of distinct species */
  pba->N_ncdm = 0;
  /** 5.b) List of names of psd files */
  pba->ncdm_psd_files = NULL;
  /** 5.c) Analytic distribution function */
  pba->ncdm_psd_parameters = NULL;
  pba->Omega0_ncdm_tot = 0.;
  /** 5.d) --> See read_parameters_background */
  /** 5.e) ncdm temperature */
  pba->T_ncdm_default = 0.71611; /* this value gives m/omega = 93.14 eV b*/
  pba->T_ncdm = NULL;
  /** 5.f) ncdm chemical potential */
  pba->ksi_ncdm_default = 0.;
  pba->ksi_ncdm = NULL;
  /** 5.g) ncdm degeneracy parameter */
  pba->deg_ncdm_default = 1.;
  pba->deg_ncdm = NULL;
  /** 5.h) --> See read_parameters_background */

  /** 6) Curvature density */
  pba->Omega0_k = 0.;
  pba->K = 0.;
  pba->sgnK = 0;

  /* ** ADDITIONAL SPECIES ** */

  /** 7.1) Decaying CDM into Dark Radiation = dcdm+dr */
  /** 7.1.a) Current fractional density of dcdm+dr */
  pba->Omega0_dcdmdr = 0.0;
  pba->Omega0_dcdm = 0.0;
  /** 7.1.b) Initial fractional density of dcdm+dr */
  pba->Omega_ini_dcdm = 0.;
  /** 7.1.c) Decay constant */
  pba->Gamma_dcdm = 0.0;
  pba->tau_dcdm = 0.0;

  /** 7.2) Interacting Dark Matter */
  /** 7.2.1.a) Current factional density of idm */
  pba->Omega0_idm = 0;
  /** 7.2.1.a) Mass of idm in eV*/
  pth->m_idm = 1.e9;
  /** 7.2.2) Current fractional density of idr */
  pba->Omega0_idr = 0.0;
  pba->T_idr = 0.0;
  /** 7.2.2.c) Coupling idm_dr*/
  pth->a_idm_dr = 0.;
  /** 7.2.2.d) temperature scaling idm_dr */
  pth->n_index_idm_dr = 0;
  /** 7.2.2.e) Approximation mode of idr */
  ppt->idr_nature=idr_free_streaming;
  /** 7.2.2.f) idr self-interactions*/
  pth->b_idr = 0.;
  /** 7.2.2.g, 7.2.2.h)  angular coefficients */
  ppt->alpha_idm_dr = NULL;
  ppt->beta_idr = NULL;
  /** 7.2.3.a) idm_b coupling */
  pth->cross_idm_b = 0.;
  /** 7.2.3.b) temperature scaling idm_b */
  pth->n_index_idm_b = 0.;
  pth->n_coeff_idm_b = 0.;
  /** 7.2.4.a) idm_g coupling */
  pth->cross_idm_g = 0.;
  pth->u_idm_g = 0.;
  /** 7.2.4.b) temperature scaling idm_g */
  pth->n_index_idm_g = 0;
  ppt->has_idm_soundspeed = _FALSE_;

  /* ** ADDITIONAL SPECIES ** */

  /** 9) Dark energy contributions */
  pba->Omega0_fld = 0.;
  pba->Omega0_scf = 0.;
  pba->Omega0_lambda = 1.-pba->Omega0_k-pba->Omega0_g-pba->Omega0_ur-pba->Omega0_b-pba->Omega0_cdm-pba->Omega0_ncdm_tot-pba->Omega0_dcdmdr - pba->Omega0_idr -pba->Omega0_idm;
  /** 8.a) Omega fluid */
  /** 8.a.1) PPF approximation */
  pba->use_ppf = _TRUE_;
  pba->c_gamma_over_c_fld = 0.4;
  /** 9.a.2) Equation of state */
  pba->fluid_equation_of_state = CLP;
  pba->w0_fld = -1.;
  pba->cs2_fld = 1.;
  /** 9.a.2.1) 'CLP' case */
  pba->wa_fld = 0.;
  /** 9.a.2.2) 'EDE' case */
  pba->Omega_EDE = 0.;
  /** 9.b) Omega scalar field */
  /** 9.b.1) Potential parameters and initial conditions */
  pba->scf_parameters = NULL;
  pba->scf_parameters_size = 0;
  /** 9.b.2) Initial conditions from attractor solution */
  pba->attractor_ic_scf = _TRUE_;
  pba->phi_ini_scf = 1;                // MZ: initial conditions are as multiplicative
  pba->phi_prime_ini_scf = 1;          //     factors of the radiation attractor values
  /** 9.b.3) Tuning parameter */
  pba->scf_tuning_index = 0;

  /**
   * Deafult to input_read_parameters_heating
   */
  pth->has_exotic_injection = _FALSE_;

  /** 1) DM annihilation */
  /** 1.a) Energy fraction absorbed by the gas */
  pin->DM_annihilation_efficiency = 0.;
  pin->DM_annihilation_cross_section = 0.;
  pin->DM_annihilation_mass = 0.;
  pin->DM_annihilation_fraction = 0.;
  /** 1.a.1) Redshift dependence */
  pin->DM_annihilation_variation = 0.;
  pin->DM_annihilation_z = 1000.;
  pin->DM_annihilation_zmax = 2500.;
  pin->DM_annihilation_zmin = 30.;
  pin->DM_annihilation_f_halo = 0.;
  pin->DM_annihilation_z_halo = 30.;

  /** 2) DM decay */
  /** 2.a) Fraction */
  pin->DM_decay_fraction = 0.;
  /** 2.b) Decay width */
  pin->DM_decay_Gamma = 0.;

  /** 3) PBH evaporation */
  /** 3.a) Fraction */
  pin->PBH_evaporation_fraction = 0.;
  /** 3.b) Mass */
  pin->PBH_evaporation_mass = 0.;

  /** 4) PBH accretion */
  /** 4.a) Fraction */
  pin->PBH_accretion_fraction = 0.;
  /** 4.b) Mass */
  pin->PBH_accretion_mass = 0.;
  /** 4.c) Recipe */
  pin->PBH_accretion_recipe = disk_accretion;
  /** 4.c.1) Additional parameters for spherical accretion */
  pin->PBH_accretion_relative_velocities = -1.;
  /** 4.c.1) Additional parameters for disk accretion */
  pin->PBH_accretion_eigenvalue = 0.1;
  pin->PBH_accretion_ADAF_delta = 1.e-3;

  /** 5) Injection efficiency */
  pin->f_eff_type = f_eff_on_the_spot;
  pin->f_eff = 1.;
  class_sprintf(pin->f_eff_file,"external/heating/example_f_eff_file.dat");

  /** 6) Deposition function */
  pin->chi_type = chi_CK;
  /** 6.1) External file */
  class_sprintf(pin->chi_z_file,"external/heating/example_chiz_file.dat");
  class_sprintf(pin->chi_x_file,"external/heating/example_chix_file.dat");

  /**
   * Default to input_read_parameters_nonlinear
   */

  /** 1) Non-linearity */
  ppt->has_nl_corrections_based_on_delta_m = _FALSE_;
  pfo->method = nl_none;
  pfo->has_pk_eq = _FALSE_;
  pfo->extrapolation_method = extrap_max_scaled;
  pfo->feedback = nl_emu_dmonly;
  pfo->z_infinity = 10.;

  /**
   * Default to input_read_parameters_primordial
   */

  /** 1) Primordial spectrum type */
  ppm->primordial_spec_type = analytic_Pk;
  /** 1.a) Pivot scale in Mpc-1 */
  ppm->k_pivot = 0.05;

  /** 1.b) For type 'analytic_Pk' */
  /** 1.b.1) For scalar perturbations */
  ppm->A_s = 2.100549e-09;
  /** 1.b.1.1) Adiabatic perturbations */
  ppm->n_s = 0.9660499;
  ppm->alpha_s = 0.;
  /** 1.b.1.2) Isocurvature/entropy perturbations */
  ppm->f_bi = 1.;
  ppm->n_bi = 1.;
  ppm->alpha_bi = 0.;
  ppm->f_cdi = 1.;
  ppm->n_cdi = 1.;
  ppm->alpha_cdi = 0.;
  ppm->f_nid = 1.;
  ppm->n_nid = 1.;
  ppm->alpha_nid = 0.;
  ppm->f_niv = 1.;
  ppm->n_niv = 1.;
  ppm->alpha_niv = 0.;
  /** 1.b.1.3) Cross-correlation between different adiabatic/entropy mode */
  ppm->c_ad_bi = 0.;
  ppm->n_ad_bi = 0.;
  ppm->alpha_ad_bi = 0.;
  ppm->c_ad_cdi = 0.;
  ppm->n_ad_cdi = 0.;
  ppm->alpha_ad_cdi = 0.;
  ppm->c_ad_nid = 0.;
  ppm->n_ad_nid = 0.;
  ppm->alpha_ad_nid = 0.;
  ppm->c_ad_niv = 0.;
  ppm->n_ad_niv = 0.;
  ppm->alpha_ad_niv = 0.;
  ppm->c_bi_cdi = 0.;
  ppm->n_bi_cdi = 0.;
  ppm->alpha_bi_cdi = 0.;
  ppm->c_bi_nid = 0.;
  ppm->n_bi_nid = 0.;
  ppm->alpha_bi_nid = 0.;
  ppm->c_bi_niv = 0.;
  ppm->n_bi_niv = 0.;
  ppm->alpha_bi_niv = 0.;
  ppm->c_cdi_nid = 0.;
  ppm->n_cdi_nid = 0.;
  ppm->alpha_cdi_nid = 0.;
  ppm->c_cdi_niv = 0.;
  ppm->n_cdi_niv = 0.;
  ppm->alpha_cdi_niv = 0.;
  ppm->c_nid_niv = 0.;
  ppm->n_nid_niv = 0.;
  ppm->alpha_nid_niv = 0.;
  /** 1.b.2) For tensor perturbations */
  ppm->r = 1.;
  ppm->n_t = -ppm->r/8.*(2.-ppm->r/8.-ppm->n_s);
  ppm->alpha_t = ppm->r/8.*(ppm->r/8.+ppm->n_s-1.);
  /** 1.c) For type 'inflation_V' */
  /** 1.c.2) Coefficients of the Taylor expansion */
  ppm->V0=1.25e-13;
  ppm->V1=-1.12e-14;
  ppm->V2=-6.95e-14;
  ppm->V3=0.;
  ppm->V4=0.;
  /** 1.d) For type 'inflation_H' */
  ppm->H0=3.69e-6;
  ppm->H1=-5.84e-7;
  ppm->H2=0.;
  ppm->H3=0.;
  ppm->H4=0.;
  /** 1.e) For type 'inflation_V_end' */
  /** 1.e.1) Value of the field at the minimum of the potential */
  ppm->phi_end=0.;
  /** 1.e.2) Shape of the potential */
  ppm->potential=polynomial;
  /** 1.e.4) Increase of scale factor or (aH) between Hubble crossing at pivot
      scale and end of inflation */
  ppm->phi_pivot_method = N_star;
  ppm->phi_pivot_target = 60;
  /** 1.e.5) Nomral numerical integration or analytical slow-roll formulas? */
  ppm->behavior=numerical;
  /** 1.g) For type 'external_Pk' */
  /** 1.g.1) Command generating the table */
  ppm->command=NULL;//"write here your command for the external Pk"

  /** 1.g.2) Parameters to be passed to the command */
  ppm->custom1=0.;
  ppm->custom2=0.;
  ppm->custom3=0.;
  ppm->custom4=0.;
  ppm->custom5=0.;
  ppm->custom6=0.;
  ppm->custom7=0.;
  ppm->custom8=0.;
  ppm->custom9=0.;
  ppm->custom10=0.;

  /**
   * Default to input_read_parameters_spectra
   */

  /** 1) Maximum l for CLs */
  ppt->l_scalar_max=2500;
  ppt->l_vector_max=500;
  ppt->l_tensor_max=500;
  ppt->l_lss_max=300;

  /** 2) Parameters for the the matter density number count */
  /** 2.a) Selection functions W(z) of each redshift bin */
  ppt->selection=gaussian;
  ppt->selection_num=1;
  ppt->selection_mean[0]=1.;
  ppt->selection_width[0]=0.1;
  ptr->selection_bias[0]=1.;
  ptr->selection_magnification_bias[0]=0.;
  phr->non_diag=0;
  /** 2.b) Selection function */
  ptr->has_nz_analytic = _FALSE_;
  ptr->has_nz_file = _FALSE_;
  /** 2.c) Source number counts evolution */
  ptr->has_nz_evo_analytic = _FALSE_;
  ptr->has_nz_evo_file = _FALSE_;

  /** 3) Power spectrum P(k) */
  /** 3.a) Maximum k in P(k) */
  ppt->k_max_for_pk=1.;
  /** 3.a) Maximum k in P(k) primordial */
  ppm->has_k_max_for_primordial_pk = _FALSE_;
  /** 3.b) Redshift values */
  pop->z_pk_num = 1;
  pop->z_pk[0] = 0.;
  /** 3.c) Maximum redshift */
  ppt->z_max_pk=0.;

  /**
   * Default to input_read_parameters_lensing
   */

  /** 1) Lensing */
  ple->has_lensed_cls = _FALSE_;

  /** 2) Should the lensed spectra be rescaled? */
  ptr->lcmb_rescale=1.;
  ptr->lcmb_tilt=0.;
  ptr->lcmb_pivot=0.1;
  ppt->want_lcmb_full_limber = _TRUE_;

  /**
   * Default to input_read_parameters_distortions
   */

  /** 1) Branching ratio approximation */
  psd->sd_branching_approx = bra_exact;
  /** 1.a.1) Number of multipoles in PCA expansion */
  psd->sd_PCA_size=2;
  /** 1.a.2) Detector noise file name */
  psd->has_detector_file = _FALSE_;
  /** 1.a.3) Detector name */
  psd->has_user_defined_name = _FALSE_;
  psd->has_user_defined_detector = _FALSE_;
  class_sprintf(psd->sd_detector_name,"PIXIE");
  /** 1.3.a.1) Detector nu min */
  psd->sd_detector_nu_min = 30.;
  /** 1.3.a.2) Detector nu max */
  psd->sd_detector_nu_max = 1005.;
  /** 1.3.a.3) Detector nu delta/bin number */
  psd->sd_detector_nu_delta = 15.;
  psd->sd_detector_bin_number = 65;
  /** 1.3.a.1) Detector noise */
  psd->sd_detector_delta_Ic = 5.e-26;

  /** 2) Only exotic species? */
  psd->include_only_exotic = _FALSE_;

  /** 3) Include g distortion in total calculation? */
  psd->include_g_distortion = _FALSE_;

  /** 4) Additional y or mu parameters? */
  psd->sd_add_y = 0.;
  psd->sd_add_mu = 0.;

  /** 5) Include SZ effect from reionization? */
  psd->has_SZ_effect = _FALSE_;
  /** 5.a) What type of approximation you want to use for the SZ effect? */
  psd->sd_reio_type = sd_reio_Chluba;

  /**
   * Default to input_read_additional
   */

  pth->compute_cb2_derivatives=_FALSE_;

  /**
   * Default to input_read_parameters_output
   */

  /** 1) Output for external files */
  /** 1.a) File name */
  class_sprintf(pop->root,"output/");
  /** 1.b) Headers */
  pop->write_header = _TRUE_;
  /** 1.c) Format */
  pop->output_format = class_format;
  /** 1.d) Background quantities */
  pop->write_background = _FALSE_;
  /** 1.e) Thermodynamics quantities */
  pop->write_thermodynamics = _FALSE_;
  /** 1.f) Table of perturbations for certain wavenumbers k */
  ppt->k_output_values_num=0;
  pop->write_perturbations = _FALSE_;
  ppt->store_perturbations = _FALSE_;
  /** 1.g) Primordial spectra */
  pop->write_primordial = _FALSE_;
  /** 1.h) Exotic energy injection function */
  pop->write_exotic_injection = _FALSE_;
  pop->write_noninjection = _FALSE_;
  /** 1.i) Spectral distortions */
  pop->write_distortions = _FALSE_;


  /** 2) Verbosity */
  pba->background_verbose = 0;
  pth->thermodynamics_verbose = 0;
  pth->hyrec_verbose = 0;
  ppt->perturbations_verbose = 0;
  ptr->transfer_verbose = 0;
  ppm->primordial_verbose = 0;
  phr->harmonic_verbose = 0;
  pfo->fourier_verbose = 0;
  ple->lensing_verbose = 0;
  psd->distortions_verbose = 0;
  pop->output_verbose = 0;

  return _SUCCESS_;

}

```

`source/lensing.c`:

```c
/** @file lensing.c Documented lensing module
 *
 * Simon Prunet and Julien Lesgourgues, 6.12.2010
 *
 * This module computes the lensed temperature and polarization
 * anisotropy power spectra \f$ C_l^{X}, P(k), ... \f$'s given the
 * unlensed temperature, polarization and lensing potential spectra.
 *
 * Follows Challinor and Lewis full-sky method, astro-ph/0502425
 *
 * The following functions can be called from other modules:
 *
 * -# lensing_init() at the beginning (but after harmonic_init())
 * -# lensing_cl_at_l() at any time for computing Cl_lensed at any l
 * -# lensing_free() at the end
 */

#include "lensing.h"
#include <time.h>
#include "parallel.h"

/**
 * Anisotropy power spectra \f$ C_l\f$'s for all types, modes and initial conditions.
 * SO FAR: ONLY SCALAR
 *
 * This routine evaluates all the lensed \f$ C_l\f$'s at a given value of l by
 * picking it in the pre-computed table. When relevant, it also
 * sums over all initial conditions for each mode, and over all modes.
 *
 * This function can be called from whatever module at whatever time,
 * provided that lensing_init() has been called before, and
 * lensing_free() has not been called yet.
 *
 * @param ple        Input: pointer to lensing structure
 * @param l          Input: multipole number
 * @param cl_lensed  Output: lensed \f$ C_l\f$'s for all types (TT, TE, EE, etc..)
 * @return the error status
 */

int lensing_cl_at_l(
                    struct lensing * ple,
                    int l,
                    double * cl_lensed    /* array with argument cl_lensed[index_ct] (must be already allocated) */
                    ) {
  int last_index;
  int index_lt;

  class_test(l > ple->l_lensed_max,
             ple->error_message,
             "you asked for lensed Cls at l=%d, they were computed only up to l=%d, you should increase l_max_scalars or decrease the precision parameter delta_l_max",l,ple->l_lensed_max);

  class_call(array_interpolate_spline(ple->l,
                                      ple->l_size,
                                      ple->cl_lens,
                                      ple->ddcl_lens,
                                      ple->lt_size,
                                      l,
                                      &last_index,
                                      cl_lensed,
                                      ple->lt_size,
                                      ple->error_message),
             ple->error_message,
             ple->error_message);

  /* set to zero for the types such that l<l_max */
  for (index_lt=0; index_lt<ple->lt_size; index_lt++)
    if ((int)l > ple->l_max_lt[index_lt])
      cl_lensed[index_lt]=0.;

  return _SUCCESS_;
}

/**
 * This routine initializes the lensing structure (in particular,
 * computes table of lensed anisotropy spectra \f$ C_l^{X} \f$)
 *
 * @param ppr Input: pointer to precision structure
 * @param ppt Input: pointer to perturbation structure (just in case, not used in current version...)
 * @param phr Input: pointer to harmonic structure
 * @param pfo Input: pointer to fourier structure
 * @param ple Output: pointer to initialized lensing structure
 * @return the error status
 */

int lensing_init(
                 struct precision * ppr,
                 struct perturbations * ppt,
                 struct harmonic * phr,
                 struct fourier * pfo,
                 struct lensing * ple
                 ) {

  /** Summary: */
  /** - Define local variables */

  double * mu; /* mu[index_mu]: discretized values of mu
                  between -1 and 1, roots of Legendre polynomial */
  double * w8; /* Corresponding Gauss-Legendre quadrature weights */
  double theta,delta_theta;

  double ** d00;  /* dmn[index_mu][index_l] */
  double ** d11;
  double ** d2m2;
  double ** d22 = NULL;
  double ** d20 = NULL;
  double ** d1m1;
  double ** d31 = NULL;
  double ** d40 = NULL;
  double ** d3m1 = NULL;
  double ** d3m3 = NULL;
  double ** d4m2 = NULL;
  double ** d4m4 = NULL;
  double * buf_dxx; /* buffer */

  double * Cgl;   /* Cgl[index_mu] */
  double * Cgl2;  /* Cgl2[index_mu] */
  double * sigma2; /* sigma[index_mu] */

  double * ksi = NULL;  /* ksi[index_mu] */
  double * ksiX = NULL;  /* ksiX[index_mu] */
  double * ksip = NULL;  /* ksip[index_mu] */
  double * ksim = NULL;  /* ksim[index_mu] */

  int num_mu,index_mu,icount;
  int l;
  double ll;
  double * cl_unlensed;  /* cl_unlensed[index_ct] */
  double * cl_tt; /* unlensed  cl, to be filled to avoid repeated calls to harmonic_cl_at_l */
  double * cl_te = NULL; /* unlensed  cl, to be filled to avoid repeated calls to harmonic_cl_at_l */
  double * cl_ee = NULL; /* unlensed  cl, to be filled to avoid repeated calls to harmonic_cl_at_l */
  double * cl_bb = NULL; /* unlensed  cl, to be filled to avoid repeated calls to harmonic_cl_at_l */
  double * cl_pp; /* potential cl, to be filled to avoid repeated calls to harmonic_cl_at_l */

  double * sqrt1;
  double * sqrt2;
  double * sqrt3;
  double * sqrt4;
  double * sqrt5;

  double ** cl_md_ic; /* array with argument
                         cl_md_ic[index_md][index_ic1_ic2*phr->ct_size+index_ct] */

  double ** cl_md;    /* array with argument
                         cl_md[index_md][index_ct] */

  int index_md;

  /* Timing */
  //double debut, fin;
  //double cpu_time;

  /** - check that we really want to compute at least one spectrum */

  if (ple->has_lensed_cls == _FALSE_) {
    if (ple->lensing_verbose > 0)
      printf("No lensing requested. Lensing module skipped.\n");
    return _SUCCESS_;
  }
  else {
    if (ple->lensing_verbose > 0) {
      printf("Computing lensed spectra ");
      if (ppr->accurate_lensing==_TRUE_)
        printf("(accurate mode)\n");
      else
        printf("(fast mode)\n");
    }
  }

  /** - initialize indices and allocate some of the arrays in the
      lensing structure */

  class_call(lensing_indices(ppr,phr,ple),
             ple->error_message,
             ple->error_message);

  /** - put all precision variables hare; will be stored later in precision structure */
  /** - Last element in \f$ \mu \f$ will be for \f$ \mu=1 \f$, needed for sigma2.
      The rest will be chosen as roots of a Gauss-Legendre quadrature **/

  if (ppr->accurate_lensing == _TRUE_) {
    num_mu=(ple->l_unlensed_max+ppr->num_mu_minus_lmax); /* Must be even ?? CHECK */
    num_mu += num_mu%2; /* Force it to be even */
  } else {
    /* Integrate correlation function difference on [0,pi/16] */
    num_mu = (ple->l_unlensed_max * 2 )/16;
  }
  /** - allocate array of \f$ \mu \f$ values, as well as quadrature weights */

  class_alloc(mu,
              num_mu*sizeof(double),
              ple->error_message);
  /* Reserve last element of mu for mu=1, needed for sigma2 */
  mu[num_mu-1] = 1.0;

  class_alloc(w8,
              (num_mu-1)*sizeof(double),
              ple->error_message);

  if (ppr->accurate_lensing == _TRUE_) {

    //debut = omp_get_wtime();
    class_call(quadrature_gauss_legendre(mu,
                                         w8,
                                         num_mu-1,
                                         ppr->tol_gauss_legendre,
                                         ple->error_message),
               ple->error_message,
               ple->error_message);
    //fin = omp_get_wtime();
    //cpu_time = (fin-debut);
    //printf("time in quadrature_gauss_legendre=%4.3f s\n",cpu_time);

  } else { /* Crude integration on [0,pi/16]: Riemann sum on theta */

    delta_theta = _PI_/16. / (double)(num_mu-1);
    for (index_mu=0;index_mu<num_mu-1;index_mu++) {
      theta = (index_mu+1)*delta_theta;
      mu[index_mu] = cos(theta);
      w8[index_mu] = sin(theta)*delta_theta; /* We integrate on mu */
    }
  }

  /** - Compute \f$ d^l_{mm'} (\mu) \f$*/

  icount = 0;
  class_alloc(d00,
              num_mu*sizeof(double*),
              ple->error_message);

  class_alloc(d11,
              num_mu*sizeof(double*),
              ple->error_message);

  class_alloc(d1m1,
              num_mu*sizeof(double*),
              ple->error_message);

  class_alloc(d2m2,
              num_mu*sizeof(double*),
              ple->error_message);
  icount += 4*num_mu*(ple->l_unlensed_max+1);

  if (ple->has_te==_TRUE_) {

    class_alloc(d20,
                num_mu*sizeof(double*),
                ple->error_message);

    class_alloc(d3m1,
                num_mu*sizeof(double*),
                ple->error_message);

    class_alloc(d4m2,
                num_mu*sizeof(double*),
                ple->error_message);
    icount += 3*num_mu*(ple->l_unlensed_max+1);
  }

  if (ple->has_ee==_TRUE_ || ple->has_bb==_TRUE_) {

    class_alloc(d22,
                num_mu*sizeof(double*),
                ple->error_message);

    class_alloc(d31,
                num_mu*sizeof(double*),
                ple->error_message);

    class_alloc(d3m3,
                num_mu*sizeof(double*),
                ple->error_message);

    class_alloc(d40,
                num_mu*sizeof(double*),
                ple->error_message);

    class_alloc(d4m4,
                num_mu*sizeof(double*),
                ple->error_message);
    icount += 5*num_mu*(ple->l_unlensed_max+1);
  }

  icount += 5*(ple->l_unlensed_max+1); /* for arrays sqrt1[l] to sqrt5[l] */

  /** - Allocate main contiguous buffer **/
  class_alloc(buf_dxx,
              icount * sizeof(double),
              ple->error_message);

  icount = 0;
  for (index_mu=0; index_mu<num_mu; index_mu++) {

    d00[index_mu] = &(buf_dxx[icount+index_mu            * (ple->l_unlensed_max+1)]);
    d11[index_mu] = &(buf_dxx[icount+(index_mu+num_mu)   * (ple->l_unlensed_max+1)]);
    d1m1[index_mu]= &(buf_dxx[icount+(index_mu+2*num_mu) * (ple->l_unlensed_max+1)]);
    d2m2[index_mu]= &(buf_dxx[icount+(index_mu+3*num_mu) * (ple->l_unlensed_max+1)]);
  }
  icount += 4*num_mu*(ple->l_unlensed_max+1);

  if (ple->has_te==_TRUE_) {
    for (index_mu=0; index_mu<num_mu; index_mu++) {
      d20[index_mu] = &(buf_dxx[icount+index_mu            * (ple->l_unlensed_max+1)]);
      d3m1[index_mu]= &(buf_dxx[icount+(index_mu+num_mu)   * (ple->l_unlensed_max+1)]);
      d4m2[index_mu]= &(buf_dxx[icount+(index_mu+2*num_mu) * (ple->l_unlensed_max+1)]);
    }
    icount += 3*num_mu*(ple->l_unlensed_max+1);
  }

  if (ple->has_ee==_TRUE_ || ple->has_bb==_TRUE_) {

    for (index_mu=0; index_mu<num_mu; index_mu++) {
      d22[index_mu] = &(buf_dxx[icount+index_mu            * (ple->l_unlensed_max+1)]);
      d31[index_mu] = &(buf_dxx[icount+(index_mu+num_mu)   * (ple->l_unlensed_max+1)]);
      d3m3[index_mu]= &(buf_dxx[icount+(index_mu+2*num_mu) * (ple->l_unlensed_max+1)]);
      d40[index_mu] = &(buf_dxx[icount+(index_mu+3*num_mu) * (ple->l_unlensed_max+1)]);
      d4m4[index_mu]= &(buf_dxx[icount+(index_mu+4*num_mu) * (ple->l_unlensed_max+1)]);
    }
    icount += 5*num_mu*(ple->l_unlensed_max+1);
  }

  sqrt1 = &(buf_dxx[icount]);
  icount += ple->l_unlensed_max+1;
  sqrt2 = &(buf_dxx[icount]);
  icount += ple->l_unlensed_max+1;
  sqrt3 = &(buf_dxx[icount]);
  icount += ple->l_unlensed_max+1;
  sqrt4 = &(buf_dxx[icount]);
  icount += ple->l_unlensed_max+1;
  sqrt5 = &(buf_dxx[icount]);
  icount += ple->l_unlensed_max+1;

  //debut = omp_get_wtime();
  class_call(lensing_d00(mu,num_mu,ple->l_unlensed_max,d00),
             ple->error_message,
             ple->error_message);

  class_call(lensing_d11(mu,num_mu,ple->l_unlensed_max,d11),
             ple->error_message,
             ple->error_message);

  class_call(lensing_d1m1(mu,num_mu,ple->l_unlensed_max,d1m1),
             ple->error_message,
             ple->error_message);

  class_call(lensing_d2m2(mu,num_mu,ple->l_unlensed_max,d2m2),
             ple->error_message,
             ple->error_message);
  //fin = omp_get_wtime();
  //cpu_time = (fin-debut);
  //printf("time in lensing_dxx=%4.3f s\n",cpu_time);


  if (ple->has_te==_TRUE_) {

    class_call(lensing_d20(mu,num_mu,ple->l_unlensed_max,d20),
               ple->error_message,
               ple->error_message);

    class_call(lensing_d3m1(mu,num_mu,ple->l_unlensed_max,d3m1),
               ple->error_message,
               ple->error_message);

    class_call(lensing_d4m2(mu,num_mu,ple->l_unlensed_max,d4m2),
               ple->error_message,
               ple->error_message);

  }

  if (ple->has_ee==_TRUE_ || ple->has_bb==_TRUE_) {

    class_call(lensing_d22(mu,num_mu,ple->l_unlensed_max,d22),
               ple->error_message,
               ple->error_message);

    class_call(lensing_d31(mu,num_mu,ple->l_unlensed_max,d31),
               ple->error_message,
               ple->error_message);

    class_call(lensing_d3m3(mu,num_mu,ple->l_unlensed_max,d3m3),
               ple->error_message,
               ple->error_message);

    class_call(lensing_d40(mu,num_mu,ple->l_unlensed_max,d40),
               ple->error_message,
               ple->error_message);

    class_call(lensing_d4m4(mu,num_mu,ple->l_unlensed_max,d4m4),
               ple->error_message,
               ple->error_message);
  }

  /** - compute \f$ Cgl(\mu)\f$, \f$ Cgl2(\mu) \f$ and sigma2(\f$\mu\f$) */

  class_alloc(Cgl,
              num_mu*sizeof(double),
              ple->error_message);

  class_alloc(Cgl2,
              num_mu*sizeof(double),
              ple->error_message);

  class_alloc(sigma2,
              (num_mu-1)*sizeof(double), /* Zero separation is omitted */
              ple->error_message);

  class_alloc(cl_unlensed,
              phr->ct_size*sizeof(double),
              ple->error_message);


  /** - Locally store unlensed temperature \f$ cl_{tt}\f$ and potential \f$ cl_{pp}\f$ spectra **/
  class_alloc(cl_tt,
              (ple->l_unlensed_max+1)*sizeof(double),
              ple->error_message);
  if (ple->has_te==_TRUE_) {
    class_alloc(cl_te,
                (ple->l_unlensed_max+1)*sizeof(double),
                ple->error_message);
  }
  if (ple->has_ee==_TRUE_ || ple->has_bb==_TRUE_) {
    class_alloc(cl_ee,
                (ple->l_unlensed_max+1)*sizeof(double),
                ple->error_message);

    class_alloc(cl_bb,
                (ple->l_unlensed_max+1)*sizeof(double),
                ple->error_message);
  }
  class_alloc(cl_pp,
              (ple->l_unlensed_max+1)*sizeof(double),
              ple->error_message);

  class_alloc(cl_md_ic,
              phr->md_size*sizeof(double *),
              ple->error_message);

  class_alloc(cl_md,
              phr->md_size*sizeof(double *),
              ple->error_message);

  for (index_md = 0; index_md < phr->md_size; index_md++) {

    if (phr->md_size > 1)

      class_alloc(cl_md[index_md],
                  phr->ct_size*sizeof(double),
                  ple->error_message);

    if (phr->ic_size[index_md] > 1)

      class_alloc(cl_md_ic[index_md],
                  phr->ic_ic_size[index_md]*phr->ct_size*sizeof(double),
                  ple->error_message);
  }

  for (l=2; l<=ple->l_unlensed_max; l++) {
    class_call(harmonic_cl_at_l(phr,l,cl_unlensed,cl_md,cl_md_ic),
               phr->error_message,
               ple->error_message);
    cl_tt[l] = cl_unlensed[ple->index_lt_tt];
    cl_pp[l] = cl_unlensed[ple->index_lt_pp];
    if (ple->has_te==_TRUE_) {
      cl_te[l] = cl_unlensed[ple->index_lt_te];
    }
    if (ple->has_ee==_TRUE_ || ple->has_bb==_TRUE_) {
      cl_ee[l] = cl_unlensed[ple->index_lt_ee];
      cl_bb[l] = cl_unlensed[ple->index_lt_bb];
    }
  }

  for (index_md = 0; index_md < phr->md_size; index_md++) {

    if (phr->md_size > 1)
      free(cl_md[index_md]);

    if (phr->ic_size[index_md] > 1)
      free(cl_md_ic[index_md]);

  }

  free(cl_md_ic);
  free(cl_md);

  /** - Compute sigma2\f$(\mu)\f$ and Cgl2(\f$\mu\f$) **/

  class_setup_parallel();

  for (index_mu=0; index_mu<num_mu; index_mu++) {

    int l_unlensed_max;
    l_unlensed_max = ple->l_unlensed_max;
    class_run_parallel(with_arguments(index_mu,l_unlensed_max,Cgl,Cgl2,cl_pp,d11,d1m1),
      int l;

      Cgl[index_mu]=0;
      Cgl2[index_mu]=0;

      for (l=2; l<=l_unlensed_max; l++) {

        Cgl[index_mu] += (2.*l+1.)*l*(l+1.)*
          cl_pp[l]*d11[index_mu][l];

        Cgl2[index_mu] += (2.*l+1.)*l*(l+1.)*
          cl_pp[l]*d1m1[index_mu][l];

      }

      Cgl[index_mu] /= 4.*_PI_;
      Cgl2[index_mu] /= 4.*_PI_;
      return _SUCCESS_;
    );

  }

  class_finish_parallel();

  for (index_mu=0; index_mu<num_mu-1; index_mu++) {
    /* Cgl(1.0) - Cgl(mu) */
    sigma2[index_mu] = Cgl[num_mu-1] - Cgl[index_mu];
  }
  //fin = omp_get_wtime();
  //cpu_time = (fin-debut);
  //printf("time in Cgl,Cgl2,sigma2=%4.3f s\n",cpu_time);


  /** - compute ksi, ksi+, ksi-, ksiX */

  /** - --> ksi is for TT **/
  if (ple->has_tt==_TRUE_) {

    class_calloc(ksi,
                 (num_mu-1),
                 sizeof(double),
                 ple->error_message);
  }

  /** - --> ksiX is for TE **/
  if (ple->has_te==_TRUE_) {

    class_calloc(ksiX,
                 (num_mu-1),
                 sizeof(double),
                 ple->error_message);
  }

  /** - --> ksip, ksim for EE, BB **/
  if (ple->has_ee==_TRUE_ || ple->has_bb==_TRUE_) {

    class_calloc(ksip,
                 (num_mu-1),
                 sizeof(double),
                 ple->error_message);

    class_calloc(ksim,
                 (num_mu-1),
                 sizeof(double),
                 ple->error_message);
  }

  for (l=2;l<=ple->l_unlensed_max;l++) {

    ll = (double)l;
    sqrt1[l]=sqrt((ll+2)*(ll+1)*ll*(ll-1));
    sqrt2[l]=sqrt((ll+2)*(ll-1));
    sqrt3[l]=sqrt((ll+3)*(ll-2));
    sqrt4[l]=sqrt((ll+4)*(ll+3)*(ll-2.)*(ll-3));
    sqrt5[l]=sqrt(ll*(ll+1));
  }

  for (index_mu=0;index_mu<num_mu-1;index_mu++) {

    // = means that all dependencies are captured.
    class_run_parallel(=,

    int l;
    double declare_list_of_variables_inside_parallel_region(ll,fac, fac1, X_000, X_p000, X_220,X_022,X_p022,X_121,X_132,X_242);
    double declare_list_of_variables_inside_parallel_region(res,resX,resp,resm,lens,lensp,lensm);
    for (l=2;l<=ple->l_unlensed_max;l++) {

      ll = (double)l;

      fac = ll*(ll+1)/4.;
      fac1 = (2*ll+1)/(4.*_PI_);

      /* In the following we will keep terms of the form (sigma2)^k*(Cgl2)^m
         with k+m <= 2 */

      X_000 = exp(-fac*sigma2[index_mu]);
      X_p000 = -fac*X_000;
      /* X_220 = 0.25*sqrt1[l] * exp(-(fac-0.5)*sigma2[index_mu]); */
      X_220 = 0.25*sqrt1[l] * X_000; /* Order 0 */
      /* next 5 lines useless, but avoid compiler warning 'may be used uninitialized' */
      X_242=0.;
      X_132=0.;
      X_121=0.;
      X_p022=0.;
      X_022=0.;

      if (ple->has_te==_TRUE_ || ple->has_ee==_TRUE_ || ple->has_bb==_TRUE_) {
        /* X_022 = exp(-(fac-1.)*sigma2[index_mu]); */
        X_022 = X_000 * (1+sigma2[index_mu]*(1+0.5*sigma2[index_mu])); /* Order 2 */
        X_p022 = -(fac-1.)*X_022; /* Old versions were missing the
                                     minus sign in this line, which introduced a very small error
                                     on the high-l C_l^TE lensed spectrum [credits for bug fix:
                                     Selim Hotinli] */

        /* X_242 = 0.25*sqrt4[l] * exp(-(fac-5./2.)*sigma2[index_mu]); */
        X_242 = 0.25*sqrt4[l] * X_000; /* Order 0 */
        if (ple->has_ee==_TRUE_ || ple->has_bb==_TRUE_) {

          /* X_121 = - 0.5*sqrt2[l] * exp(-(fac-2./3.)*sigma2[index_mu]);
             X_132 = - 0.5*sqrt3[l] * exp(-(fac-5./3.)*sigma2[index_mu]); */
          X_121 = -0.5*sqrt2[l] * X_000 * (1+2./3.*sigma2[index_mu]); /* Order 1 */
          X_132 = -0.5*sqrt3[l] * X_000 * (1+5./3.*sigma2[index_mu]); /* Order 1 */
        }
      }


      if (ple->has_tt==_TRUE_) {

        res = fac1*cl_tt[l];

        lens = (X_000*X_000*d00[index_mu][l] +
                X_p000*X_p000*d1m1[index_mu][l]
                *Cgl2[index_mu]*8./(ll*(ll+1)) +
                (X_p000*X_p000*d00[index_mu][l] +
                 X_220*X_220*d2m2[index_mu][l])
                *Cgl2[index_mu]*Cgl2[index_mu]);
        if (ppr->accurate_lensing == _FALSE_) {
          /* Remove unlensed correlation function */
          lens -= d00[index_mu][l];
        }
        res *= lens;
        ksi[index_mu] += res;
      }

      if (ple->has_te==_TRUE_) {

        resX = fac1*cl_te[l];


        lens = ( X_022*X_000*d20[index_mu][l] +
                 Cgl2[index_mu]*2.*X_p000/sqrt5[l] *
                 (X_121*d11[index_mu][l] + X_132*d3m1[index_mu][l]) +
                 0.5 * Cgl2[index_mu] * Cgl2[index_mu] *
                 ( ( 2.*X_p022*X_p000+X_220*X_220 ) *
                   d20[index_mu][l] + X_220*X_242*d4m2[index_mu][l] ) );
        if (ppr->accurate_lensing == _FALSE_) {
          lens -= d20[index_mu][l];
        }
        resX *= lens;
        ksiX[index_mu] += resX;
      }

      if (ple->has_ee==_TRUE_ || ple->has_bb==_TRUE_) {

        resp = fac1*(cl_ee[l]+cl_bb[l]);
        resm = fac1*(cl_ee[l]-cl_bb[l]);

        lensp = ( X_022*X_022*d22[index_mu][l] +
                  2.*Cgl2[index_mu]*X_132*X_121*d31[index_mu][l] +
                  Cgl2[index_mu]*Cgl2[index_mu] *
                  ( X_p022*X_p022*d22[index_mu][l] +
                    X_242*X_220*d40[index_mu][l] ) );

        lensm = ( X_022*X_022*d2m2[index_mu][l] +
                  Cgl2[index_mu] *
                  ( X_121*X_121*d1m1[index_mu][l] +
                    X_132*X_132*d3m3[index_mu][l] ) +
                  0.5 * Cgl2[index_mu] * Cgl2[index_mu] *
                  ( 2.*X_p022*X_p022*d2m2[index_mu][l] +
                    X_220*X_220*d00[index_mu][l] +
                    X_242*X_242*d4m4[index_mu][l] ) );
        if (ppr->accurate_lensing == _FALSE_) {
          lensp -= d22[index_mu][l];
          lensm -= d2m2[index_mu][l];
        }
        resp *= lensp;
        resm *= lensm;
        ksip[index_mu] += resp;
        ksim[index_mu] += resm;
      }
    }
    return _SUCCESS_;

    );
  }

  class_finish_parallel();
  //fin = omp_get_wtime();
  //cpu_time = (fin-debut);
  //printf("time in ksi=%4.3f s\n",cpu_time);


  /** - compute lensed \f$ C_l\f$'s by integration */
  //debut = omp_get_wtime();
  if (ple->has_tt==_TRUE_) {
    class_call(lensing_lensed_cl_tt(ksi,d00,w8,num_mu-1,ple),
               ple->error_message,
               ple->error_message);
    if (ppr->accurate_lensing == _FALSE_) {
      class_call(lensing_addback_cl_tt(ple,cl_tt),
                 ple->error_message,
                 ple->error_message);
    }
  }

  if (ple->has_te==_TRUE_) {
    class_call(lensing_lensed_cl_te(ksiX,d20,w8,num_mu-1,ple),
               ple->error_message,
               ple->error_message);
    if (ppr->accurate_lensing == _FALSE_) {
      class_call(lensing_addback_cl_te(ple,cl_te),
                 ple->error_message,
                 ple->error_message);
    }
  }

  if (ple->has_ee==_TRUE_ || ple->has_bb==_TRUE_) {

    class_call(lensing_lensed_cl_ee_bb(ksip,ksim,d22,d2m2,w8,num_mu-1,ple),
               ple->error_message,
               ple->error_message);
    if (ppr->accurate_lensing == _FALSE_) {
      class_call(lensing_addback_cl_ee_bb(ple,cl_ee,cl_bb),
                 ple->error_message,
                 ple->error_message);
    }
  }
  //fin=omp_get_wtime();
  //cpu_time = (fin-debut);
  //printf("time in final lensing computation=%4.3f s\n",cpu_time);

  /** - spline computed \f$ C_l\f$'s in view of interpolation */

  class_call(array_spline_table_lines(ple->l,
                                      ple->l_size,
                                      ple->cl_lens,
                                      ple->lt_size,
                                      ple->ddcl_lens,
                                      _SPLINE_EST_DERIV_,
                                      ple->error_message),
             ple->error_message,
             ple->error_message);

  /** - Free lots of stuff **/
  free(buf_dxx);

  free(d00);
  free(d11);
  free(d1m1);
  free(d2m2);
  if (ple->has_te==_TRUE_) {
    free(d20);
    free(d3m1);
    free(d4m2);
  }
  if (ple->has_ee==_TRUE_ || ple->has_bb==_TRUE_) {
    free(d22);
    free(d31);
    free(d3m3);
    free(d40);
    free(d4m4);
  }

  if (ple->has_tt==_TRUE_)
    free(ksi);
  if (ple->has_te==_TRUE_)
    free(ksiX);
  if (ple->has_ee==_TRUE_ || ple->has_bb==_TRUE_) {
    free(ksip);
    free(ksim);
  }
  free(Cgl);
  free(Cgl2);
  free(sigma2);

  free(mu);
  free(w8);

  free(cl_unlensed);
  free(cl_tt);
  if (ple->has_te==_TRUE_)
    free(cl_te);
  if (ple->has_ee==_TRUE_ || ple->has_bb==_TRUE_) {
    free(cl_ee);
    free(cl_bb);
  }
  free(cl_pp);
  /** - Exit **/

  ple->is_allocated = _TRUE_;

  return _SUCCESS_;

}

/**
 * This routine frees all the memory space allocated by lensing_init().
 *
 * To be called at the end of each run, only when no further calls to
 * lensing_cl_at_l() are needed.
 *
 * @param ple Input: pointer to lensing structure (which fields must be freed)
 * @return the error status
 */

int lensing_free(
                 struct lensing * ple
                 ) {

  if (ple->has_lensed_cls == _TRUE_) {

    free(ple->l);
    free(ple->cl_lens);
    free(ple->ddcl_lens);
    free(ple->l_max_lt);

  }

  ple->is_allocated = _FALSE_;

  return _SUCCESS_;

}

/**
 * This routine defines indices and allocates tables in the lensing structure
 *
 * @param ppr  Input: pointer to precision structure
 * @param phr  Input: pointer to harmonic structure
 * @param ple  Input/output: pointer to lensing structure
 * @return the error status
 */

int lensing_indices(
                    struct precision * ppr,
                    struct harmonic * phr,
                    struct lensing * ple
                    ){

  int index_l;

  double ** cl_md_ic; /* array with argument
                         cl_md_ic[index_md][index_ic1_ic2*phr->ct_size+index_ct] */

  double ** cl_md;    /* array with argument
                         cl_md[index_md][index_ct] */

  int index_md;
  int index_lt;

  /* indices of all Cl types (lensed and unlensed) */

  if (phr->has_tt == _TRUE_) {
    ple->has_tt = _TRUE_;
    ple->index_lt_tt=phr->index_ct_tt;
  }
  else {
    ple->has_tt = _FALSE_;
  }

  if (phr->has_ee == _TRUE_) {
    ple->has_ee = _TRUE_;
    ple->index_lt_ee=phr->index_ct_ee;
  }
  else {
    ple->has_ee = _FALSE_;
  }

  if (phr->has_te == _TRUE_) {
    ple->has_te = _TRUE_;
    ple->index_lt_te=phr->index_ct_te;
  }
  else {
    ple->has_te = _FALSE_;
  }

  if (phr->has_bb == _TRUE_) {
    ple->has_bb = _TRUE_;
    ple->index_lt_bb=phr->index_ct_bb;
  }
  else {
    ple->has_bb = _FALSE_;
  }

  if (phr->has_pp == _TRUE_) {
    ple->has_pp = _TRUE_;
    ple->index_lt_pp=phr->index_ct_pp;
  }
  else {
    ple->has_pp = _FALSE_;
  }

  if (phr->has_tp == _TRUE_) {
    ple->has_tp = _TRUE_;
    ple->index_lt_tp=phr->index_ct_tp;
  }
  else {
    ple->has_tp = _FALSE_;
  }

  if (phr->has_dd == _TRUE_) {
    ple->has_dd = _TRUE_;
    ple->index_lt_dd=phr->index_ct_dd;
  }
  else {
    ple->has_dd = _FALSE_;
  }

  if (phr->has_td == _TRUE_) {
    ple->has_td = _TRUE_;
    ple->index_lt_td=phr->index_ct_td;
  }
  else {
    ple->has_td = _FALSE_;
  }

  if (phr->has_ll == _TRUE_) {
    ple->has_ll = _TRUE_;
    ple->index_lt_ll=phr->index_ct_ll;
  }
  else {
    ple->has_ll = _FALSE_;
  }

  if (phr->has_tl == _TRUE_) {
    ple->has_tl = _TRUE_;
    ple->index_lt_tl=phr->index_ct_tl;
  }
  else {
    ple->has_tl = _FALSE_;
  }

  ple->lt_size = phr->ct_size;

  /* number of multipoles */

  ple->l_unlensed_max = phr->l_max_tot;

  ple->l_lensed_max = ple->l_unlensed_max - ppr->delta_l_max;

  for (index_l=0; (index_l < phr->l_size_max) && (phr->l[index_l] <= ple->l_lensed_max); index_l++);

  if (index_l < phr->l_size_max) index_l++; /* one more point in order to be able to interpolate till ple->l_lensed_max */

  ple->l_size = index_l+1;

  class_alloc(ple->l,ple->l_size*sizeof(double),ple->error_message);

  for (index_l=0; index_l < ple->l_size; index_l++) {

    ple->l[index_l] = phr->l[index_l];

  }

  /* allocate table where results will be stored */

  class_alloc(ple->cl_lens,
              ple->l_size*ple->lt_size*sizeof(double),
              ple->error_message);

  class_alloc(ple->ddcl_lens,
              ple->l_size*ple->lt_size*sizeof(double),
              ple->error_message);

  /* fill with unlensed cls */

  class_alloc(cl_md_ic,
              phr->md_size*sizeof(double *),
              ple->error_message);

  class_alloc(cl_md,
              phr->md_size*sizeof(double *),
              ple->error_message);

  for (index_md = 0; index_md < phr->md_size; index_md++) {

    if (phr->md_size > 1)

      class_alloc(cl_md[index_md],
                  phr->ct_size*sizeof(double),
                  ple->error_message);

    if (phr->ic_size[index_md] > 1)

      class_alloc(cl_md_ic[index_md],
                  phr->ic_ic_size[index_md]*phr->ct_size*sizeof(double),
                  ple->error_message);
  }

  for (index_l=0; index_l<ple->l_size; index_l++) {

    class_call(harmonic_cl_at_l(phr,ple->l[index_l],&(ple->cl_lens[index_l*ple->lt_size]),cl_md,cl_md_ic),
               phr->error_message,
               ple->error_message);

  }

  for (index_md = 0; index_md < phr->md_size; index_md++) {

    if (phr->md_size > 1)
      free(cl_md[index_md]);

    if (phr->ic_size[index_md] > 1)
      free(cl_md_ic[index_md]);

  }

  free(cl_md_ic);
  free(cl_md);

  /* we want to output Cl_lensed up to the same l_max as Cl_unlensed
     (even if a number delta_l_max of extra values of l have been used
     internally for more accurate results). Notable exception to the
     above rule: ClBB_lensed(scalars) must be outputed at least up to the same l_max as
     ClEE_unlensed(scalars) (since ClBB_unlensed is null for scalars)
  */

  class_alloc(ple->l_max_lt,ple->lt_size*sizeof(double),ple->error_message);
  for (index_lt = 0; index_lt < ple->lt_size; index_lt++) {
    ple->l_max_lt[index_lt]=0.;
    for (index_md = 0; index_md < phr->md_size; index_md++) {
      ple->l_max_lt[index_lt]=MAX(ple->l_max_lt[index_lt],phr->l_max_ct[index_md][index_lt]);

      if ((ple->has_bb == _TRUE_) && (ple->has_ee == _TRUE_) && (index_lt == ple->index_lt_bb)) {
        ple->l_max_lt[index_lt]=MAX(ple->l_max_lt[index_lt],phr->l_max_ct[index_md][ple->index_lt_ee]);
      }

    }
  }

  return _SUCCESS_;

}

/**
 * This routine computes the lensed power spectra by Gaussian quadrature
 *
 * @param ksi  Input: Lensed correlation function (ksi[index_mu])
 * @param d00  Input: Legendre polynomials (\f$ d^l_{00}\f$[l][index_mu])
 * @param w8   Input: Legendre quadrature weights (w8[index_mu])
 * @param nmu  Input: Number of quadrature points (0<=index_mu<=nmu)
 * @param ple  Input/output: Pointer to the lensing structure
 * @return the error status
 */


int lensing_lensed_cl_tt(
                         double *ksi,
                         double **d00,
                         double *w8,
                         int nmu,
                         struct lensing * ple
                         ) {

  int index_l;

  /** Integration by Gauss-Legendre quadrature. **/
  class_setup_parallel();

  for (index_l=0; index_l<ple->l_size; index_l++){
    class_run_parallel(=,
      double cle;
      int imu;
      cle=0;
      for (imu=0;imu<nmu;imu++) {
        cle += ksi[imu]*d00[imu][(int)ple->l[index_l]]*w8[imu]; /* loop could be optimized */
      }
      ple->cl_lens[index_l*ple->lt_size+ple->index_lt_tt]=cle*2.0*_PI_;
      return _SUCCESS_;
    );
  }

  class_finish_parallel();

  return _SUCCESS_;
}

/**
 * This routine adds back the unlensed \f$ cl_{tt}\f$ power spectrum
 * Used in case of fast (and BB inaccurate) integration of
 * correlation functions.
 *
 * @param ple   Input/output: Pointer to the lensing structure
 * @param cl_tt Input: Array of unlensed power spectrum
 * @return the error status
 */

int lensing_addback_cl_tt(
                          struct lensing * ple,
                          double *cl_tt) {
  int index_l, l;

  for (index_l=0; index_l<ple->l_size; index_l++) {
    l = (int)ple->l[index_l];
    ple->cl_lens[index_l*ple->lt_size+ple->index_lt_tt] += cl_tt[l];
  }
  return _SUCCESS_;

}

/**
 * This routine computes the lensed power spectra by Gaussian quadrature
 *
 * @param ksiX Input: Lensed correlation function (ksiX[index_mu])
 * @param d20  Input: Wigner d-function (\f$ d^l_{20}\f$[l][index_mu])
 * @param w8   Input: Legendre quadrature weights (w8[index_mu])
 * @param nmu  Input: Number of quadrature points (0<=index_mu<=nmu)
 * @param ple  Input/output: Pointer to the lensing structure
 * @return the error status
 */


int lensing_lensed_cl_te(
                         double *ksiX,
                         double **d20,
                         double *w8,
                         int nmu,
                         struct lensing * ple
                         ) {

  int index_l;

  /** Integration by Gauss-Legendre quadrature. **/
  class_setup_parallel();

  for (index_l=0; index_l < ple->l_size; index_l++){
    class_run_parallel(=,
      double clte;
      int imu;
      clte=0;
      for (imu=0;imu<nmu;imu++) {
        clte += ksiX[imu]*d20[imu][(int)ple->l[index_l]]*w8[imu]; /* loop could be optimized */
      }
      ple->cl_lens[index_l*ple->lt_size+ple->index_lt_te]=clte*2.0*_PI_;
      return _SUCCESS_;
    );
  }

  class_finish_parallel();
  return _SUCCESS_;
}

/**
 * This routine adds back the unlensed \f$ cl_{te}\f$ power spectrum
 * Used in case of fast (and BB inaccurate) integration of
 * correlation functions.
 *
 * @param ple   Input/output: Pointer to the lensing structure
 * @param cl_te Input: Array of unlensed power spectrum
 * @return the error status
 */

int lensing_addback_cl_te(
                          struct lensing * ple,
                          double *cl_te) {
  int index_l, l;

  for (index_l=0; index_l<ple->l_size; index_l++) {
    l = (int)ple->l[index_l];
    ple->cl_lens[index_l*ple->lt_size+ple->index_lt_te] += cl_te[l];
  }
  return _SUCCESS_;

}

/**
 * This routine computes the lensed power spectra by Gaussian quadrature
 *
 * @param ksip Input: Lensed correlation function (ksi+[index_mu])
 * @param ksim Input: Lensed correlation function (ksi-[index_mu])
 * @param d22  Input: Wigner d-function (\f$ d^l_{22}\f$[l][index_mu])
 * @param d2m2 Input: Wigner d-function (\f$ d^l_{2-2}\f$[l][index_mu])
 * @param w8   Input: Legendre quadrature weights (w8[index_mu])
 * @param nmu  Input: Number of quadrature points (0<=index_mu<=nmu)
 * @param ple  Input/output: Pointer to the lensing structure
 * @return the error status
 */


int lensing_lensed_cl_ee_bb(
                            double *ksip,
                            double *ksim,
                            double **d22,
                            double **d2m2,
                            double *w8,
                            int nmu,
                            struct lensing * ple
                            ) {

  int index_l;

  class_setup_parallel();
  /** Integration by Gauss-Legendre quadrature. **/
  for (index_l=0; index_l < ple->l_size; index_l++){
    class_run_parallel(=,
      double clp;
      double clm;
      int imu;
      clp=0; clm=0;
      for (imu=0;imu<nmu;imu++) {
        clp += ksip[imu]*d22[imu][(int)ple->l[index_l]]*w8[imu]; /* loop could be optimized */
        clm += ksim[imu]*d2m2[imu][(int)ple->l[index_l]]*w8[imu]; /* loop could be optimized */
      }
      ple->cl_lens[index_l*ple->lt_size+ple->index_lt_ee]=(clp+clm)*_PI_;
      ple->cl_lens[index_l*ple->lt_size+ple->index_lt_bb]=(clp-clm)*_PI_;
      return _SUCCESS_;
    );
  }
  class_finish_parallel();

  return _SUCCESS_;
}

/**
 * This routine adds back the unlensed \f$ cl_{ee}\f$, \f$ cl_{bb}\f$ power spectra
 * Used in case of fast (and BB inaccurate) integration of
 * correlation functions.
 *
 * @param ple   Input/output: Pointer to the lensing structure
 * @param cl_ee Input: Array of unlensed power spectrum
 * @param cl_bb Input: Array of unlensed power spectrum
 * @return the error status
 */

int lensing_addback_cl_ee_bb(
                             struct lensing * ple,
                             double * cl_ee,
                             double * cl_bb) {

  int index_l, l;

  for (index_l=0; index_l<ple->l_size; index_l++) {
    l = (int)ple->l[index_l];
    ple->cl_lens[index_l*ple->lt_size+ple->index_lt_ee] += cl_ee[l];
    ple->cl_lens[index_l*ple->lt_size+ple->index_lt_bb] += cl_bb[l];
  }
  return _SUCCESS_;

}

/**
 * This routine computes the d00 term
 *
 * @param mu     Input: Vector of cos(beta) values
 * @param num_mu Input: Number of cos(beta) values
 * @param lmax   Input: maximum multipole
 * @param d00    Input/output: Result is stored here
 *
 * Wigner d-functions, computed by recurrence
 * actual recurrence on \f$ \sqrt{(2l+1)/2} d^l_{mm'} \f$ for stability
 * Formulae from Kostelec & Rockmore 2003
 **/

int lensing_d00(
                double * mu,
                int num_mu,
                int lmax,
                double ** d00
                ) {
  double ll;
  int index_mu, l;
  double *fac1, *fac2, *fac3;
  ErrorMsg erreur;

  class_alloc(fac1,lmax*sizeof(double),erreur);
  class_alloc(fac2,lmax*sizeof(double),erreur);
  class_alloc(fac3,lmax*sizeof(double),erreur);
  for (l=1; l<lmax; l++) {
    ll = (double) l;
    fac1[l] = sqrt((2*ll+3)/(2*ll+1))*(2*ll+1)/(ll+1);
    fac2[l] = sqrt((2*ll+3)/(2*ll-1))*ll/(ll+1);
    fac3[l] = sqrt(2./(2*ll+3));
  }

  class_setup_parallel();
  for (index_mu=0;index_mu<num_mu;index_mu++) {
    class_run_parallel(=,
      double declare_list_of_variables_inside_parallel_region(dlm1, dl, dlp1);
      int l;
      dlm1=1.0/sqrt(2.); /* l=0 */
      d00[index_mu][0]=dlm1*sqrt(2.);
      dl=mu[index_mu] * sqrt(3./2.); /*l=1*/
      d00[index_mu][1]=dl*sqrt(2./3.);
      for (l=1;l<lmax;l++){
        /* sqrt((2l+1)/2)*d00 recurrence, supposed to be more stable */
        dlp1 = fac1[l]*mu[index_mu]*dl - fac2[l]*dlm1;
        d00[index_mu][l+1] = dlp1 * fac3[l];
        dlm1 = dl;
        dl = dlp1;
      }
      return _SUCCESS_;
    );
  }
  class_finish_parallel();
  free(fac1); free(fac2); free(fac3);
  return _SUCCESS_;
}


/**
 * This routine computes the d11 term
 *
 * @param mu     Input: Vector of cos(beta) values
 * @param num_mu Input: Number of cos(beta) values
 * @param lmax   Input: maximum multipole
 * @param d11    Input/output: Result is stored here
 *
 * Wigner d-functions, computed by recurrence
 * actual recurrence on \f$ \sqrt{(2l+1)/2} d^l_{mm'} \f$ for stability
 * Formulae from Kostelec & Rockmore 2003
 **/

int lensing_d11(
                double * mu,
                int num_mu,
                int lmax,
                double ** d11
                ) {
  double ll;
  int index_mu, l;
  double *fac1, *fac2, *fac3, *fac4;
  ErrorMsg erreur;
  class_alloc(fac1,lmax*sizeof(double),erreur);
  class_alloc(fac2,lmax*sizeof(double),erreur);
  class_alloc(fac3,lmax*sizeof(double),erreur);
  class_alloc(fac4,lmax*sizeof(double),erreur);
  for (l=2;l<lmax;l++) {
    ll = (double) l;
    fac1[l] = sqrt((2*ll+3)/(2*ll+1))*(ll+1)*(2*ll+1)/(ll*(ll+2));
    fac2[l] = 1.0/(ll*(ll+1.));
    fac3[l] = sqrt((2*ll+3)/(2*ll-1))*(ll-1)*(ll+1)/(ll*(ll+2))*(ll+1)/ll;
    fac4[l] = sqrt(2./(2*ll+3));
  }

  class_setup_parallel();
  for (index_mu=0;index_mu<num_mu;index_mu++) {
    class_run_parallel(=,
      int l;
      double declare_list_of_variables_inside_parallel_region(dlm1, dl, dlp1);
      d11[index_mu][0]=0;
      dlm1=(1.0+mu[index_mu])/2. * sqrt(3./2.); /*l=1*/
      d11[index_mu][1]=dlm1 * sqrt(2./3.);
      dl=(1.0+mu[index_mu])/2.*(2.0*mu[index_mu]-1.0) * sqrt(5./2.); /*l=2*/
      d11[index_mu][2] = dl * sqrt(2./5.);
      for (l=2;l<lmax;l++){
        /* sqrt((2l+1)/2)*d11 recurrence, supposed to be more stable */
        dlp1 = fac1[l]*(mu[index_mu]-fac2[l])*dl - fac3[l]*dlm1;
        d11[index_mu][l+1] = dlp1 * fac4[l];
        dlm1 = dl;
        dl = dlp1;
      }
      return _SUCCESS_;
    );
  }
  class_finish_parallel();
  free(fac1); free(fac2); free(fac3); free(fac4);
  return _SUCCESS_;
}

/**
 * This routine computes the d1m1 term
 *
 * @param mu     Input: Vector of cos(beta) values
 * @param num_mu Input: Number of cos(beta) values
 * @param lmax   Input: maximum multipole
 * @param d1m1    Input/output: Result is stored here
 *
 * Wigner d-functions, computed by recurrence
 * actual recurrence on \f$ \sqrt{(2l+1)/2} d^l_{mm'} \f$ for stability
 * Formulae from Kostelec & Rockmore 2003
 **/

int lensing_d1m1(
                 double * mu,
                 int num_mu,
                 int lmax,
                 double ** d1m1
                 ) {
  double ll;
  int index_mu, l;
  double *fac1, *fac2, *fac3, *fac4;
  ErrorMsg erreur;
  class_alloc(fac1,lmax*sizeof(double),erreur);
  class_alloc(fac2,lmax*sizeof(double),erreur);
  class_alloc(fac3,lmax*sizeof(double),erreur);
  class_alloc(fac4,lmax*sizeof(double),erreur);
  for (l=2;l<lmax;l++) {
    ll = (double) l;
    fac1[l] = sqrt((2*ll+3)/(2*ll+1))*(ll+1)*(2*ll+1)/(ll*(ll+2));
    fac2[l] = 1.0/(ll*(ll+1.));
    fac3[l] = sqrt((2*ll+3)/(2*ll-1))*(ll-1)*(ll+1)/(ll*(ll+2))*(ll+1)/ll;
    fac4[l] = sqrt(2./(2*ll+3));
  }
  class_setup_parallel();
  for (index_mu=0;index_mu<num_mu;index_mu++) {
    class_run_parallel(=,
      int l;
      double declare_list_of_variables_inside_parallel_region(dlm1, dl, dlp1);
      d1m1[index_mu][0]=0;
      dlm1=(1.0-mu[index_mu])/2. * sqrt(3./2.); /*l=1*/
      d1m1[index_mu][1]=dlm1 * sqrt(2./3.);
      dl=(1.0-mu[index_mu])/2.*(2.0*mu[index_mu]+1.0) * sqrt(5./2.); /*l=2*/
      d1m1[index_mu][2] = dl * sqrt(2./5.);
      for (l=2;l<lmax;l++){
        /* sqrt((2l+1)/2)*d1m1 recurrence, supposed to be more stable */
        dlp1 = fac1[l]*(mu[index_mu]+fac2[l])*dl - fac3[l]*dlm1;
        d1m1[index_mu][l+1] = dlp1 * fac4[l];
        dlm1 = dl;
        dl = dlp1;
      }
      return _SUCCESS_;
    );
  }
  class_finish_parallel();
  free(fac1); free(fac2); free(fac3); free(fac4);
  return _SUCCESS_;
}

/**
 * This routine computes the d2m2 term
 *
 * @param mu     Input: Vector of cos(beta) values
 * @param num_mu Input: Number of cos(beta) values
 * @param lmax   Input: maximum multipole
 * @param d2m2   Input/output: Result is stored here
 *
 * Wigner d-functions, computed by recurrence
 * actual recurrence on \f$ \sqrt{(2l+1)/2} d^l_{mm'} \f$ for stability
 * Formulae from Kostelec & Rockmore 2003
 **/

int lensing_d2m2(
                 double * mu,
                 int num_mu,
                 int lmax,
                 double ** d2m2
                 ) {
  double ll;
  int index_mu, l;
  double *fac1, *fac2, *fac3, *fac4;
  ErrorMsg erreur;
  class_alloc(fac1,lmax*sizeof(double),erreur);
  class_alloc(fac2,lmax*sizeof(double),erreur);
  class_alloc(fac3,lmax*sizeof(double),erreur);
  class_alloc(fac4,lmax*sizeof(double),erreur);
  for (l=2;l<lmax;l++) {
    ll = (double) l;
    fac1[l] = sqrt((2*ll+3)/(2*ll+1))*(ll+1)*(2*ll+1)/((ll-1)*(ll+3));
    fac2[l] = 4.0/(ll*(ll+1));
    fac3[l] = sqrt((2*ll+3)/(2*ll-1))*(ll-2)*(ll+2)/((ll-1)*(ll+3))*(ll+1)/ll;
    fac4[l] = sqrt(2./(2*ll+3));
  }

  class_setup_parallel();
  for (index_mu=0;index_mu<num_mu;index_mu++) {
    class_run_parallel(=,
      int l;
      double declare_list_of_variables_inside_parallel_region(dlm1, dl, dlp1);
      d2m2[index_mu][0]=0;
      dlm1=0.; /*l=1*/
      d2m2[index_mu][1]=0;
      dl=(1.0-mu[index_mu])*(1.0-mu[index_mu])/4. * sqrt(5./2.); /*l=2*/
      d2m2[index_mu][2] = dl * sqrt(2./5.);
      for (l=2;l<lmax;l++){
        /* sqrt((2l+1)/2)*d2m2 recurrence, supposed to be more stable */
        dlp1 = fac1[l]*(mu[index_mu]+fac2[l])*dl - fac3[l]*dlm1;
        d2m2[index_mu][l+1] = dlp1 * fac4[l];
        dlm1 = dl;
        dl = dlp1;
      }
      return _SUCCESS_;
    );
  }
  class_finish_parallel();
  free(fac1); free(fac2); free(fac3); free(fac4);
  return _SUCCESS_;
}

/**
 * This routine computes the d22 term
 *
 * @param mu     Input: Vector of cos(beta) values
 * @param num_mu Input: Number of cos(beta) values
 * @param lmax   Input: maximum multipole
 * @param d22    Input/output: Result is stored here
 *
 * Wigner d-functions, computed by recurrence
 * actual recurrence on \f$ \sqrt{(2l+1)/2} d^l_{mm'} \f$ for stability
 * Formulae from Kostelec & Rockmore 2003
 **/

int lensing_d22(
                double * mu,
                int num_mu,
                int lmax,
                double ** d22
                ) {
  double ll;
  int index_mu, l;
  double *fac1, *fac2, *fac3, *fac4;
  ErrorMsg erreur;
  class_alloc(fac1,lmax*sizeof(double),erreur);
  class_alloc(fac2,lmax*sizeof(double),erreur);
  class_alloc(fac3,lmax*sizeof(double),erreur);
  class_alloc(fac4,lmax*sizeof(double),erreur);
  for (l=2;l<lmax;l++) {
    ll = (double) l;
    fac1[l] = sqrt((2*ll+3)/(2*ll+1))*(ll+1)*(2*ll+1)/((ll-1)*(ll+3));
    fac2[l] = 4.0/(ll*(ll+1));
    fac3[l] = sqrt((2*ll+3)/(2*ll-1))*(ll-2)*(ll+2)/((ll-1)*(ll+3))*(ll+1)/ll;
    fac4[l] = sqrt(2./(2*ll+3));
  }

  class_setup_parallel();
  for (index_mu=0;index_mu<num_mu;index_mu++) {
    class_run_parallel(=,
      int l;
      double declare_list_of_variables_inside_parallel_region(dlm1, dl, dlp1);
      d22[index_mu][0]=0;
      dlm1=0.; /*l=1*/
      d22[index_mu][1]=0;
      dl=(1.0+mu[index_mu])*(1.0+mu[index_mu])/4. * sqrt(5./2.); /*l=2*/
      d22[index_mu][2] = dl * sqrt(2./5.);
      for (l=2;l<lmax;l++){
        /* sqrt((2l+1)/2)*d22 recurrence, supposed to be more stable */
        dlp1 = fac1[l]*(mu[index_mu]-fac2[l])*dl - fac3[l]*dlm1;
        d22[index_mu][l+1] = dlp1 * fac4[l];
        dlm1 = dl;
        dl = dlp1;
      }
      return _SUCCESS_;
    );
  }
  class_finish_parallel();
  free(fac1); free(fac2); free(fac3); free(fac4);
  return _SUCCESS_;
}

/**
 * This routine computes the d20 term
 *
 * @param mu     Input: Vector of cos(beta) values
 * @param num_mu Input: Number of cos(beta) values
 * @param lmax   Input: maximum multipole
 * @param d20    Input/output: Result is stored here
 *
 * Wigner d-functions, computed by recurrence
 * actual recurrence on \f$ \sqrt{(2l+1)/2} d^l_{mm'} \f$ for stability
 * Formulae from Kostelec & Rockmore 2003
 **/

int lensing_d20(
                double * mu,
                int num_mu,
                int lmax,
                double ** d20
                ) {
  double ll;
  int index_mu, l;
  double *fac1, *fac3, *fac4;
  ErrorMsg erreur;
  class_alloc(fac1,lmax*sizeof(double),erreur);
  class_alloc(fac3,lmax*sizeof(double),erreur);
  class_alloc(fac4,lmax*sizeof(double),erreur);
  for (l=2;l<lmax;l++) {
    ll = (double) l;
    fac1[l] = sqrt((2*ll+3)*(2*ll+1)/((ll-1)*(ll+3)));
    fac3[l] = sqrt((2*ll+3)*(ll-2)*(ll+2)/((2*ll-1)*(ll-1)*(ll+3)));
    fac4[l] = sqrt(2./(2*ll+3));
  }

  class_setup_parallel();
  for (index_mu=0;index_mu<num_mu;index_mu++) {
    class_run_parallel(=,
      int l;
      double declare_list_of_variables_inside_parallel_region(dlm1, dl, dlp1);
      d20[index_mu][0]=0;
      dlm1=0.; /*l=1*/
      d20[index_mu][1]=0;
      dl=sqrt(15.)/4.*(1-mu[index_mu]*mu[index_mu]); /*l=2*/
      d20[index_mu][2] = dl * sqrt(2./5.);
      for (l=2;l<lmax;l++){
        /* sqrt((2l+1)/2)*d22 recurrence, supposed to be more stable */
        dlp1 = fac1[l]*mu[index_mu]*dl - fac3[l]*dlm1;
        d20[index_mu][l+1] = dlp1 * fac4[l];
        dlm1 = dl;
        dl = dlp1;
      }
      return _SUCCESS_;
    );
  }
  class_finish_parallel();
  free(fac1); free(fac3); free(fac4);
  return _SUCCESS_;
}

/**
 * This routine computes the d31 term
 *
 * @param mu     Input: Vector of cos(beta) values
 * @param num_mu Input: Number of cos(beta) values
 * @param lmax   Input: maximum multipole
 * @param d31    Input/output: Result is stored here
 *
 * Wigner d-functions, computed by recurrence
 * actual recurrence on \f$ \sqrt{(2l+1)/2} d^l_{mm'} \f$ for stability
 * Formulae from Kostelec & Rockmore 2003
 **/

int lensing_d31(
                double * mu,
                int num_mu,
                int lmax,
                double ** d31
                ) {
  double ll;
  int index_mu, l;
  double *fac1, *fac2, *fac3, *fac4;
  ErrorMsg erreur;
  class_alloc(fac1,lmax*sizeof(double),erreur);
  class_alloc(fac2,lmax*sizeof(double),erreur);
  class_alloc(fac3,lmax*sizeof(double),erreur);
  class_alloc(fac4,lmax*sizeof(double),erreur);
  for (l=3;l<lmax;l++) {
    ll = (double) l;
    fac1[l] = sqrt((2*ll+3)*(2*ll+1)/((ll-2)*(ll+4)*ll*(ll+2))) * (ll+1);
    fac2[l] = 3.0/(ll*(ll+1));
    fac3[l] = sqrt((2*ll+3)/(2*ll-1)*(ll-3)*(ll+3)*(ll-1)*(ll+1)/((ll-2)*(ll+4)*ll*(ll+2)))*(ll+1)/ll;
    fac4[l] = sqrt(2./(2*ll+3));
  }

  class_setup_parallel();
  for (index_mu=0;index_mu<num_mu;index_mu++) {
    class_run_parallel(=,
      int l;
      double declare_list_of_variables_inside_parallel_region(dlm1, dl, dlp1);
      d31[index_mu][0]=0;
      d31[index_mu][1]=0;
      dlm1=0.; /*l=2*/
      d31[index_mu][2]=0;
      dl=sqrt(105./2.)*(1+mu[index_mu])*(1+mu[index_mu])*(1-mu[index_mu])/8.; /*l=3*/
      d31[index_mu][3] = dl * sqrt(2./7.);
      for (l=3;l<lmax;l++){
        /* sqrt((2l+1)/2)*d22 recurrence, supposed to be more stable */
        dlp1 = fac1[l]*(mu[index_mu]-fac2[l])*dl - fac3[l]*dlm1;
        d31[index_mu][l+1] = dlp1 * fac4[l];
        dlm1 = dl;
        dl = dlp1;
      }
      return _SUCCESS_;
    );
  }
  class_finish_parallel();
  free(fac1); free(fac2); free(fac3); free(fac4);
  return _SUCCESS_;
}

/**
 * This routine computes the d3m1 term
 *
 * @param mu     Input: Vector of cos(beta) values
 * @param num_mu Input: Number of cos(beta) values
 * @param lmax   Input: maximum multipole
 * @param d3m1   Input/output: Result is stored here
 *
 * Wigner d-functions, computed by recurrence
 * actual recurrence on \f$ \sqrt{(2l+1)/2} d^l_{mm'} \f$ for stability
 * Formulae from Kostelec & Rockmore 2003
 **/

int lensing_d3m1(
                 double * mu,
                 int num_mu,
                 int lmax,
                 double ** d3m1
                 ) {
  double ll;
  int index_mu, l;
  double *fac1, *fac2, *fac3, *fac4;
  ErrorMsg erreur;
  class_alloc(fac1,lmax*sizeof(double),erreur);
  class_alloc(fac2,lmax*sizeof(double),erreur);
  class_alloc(fac3,lmax*sizeof(double),erreur);
  class_alloc(fac4,lmax*sizeof(double),erreur);
  for (l=3;l<lmax;l++) {
    ll = (double) l;
    fac1[l] = sqrt((2*ll+3)*(2*ll+1)/((ll-2)*(ll+4)*ll*(ll+2))) * (ll+1);
    fac2[l] = 3.0/(ll*(ll+1));
    fac3[l] = sqrt((2*ll+3)/(2*ll-1)*(ll-3)*(ll+3)*(ll-1)*(ll+1)/((ll-2)*(ll+4)*ll*(ll+2)))*(ll+1)/ll;
    fac4[l] = sqrt(2./(2*ll+3));
  }

  class_setup_parallel();
  for (index_mu=0;index_mu<num_mu;index_mu++) {
    class_run_parallel(=,
      int l;
      double declare_list_of_variables_inside_parallel_region(dlm1, dl, dlp1);
      d3m1[index_mu][0]=0;
      d3m1[index_mu][1]=0;
      dlm1=0.; /*l=2*/
      d3m1[index_mu][2]=0;
      dl=sqrt(105./2.)*(1+mu[index_mu])*(1-mu[index_mu])*(1-mu[index_mu])/8.; /*l=3*/
      d3m1[index_mu][3] = dl * sqrt(2./7.);
      for (l=3;l<lmax;l++){
        /* sqrt((2l+1)/2)*d22 recurrence, supposed to be more stable */
        dlp1 = fac1[l]*(mu[index_mu]+fac2[l])*dl - fac3[l]*dlm1;
        d3m1[index_mu][l+1] = dlp1 * fac4[l];
        dlm1 = dl;
        dl = dlp1;
      }
      return _SUCCESS_;
    );
  }
  class_finish_parallel();
  free(fac1); free(fac2); free(fac3); free(fac4);
  return _SUCCESS_;
}

/**
 * This routine computes the d3m3 term
 *
 * @param mu     Input: Vector of cos(beta) values
 * @param num_mu Input: Number of cos(beta) values
 * @param lmax   Input: maximum multipole
 * @param d3m3   Input/output: Result is stored here
 *
 * Wigner d-functions, computed by recurrence
 * actual recurrence on \f$ \sqrt{(2l+1)/2} d^l_{mm'} \f$ for stability
 * Formulae from Kostelec & Rockmore 2003
 **/

int lensing_d3m3(
                 double * mu,
                 int num_mu,
                 int lmax,
                 double ** d3m3
                 ) {
  double ll;
  int index_mu, l;
  double *fac1, *fac2, *fac3, *fac4;
  ErrorMsg erreur;
  class_alloc(fac1,lmax*sizeof(double),erreur);
  class_alloc(fac2,lmax*sizeof(double),erreur);
  class_alloc(fac3,lmax*sizeof(double),erreur);
  class_alloc(fac4,lmax*sizeof(double),erreur);
  for (l=3;l<lmax;l++) {
    ll = (double) l;
    fac1[l] = sqrt((2*ll+3)*(2*ll+1))*(ll+1)/((ll-2)*(ll+4));
    fac2[l] = 9.0/(ll*(ll+1));
    fac3[l] = sqrt((2*ll+3)/(2*ll-1))*(ll-3)*(ll+3)*(l+1)/((ll-2)*(ll+4)*ll);
    fac4[l] = sqrt(2./(2*ll+3));
  }

  class_setup_parallel();
  for (index_mu=0;index_mu<num_mu;index_mu++) {
    class_run_parallel(=,
      int l;
      double declare_list_of_variables_inside_parallel_region(dlm1, dl, dlp1);
      d3m3[index_mu][0]=0;
      d3m3[index_mu][1]=0;
      dlm1=0.; /*l=2*/
      d3m3[index_mu][2]=0;
      dl=sqrt(7./2.)*(1-mu[index_mu])*(1-mu[index_mu])*(1-mu[index_mu])/8.; /*l=3*/
      d3m3[index_mu][3] = dl * sqrt(2./7.);
      for (l=3;l<lmax;l++){
        /* sqrt((2l+1)/2)*d22 recurrence, supposed to be more stable */
        dlp1 = fac1[l]*(mu[index_mu]+fac2[l])*dl - fac3[l]*dlm1;
        d3m3[index_mu][l+1] = dlp1 * fac4[l];
        dlm1 = dl;
        dl = dlp1;
      }
      return _SUCCESS_;
    );
  }
  class_finish_parallel();
  free(fac1); free(fac2); free(fac3); free(fac4);
  return _SUCCESS_;
}

/**
 * This routine computes the d40 term
 *
 * @param mu     Input: Vector of cos(beta) values
 * @param num_mu Input: Number of cos(beta) values
 * @param lmax   Input: maximum multipole
 * @param d40    Input/output: Result is stored here
 *
 * Wigner d-functions, computed by recurrence
 * actual recurrence on \f$ \sqrt{(2l+1)/2} d^l_{mm'} \f$ for stability
 * Formulae from Kostelec & Rockmore 2003
 **/

int lensing_d40(
                double * mu,
                int num_mu,
                int lmax,
                double ** d40
                ) {
  double ll;
  int index_mu, l;
  double *fac1, *fac3, *fac4;
  ErrorMsg erreur;
  class_alloc(fac1,lmax*sizeof(double),erreur);
  class_alloc(fac3,lmax*sizeof(double),erreur);
  class_alloc(fac4,lmax*sizeof(double),erreur);
  for (l=4;l<lmax;l++) {
    ll = (double) l;
    fac1[l] = sqrt((2*ll+3)*(2*ll+1)/((ll-3)*(ll+5)));
    fac3[l] = sqrt((2*ll+3)*(ll-4)*(ll+4)/((2*ll-1)*(ll-3)*(ll+5)));
    fac4[l] = sqrt(2./(2*ll+3));
  }

  class_setup_parallel();
  for (index_mu=0;index_mu<num_mu;index_mu++) {
    class_run_parallel(=,
      int l;
      double declare_list_of_variables_inside_parallel_region(dlm1, dl, dlp1);
      d40[index_mu][0]=0;
      d40[index_mu][1]=0;
      d40[index_mu][2]=0;
      dlm1=0.; /*l=3*/
      d40[index_mu][3]=0;
      dl=sqrt(315.)*(1+mu[index_mu])*(1+mu[index_mu])*(1-mu[index_mu])*(1-mu[index_mu])/16.; /*l=4*/
      d40[index_mu][4] = dl * sqrt(2./9.);
      for (l=4;l<lmax;l++){
        /* sqrt((2l+1)/2)*d22 recurrence, supposed to be more stable */
        dlp1 = fac1[l]*mu[index_mu]*dl - fac3[l]*dlm1;
        d40[index_mu][l+1] = dlp1 * fac4[l];
        dlm1 = dl;
        dl = dlp1;
      }
      return _SUCCESS_;
    );
  }
  class_finish_parallel();
  free(fac1); free(fac3); free(fac4);
  return _SUCCESS_;
}

/**
 * This routine computes the d4m2 term
 *
 * @param mu     Input: Vector of cos(beta) values
 * @param num_mu Input: Number of cos(beta) values
 * @param lmax   Input: maximum multipole
 * @param d4m2   Input/output: Result is stored here
 *
 * Wigner d-functions, computed by recurrence
 * actual recurrence on \f$ \sqrt{(2l+1)/2} d^l_{mm'} \f$ for stability
 * Formulae from Kostelec & Rockmore 2003
 **/

int lensing_d4m2(
                 double * mu,
                 int num_mu,
                 int lmax,
                 double ** d4m2
                 ) {
  double ll;
  int index_mu, l;
  double *fac1, *fac2, *fac3, *fac4;
  ErrorMsg erreur;
  class_alloc(fac1,lmax*sizeof(double),erreur);
  class_alloc(fac2,lmax*sizeof(double),erreur);
  class_alloc(fac3,lmax*sizeof(double),erreur);
  class_alloc(fac4,lmax*sizeof(double),erreur);
  for (l=4;l<lmax;l++) {
    ll = (double) l;
    fac1[l] = sqrt((2*ll+3)*(2*ll+1)/((ll-3)*(ll+5)*(ll-1)*(ll+3))) * (ll+1.);
    fac2[l] = 8./(ll*(ll+1));
    fac3[l] = sqrt((2*ll+3)*(ll-4)*(ll+4)*(ll-2)*(ll+2)/((2*ll-1)*(ll-3)*(ll+5)*(ll-1)*(ll+3)))*(ll+1)/ll;
    fac4[l] = sqrt(2./(2*ll+3));
  }

  class_setup_parallel();
  for (index_mu=0;index_mu<num_mu;index_mu++) {
    class_run_parallel(=,
      int l;
      double declare_list_of_variables_inside_parallel_region(dlm1, dl, dlp1);
      d4m2[index_mu][0]=0;
      d4m2[index_mu][1]=0;
      d4m2[index_mu][2]=0;
      dlm1=0.; /*l=3*/
      d4m2[index_mu][3]=0;
      dl=sqrt(126.)*(1+mu[index_mu])*(1-mu[index_mu])*(1-mu[index_mu])*(1-mu[index_mu])/16.; /*l=4*/
      d4m2[index_mu][4] = dl * sqrt(2./9.);
      for (l=4;l<lmax;l++){
        /* sqrt((2l+1)/2)*d22 recurrence, supposed to be more stable */
        dlp1 = fac1[l]*(mu[index_mu]+fac2[l])*dl - fac3[l]*dlm1;
        d4m2[index_mu][l+1] = dlp1 * fac4[l];
        dlm1 = dl;
        dl = dlp1;
      }
      return _SUCCESS_;
    );
  }
  class_finish_parallel();
  free(fac1); free(fac2); free(fac3); free(fac4);
  return _SUCCESS_;
}

/**
 * This routine computes the d4m4 term
 *
 * @param mu     Input: Vector of cos(beta) values
 * @param num_mu Input: Number of cos(beta) values
 * @param lmax   Input: maximum multipole
 * @param d4m4   Input/output: Result is stored here
 *
 * Wigner d-functions, computed by recurrence
 * actual recurrence on \f$ \sqrt{(2l+1)/2} d^l_{mm'} \f$ for stability
 * Formulae from Kostelec & Rockmore 2003
 **/

int lensing_d4m4(
                 double * mu,
                 int num_mu,
                 int lmax,
                 double ** d4m4
                 ) {
  double ll;
  int index_mu, l;
  double *fac1, *fac2, *fac3, *fac4;
  ErrorMsg erreur;
  class_alloc(fac1,lmax*sizeof(double),erreur);
  class_alloc(fac2,lmax*sizeof(double),erreur);
  class_alloc(fac3,lmax*sizeof(double),erreur);
  class_alloc(fac4,lmax*sizeof(double),erreur);
  for (l=4;l<lmax;l++) {
    ll = (double) l;
    fac1[l] = sqrt((2*ll+3)*(2*ll+1))*(ll+1)/((ll-3)*(ll+5));
    fac2[l] = 16./(ll*(ll+1));
    fac3[l] = sqrt((2*ll+3)/(2*ll-1))*(ll-4)*(ll+4)*(ll+1)/((ll-3)*(ll+5)*ll);
    fac4[l] = sqrt(2./(2*ll+3));
  }

  class_setup_parallel();
  for (index_mu=0;index_mu<num_mu;index_mu++) {
    class_run_parallel(=,
      int l;
      double declare_list_of_variables_inside_parallel_region(dlm1, dl, dlp1);
      d4m4[index_mu][0]=0;
      d4m4[index_mu][1]=0;
      d4m4[index_mu][2]=0;
      dlm1=0.; /*l=3*/
      d4m4[index_mu][3]=0;
      dl=sqrt(9./2.)*(1-mu[index_mu])*(1-mu[index_mu])*(1-mu[index_mu])*(1-mu[index_mu])/16.; /*l=4*/
      d4m4[index_mu][4] = dl * sqrt(2./9.);
      for (l=4;l<lmax;l++){
        /* sqrt((2l+1)/2)*d22 recurrence, supposed to be more stable */
        dlp1 = fac1[l]*(mu[index_mu]+fac2[l])*dl - fac3[l]*dlm1;
        d4m4[index_mu][l+1] = dlp1 * fac4[l];
        dlm1 = dl;
        dl = dlp1;
      }
      return _SUCCESS_;
    );
  }
  class_finish_parallel();
  free(fac1); free(fac2); free(fac3); free(fac4);
  return _SUCCESS_;
}

```

`source/output.c`:

```c
/** @file output.c Documented output module
 *
 * Julien Lesgourgues, 26.08.2010
 *
 * This module writes the output in files.
 *
 * The following functions can be called from other modules or from the main:
 *
 * -# output_init() (must be called after harmonic_init())
 * -# output_total_cl_at_l() (can be called even before output_init())
 *
 * No memory needs to be deallocated after that,
 * hence there is no output_free() routine like in other modules.
 */

#include "output.h"

int output_total_cl_at_l(
                         struct harmonic * phr,
                         struct lensing * ple,
                         struct output * pop,
                         int l,
                         double * cl
                         ){

  double ** cl_md_ic; /* array with argument
                         cl_md_ic[index_md][index_ic1_ic2*phr->ct_size+index_ct] */

  double ** cl_md;    /* array with argument
                         cl_md[index_md][index_ct] */

  int index_md;

  if (ple->has_lensed_cls == _TRUE_) {
    class_call(lensing_cl_at_l(ple,
                               l,
                               cl),
               ple->error_message,
               pop->error_message);
  }
  else {

    class_alloc(cl_md_ic,
                phr->md_size*sizeof(double *),
                pop->error_message);

    class_alloc(cl_md,
                phr->md_size*sizeof(double *),
                pop->error_message);

    for (index_md = 0; index_md < phr->md_size; index_md++) {

      if (phr->md_size > 1)

        class_alloc(cl_md[index_md],
                    phr->ct_size*sizeof(double),
                    ple->error_message);

      if (phr->ic_size[index_md] > 1)

        class_alloc(cl_md_ic[index_md],
                    phr->ic_ic_size[index_md]*phr->ct_size*sizeof(double),
                    ple->error_message);
    }

    class_call(harmonic_cl_at_l(phr,
                                (double)l,
                                cl,
                                cl_md,
                                cl_md_ic),
               phr->error_message,
               pop->error_message);

    for (index_md = 0; index_md < phr->md_size; index_md++) {

      if (phr->md_size > 1)
        free(cl_md[index_md]);

      if (phr->ic_size[index_md] > 1)
        free(cl_md_ic[index_md]);

    }

    free(cl_md_ic);
    free(cl_md);

  }

  return _SUCCESS_;

}

/**
 * This routine writes the output in files.
 *
 *
 * @param pba Input: pointer to background structure (needed for calling harmonic_pk_at_z())
 * @param pth Input: pointer to thermodynamics structure
 * @param ppt Input: pointer perturbation structure
 * @param ppm Input: pointer to primordial structure
 * @param ptr Input: pointer to transfer structure
 * @param phr Input: pointer to harmonic structure
 * @param pfo Input: pointer to fourier structure
 * @param ple Input: pointer to lensing structure
 * @param psd Input: pointer to distortions structure
 * @param pop Input: pointer to output structure
 */

int output_init(
                struct background * pba,
                struct thermodynamics * pth,
                struct perturbations * ppt,
                struct primordial * ppm,
                struct transfer * ptr,
                struct harmonic * phr,
                struct fourier * pfo,
                struct lensing * ple,
                struct distortions * psd,
                struct output * pop
                ) {

  /** Summary: */

  /** - check that we really want to output at least one file */

  if ((ppt->has_cls == _FALSE_) && (ppt->has_pk_matter == _FALSE_) && (ppt->has_density_transfers == _FALSE_) && (ppt->has_velocity_transfers == _FALSE_) && (pop->write_background == _FALSE_) && (pop->write_thermodynamics == _FALSE_) && (pop->write_primordial == _FALSE_)) {
    if (pop->output_verbose > 0)
      printf("No output files requested. Output module skipped.\n");
    return _SUCCESS_;
  }
  else {
    if (pop->output_verbose > 0)
      printf("Writing output files in %s... \n",pop->root);
  }

  /** - deal with all anisotropy power spectra \f$ C_l\f$'s */

  if (ppt->has_cls == _TRUE_) {

    class_call(output_cl(pba,ppt,phr,ple,pop),
               pop->error_message,
               pop->error_message);
  }

  /** - deal with all Fourier matter power spectra P(k)'s */

  if (ppt->has_pk_matter == _TRUE_) {

    class_call(output_pk(pba,ppt,pfo,pop,pk_linear),
               pop->error_message,
               pop->error_message);

    if (pfo->method != nl_none) {

      class_call(output_pk(pba,ppt,pfo,pop,pk_nonlinear),
                 pop->error_message,
                 pop->error_message);

    }
  }

  /** - deal with density and matter power spectra */

  if ((ppt->has_density_transfers == _TRUE_) || (ppt->has_velocity_transfers == _TRUE_)) {

    class_call(output_tk(pba,ppt,pop),
               pop->error_message,
               pop->error_message);

  }

  /** - deal with background quantities */

  if (pop->write_background == _TRUE_) {

    class_call(output_background(pba,pop),
               pop->error_message,
               pop->error_message);

  }

  /** - deal with thermodynamics quantities */

  if (pop->write_thermodynamics == _TRUE_) {

    class_call(output_thermodynamics(pba,pth,pop),
               pop->error_message,
               pop->error_message);

  }

  /** - deal with perturbation quantities */

  if (pop->write_perturbations == _TRUE_ && ppt->has_perturbations) {

    class_call(output_perturbations(pba,ppt,pop),
               pop->error_message,
               pop->error_message);

  }

  /** - deal with primordial spectra */

  if (pop->write_primordial == _TRUE_ && ppt->has_perturbations) {

    class_call(output_primordial(ppt,ppm,pop),
               pop->error_message,
               pop->error_message);

  }

  /** - deal with heating */

  if (pop->write_exotic_injection == _TRUE_ || pop->write_noninjection == _TRUE_) {

    class_call(output_heating(&(pth->in),&(psd->ni),pop),
               pop->error_message,
               pop->error_message);
  }

  /** - deal with spectral distortions */

  if (pop->write_distortions == _TRUE_) {

    class_call(output_distortions(psd,pop),
               pop->error_message,
               pop->error_message);
  }

  return _SUCCESS_;

}

/**
 * This routines writes the output in files for anisotropy power spectra \f$ C_l\f$'s.
 *
 * @param pba Input: pointer to background structure (needed for \f$ T_{cmb}\f$)
 * @param ppt Input: pointer perturbation structure
 * @param phr Input: pointer to harmonic structure
 * @param ple Input: pointer to lensing structure
 * @param pop Input: pointer to output structure
 */

int output_cl(
              struct background * pba,
              struct perturbations * ppt,
              struct harmonic * phr,
              struct lensing * ple,
              struct output * pop
              ) {

  /** Summary: */

  /** - define local variables */

  FILE *** out_md_ic; /* array of pointers to files with argument
                         out_md_ic[index_md][index_ic1_ic2]
                         (will contain cl's for each mode and pairs of initial conditions) */

  FILE ** out_md;     /* array of pointers to files with argument
                         out_md[index_md]
                         (will contain cl's for each mode, summed eventually over ic's) */

  FILE * out;         /* (will contain total cl's, summed eventually over modes and ic's) */

  FILE * out_lensed;         /* (will contain total lensed cl's) */

  double ** cl_md_ic; /* array with argument
                         cl_md_ic[index_md][index_ic1_ic2*phr->ct_size+index_ct] */

  double ** cl_md;    /* array with argument
                         cl_md[index_md][index_ct] */

  double * cl_tot;    /* array with argument
                         cl_tot[index_ct] */

  int index_md;
  int index_ic1,index_ic2,index_ic1_ic2;
  int l;

  FileName file_name;
  char first_line[_LINE_LENGTH_MAX_];

  /** - first, allocate all arrays of files and \f$ C_l\f$'s */

  class_alloc(out_md_ic,
              phr->md_size*sizeof(FILE * *),
              pop->error_message);

  class_alloc(cl_md_ic,
              phr->md_size*sizeof(double *),
              pop->error_message);

  class_alloc(out_md,
              phr->md_size*sizeof(FILE *),
              pop->error_message);

  class_alloc(cl_md,
              phr->md_size*sizeof(double *),
              pop->error_message);

  for (index_md = 0; index_md < ppt->md_size; index_md++) {

    class_alloc(out_md_ic[index_md],
                phr->ic_ic_size[index_md]*sizeof(FILE *),
                pop->error_message);

  }

  /** - second, open only the relevant files, and write a heading in each of them */

  class_sprintf(file_name,"%s%s",pop->root,"cl.dat");

  class_call(output_open_cl_file(phr,
                                 pop,
                                 &out,
                                 file_name,
                                 "total [l(l+1)/2pi] C_l's",
                                 phr->l_max_tot
                                 ),
             pop->error_message,
             pop->error_message);

  class_alloc(cl_tot,
              phr->ct_size*sizeof(double),
              pop->error_message);


  if (ple->has_lensed_cls == _TRUE_) {

    class_sprintf(file_name,"%s%s",pop->root,"cl_lensed.dat");

    class_call(output_open_cl_file(phr,
                                   pop,
                                   &out_lensed,
                                   file_name,
                                   "total lensed [l(l+1)/2pi] C_l's",
                                   ple->l_lensed_max
                                   ),
               pop->error_message,
               pop->error_message);
  }

  if (ppt->md_size > 1) {

    for (index_md = 0; index_md < ppt->md_size; index_md++) {

      if (_scalars_) {

        class_sprintf(file_name,"%s%s",pop->root,"cls.dat");
        strcpy(first_line,"[l(l+1)/2pi] C_l's for scalar mode");

      }

      if (_tensors_) {

        class_sprintf(file_name,"%s%s",pop->root,"clt.dat");
        strcpy(first_line,"[l(l+1)/2pi] C_l's for tensor mode");

      }

      class_call(output_open_cl_file(phr,
                                     pop,
                                     &(out_md[index_md]),
                                     file_name,
                                     first_line,
                                     phr->l_max[index_md]
                                     ),
                 pop->error_message,
                 pop->error_message);

      class_alloc(cl_md[index_md],
                  phr->ct_size*sizeof(double),
                  pop->error_message);

    }
  }

  for (index_md = 0; index_md < ppt->md_size; index_md++) {

    if (ppt->ic_size[index_md] > 1) {

      for (index_ic1 = 0; index_ic1 < ppt->ic_size[index_md]; index_ic1++) {

        for (index_ic2 = index_ic1; index_ic2 < ppt->ic_size[index_md]; index_ic2++) {

          if (_scalars_) {

            if ((ppt->has_ad == _TRUE_) &&
                (index_ic1 == ppt->index_ic_ad) && (index_ic2 == ppt->index_ic_ad)) {

              class_sprintf(file_name,"%s%s",pop->root,"cls_ad.dat");
              strcpy(first_line,"[l(l+1)/2pi] C_l's for scalar adiabatic (AD) mode");
            }

            if ((ppt->has_bi == _TRUE_) &&
                (index_ic1 == ppt->index_ic_bi) && (index_ic2 == ppt->index_ic_bi)) {

              class_sprintf(file_name,"%s%s",pop->root,"cls_bi.dat");
              strcpy(first_line,"[l(l+1)/2pi] C_l's for scalar baryon isocurvature (BI) mode");
            }

            if ((ppt->has_cdi == _TRUE_) &&
                (index_ic1 == ppt->index_ic_cdi) && (index_ic2 == ppt->index_ic_cdi)) {

              class_sprintf(file_name,"%s%s",pop->root,"cls_cdi.dat");
              strcpy(first_line,"[l(l+1)/2pi] C_l's for scalar CDM isocurvature (CDI) mode");
            }

            if ((ppt->has_nid == _TRUE_) &&
                (index_ic1 == ppt->index_ic_nid) && (index_ic2 == ppt->index_ic_nid)) {

              class_sprintf(file_name,"%s%s",pop->root,"cls_nid.dat");
              strcpy(first_line,"[l(l+1)/2pi] C_l's for scalar neutrino density isocurvature (NID) mode");
            }

            if ((ppt->has_niv == _TRUE_) &&
                (index_ic1 == ppt->index_ic_niv) && (index_ic2 == ppt->index_ic_niv)) {

              class_sprintf(file_name,"%s%s",pop->root,"cls_niv.dat");
              strcpy(first_line,"[l(l+1)/2pi] C_l's for scalar neutrino velocity isocurvature (NIV) mode");
            }

            if ((ppt->has_ad == _TRUE_) &&
                (ppt->has_bi == _TRUE_) && (index_ic1 == ppt->index_ic_ad) && (index_ic2 == ppt->index_ic_bi)) {

              class_sprintf(file_name,"%s%s",pop->root,"cls_ad_bi.dat");
              strcpy(first_line,"[l(l+1)/2pi] C_l's for scalar cross ADxBI mode");
            }

            if ((ppt->has_ad == _TRUE_) && (ppt->has_cdi == _TRUE_) &&
                (index_ic1 == ppt->index_ic_ad) && (index_ic2 == ppt->index_ic_cdi)) {

              class_sprintf(file_name,"%s%s",pop->root,"cls_ad_cdi.dat");
              strcpy(first_line,"[l(l+1)/2pi] C_l's for scalar cross ADxCDI mode");
            }

            if ((ppt->has_ad == _TRUE_) && (ppt->has_nid == _TRUE_) &&
                (index_ic1 == ppt->index_ic_ad) && (index_ic2 == ppt->index_ic_nid)) {

              class_sprintf(file_name,"%s%s",pop->root,"cls_ad_nid.dat");
              strcpy(first_line,"[l(l+1)/2pi] C_l's for scalar cross ADxNID mode");
            }

            if ((ppt->has_ad == _TRUE_) && (ppt->has_niv == _TRUE_) &&
                (index_ic1 == ppt->index_ic_ad) && (index_ic2 == ppt->index_ic_niv)) {

              class_sprintf(file_name,"%s%s",pop->root,"cls_ad_niv.dat");
              strcpy(first_line,"[l(l+1)/2pi] C_l's for scalar cross ADxNIV mode");
            }

            if ((ppt->has_bi == _TRUE_) && (ppt->has_cdi == _TRUE_) &&
                (index_ic1 == ppt->index_ic_bi) && (index_ic2 == ppt->index_ic_cdi)) {

              class_sprintf(file_name,"%s%s",pop->root,"cls_bi_cdi.dat");
              strcpy(first_line,"[l(l+1)/2pi] C_l's for scalar cross BIxCDI mode");
            }

            if ((ppt->has_bi == _TRUE_) && (ppt->has_nid == _TRUE_) &&
                (index_ic1 == ppt->index_ic_bi) && (index_ic2 == ppt->index_ic_nid)) {

              class_sprintf(file_name,"%s%s",pop->root,"cls_bi_nid.dat");
              strcpy(first_line,"[l(l+1)/2pi] C_l's for scalar cross BIxNID mode");
            }

            if ((ppt->has_bi == _TRUE_) && (ppt->has_niv == _TRUE_) &&
                (index_ic1 == ppt->index_ic_bi) && (index_ic2 == ppt->index_ic_niv)) {

              class_sprintf(file_name,"%s%s",pop->root,"cls_bi_niv.dat");
              strcpy(first_line,"[l(l+1)/2pi] C_l's for scalar cross BIxNIV mode");
            }

            if ((ppt->has_cdi == _TRUE_) && (ppt->has_nid == _TRUE_) &&
                (index_ic1 == ppt->index_ic_cdi) && (index_ic2 == ppt->index_ic_nid)) {

              class_sprintf(file_name,"%s%s",pop->root,"cls_cdi_nid.dat");
              strcpy(first_line,"[l(l+1)/2pi] C_l's for scalar cross CDIxNID mode");
            }

            if ((ppt->has_cdi == _TRUE_) && (ppt->has_niv == _TRUE_) &&
                (index_ic1 == ppt->index_ic_cdi) && (index_ic2 == ppt->index_ic_niv)) {

              class_sprintf(file_name,"%s%s",pop->root,"cls_cdi_niv.dat");
              strcpy(first_line,"[l(l+1)/2pi] C_l's for scalar cross CDIxNIV mode");
            }

            if ((ppt->has_nid == _TRUE_) && (ppt->has_niv == _TRUE_) &&
                (index_ic1 == ppt->index_ic_nid) && (index_ic2 == ppt->index_ic_niv)) {

              class_sprintf(file_name,"%s%s",pop->root,"cls_nid_niv.dat");
              strcpy(first_line,"[l(l+1)/2pi] C_l's for scalar cross NIDxNIV mode");
            }

          }

          if (_tensors_) {

            class_test(0==0,
                       pop->error_message,
                       "Seems that we have mixed initial conditions for tensors? Should not happen!\n");

          }

          index_ic1_ic2 = index_symmetric_matrix(index_ic1,index_ic2,phr->ic_size[index_md]);

          if (phr->is_non_zero[index_md][index_ic1_ic2] == _TRUE_) {

            class_call(output_open_cl_file(phr,
                                           pop,
                                           &(out_md_ic[index_md][index_ic1_ic2]),
                                           file_name,
                                           first_line,
                                           phr->l_max[index_md]
                                           ),
                       pop->error_message,
                       pop->error_message);

          }
        }
      }

      class_alloc(cl_md_ic[index_md],
                  phr->ic_ic_size[index_md]*phr->ct_size*sizeof(double),
                  pop->error_message);
    }
  }

  /** - third, perform loop over l. For each multipole, get all \f$ C_l\f$'s
      by calling harmonic_cl_at_l() and distribute the results to
      relevant files */

  for (l = 2; l <= phr->l_max_tot; l++) {

    class_call(harmonic_cl_at_l(phr,(double)l,cl_tot,cl_md,cl_md_ic),
               phr->error_message,
               pop->error_message);

    class_call(output_one_line_of_cl(pba,phr,pop,out,(double)l,cl_tot,phr->ct_size),
               pop->error_message,
               pop->error_message);

    if ((ple->has_lensed_cls == _TRUE_) && (l<=ple->l_lensed_max)) {

      class_call(lensing_cl_at_l(ple,
                                 (double)l,
                                 cl_tot),
                 ple->error_message,
                 pop->error_message);

      class_call(output_one_line_of_cl(pba,phr,pop,out_lensed,l,cl_tot,phr->ct_size),
                 pop->error_message,
                 pop->error_message);
    }

    if (ppt->md_size > 1) {
      for (index_md = 0; index_md < ppt->md_size; index_md++) {
        if (l <= phr->l_max[index_md]) {

          class_call(output_one_line_of_cl(pba,phr,pop,out_md[index_md],l,cl_md[index_md],phr->ct_size),
                     pop->error_message,
                     pop->error_message);
        }
      }
    }

    for (index_md = 0; index_md < ppt->md_size; index_md++) {
      if ((ppt->ic_size[index_md] > 1) && (l <= phr->l_max[index_md])) {
        for (index_ic1_ic2 = 0; index_ic1_ic2 < phr->ic_ic_size[index_md]; index_ic1_ic2++) {
          if (phr->is_non_zero[index_md][index_ic1_ic2] == _TRUE_) {

            class_call(output_one_line_of_cl(pba,phr,pop,out_md_ic[index_md][index_ic1_ic2],l,&(cl_md_ic[index_md][index_ic1_ic2*phr->ct_size]),phr->ct_size),
                       pop->error_message,
                       pop->error_message);
          }
        }
      }
    }
  }

  /** - finally, close files and free arrays of files and \f$ C_l\f$'s */

  for (index_md = 0; index_md < ppt->md_size; index_md++) {
    if (ppt->ic_size[index_md] > 1) {
      for (index_ic1_ic2 = 0; index_ic1_ic2 < phr->ic_ic_size[index_md]; index_ic1_ic2++) {
        if (phr->is_non_zero[index_md][index_ic1_ic2] == _TRUE_) {
          fclose(out_md_ic[index_md][index_ic1_ic2]);
        }
      }
      free(cl_md_ic[index_md]);
    }
  }
  if (ppt->md_size > 1) {
    for (index_md = 0; index_md < ppt->md_size; index_md++) {
      fclose(out_md[index_md]);
      free(cl_md[index_md]);
    }
  }
  fclose(out);
  if (ple->has_lensed_cls == _TRUE_) {
    fclose(out_lensed);
  }
  free(cl_tot);
  for (index_md = 0; index_md < ppt->md_size; index_md++) {
    free(out_md_ic[index_md]);
  }
  free(out_md_ic);
  free(cl_md_ic);
  free(out_md);
  free(cl_md);

  return _SUCCESS_;

}

/**
 * This routines writes the output in files for Fourier matter power spectra P(k)'s
 * (linear or non-linear)
 *
 * @param pba       Input: pointer to background structure (needed for calling harmonic_pk_at_z())
 * @param ppt       Input: pointer perturbation structure
 * @param pfo       Input: pointer to fourier structure
 * @param pop       Input: pointer to output structure
 * @param pk_output Input: pk_linear or pk_nonlinear
 */

int output_pk(
              struct background * pba,
              struct perturbations * ppt,
              struct fourier * pfo,
              struct output * pop,
              enum pk_outputs pk_output
              ) {

  /** Summary: */

  /** - define local variables */

  FILE ** out_pk_ic = NULL;  /* out_pk_ic[index_ic1_ic2] is a pointer to a file with P(k) for each pair of ic */
  FILE * out_pk;             /* out_pk[index_pk] is a pointer to a file with total P(k) summed over ic */

  double * ln_pk_ic = NULL;  /* array ln_pk_ic[index_k * pfo->ic_ic_size + index_ic1_ic2] */
  double * ln_pk;            /* array ln_pk[index_k] */

  int index_ic1,index_ic2;
  int index_ic1_ic2=0;
  int index_k;
  int index_z;
  int index_pk;

  FileName file_name;

  char redshift_suffix[7]; // 7 is enough to write "z%d_" as long as there are at most 10'000 bins
  char type_suffix[9];     // 6 is enough to write "pk_cb_nl" plus closing character \0
  char first_line[_LINE_LENGTH_MAX_];
  short do_ic = _FALSE_;

  /** - preliminary: check whether we need to output the decomposition into contributions from each initial condition */

  if ((pk_output == pk_linear) && (pfo->ic_size > 1))
    do_ic = _TRUE_;

  /** - allocate arrays to store the P(k) */

  class_alloc(ln_pk,
              pfo->k_size*sizeof(double),
              pop->error_message);

  if (do_ic == _TRUE_) {

    class_alloc(ln_pk_ic,
                pfo->k_size*pfo->ic_ic_size*sizeof(double),
                pop->error_message);

    /** - allocate pointer to output files */

    class_alloc(out_pk_ic,
                pfo->ic_ic_size*sizeof(FILE *),
                pop->error_message);
  }

  /** - loop over pk type (_cb, _m) */

  for (index_pk=0; index_pk<pfo->pk_size; index_pk++) {

    if ((pfo->has_pk_m == _TRUE_) && (index_pk == pfo->index_pk_m)) {
      if (pk_output == pk_linear)
        class_sprintf(type_suffix,"pk");
      else
        class_sprintf(type_suffix,"pk_nl");
    }
    if ((pfo->has_pk_cb == _TRUE_) && (index_pk == pfo->index_pk_cb)) {
      if (pk_output == pk_linear)
        class_sprintf(type_suffix,"pk_cb");
      else
        class_sprintf(type_suffix,"pk_cb_nl");
    }

    /** - loop over z */

    for (index_z = 0; index_z < pop->z_pk_num; index_z++) {

      /** - first, check that requested redshift z_pk is consistent */

      class_test((pop->z_pk[index_z] > ppt->z_max_pk),
                 pop->error_message,
                 "P(k,z) computed up to z=%f but requested at z=%f. Must increase z_max_pk in precision file.",ppt->z_max_pk,pop->z_pk[index_z]);

      if (pop->z_pk_num == 1)
        redshift_suffix[0]='\0';
      else
        class_sprintf(redshift_suffix,"z%d_",index_z+1);

      /** - second, open only the relevant files and write a header in each of them */

      class_sprintf(file_name,"%s%s%s%s",pop->root,redshift_suffix,type_suffix,".dat");

      class_call(output_open_pk_file(pba,
                                     pfo,
                                     pop,
                                     &out_pk,
                                     file_name,
                                     "",
                                     pop->z_pk[index_z]
                                     ),
                 pop->error_message,
                 pop->error_message);

      if (do_ic == _TRUE_) {

        for (index_ic1 = 0; index_ic1 < pfo->ic_size; index_ic1++) {

          for (index_ic2 = index_ic1; index_ic2 < pfo->ic_size; index_ic2++) {

            if ((ppt->has_ad == _TRUE_) && (index_ic1 == ppt->index_ic_ad) && (index_ic2 == ppt->index_ic_ad)) {
              class_sprintf(file_name,"%s%s%s%s",pop->root,redshift_suffix,type_suffix,"_ad.dat");
              strcpy(first_line,"for adiabatic (AD) mode ");
            }

            if ((ppt->has_bi == _TRUE_) && (index_ic1 == ppt->index_ic_bi) && (index_ic2 == ppt->index_ic_bi)) {
              class_sprintf(file_name,"%s%s%s%s",pop->root,redshift_suffix,type_suffix,"_bi.dat");
              strcpy(first_line,"for baryon isocurvature (BI) mode ");
            }

            if ((ppt->has_cdi == _TRUE_) && (index_ic1 == ppt->index_ic_cdi) && (index_ic2 == ppt->index_ic_cdi)) {
              class_sprintf(file_name,"%s%s%s%s",pop->root,redshift_suffix,type_suffix,"_cdi.dat");
              strcpy(first_line,"for CDM isocurvature (CDI) mode ");
            }

            if ((ppt->has_nid == _TRUE_) && (index_ic1 == ppt->index_ic_nid) && (index_ic2 == ppt->index_ic_nid)) {
              class_sprintf(file_name,"%s%s%s%s",pop->root,redshift_suffix,type_suffix,"_nid.dat");
              strcpy(first_line,"for neutrino density isocurvature (NID) mode ");
            }

            if ((ppt->has_niv == _TRUE_) && (index_ic1 == ppt->index_ic_niv) && (index_ic2 == ppt->index_ic_niv)) {
              class_sprintf(file_name,"%s%s%s%s",pop->root,redshift_suffix,type_suffix,"_niv.dat");
              strcpy(first_line,"for neutrino velocity isocurvature (NIV) mode ");
            }

            if ((ppt->has_ad == _TRUE_) && (ppt->has_bi == _TRUE_) && (index_ic1 == ppt->index_ic_ad) && (index_ic2 == ppt->index_ic_bi)) {
              class_sprintf(file_name,"%s%s%s%s",pop->root,redshift_suffix,type_suffix,"_ad_bi.dat");
              strcpy(first_line,"for cross ADxBI mode ");
            }

            if ((ppt->has_ad == _TRUE_) && (ppt->has_cdi == _TRUE_) && (index_ic1 == ppt->index_ic_ad) && (index_ic2 == ppt->index_ic_cdi)) {
              class_sprintf(file_name,"%s%s%s%s",pop->root,redshift_suffix,type_suffix,"_ad_cdi.dat");
              strcpy(first_line,"for cross ADxCDI mode ");
            }

            if ((ppt->has_ad == _TRUE_) && (ppt->has_nid == _TRUE_) && (index_ic1 == ppt->index_ic_ad) && (index_ic2 == ppt->index_ic_nid)) {
              class_sprintf(file_name,"%s%s%s%s",pop->root,redshift_suffix,type_suffix,"_ad_nid.dat");
              strcpy(first_line,"for scalar cross ADxNID mode ");
            }

            if ((ppt->has_ad == _TRUE_) && (ppt->has_niv == _TRUE_) && (index_ic1 == ppt->index_ic_ad) && (index_ic2 == ppt->index_ic_niv)) {
              class_sprintf(file_name,"%s%s%s%s",pop->root,redshift_suffix,type_suffix,"_ad_niv.dat");
              strcpy(first_line,"for cross ADxNIV mode ");
            }

            if ((ppt->has_bi == _TRUE_) && (ppt->has_cdi == _TRUE_) && (index_ic1 == ppt->index_ic_bi) && (index_ic2 == ppt->index_ic_cdi)) {
              class_sprintf(file_name,"%s%s%s%s",pop->root,redshift_suffix,type_suffix,"_bi_cdi.dat");
              strcpy(first_line,"for cross BIxCDI mode ");
            }

            if ((ppt->has_bi == _TRUE_) && (ppt->has_nid == _TRUE_) && (index_ic1 == ppt->index_ic_bi) && (index_ic2 == ppt->index_ic_nid)) {
              class_sprintf(file_name,"%s%s%s%s",pop->root,redshift_suffix,type_suffix,"_bi_nid.dat");
              strcpy(first_line,"for cross BIxNID mode ");
            }

            if ((ppt->has_bi == _TRUE_) && (ppt->has_niv == _TRUE_) && (index_ic1 == ppt->index_ic_bi) && (index_ic2 == ppt->index_ic_niv)) {
              class_sprintf(file_name,"%s%s%s%s",pop->root,redshift_suffix,type_suffix,"_bi_niv.dat");
              strcpy(first_line,"for cross BIxNIV mode ");
            }

            if ((ppt->has_cdi == _TRUE_) && (ppt->has_nid == _TRUE_) && (index_ic1 == ppt->index_ic_cdi) && (index_ic2 == ppt->index_ic_nid)) {
              class_sprintf(file_name,"%s%s%s%s",pop->root,redshift_suffix,type_suffix,"_cdi_nid.dat");
              strcpy(first_line,"for cross CDIxNID mode ");
            }

            if ((ppt->has_cdi == _TRUE_) && (ppt->has_niv == _TRUE_) && (index_ic1 == ppt->index_ic_cdi) && (index_ic2 == ppt->index_ic_niv)) {
              class_sprintf(file_name,"%s%s%s%s",pop->root,redshift_suffix,type_suffix,"_cdi_niv.dat");
              strcpy(first_line,"for cross CDIxNIV mode ");
            }

            if ((ppt->has_nid == _TRUE_) && (ppt->has_niv == _TRUE_) && (index_ic1 == ppt->index_ic_nid) && (index_ic2 == ppt->index_ic_niv)) {
              class_sprintf(file_name,"%s%s%s%s",pop->root,redshift_suffix,type_suffix,"_nid_niv.dat");
              strcpy(first_line,"for cross NIDxNIV mode ");
            }

            index_ic1_ic2 = index_symmetric_matrix(index_ic1,index_ic2,pfo->ic_size);

            if (pfo->is_non_zero[index_ic1_ic2] == _TRUE_) {

              class_call(output_open_pk_file(pba,
                                             pfo,
                                             pop,
                                             &(out_pk_ic[index_ic1_ic2]),
                                             file_name,
                                             first_line,
                                             pop->z_pk[index_z]
                                             ),
                         pop->error_message,
                         pop->error_message);
            }
          }
        }
      }

      /** - third, compute P(k) for each k */

      class_call(fourier_pk_at_z(pba,
                                 pfo,
                                 logarithmic,
                                 pk_output,
                                 pop->z_pk[index_z],
                                 index_pk,
                                 ln_pk,
                                 ln_pk_ic
                                 ),
                 pfo->error_message,
                 pop->error_message);

      /** - fourth, write in files */

      for (index_k=0; index_k<pfo->k_size; index_k++) {

        class_call(output_one_line_of_pk(out_pk,
                                         exp(pfo->ln_k[index_k])/pba->h,
                                         exp(ln_pk[index_k])*pow(pba->h,3)
                                         ),
                   pop->error_message,
                   pop->error_message);

        if (do_ic == _TRUE_) {

          for (index_ic1_ic2 = 0; index_ic1_ic2 < pfo->ic_ic_size; index_ic1_ic2++) {

            if (pfo->is_non_zero[index_ic1_ic2] == _TRUE_) {

              class_call(output_one_line_of_pk(out_pk_ic[index_ic1_ic2],
                                               exp(pfo->ln_k[index_k])/pba->h,
                                               exp(ln_pk_ic[index_k * pfo->ic_ic_size + index_ic1_ic2])*pow(pba->h,3)),
                         pop->error_message,
                         pop->error_message);
            }
          }
        }
      } /* end loop over k */

      /** - fifth, close files */

      fclose(out_pk);

      if (do_ic == _TRUE_) {
        for (index_ic1_ic2 = 0; index_ic1_ic2 < pfo->ic_ic_size; index_ic1_ic2++) {
          if (pfo->is_non_zero[index_ic1_ic2] == _TRUE_) {
            fclose(out_pk_ic[index_ic1_ic2]);
          }
        }
      }

    } /* end loop over index_z */

  } /* end loop over index_pk */

  /* free arrays and pointers */
  free(ln_pk);
  if (pk_output == pk_linear) {
    free(ln_pk_ic);
    free(out_pk_ic);
  }

  return _SUCCESS_;
}

/**
 * This routines writes the output in files for matter transfer functions \f$ T_i(k)\f$'s.
 *
 * @param pba Input: pointer to background structure (needed for calling harmonic_pk_at_z())
 * @param ppt Input: pointer perturbation structure
 * @param pop Input: pointer to output structure
 */

int output_tk(
              struct background * pba,
              struct perturbations * ppt,
              struct output * pop
              ) {

  /** Summary: */

  /** - define local variables */
  char titles[_MAXTITLESTRINGLENGTH_]={0};
  double * data;
  int size_data, number_of_titles;

  FILE * tkfile;

  int index_md;
  int index_ic;
  int index_z;

  double z;

  FileName file_name;
  char redshift_suffix[7]; // 7 is enough to write "z%d_" as long as there are at most 10'000 bins
  char first_line[_LINE_LENGTH_MAX_];
  char ic_suffix[_SUFFIXNAMESIZE_];   // 4 is enough to write "ad", "bi", "cdi", "nid", "niv", ...


  index_md=ppt->index_md_scalars;

  if (pop->output_format == camb_format) {

    class_test(pba->N_ncdm>1,
               pop->error_message,
               "you wish to output the transfer functions in CMBFAST/CAMB format but you have more than one non-cold dark matter (ncdm) species. The two are not compatible (since CMBFAST/CAMB only have one ncdm species): switch to CLASS output format or keep only on ncdm species");

    class_test(ppt->has_velocity_transfers == _TRUE_,
               pop->error_message,
               "you wish to output the transfer functions in CMBFAST/CAMB format, but you requested velocity transfer functions. The two are not compatible (since CMBFAST/CAMB do not compute velocity transfer functions): switch to CLASS output format, or ask only for density transfer function");
  }


  class_call(perturbations_output_titles(pba,ppt,pop->output_format,titles),
             pba->error_message,
             pop->error_message);
  number_of_titles = get_number_of_titles(titles);
  size_data = number_of_titles*ppt->k_size[index_md];

  class_alloc(data, sizeof(double)*ppt->ic_size[index_md]*size_data, pop->error_message);

  for (index_z = 0; index_z < pop->z_pk_num; index_z++) {

    z = pop->z_pk[index_z];

    /** - first, check that requested redshift z_pk is consistent */

    class_test((pop->z_pk[index_z] > ppt->z_max_pk),
               pop->error_message,
               "T_i(k,z) computed up to z=%f but requested at z=%f. Must increase z_max_pk in precision file.",ppt->z_max_pk,pop->z_pk[index_z]);

    if (pop->z_pk_num == 1)
      redshift_suffix[0]='\0';
    else
      class_sprintf(redshift_suffix,"z%d_",index_z+1);

    /** - second, open only the relevant files, and write a heading in each of them */

    class_call(perturbations_output_data_at_z(pba,
                                              ppt,
                                              pop->output_format,
                                              pop->z_pk[index_z],
                                              number_of_titles,
                                              data
                                              ),
               ppt->error_message,
               pop->error_message);

    for (index_ic = 0; index_ic < ppt->ic_size[index_md]; index_ic++) {

      class_call(perturbations_output_firstline_and_ic_suffix(ppt, index_ic, first_line, ic_suffix),
                 ppt->error_message, pop->error_message);

      if ((ppt->has_ad == _TRUE_) && (ppt->ic_size[index_md] == 1) )
        class_sprintf(file_name,"%s%s%s",pop->root,redshift_suffix,"tk.dat");
      else
        class_sprintf(file_name,"%s%s%s%s%s",pop->root,redshift_suffix,"tk_",ic_suffix,".dat");

      class_open(tkfile, file_name, "w", pop->error_message);

      if (pop->write_header == _TRUE_) {
        if (pop->output_format == class_format) {
          fprintf(tkfile,"# Transfer functions T_i(k) %sat redshift z=%g\n",first_line,z);
          fprintf(tkfile,"# for k=%g to %g h/Mpc,\n",ppt->k[index_md][0]/pba->h,ppt->k[index_md][ppt->k_size[index_md]-1]/pba->h);
          fprintf(tkfile,"# number of wavenumbers equal to %d\n",ppt->k_size[index_md]);
          if (ppt->has_density_transfers == _TRUE_) {
            fprintf(tkfile,"# d_i   stands for (delta rho_i/rho_i)(k,z) with above normalization \n");
            fprintf(tkfile,"# d_tot stands for (delta rho_tot/rho_tot)(k,z) with rho_Lambda NOT included in rho_tot\n");
            fprintf(tkfile,"# (note that this differs from the transfer function output from CAMB/CMBFAST, which gives the same\n");
            fprintf(tkfile,"#  quantities divided by -k^2 with k in Mpc^-1; use format=camb to match CAMB)\n");
          }
          if (ppt->has_velocity_transfers == _TRUE_) {
            fprintf(tkfile,"# t_i   stands for theta_i(k,z) with above normalization \n");
            fprintf(tkfile,"# t_tot stands for (sum_i [rho_i+p_i] theta_i)/(sum_i [rho_i+p_i]))(k,z)\n");
          }
          fprintf(tkfile,"#\n");
        }
        else if (pop->output_format == camb_format) {

          fprintf(tkfile,"# Rescaled matter transfer functions [-T_i(k)/k^2] %sat redshift z=%g\n",first_line,z);
          fprintf(tkfile,"# for k=%g to %g h/Mpc,\n",ppt->k[index_md][0]/pba->h,ppt->k[index_md][ppt->k_size[index_md]-1]/pba->h);
          fprintf(tkfile,"# number of wavenumbers equal to %d\n",ppt->k_size[index_md]);
          fprintf(tkfile,"# T_i   stands for (delta rho_i/rho_i)(k,z) with above normalization \n");
          fprintf(tkfile,"# The rescaling factor [-1/k^2] with k in 1/Mpc is here to match the CMBFAST/CAMB output convention\n");
          fprintf(tkfile,"#\n");
          fprintf(tkfile,"#");
          fprintf(tkfile,"\n");

        }
      }

      output_print_data(tkfile,
                        titles,
                        data+index_ic*size_data,
                        size_data);

      /** - free memory and close files */
      fclose(tkfile);

    }

  }

  free(data);

  return _SUCCESS_;

}

int output_background(
                      struct background * pba,
                      struct output * pop
                      ) {

  FILE * backfile;
  FileName file_name;

  char titles[_MAXTITLESTRINGLENGTH_]={0};
  double * data;
  int size_data, number_of_titles;

  class_call(background_output_titles(pba,titles),
             pba->error_message,
             pop->error_message);
  number_of_titles = get_number_of_titles(titles);
  size_data = number_of_titles*pba->bt_size;
  class_alloc(data,sizeof(double)*size_data,pop->error_message);
  class_call(background_output_data(pba,
                                    number_of_titles,
                                    data),
             pba->error_message,
             pop->error_message);

  class_sprintf(file_name,"%s%s",pop->root,"background.dat");
  class_open(backfile,file_name,"w",pop->error_message);

  if (pop->write_header == _TRUE_) {
    fprintf(backfile,"# Table of selected background quantities\n");
    fprintf(backfile,"# All densities are multiplied by (8piG/3) (below, shortcut notation (.) for this factor) \n");
    fprintf(backfile,"# Densities are in units [Mpc^-2] while all distances are in [Mpc]. \n");
    if (pba->has_scf == _TRUE_){
      fprintf(backfile,"# The units of phi, tau in the derivatives and the potential V are the following:\n");
      fprintf(backfile,"# --> phi is given in units of the reduced Planck mass m_Pl = (8 pi G)^(-1/2)\n");
      fprintf(backfile,"# --> tau in the derivative of V(phi) is given in units of Mpc.\n");
      fprintf(backfile,"# --> the potential V(phi) is given in units of m_Pl^2/Mpc^2.\n");
    }
  }

  output_print_data(backfile,
                    titles,
                    data,
                    size_data);

  free(data);
  fclose(backfile);

  return _SUCCESS_;

}

int output_thermodynamics(
                          struct background * pba,
                          struct thermodynamics * pth,
                          struct output * pop
                          ) {

  FileName file_name;
  FILE * thermofile;
  char titles[_MAXTITLESTRINGLENGTH_]={0};
  double * data;
  int size_data, number_of_titles;

  class_call(thermodynamics_output_titles(pba,pth,titles),
             pth->error_message,
             pop->error_message);
  number_of_titles = get_number_of_titles(titles);
  size_data = number_of_titles*pth->tt_size;
  class_alloc(data,sizeof(double)*size_data,pop->error_message);
  class_call(thermodynamics_output_data(pba,
                                        pth,
                                        number_of_titles,
                                        data),
             pth->error_message,
             pop->error_message);

  class_sprintf(file_name,"%s%s",pop->root,"thermodynamics.dat");
  class_open(thermofile,file_name,"w",pop->error_message);

  if (pop->write_header == _TRUE_) {
    fprintf(thermofile,"# Table of selected thermodynamics quantities\n");
    fprintf(thermofile,"# The following notation is used in column titles:\n");
    fprintf(thermofile,"#         x_e = electron ionization fraction\n");
    fprintf(thermofile,"#      -kappa = optical depth\n");
    fprintf(thermofile,"#      kappa' = Thomson scattering rate, prime denotes conformal time derivatives\n");
    fprintf(thermofile,"#           g = kappa' e^-kappa = visibility function \n");
    fprintf(thermofile,"#          Tb = baryon temperature \n");
    fprintf(thermofile,"#         w_b = baryon equation of state parameter \n");
    fprintf(thermofile,"#       c_b^2 = baryon sound speed squared \n");
    fprintf(thermofile,"#       tau_d = baryon drag optical depth \n");
    if (pth->compute_damping_scale == _TRUE_)
      fprintf(thermofile,"#         r_d = approximate comoving value of photon damping scale \n");
    if (pth->has_idm_dr == _TRUE_) {
      fprintf(thermofile,"#  dmu_idm_dr = scattering rate of idr with idm_dr (i.e. idr opacity to idm_dr scattering) (units 1/Mpc)\n");
      fprintf(thermofile,"# ddmu_idm_dr = derivative of this rate\n");
      fprintf(thermofile,"#  tau_idm_dr = optical depth of idm_dr (due to interactions with idr) \n");
      fprintf(thermofile,"#     tau_idr = optical depth of idr (due to self-interactions) \n");
      fprintf(thermofile,"#    g_idm_dr = visibility function of idm_idr \n");
      fprintf(thermofile,"#  c_idm_dr^2 = interacting dark matter squared sound speed \n");
      fprintf(thermofile,"#    T_idm_dr = temperature of DM interacting with DR \n");
      fprintf(thermofile,"#     dmu_idr = idr self-interaction rate \n");
    }
  }

  output_print_data(thermofile,
                    titles,
                    data,
                    size_data);

  free(data);
  fclose(thermofile);

  return _SUCCESS_;

}


int output_perturbations(
                         struct background * pba,
                         struct perturbations * ppt,
                         struct output * pop
                         ) {

  FILE * out;
  FileName file_name;
  int index_ikout, index_md;
  double k;

  for (index_ikout=0; index_ikout<ppt->k_output_values_num; index_ikout++){

    if (ppt->has_scalars == _TRUE_){
      index_md = ppt->index_md_scalars;
      k = ppt->k[index_md][ppt->index_k_output_values[index_md*ppt->k_output_values_num+index_ikout]];
      class_sprintf(file_name,"%s%s%d%s",pop->root,"perturbations_k",index_ikout,"_s.dat");
      class_open(out, file_name, "w", ppt->error_message);
      fprintf(out,"#scalar perturbations for mode k = %.*e Mpc^(-1)\n",_OUTPUTPRECISION_,k);
      output_print_data(out,
                        ppt->scalar_titles,
                        ppt->scalar_perturbations_data[index_ikout],
                        ppt->size_scalar_perturbation_data[index_ikout]);

      fclose(out);
    }
    if (ppt->has_vectors == _TRUE_){
      index_md = ppt->index_md_vectors;
      k = ppt->k[index_md][ppt->index_k_output_values[index_md*ppt->k_output_values_num+index_ikout]];
      class_sprintf(file_name,"%s%s%d%s",pop->root,"perturbations_k",index_ikout,"_v.dat");
      class_open(out, file_name, "w", ppt->error_message);
      fprintf(out,"#vector perturbations for mode k = %.*e Mpc^(-1)\n",_OUTPUTPRECISION_,k);
      output_print_data(out,
                        ppt->vector_titles,
                        ppt->vector_perturbations_data[index_ikout],
                        ppt->size_vector_perturbation_data[index_ikout]);

      fclose(out);
    }
    if (ppt->has_tensors == _TRUE_){
      index_md = ppt->index_md_tensors;
      k = ppt->k[index_md][ppt->index_k_output_values[index_md*ppt->k_output_values_num+index_ikout]];
      class_sprintf(file_name,"%s%s%d%s",pop->root,"perturbations_k",index_ikout,"_t.dat");
      class_open(out, file_name, "w", ppt->error_message);
      fprintf(out,"#tensor perturbations for mode k = %.*e Mpc^(-1)\n",_OUTPUTPRECISION_,k);
      output_print_data(out,
                        ppt->tensor_titles,
                        ppt->tensor_perturbations_data[index_ikout],
                        ppt->size_tensor_perturbation_data[index_ikout]);

      fclose(out);
    }


  }
  return _SUCCESS_;

}

int output_primordial(
                      struct perturbations * ppt,
                      struct primordial * ppm,
                      struct output * pop
                      ) {
  FileName file_name;
  FILE * out;
  char titles[_MAXTITLESTRINGLENGTH_]={0};
  double * data;
  int size_data, number_of_titles;

  class_sprintf(file_name,"%s%s",pop->root,"primordial_Pk.dat");

  class_call(primordial_output_titles(ppt,ppm,titles),
             ppm->error_message,
             pop->error_message);
  number_of_titles = get_number_of_titles(titles);
  size_data = number_of_titles*ppm->lnk_size;
  class_alloc(data,sizeof(double)*size_data,pop->error_message);
  class_call(primordial_output_data(ppt,
                                    ppm,
                                    number_of_titles,
                                    data),
             ppm->error_message,
             pop->error_message);

  class_open(out,file_name,"w",pop->error_message);
  if (pop->write_header == _TRUE_) {
    fprintf(out,"# Dimensionless primordial spectrum, equal to [k^3/2pi^2] P(k) \n");
  }

  output_print_data(out,
                    titles,
                    data,
                    size_data);

  free(data);
  fclose(out);

  return _SUCCESS_;
}

int output_heating(struct injection* pin, struct noninjection* pni, struct output * pop) {

  /** Local variables*/
  FileName file_name_injection;
  FILE * out_injection;
  FileName file_name_noninjection;
  FILE * out_noninjection;

  char titles_injection[_MAXTITLESTRINGLENGTH_]={0};

  double * data_injection;
  int size_data_injection;
  int number_of_titles_injection;

  char titles_noninjection[_MAXTITLESTRINGLENGTH_]={0};

  double * data_noninjection;
  int size_data_noninjection;
  int number_of_titles_noninjection;

  if (pop->write_exotic_injection == _TRUE_){

    /* File name */
    class_sprintf(file_name_injection,"%s%s",pop->root,"exotic_injection.dat");

    /* Titles */
    class_call(injection_output_titles(pin,titles_injection),
               pin->error_message,
               pin->error_message);
    number_of_titles_injection = get_number_of_titles(titles_injection);

    /* Data array */
    size_data_injection = number_of_titles_injection*pin->z_size;
    class_alloc(data_injection,
                sizeof(double)*size_data_injection,
                pop->error_message);
    class_call(injection_output_data(pin,
                                     number_of_titles_injection,
                                     data_injection),
               pin->error_message,
               pop->error_message);

    /* File IO */
    class_open(out_injection,
               file_name_injection,
               "w",
               pop->error_message);

    if (pop->write_header == _TRUE_){
      fprintf(out_injection,"# Table of energy injection and deposition from exotic processes \n");
      fprintf(out_injection,"# Heat is dE/dt|dep_h\n");
    }

    output_print_data(out_injection,
                      titles_injection,
                      data_injection,
                      size_data_injection);
    free(data_injection);
    fclose(out_injection);

  }

  if (pop->write_noninjection == _TRUE_){

    /* File name */
    class_sprintf(file_name_noninjection,"%s%s",pop->root,"photon_noninjection.dat");

    /* Titles */
    class_call(noninjection_output_titles(pni,titles_noninjection),
               pni->error_message,
               pni->error_message);
    number_of_titles_noninjection = get_number_of_titles(titles_noninjection);

    /* Data array */
    size_data_noninjection = number_of_titles_noninjection*pin->z_size;
    class_alloc(data_noninjection,
                sizeof(double)*size_data_noninjection,
                pop->error_message);
    class_call(noninjection_output_data(pni,
                                        number_of_titles_noninjection,
                                        data_noninjection),
               pni->error_message,
               pop->error_message);

    /* File IO */
    class_open(out_noninjection,
               file_name_noninjection,
               "w",
               pop->error_message);

    if (pop->write_header == _TRUE_){
      fprintf(out_noninjection,"# Table of non-injected energy influencing the photon spectral distortions \n");
    }

    output_print_data(out_noninjection,
                      titles_noninjection,
                      data_noninjection,
                      size_data_noninjection);
    free(data_noninjection);
    fclose(out_noninjection);

  }

  return _SUCCESS_;
}

int output_distortions(
                       struct distortions * psd,
                       struct output * pop
                       ) {

  /** Local variables*/
  FileName file_name_heat, file_name_distortion;
  FILE * out_heat, * out_distortion;

  char titles_heat[_MAXTITLESTRINGLENGTH_]={0};
  char titles_distortion[_MAXTITLESTRINGLENGTH_]={0};

  double * data_heat, * data_distortion;
  int size_data_heat, size_data_distortion;
  int number_of_titles_heat, number_of_titles_distortion;

  if (pop->write_distortions==_TRUE_ && psd->has_distortions == _TRUE_){

    /* File name */
    class_sprintf(file_name_heat,"%s%s",pop->root,"sd_heating.dat");

    /* Titles */
    class_call(distortions_output_heat_titles(psd,titles_heat),
               psd->error_message,
               pop->error_message);
    number_of_titles_heat = get_number_of_titles(titles_heat);

    /* Data array */
    size_data_heat = number_of_titles_heat*psd->z_size;
    class_alloc(data_heat,
                sizeof(double)*size_data_heat,
                pop->error_message);
    class_call(distortions_output_heat_data(psd,
                                            number_of_titles_heat,
                                            data_heat),
               psd->error_message,
               pop->error_message);

    /* File IO */
    class_open(out_heat,
               file_name_heat,
               "w",
               pop->error_message);

    if (pop->write_header == _TRUE_){
      fprintf(out_heat,"# Heat is d(Q/rho)/dz\n");
      fprintf(out_heat,"# LHeat is d(Q/rho)/dlnz\n");
      fprintf(out_heat,"#\n");
    }

    output_print_data(out_heat,
                      titles_heat,
                      data_heat,
                      size_data_heat);
    free(data_heat);
    fclose(out_heat);

    /* File name */
    class_sprintf(file_name_distortion,"%s%s",pop->root,"sd_distortions.dat");

    /* Titles */
    class_call(distortions_output_sd_titles(psd,titles_distortion),
               psd->error_message,
               pop->error_message);
    number_of_titles_distortion = get_number_of_titles(titles_distortion);

    /* Data array */
    size_data_distortion = number_of_titles_distortion*psd->x_size;
    class_alloc(data_distortion,
                sizeof(double)*size_data_distortion,
                pop->error_message);
    class_call(distortions_output_sd_data(psd,
                                          number_of_titles_distortion,
                                          data_distortion),
               psd->error_message,
               pop->error_message);

    /* File IO */
    class_open(out_distortion,
               file_name_distortion,
               "w",
               pop->error_message);

    if (pop->write_header == _TRUE_){
      fprintf(out_distortion,"# SD_tot is the amplitude of the overall spectral distortion (SD)\n");
      fprintf(out_distortion,"# The SD[i] are the amplitudes of the individual SDs\n");
      fprintf(out_distortion,"# The SDs are given in units [10^-26 W m^-2 Hz^-1 sr^-1] \n");
      fprintf(out_distortion,"#\n");
    }

    output_print_data(out_distortion,
                      titles_distortion,
                      data_distortion,
                      size_data_distortion);
    free(data_distortion);
    fclose(out_distortion);
  }

  return _SUCCESS_;
}


int output_print_data(FILE *out,
                      char titles[_MAXTITLESTRINGLENGTH_],
                      double *dataptr,
                      int size_dataptr){
  int colnum=1, number_of_titles;
  int index_title, index_tau;
  char thetitle[_MAXTITLESTRINGLENGTH_];
  char *pch;

  /** Summary*/

  /** - First we print the titles */
  fprintf(out,"#");

  strcpy(thetitle,titles);
  pch = strtok(thetitle,_DELIMITER_);
  while (pch != NULL){
    class_fprintf_columntitle(out, pch, _TRUE_, colnum);
    pch = strtok(NULL,_DELIMITER_);
  }
  fprintf(out,"\n");

  /** - Then we print the data */
  number_of_titles = colnum-1;
  if (number_of_titles>0){
    for (index_tau=0; index_tau<size_dataptr/number_of_titles; index_tau++){
      fprintf(out," ");
      for (index_title=0; index_title<number_of_titles; index_title++){
        class_fprintf_double(out, dataptr[index_tau*number_of_titles+index_title], _TRUE_);
      }
      fprintf(out,"\n");
    }
  }
  return _SUCCESS_;
}


/**
 * This routine opens one file where some \f$ C_l\f$'s will be written, and writes
 * a heading with some general information concerning its content.
 *
 * @param phr        Input: pointer to harmonic structure
 * @param pop        Input: pointer to output structure
 * @param clfile     Output: returned pointer to file pointer
 * @param filename   Input: name of the file
 * @param first_line Input: text describing the content (mode, initial condition..)
 * @param lmax       Input: last multipole in the file (the first one is assumed to be 2)
 * @return the error status
 */

int output_open_cl_file(
                        struct harmonic * phr,
                        struct output * pop,
                        FILE * * clfile,
                        FileName filename,
                        char * first_line,
                        int lmax
                        ) {
  /** Summary */

  int index_d1,index_d2;
  int colnum = 1;
  char tmp[60]; //A fixed number here is ok, since it should just correspond to the largest string which is printed to tmp.

  class_open(*clfile,filename,"w",pop->error_message);

  if (pop->write_header == _TRUE_) {

    /** - First we deal with the entries that are dependent of format type */

    if (pop->output_format == class_format) {
      fprintf(*clfile,"# dimensionless %s\n",first_line);
    }
    if (pop->output_format == camb_format) {
      fprintf(*clfile,"# %s (units: [microK]^2)\n",first_line);
    }

    fprintf(*clfile,"# for l=2 to %d, i.e. number of multipoles equal to %d\n",lmax,lmax-1);
    fprintf(*clfile,"#\n");

    if (pop->output_format == class_format) {
      fprintf(*clfile,"# -> if you prefer output in CAMB/HealPix/LensPix units/order, set 'format' to 'camb' in input file\n");
    }

    fprintf(*clfile,"# -> if you don't want to see such a header, set 'headers' to 'no' in input file\n");

    if (phr->has_pp == _TRUE_) {
      if (pop->output_format == class_format) {
        fprintf(*clfile,"# -> for CMB lensing (phi), these are C_l^phi-phi for the lensing potential.\n");
      }
      if (pop->output_format == camb_format) {
        fprintf(*clfile,"# -> for CMB lensing (d), these are C_l^dd for the deflection field.\n");
      }
    }

    if (phr->has_ll == _TRUE_) {
      fprintf(*clfile,"# -> for galaxy lensing (lens[i]), these are C_l^phi-phi for the lensing potential.\n");
    }

    if (phr->has_pp == _TRUE_ || phr->has_ll == _TRUE_) {
      fprintf(*clfile,"#    Remember the conversion factors:\n");
      fprintf(*clfile,"#    C_l^dd (deflection) = l(l+1) C_l^phi-phi\n");
      fprintf(*clfile,"#    C_l^gg (shear/convergence) = 1/4 (l(l+1))^2 C_l^phi-phi\n");
    }

    fprintf(*clfile,"#\n");

    if (0==1){
      fprintf(*clfile,"#");
      class_fprintf_columntitle(*clfile,"l",_TRUE_,colnum);
    }
    else{
      fprintf(*clfile,"# 1:l ");
      colnum++;
    }
    if (pop->output_format == class_format) {
      class_fprintf_columntitle(*clfile,"TT",phr->has_tt,colnum);
      class_fprintf_columntitle(*clfile,"EE",phr->has_ee,colnum);
      class_fprintf_columntitle(*clfile,"TE",phr->has_te,colnum);
      class_fprintf_columntitle(*clfile,"BB",phr->has_bb,colnum);
      class_fprintf_columntitle(*clfile,"phiphi",phr->has_pp,colnum);
      class_fprintf_columntitle(*clfile,"TPhi",phr->has_tp,colnum);
      class_fprintf_columntitle(*clfile,"Ephi",phr->has_ep,colnum);
    }
    else if (pop->output_format == camb_format) {
      class_fprintf_columntitle(*clfile,"TT",phr->has_tt,colnum);
      class_fprintf_columntitle(*clfile,"EE",phr->has_ee,colnum);
      class_fprintf_columntitle(*clfile,"BB",phr->has_bb,colnum);
      class_fprintf_columntitle(*clfile,"TE",phr->has_te,colnum);
      class_fprintf_columntitle(*clfile,"dd",phr->has_pp,colnum);
      class_fprintf_columntitle(*clfile,"dT",phr->has_tp,colnum);
      class_fprintf_columntitle(*clfile,"dE",phr->has_ep,colnum);
    }

    /** - Next deal with entries that are independent of format type */

    if (phr->has_dd == _TRUE_){
      for (index_d1=0; index_d1<phr->d_size; index_d1++){
        for (index_d2=index_d1; index_d2<=MIN(index_d1+phr->non_diag,phr->d_size-1); index_d2++){
          class_sprintf(tmp,"dens[%d]-dens[%d]",index_d1+1,index_d2+1);
          class_fprintf_columntitle(*clfile,tmp,_TRUE_,colnum);
        }
      }
    }
    if (phr->has_td == _TRUE_){
      for (index_d1=0; index_d1<phr->d_size; index_d1++){
        class_sprintf(tmp,"T-dens[%d]",index_d1+1);
        class_fprintf_columntitle(*clfile,tmp,_TRUE_,colnum);
      }
    }
    if (phr->has_pd == _TRUE_){
      for (index_d1=0; index_d1<phr->d_size; index_d1++){
        class_sprintf(tmp,"phi-dens[%d]",index_d1+1);
        class_fprintf_columntitle(*clfile,tmp,_TRUE_,colnum);
      }
    }
    if (phr->has_ll == _TRUE_){
      for (index_d1=0; index_d1<phr->d_size; index_d1++){
        for (index_d2=index_d1; index_d2<=MIN(index_d1+phr->non_diag,phr->d_size-1); index_d2++){
          class_sprintf(tmp,"lens[%d]-lens[%d]",index_d1+1,index_d2+1);
          class_fprintf_columntitle(*clfile,tmp,_TRUE_,colnum);
        }
      }
    }
    if (phr->has_tl == _TRUE_){
      for (index_d1=0; index_d1<phr->d_size; index_d1++){
        class_sprintf(tmp,"T-lens[%d]",index_d1+1);
        class_fprintf_columntitle(*clfile,tmp,_TRUE_,colnum);
      }
    }
    if (phr->has_dl == _TRUE_){
      for (index_d1=0; index_d1<phr->d_size; index_d1++){
        for (index_d2=MAX(index_d1-phr->non_diag,0); index_d2<=MIN(index_d1+phr->non_diag,phr->d_size-1); index_d2++) {
          class_sprintf(tmp,"dens[%d]-lens[%d]",index_d1+1,index_d2+1);
          class_fprintf_columntitle(*clfile,tmp,_TRUE_,colnum);
        }
      }
    }
    fprintf(*clfile,"\n");
  }

  return _SUCCESS_;

}

/**
 * This routine write one line with l and all \f$ C_l\f$'s for all types (TT, TE...)
 *
 * @param pba        Input: pointer to background structure (needed for \f$ T_{cmb}\f$)
 * @param phr        Input: pointer to harmonic structure
 * @param pop        Input: pointer to output structure
 * @param clfile  Input: file pointer
 * @param l       Input: multipole
 * @param cl      Input: \f$ C_l\f$'s for all types
 * @param ct_size Input: number of types
 * @return the error status
 */

int output_one_line_of_cl(
                          struct background * pba,
                          struct harmonic * phr,
                          struct output * pop,
                          FILE * clfile,
                          double l,
                          double * cl, /* array with argument cl[index_ct] */
                          int ct_size
                          ) {
  int index_ct, index_ct_rest;
  double factor;

  factor = l*(l+1)/2./_PI_;

  fprintf(clfile," ");

  if (0==1){
    class_fprintf_int(clfile, (int)l, _TRUE_);
  }
  else{
    fprintf(clfile,"%4d ",(int)l);
  }

  if (pop->output_format == class_format) {

    for (index_ct=0; index_ct < ct_size; index_ct++) {
      class_fprintf_double(clfile, factor*cl[index_ct], _TRUE_);
    }
    fprintf(clfile,"\n");
  }

  if (pop->output_format == camb_format) {
    class_fprintf_double(clfile, factor*pow(pba->T_cmb*1.e6,2)*cl[phr->index_ct_tt], phr->has_tt);
    class_fprintf_double(clfile, factor*pow(pba->T_cmb*1.e6,2)*cl[phr->index_ct_ee], phr->has_ee);
    class_fprintf_double(clfile, factor*pow(pba->T_cmb*1.e6,2)*cl[phr->index_ct_bb], phr->has_bb);
    class_fprintf_double(clfile, factor*pow(pba->T_cmb*1.e6,2)*cl[phr->index_ct_te], phr->has_te);
    class_fprintf_double(clfile, l*(l+1)*factor*cl[phr->index_ct_pp], phr->has_pp);
    class_fprintf_double(clfile, sqrt(l*(l+1))*factor*pba->T_cmb*1.e6*cl[phr->index_ct_tp], phr->has_tp);
    class_fprintf_double(clfile, sqrt(l*(l+1))*factor*pba->T_cmb*1.e6*cl[phr->index_ct_ep], phr->has_ep);
    index_ct_rest = 0;
    if (phr->has_tt == _TRUE_)
      index_ct_rest++;
    if (phr->has_ee == _TRUE_)
      index_ct_rest++;
    if (phr->has_bb == _TRUE_)
      index_ct_rest++;
    if (phr->has_te == _TRUE_)
      index_ct_rest++;
    if (phr->has_pp == _TRUE_)
      index_ct_rest++;
    if (phr->has_tp == _TRUE_)
      index_ct_rest++;
    if (phr->has_ep == _TRUE_)
      index_ct_rest++;
    /* Now print the remaining (if any) entries:*/
    for (index_ct=index_ct_rest; index_ct < ct_size; index_ct++) {
      class_fprintf_double(clfile, factor*cl[index_ct], _TRUE_);
    }

    fprintf(clfile,"\n");

  }
  return _SUCCESS_;

}

/**
 * This routine opens one file where some P(k)'s will be written, and writes
 * a heading with some general information concerning its content.
 *
 * @param pba        Input: pointer to background structure (needed for h)
 * @param pfo        Input: pointer to fourier structure
 * @param pop        Input: pointer to output structure
 * @param pkfile     Output: returned pointer to file pointer
 * @param filename   Input: name of the file
 * @param first_line Input: text describing the content (initial conditions, ...)
 * @param z          Input: redshift of the output
 * @return the error status
 */

int output_open_pk_file(
                        struct background * pba,
                        struct fourier * pfo,
                        struct output * pop,
                        FILE * * pkfile,
                        FileName filename,
                        char * first_line,
                        double z
                        ) {

  int colnum = 1;
  class_open(*pkfile,filename,"w",pop->error_message);

  if (pop->write_header == _TRUE_) {
    fprintf(*pkfile,"# Matter power spectrum P(k) %sat redshift z=%g\n",first_line,z);
    fprintf(*pkfile,"# for k=%g to %g h/Mpc,\n",
            exp(pfo->ln_k[0])/pba->h,
            exp(pfo->ln_k[pfo->k_size-1])/pba->h);
    fprintf(*pkfile,"# number of wavenumbers equal to %d\n",pfo->k_size);

    fprintf(*pkfile,"#");
    class_fprintf_columntitle(*pkfile,"k (h/Mpc)",_TRUE_,colnum);
    class_fprintf_columntitle(*pkfile,"P (Mpc/h)^3",_TRUE_,colnum);

    fprintf(*pkfile,"\n");
  }

  return _SUCCESS_;
}

/**
 * This routine writes one line with k and P(k)
 *
 * @param pkfile  Input: file pointer
 * @param one_k   Input: wavenumber
 * @param one_pk  Input: matter power spectrum
 * @return the error status
 */

int output_one_line_of_pk(
                          FILE * pkfile,
                          double one_k,
                          double one_pk
                          ) {

  fprintf(pkfile," ");
  class_fprintf_double(pkfile,one_k,_TRUE_);
  class_fprintf_double(pkfile,one_pk,_TRUE_);
  fprintf(pkfile,"\n");

  return _SUCCESS_;

}

```

`source/perturbations.c`:

```c
/** @file perturbations.c Documented perturbation module
 *
 * Julien Lesgourgues, 23.09.2010
 *
 * Deals with the perturbation evolution.
 * This module has two purposes:
 *
 * - at the beginning; to initialize the perturbations, i.e. to
 * integrate the perturbation equations, and store temporarily the terms
 * contributing to the source functions as a function of conformal
 * time. Then, to perform a few manipulations of these terms in order to
 * infer the actual source functions \f$ S^{X} (k, \tau) \f$, and to
 * store them as a function of conformal time inside an interpolation
 * table.
 *
 * - at any time in the code; to evaluate the source functions at a
 * given conformal time (by interpolating within the interpolation
 * table).
 *
 * Hence the following functions can be called from other modules:
 *
 * -# perturbations_init() at the beginning (but after background_init() and thermodynamics_init())
 * -# perturbations_sources_at_tau() at any later time
 * -# perturbations_free() at the end, when no more calls to perturbations_sources_at_tau() are needed
 */

#include "perturbations.h"
#include "parallel.h"


/**
 * Source function \f$ S^{X} (k, \tau) \f$ at a given conformal time tau.
 *
 * Evaluate source functions at given conformal time tau by reading
 * the pre-computed table and interpolating.
 *
 * @param ppt        Input: pointer to perturbation structure containing interpolation tables
 * @param index_md   Input: index of requested mode (for scalars, just pass ppt->index_md_scalars)
 * @param index_ic   Input: index of requested initial condition (for adiabatic, just pass ppt->index_ic_ad)
 * @param index_tp   Input: index of requested source function type
 * @param tau        Input: any value of conformal time
 * @param psource_at_tau Output: vector (already allocated) of source function as a function of k, psource_at_tau[index_k]
 * @return the error status
 */

int perturbations_sources_at_tau(
                                 struct perturbations * ppt,
                                 int index_md,
                                 int index_ic,
                                 int index_tp,
                                 double tau,
                                 double * psource_at_tau
                                 ) {

  /** Summary: */

  /** - define local variables */

  int last_index;
  double logtau;

  short do_spline = _FALSE_;

  logtau = log(tau);

  /** - If we have defined a z_max_pk > 0, then we have already an
     array of sources and of their second derivative with respect to
     time in the range 0 < z < z_max_pk, that can be used for an
     accurate spline interpolation at a given tau. Check whether we
     are in this situation and whether the value of tau is in the
     right range. */

  if (ppt->ln_tau_size > 1) {
    if (logtau >= ppt->ln_tau[0]) {
      do_spline = _TRUE_;
    }
  }

  /** - If yes, we do such a spline */

  if (do_spline == _TRUE_) {

    class_call(array_interpolate_spline(ppt->ln_tau,
                                        ppt->ln_tau_size,
                                        ppt->late_sources[index_md][index_ic * ppt->tp_size[index_md] + index_tp],
                                        ppt->ddlate_sources[index_md][index_ic*ppt->tp_size[index_md] + index_tp],
                                        ppt->k_size[index_md],
                                        logtau,
                                        &last_index,
                                        psource_at_tau,
                                        ppt->k_size[index_md],
                                        ppt->error_message),
               ppt->error_message,
               ppt->error_message);
  }


  /** - otherwise, we just go for a quick linear interpolation. This
        is made available for developpers for completeness, but it is
        actually never used by the default version of CLASS */

  else {

    class_call(array_interpolate_two_bis(ppt->tau_sampling,
                                         1,
                                         0,
                                         ppt->sources[index_md][index_ic*ppt->tp_size[index_md]+index_tp],
                                         ppt->k_size[index_md],
                                         ppt->tau_size,
                                         tau,
                                         psource_at_tau,
                                         ppt->k_size[index_md],
                                         ppt->error_message),
               ppt->error_message,
               ppt->error_message);
  }

  return _SUCCESS_;
}

/**
 * Source function \f$ S^{X} (k, \tau) \f$ at a given redhsift z.
 *
 * Evaluate source functions at given redhsift z by reading
 * the pre-computed table and interpolating.
 *
 * @param pba        Input: pointer to background structure
 * @param ppt        Input: pointer to perturbation structure containing interpolation tables
 * @param index_md   Input: index of requested mode (for scalars, just pass ppt->index_md_scalars)
 * @param index_ic   Input: index of requested initial condition (for adiabatic, just pass ppt->index_ic_ad)
 * @param index_tp   Input: index of requested source function type
 * @param z          Input: any value of redshift
 * @param psource_at_z Output: vector (already allocated) of source function as a function of k, psource_at_z[index_k]
 * @return the error status
 */

int perturbations_sources_at_z(
                               struct background * pba,
                               struct perturbations * ppt,
                               int index_md,
                               int index_ic,
                               int index_tp,
                               double z,
                               double * psource_at_z
                               ) {

  double tau;

  class_call(background_tau_of_z(pba,
                                 z,
                                 &tau),
             pba->error_message,
             ppt->error_message);

  class_call(perturbations_sources_at_tau(ppt,index_md,index_ic,index_tp,tau,psource_at_z),
             ppt->error_message,
             ppt->error_message);

  return _SUCCESS_;
}

/**
 * Source function \f$ S^{X} (k, \tau) \f$ at a given redhsift z and wavenumber k.
 *
 * Evaluate source functions at given redhsift z and wavenumber k by reading
 * the pre-computed table and interpolating.
 *
 * @param pba        Input: pointer to background structure
 * @param ppt        Input: pointer to perturbation structure containing interpolation tables
 * @param index_md   Input: index of requested mode (for scalars, just pass ppt->index_md_scalars)
 * @param index_ic   Input: index of requested initial condition (for adiabatic, just pass ppt->index_ic_ad)
 * @param index_tp   Input: index of requested source function type
 * @param k          Input: any value of wavenumber
 * @param z          Input: any value of redshift
 * @param psource_at_k_and_z Output: pointer to the source function at (k,z) (so to just one number)
 * @return the error status
 */

int perturbations_sources_at_k_and_z(
                                     struct background * pba,
                                     struct perturbations * ppt,
                                     int index_md,
                                     int index_ic,
                                     int index_tp,
                                     double k,
                                     double z,
                                     double * psource_at_k_and_z
                                     ) {

  double * sources;
  double * ddsources_dk2;
  int last_index;

  class_alloc(sources,
              ppt->k_size[index_md]*sizeof(double),
              ppt->error_message);

  class_alloc(ddsources_dk2,
              ppt->k_size[index_md]*sizeof(double),
              ppt->error_message);

  class_call(perturbations_sources_at_z(pba,ppt,index_md,index_ic,index_tp,z,sources),
             ppt->error_message,
             ppt->error_message);

  class_call(array_spline_table_lines(ppt->k[index_md],
                                      ppt->k_size[index_md],
                                      sources,
                                      1,
                                      ddsources_dk2,
                                      _SPLINE_EST_DERIV_,
                                      ppt->error_message),
             ppt->error_message,
             ppt->error_message);

  class_call(array_interpolate_spline(ppt->k[index_md],
                                      ppt->k_size[index_md],
                                      sources,
                                      ddsources_dk2,
                                      1,
                                      k,
                                      &last_index,
                                      psource_at_k_and_z,
                                      1,
                                      ppt->error_message),
             ppt->error_message,
             ppt->error_message);

  return _SUCCESS_;
}

/**
 * Function called by the output module or the wrappers, which returns
 * the source functions \f$ S^{X} (k, \tau) \f$ corresponding to
 * densities ('dTk') and velocities ('vTk') at a given conformal time
 * tau corresponding to the input redshift z.
 *
 * @param pba              Input: pointer to background structure
 * @param ppt              Input: pointer to perturbation structure
 * @param output_format    Input: choice of ordering and normalisation for the output quantities
 * @param z                Input: redshift
 * @param number_of_titles Input: number of requested source functions (found in perturbations_output_titles)
 * @param data             Output: vector of all source functions for all k values and initial conditions (previously allocated with the right size)
 * @return the error status
 */

int perturbations_output_data_at_z(
                                   struct background * pba,
                                   struct perturbations * ppt,
                                   enum file_format output_format,
                                   double z,
                                   int number_of_titles,
                                   double *data
                                   ) {

  double * tkfull=NULL;  /* array with argument tkfull[(index_k * ppt->ic_size[index_md] + index_ic) * ppt->tp_size[index_md] + index_tp] */

  double * pvecsources;

  double tau;

  int index_md = ppt->index_md_scalars;
  int index_ic;
  int index_k;
  int index_tp;

  /** - allocate tkfull */

  if (ppt->k_size[index_md]*ppt->ic_size[index_md]*ppt->tp_size[index_md] > 0) {
    class_alloc(tkfull,
                ppt->k_size[index_md]*ppt->ic_size[index_md]*ppt->tp_size[index_md]*sizeof(double),
                ppt->error_message);
  }

  /** - compute \f$T_i(k)\f$ for each k (if several ic's, compute it
        for each ic; if z_pk = 0, this is done by directly reading
        inside the pre-computed table; if not, this is done by
        interpolating the table at the correct value of tau. */

  /* if z_pk = 0, no interpolation needed */

  if (z == 0.) {

    for (index_k=0; index_k<ppt->k_size[index_md]; index_k++) {
      for (index_tp=0; index_tp<ppt->tp_size[index_md]; index_tp++) {
        for (index_ic=0; index_ic<ppt->ic_size[index_md]; index_ic++) {
          tkfull[(index_k * ppt->ic_size[index_md] + index_ic) * ppt->tp_size[index_md] + index_tp]
            = ppt->sources[index_md][index_ic * ppt->tp_size[index_md] + index_tp][(ppt->tau_size-1) * ppt->k_size[index_md] + index_k];
        }
      }
    }
  }

  /* if 0 <= z_pk <= z_max_pk, interpolation needed, */
  else {

    /* check the time corresponding to the highest redshift requested in output plus one */
    class_call(background_tau_of_z(pba,
                                   z,
                                   &tau),
               pba->error_message,
               ppt->error_message);

    class_test(log(tau) < ppt->ln_tau[0],
               "Asking sources at a z bigger than z_max_pk, something probably went wrong",
               ppt->error_message);

    class_alloc(pvecsources,
                ppt->k_size[index_md]*sizeof(double),
                ppt->error_message);


    for (index_tp=0; index_tp<ppt->tp_size[index_md]; index_tp++) {
      for (index_ic=0; index_ic<ppt->ic_size[index_md]; index_ic++) {
	class_call(perturbations_sources_at_tau(ppt,
						index_md,
						index_ic,
						index_tp,
						tau,
						pvecsources),
		   ppt->error_message,
		   ppt->error_message);
	for (index_k=0; index_k<ppt->k_size[index_md]; index_k++) {

          tkfull[(index_k * ppt->ic_size[index_md] + index_ic) * ppt->tp_size[index_md] + index_tp] =
            pvecsources[index_k];
        }
      }
    }
    free(pvecsources);
  }

  /** - store data */

  class_call(perturbations_output_data(pba,ppt,output_format,tkfull,number_of_titles,data),
             ppt->error_message,
             ppt->error_message);

  /** - free tkfull */
  // condition necessary because the size could be zero (if ppt->tp_size is zero)
  if (tkfull != NULL)
    free(tkfull);

  return _SUCCESS_;
}

/**
 * Function called by the output module or the wrappers, which returns
 * the source functions \f$ S^{X} (k, \tau) \f$ corresponding to
 * densities ('dTk') and velocities ('vTk') at a given conformal time
 * tau corresponding to index index_tau in pre-computed table.
 *
 * @param pba              Input: pointer to background structure
 * @param ppt              Input: pointer to perturbation structure
 * @param output_format    Input: choice of ordering and normalisation for the output quantities
 * @param index_tau        Input: index pre-computed table ppt->ln_tau[index_tau]
 * @param number_of_titles Input: number of requested source functions (found in perturbations_output_titles)
 * @param data             Output: vector of all source functions for all k values and initial conditions (previously allocated with the right size)
 * @return the error status
 */

int perturbations_output_data_at_index_tau(
                                           struct background * pba,
                                           struct perturbations * ppt,
                                           enum file_format output_format,
                                           int index_tau,
                                           int number_of_titles,
                                           double *data
                                           ) {

  double * tkfull=NULL;  /* array with argument tkfull[(index_k * ppt->ic_size[index_md] + index_ic) * ppt->tp_size[index_md] + index_tp] */

  int index_md = ppt->index_md_scalars;
  int index_ic;
  int index_k;
  int index_tp;

  class_test((index_tau < 0) || (index_tau >= ppt->ln_tau_size),
             ppt->error_message,
             "index_tau outside of array range");

  /** - allocate and fill tkfull */

  if (ppt->k_size[index_md]*ppt->ic_size[index_md]*ppt->tp_size[index_md] > 0) {
    class_alloc(tkfull,
                ppt->k_size[index_md]*ppt->ic_size[index_md]*ppt->tp_size[index_md]*sizeof(double),
                ppt->error_message);
  }

  for (index_k=0; index_k<ppt->k_size[index_md]; index_k++) {
    for (index_tp=0; index_tp<ppt->tp_size[index_md]; index_tp++) {
      for (index_ic=0; index_ic<ppt->ic_size[index_md]; index_ic++) {
        tkfull[(index_k * ppt->ic_size[index_md] + index_ic) * ppt->tp_size[index_md] + index_tp]
          = ppt->late_sources[index_md][index_ic * ppt->tp_size[index_md] + index_tp][index_tau * ppt->k_size[index_md] + index_k];
      }
    }
  }

  /** - store data */

  class_call(perturbations_output_data(pba,ppt,output_format,tkfull,number_of_titles,data),
             ppt->error_message,
             ppt->error_message);

  /** - free tkfull */
  // condition necessary because the size could be zero (if ppt->tp_size is zero)
  if (tkfull != NULL)
    free(tkfull);

  return _SUCCESS_;
}

/**
 * Function called by the output module or the wrappers, which returns
 * the source functions \f$ S^{X} (k, \tau) \f$ corresponding to
 * densities ('dTk') and velocities ('vTk') in the correct order
 * (matching that in perturbations_output_titles), given a vector
 * containing the corresponding scalar source functions at a given
 * time.
 *
 * @param pba              Input: pointer to background structure
 * @param ppt              Input: pointer to perturbation structure
 * @param output_format    Input: choice of ordering and normalisation for the output quantities
 * @param tkfull           Input: vector of scalar sources at given time, tk[(index_k * ppt->ic_size[index_md] + index_ic) * ppt->tp_size[index_md] + index_tp]
 * @param number_of_titles Input: number of requested source functions (found in perturbations_output_titles)
 * @param data             Output: vector of all source functions for all k values and initial conditions (previously allocated with the right size)
 * @return the error status
 */

int perturbations_output_data(
                              struct background * pba,
                              struct perturbations * ppt,
                              enum file_format output_format,
                              double * tkfull,
                              int number_of_titles,
                              double *data
                              ) {

  int n_ncdm;
  double k, k_over_h, k2;
  double *tk;
  double *dataptr;
  int index_md = ppt->index_md_scalars;
  int index_ic;
  int index_k;
  int storeidx;

  /** - store data */

  for (index_ic = 0; index_ic < ppt->ic_size[index_md]; index_ic++) {

    for (index_k=0; index_k<ppt->k_size[index_md]; index_k++) {

      storeidx = 0;
      dataptr = data+index_ic*(ppt->k_size[index_md]*number_of_titles)+index_k*number_of_titles;
      tk = &(tkfull[(index_k * ppt->ic_size[index_md] + index_ic) * ppt->tp_size[index_md]]);
      k = ppt->k[index_md][index_k];
      k2 = k*k;
      k_over_h = k/pba->h;

      class_store_double(dataptr, k_over_h, _TRUE_,storeidx);

      /* indices for species associated with a velocity transfer function in Fourier space */

      if (output_format == class_format) {

        if (ppt->has_density_transfers == _TRUE_) {
          class_store_double(dataptr,tk[ppt->index_tp_delta_g],ppt->has_source_delta_g,storeidx);
          class_store_double(dataptr,tk[ppt->index_tp_delta_b],ppt->has_source_delta_b,storeidx);
          class_store_double(dataptr,tk[ppt->index_tp_delta_cdm],ppt->has_source_delta_cdm,storeidx);
          class_store_double(dataptr,tk[ppt->index_tp_delta_idm],ppt->has_source_delta_idm,storeidx);
          class_store_double(dataptr,tk[ppt->index_tp_delta_fld],ppt->has_source_delta_fld,storeidx);
          class_store_double(dataptr,tk[ppt->index_tp_delta_ur],ppt->has_source_delta_ur,storeidx);
          class_store_double(dataptr,tk[ppt->index_tp_delta_idr],ppt->has_source_delta_idr,storeidx);
          if (pba->has_ncdm == _TRUE_){
            for (n_ncdm = 0; n_ncdm < pba->N_ncdm; n_ncdm++){
              class_store_double(dataptr,tk[ppt->index_tp_delta_ncdm1+n_ncdm],ppt->has_source_delta_ncdm,storeidx);
            }
          }
          class_store_double(dataptr,tk[ppt->index_tp_delta_dcdm],ppt->has_source_delta_dcdm,storeidx);
          class_store_double(dataptr,tk[ppt->index_tp_delta_dr],ppt->has_source_delta_dr,storeidx);
          class_store_double(dataptr,tk[ppt->index_tp_delta_scf],ppt->has_source_delta_scf,storeidx);
          class_store_double(dataptr,tk[ppt->index_tp_delta_m],ppt->has_source_delta_m,storeidx);
          class_store_double(dataptr,tk[ppt->index_tp_delta_tot],ppt->has_source_delta_tot,storeidx);
          class_store_double(dataptr,tk[ppt->index_tp_phi],ppt->has_source_phi,storeidx);
          class_store_double(dataptr,tk[ppt->index_tp_psi],ppt->has_source_psi,storeidx);
          class_store_double(dataptr,tk[ppt->index_tp_phi_prime],ppt->has_source_phi_prime,storeidx);
          class_store_double(dataptr,tk[ppt->index_tp_h],ppt->has_source_h,storeidx);
          class_store_double(dataptr,tk[ppt->index_tp_h_prime],ppt->has_source_h_prime,storeidx);
          class_store_double(dataptr,tk[ppt->index_tp_eta],ppt->has_source_eta,storeidx);
          class_store_double(dataptr,tk[ppt->index_tp_eta_prime],ppt->has_source_eta_prime,storeidx);
          class_store_double(dataptr,tk[ppt->index_tp_H_T_Nb_prime],ppt->has_source_H_T_Nb_prime,storeidx);
          class_store_double(dataptr,tk[ppt->index_tp_k2gamma_Nb],ppt->has_source_k2gamma_Nb,storeidx);
        }
        if (ppt->has_velocity_transfers == _TRUE_) {

          class_store_double(dataptr,tk[ppt->index_tp_theta_g],ppt->has_source_theta_g,storeidx);
          class_store_double(dataptr,tk[ppt->index_tp_theta_b],ppt->has_source_theta_b,storeidx);
          class_store_double(dataptr,tk[ppt->index_tp_theta_cdm],ppt->has_source_theta_cdm,storeidx);
          class_store_double(dataptr,tk[ppt->index_tp_theta_idm],ppt->has_source_theta_idm,storeidx);
          class_store_double(dataptr,tk[ppt->index_tp_theta_fld],ppt->has_source_theta_fld,storeidx);
          class_store_double(dataptr,tk[ppt->index_tp_theta_ur],ppt->has_source_theta_ur,storeidx);
          class_store_double(dataptr,tk[ppt->index_tp_theta_idr],ppt->has_source_theta_idr,storeidx);
          if (pba->has_ncdm == _TRUE_){
            for (n_ncdm = 0; n_ncdm < pba->N_ncdm; n_ncdm++){
              class_store_double(dataptr,tk[ppt->index_tp_theta_ncdm1+n_ncdm],ppt->has_source_theta_ncdm,storeidx);
            }
          }
          class_store_double(dataptr,tk[ppt->index_tp_theta_dcdm],ppt->has_source_theta_dcdm,storeidx);
          class_store_double(dataptr,tk[ppt->index_tp_theta_dr],ppt->has_source_theta_dr,storeidx);
          class_store_double(dataptr,tk[ppt->index_tp_theta_scf],ppt->has_source_theta_scf,storeidx);
          class_store_double(dataptr,tk[ppt->index_tp_theta_tot],ppt->has_source_theta_tot,storeidx);

        }

      }
      else if (output_format == camb_format) {

        /* rescale and reorder the matter transfer functions following the CMBFAST/CAMB convention */
        class_store_double_or_default(dataptr,-tk[ppt->index_tp_delta_cdm]/k2,ppt->has_source_delta_cdm,storeidx,0.0);
        class_store_double_or_default(dataptr,-tk[ppt->index_tp_delta_b]/k2,ppt->has_source_delta_b,storeidx,0.0);
        class_store_double_or_default(dataptr,-tk[ppt->index_tp_delta_g]/k2,ppt->has_source_delta_g,storeidx,0.0);
        class_store_double_or_default(dataptr,-tk[ppt->index_tp_delta_ur]/k2,ppt->has_source_delta_ur,storeidx,0.0);
        class_store_double_or_default(dataptr,-tk[ppt->index_tp_delta_ncdm1]/k2,ppt->has_source_delta_ncdm,storeidx,0.0);
        class_store_double_or_default(dataptr,-tk[ppt->index_tp_delta_tot]/k2,_TRUE_,storeidx,0.0);
      }
    }
  }

  return _SUCCESS_;
}

/**
 * Fill array of strings with the name of the requested 'mTk, vTk' functions
 * (transfer functions as a function of wavenumber for fixed times).
 *
 * @param pba           Input: pointer to the background structure
 * @param ppt           Input: pointer to the perturbation structure
 * @param output_format Input: flag for the format
 * @param titles        Output: name strings
 * @return the error status
 */

int perturbations_output_titles(
                                struct background *pba,
                                struct perturbations *ppt,
                                enum file_format output_format,
                                char titles[_MAXTITLESTRINGLENGTH_]
                                ){
  int n_ncdm;
  char tmp[40];

  if (output_format == class_format) {
    class_store_columntitle(titles,"k (h/Mpc)",_TRUE_);
    if (ppt->has_density_transfers == _TRUE_) {
      class_store_columntitle(titles,"d_g",_TRUE_);
      class_store_columntitle(titles,"d_b",_TRUE_);
      class_store_columntitle(titles,"d_cdm",pba->has_cdm);
      class_store_columntitle(titles,"d_idm",pba->has_idm);
      class_store_columntitle(titles,"d_fld",pba->has_fld);
      class_store_columntitle(titles,"d_ur",pba->has_ur);
      class_store_columntitle(titles,"d_idr",pba->has_idr);
      if (pba->has_ncdm == _TRUE_) {
        for (n_ncdm=0; n_ncdm < pba->N_ncdm; n_ncdm++) {
          class_sprintf(tmp,"d_ncdm[%d]",n_ncdm);
          class_store_columntitle(titles,tmp,_TRUE_);
        }
      }
      class_store_columntitle(titles,"d_dcdm",pba->has_dcdm);
      class_store_columntitle(titles,"d_dr",pba->has_dr);
      class_store_columntitle(titles,"d_scf",pba->has_scf);
      class_store_columntitle(titles,"d_m",ppt->has_source_delta_m);
      class_store_columntitle(titles,"d_tot",ppt->has_source_delta_tot);
      class_store_columntitle(titles,"phi",ppt->has_source_phi);
      class_store_columntitle(titles,"psi",ppt->has_source_psi);
      class_store_columntitle(titles,"phi_prime",ppt->has_source_phi_prime);
      class_store_columntitle(titles,"h",ppt->has_source_h);
      class_store_columntitle(titles,"h_prime",ppt->has_source_h_prime);
      class_store_columntitle(titles,"eta",ppt->has_source_eta);
      class_store_columntitle(titles,"eta_prime",ppt->has_source_eta_prime);
      class_store_columntitle(titles,"H_T_Nb_prime",ppt->has_source_H_T_Nb_prime);
      class_store_columntitle(titles,"k2gamma_Nb",ppt->has_source_k2gamma_Nb);
    }
    if (ppt->has_velocity_transfers == _TRUE_) {
      class_store_columntitle(titles,"t_g",_TRUE_);
      class_store_columntitle(titles,"t_b",_TRUE_);
      class_store_columntitle(titles,"t_cdm",((pba->has_cdm == _TRUE_) && (ppt->gauge != synchronous)));
      class_store_columntitle(titles,"t_idm",pba->has_idm);
      class_store_columntitle(titles,"t_fld",pba->has_fld);
      class_store_columntitle(titles,"t_ur",pba->has_ur);
      class_store_columntitle(titles,"t_idr",pba->has_idr);
      if (pba->has_ncdm == _TRUE_) {
        for (n_ncdm=0; n_ncdm < pba->N_ncdm; n_ncdm++) {
          class_sprintf(tmp,"t_ncdm[%d]",n_ncdm);
          class_store_columntitle(titles,tmp,_TRUE_);
        }
      }
      class_store_columntitle(titles,"t_dcdm",pba->has_dcdm);
      class_store_columntitle(titles,"t_dr",pba->has_dr);
      class_store_columntitle(titles,"t_scf",pba->has_scf);
      class_store_columntitle(titles,"t_tot",_TRUE_);
    }
  }

  else if (output_format == camb_format) {

    class_store_columntitle(titles,"k (h/Mpc)",_TRUE_);
    class_store_columntitle(titles,"-T_cdm/k2",_TRUE_);
    class_store_columntitle(titles,"-T_b/k2",_TRUE_);
    class_store_columntitle(titles,"-T_g/k2",_TRUE_);
    class_store_columntitle(titles,"-T_ur/k2",_TRUE_);
    class_store_columntitle(titles,"-T_ncdm/k2",_TRUE_);
    class_store_columntitle(titles,"-T_tot/k2",_TRUE_);

  }

  return _SUCCESS_;
}

/**
 * Fill strings that will be used when writing the transfer functions
 * and the spectra in files (in the file names and in the comment at the beginning of each file).
 *
 * @param ppt        Input: pointer to the perturbation structure
 * @param index_ic   Input: index of the initial condition
 * @param first_line Output: line of comment
 * @param ic_suffix  Output: suffix for the output file name
 * @return the error status
 *
 */

int perturbations_output_firstline_and_ic_suffix(
                                                 struct perturbations *ppt,
                                                 int index_ic,
                                                 char first_line[_LINE_LENGTH_MAX_],
                                                 char ic_suffix[_SUFFIXNAMESIZE_]
                                                 ){

  first_line[0]='\0';
  ic_suffix[0]='\0';

  if ((ppt->has_ad == _TRUE_) && (index_ic == ppt->index_ic_ad)) {
    strcpy(ic_suffix,"ad");
    strcpy(first_line,"for adiabatic (AD) mode (normalized to initial curvature=1) ");
  }

  if ((ppt->has_bi == _TRUE_) && (index_ic == ppt->index_ic_bi)) {
    strcpy(ic_suffix,"bi");
    strcpy(first_line,"for baryon isocurvature (BI) mode (normalized to initial entropy=1)");
  }

  if ((ppt->has_cdi == _TRUE_) && (index_ic == ppt->index_ic_cdi)) {
    strcpy(ic_suffix,"cdi");
    strcpy(first_line,"for CDM isocurvature (CDI) mode (normalized to initial entropy=1)");
  }

  if ((ppt->has_nid == _TRUE_) && (index_ic == ppt->index_ic_nid)) {
    strcpy(ic_suffix,"nid");
    strcpy(first_line,"for neutrino density isocurvature (NID) mode (normalized to initial entropy=1)");
  }

  if ((ppt->has_niv == _TRUE_) && (index_ic == ppt->index_ic_niv)) {
    strcpy(ic_suffix,"niv");
    strcpy(first_line,"for neutrino velocity isocurvature (NIV) mode (normalized to initial entropy=1)");
  }
  return _SUCCESS_;
}

/**
 * Initialize the perturbations structure, and in particular the table of source functions.
 *
 * Main steps:
 *
 * - given the values of the flags describing which kind of
 *   perturbations should be considered (modes: scalar/vector/tensor,
 *   initial conditions, type of source functions needed...),
 *   initialize indices and wavenumber list
 *
 * - define the time sampling for the output source functions
 *
 * - for each mode (scalar/vector/tensor): initialize the indices of
 *   relevant perturbations, integrate the differential system,
 *   compute and store the source functions.
 *
 * @param ppr Input: pointer to precision structure
 * @param pba Input: pointer to background structure
 * @param pth Input: pointer to thermodynamics structure
 * @param ppt Output: Initialized perturbation structure
 * @return the error status
 */

int perturbations_init(
                       struct precision * ppr,
                       struct background * pba,
                       struct thermodynamics * pth,
                       struct perturbations * ppt
                       ) {

  /** Summary: */

  /** - define local variables */

  /* running index for modes */
  int index_md;
  /* running index for initial conditions */
  int index_ic;
  /* running index for wavenumbers */
  int index_k;
  /* running index for type of perturbation */
  int index_tp;
  /* background quantities */
  double w_fld_ini, w_fld_0,dw_over_da_fld,integral_fld;

  /** - perform preliminary checks */

  if (ppt->has_perturbations == _FALSE_) {
    if (ppt->perturbations_verbose > 0)
      printf("No sources requested. Perturbation module skipped.\n");
    return _SUCCESS_;
  }
  else {
    if (ppt->perturbations_verbose > 0)
      printf("Computing sources\n");
  }

  class_test((ppt->gauge == synchronous) && (pba->has_cdm == _FALSE_),
             ppt->error_message,
             "In the synchronous gauge, it is not self-consistent to assume no CDM: the later is used to define the initial timelike hypersurface. You can either add a negligible amount of CDM, or switch to newtonian gauge");

  class_test ((ppr->tight_coupling_approximation < first_order_MB) ||
              (ppr->tight_coupling_approximation > compromise_CLASS),
              ppt->error_message,
              "your tight_coupling_approximation is set to %d, out of range defined in perturbations.h",ppr->tight_coupling_approximation);

  class_test ((ppr->radiation_streaming_approximation < rsa_null) ||
              (ppr->radiation_streaming_approximation > rsa_none),
              ppt->error_message,
              "your radiation_streaming_approximation is set to %d, out of range defined in perturbations.h",ppr->radiation_streaming_approximation);

  if (pba->has_idr == _TRUE_){
    class_test ((ppr->idr_streaming_approximation < rsa_idr_none) ||
                (ppr->idr_streaming_approximation > rsa_idr_MD),
                ppt->error_message,
                "your idr_radiation_streaming_approximation is set to %d, out of range defined in perturbations.h",ppr->idr_streaming_approximation);
  }

  if (pba->has_ur == _TRUE_) {

    class_test ((ppr->ur_fluid_approximation < ufa_mb) ||
                (ppr->ur_fluid_approximation > ufa_none),
                ppt->error_message,
                "your ur_fluid_approximation is set to %d, out of range defined in perturbations.h",ppr->ur_fluid_approximation);
  }

  if (pba->has_ncdm == _TRUE_) {

    class_test ((ppr->ncdm_fluid_approximation < ncdmfa_mb) ||
                (ppr->ncdm_fluid_approximation > ncdmfa_none),
                ppt->error_message,
                "your ncdm_fluid_approximation is set to %d, out of range defined in perturbations.h",ppr->ncdm_fluid_approximation);

    if (ppt->has_nc_density == _TRUE_) {
      if (ppt->perturbations_verbose > 0) {
        fprintf(stdout," -> [WARNING:] You request the number count Cl's in presence of non-cold dark matter.\n    Like in all previous CLASS and CLASSgal versions, this will be inferred from the total matter density,\n    but it could make much more sense physically to compute it from the CDM+baryon density only.\n    To get the latter behavior you would just need to change one line in transfer.c:\n    search there for a comment starting with 'use here delta_cb'\n");
      }
    }

  }

  if (pba->has_fld == _TRUE_) {

    /* check values of w_fld at initial time and today. Since 'a' in the code stands for 'a/a_0', its current value is 1 by definition */
    class_call(background_w_fld(pba, 0., &w_fld_ini, &dw_over_da_fld, &integral_fld), pba->error_message, ppt->error_message);
    class_call(background_w_fld(pba, 1.,   &w_fld_0, &dw_over_da_fld, &integral_fld), pba->error_message, ppt->error_message);

    class_test(w_fld_ini >= 0.,
               ppt->error_message,
               "The fluid is meant to be negligible at early time, and unimportant for defining the initial conditions of other species. You are using parameters for which this assumption may break down, since at early times you have w_fld(a--->0) = %e >= 0",w_fld_ini);

    if (pba->use_ppf == _FALSE_) {

      class_test((w_fld_ini +1.0)*(w_fld_0+1.0) <= 0.0,
                 ppt->error_message,
                 "w crosses -1 between the infinite past and today, and this would lead to divergent perturbation equations for the fluid perturbations. Try to switch to PPF scheme: use_ppf = yes");

      /* the next check is meaningful at least for w(a) = w0 + wa*(1-a/a0); for general formulas and with use_ppf=no, you may prefer to comment it out... */
      class_test((w_fld_0 == -1.) && (dw_over_da_fld == 0.),
                 ppt->error_message,
                 "Your choice of a fluid with (w0,wa)=(-1,0) is not valid due to instabilities in the unphysical perturbations of such a fluid. Try instead with a plain cosmological constant or with PPF scheme: use_ppf = yes");

    }

  }

  if (pba->has_dcdm == _TRUE_) {

    class_test((ppt->has_cdi == _TRUE_) || (ppt->has_bi == _TRUE_) || (ppt->has_nid == _TRUE_) || (ppt->has_niv == _TRUE_),
               ppt->error_message,
               "Non-adiabatic initial conditions not coded in presence of decaying dark matter");

  }

  class_test(ppt->has_vectors == _TRUE_,
             ppt->error_message,
             "Vectors not coded yet");

  if ((ppt->has_niv == _TRUE_) && (ppt->perturbations_verbose > 0)) {
    printf("Warning: the niv initial conditions in CLASS (and also in CAMB) should still be double-checked: if you want to do it and send feedback, you are welcome!\n");
  }

  if (ppt->has_tensors == _TRUE_) {

    ppt->evolve_tensor_ur = _FALSE_;
    ppt->evolve_tensor_ncdm = _FALSE_;

    switch (ppt->tensor_method) {

    case (tm_photons_only):
      break;

    case (tm_massless_approximation):
      if ((pba->has_ur == _TRUE_) || (pba->has_ncdm == _TRUE_))
        ppt->evolve_tensor_ur = _TRUE_;
      break;

    case (tm_exact):
      if (pba->has_ur == _TRUE_)
        ppt->evolve_tensor_ur = _TRUE_;
      if (pba->has_ncdm == _TRUE_)
        ppt->evolve_tensor_ncdm = _TRUE_;
      break;
    }
  }

  /*
    class_test((pba->h > _h_BIG_) || (pba->h < _h_SMALL_),
    ppt->error_message,
    "Your value of pba->h=%e is out of the bounds [%e , %e] and could cause a crash of the perturbation ODE integration. If you want to force this barrier, you may comment it out in perturbation.c",
    pba->h,
    _h_SMALL_,
    _h_BIG_);

    class_test((pba->Omega0_b*pba->h*pba->h < _omegab_SMALL_) || (pba->Omega0_b*pba->h*pba->h > _omegab_BIG_),
    ppt->error_message,
    "Your value of omega_b=%e is out of the bounds [%e , %e] and could cause a crash of the perturbation ODE integration. If you want to force this barrier, you may comment it out in perturbation.c",
    pba->Omega0_b*pba->h*pba->h,
    _omegab_SMALL_,
    _omegab_BIG_);
  */

  /** - initialize all indices and lists in perturbations structure using perturbations_indices() */

  class_call(perturbations_indices(ppr,
                                   pba,
                                   pth,
                                   ppt),
             ppt->error_message,
             ppt->error_message);


  if (ppt->z_max_pk > pth->z_rec) {

    class_test(ppt->has_cmb == _TRUE_,
               ppt->error_message,
               "You requested a very high z_pk=%e, higher than z_rec=%e. This works very well when you don't ask for a calculation of the CMB source function(s). Remove any CMB from your output and try e.g. with 'output=mTk' or 'output=mTk,vTk'",
               ppt->z_max_pk,
               pth->z_rec);

    class_test((ppt->has_source_delta_m == _TRUE_) && (ppt->has_matter_source_in_current_gauge == _FALSE_),
               ppt->error_message,
               "You requested a very high z_pk=%e, higher than z_rec=%e. This works very well when you ask only transfer functions, e.g. with 'output=mTk' or 'output=mTk,vTk'. But if you need the total matter (e.g. with 'mPk', 'dCl', etc.) there is an issue with the calculation of delta_m (or delta_cb) at very early times. By default, delta_m and delta_cb are expressed by the code as gauge-invariant variables (the density fluctuation in comoving gauge). This quantity is hard to get accurately at very early times. The solution is to define delta_m and delta_cb as density fluctuations in the current gauge, e.g. synchronous or newtonian. This is done by setting the input flag 'matter_source_in_current_gauge' to 'yes'.",
               ppt->z_max_pk,
               pth->z_rec);

  }



  /** - define the common time sampling for all sources using
      perturbations_timesampling_for_sources() */

  class_call(perturbations_timesampling_for_sources(ppr,
                                                    pba,
                                                    pth,
                                                    ppt),
             ppt->error_message,
             ppt->error_message);

  /** - if we want to store perturbations for given k values, write titles and allocate storage */
  class_call(perturbations_prepare_k_output(pba,ppt),
             ppt->error_message,
             ppt->error_message);

  /* Setup task system */
  class_setup_parallel();
  /** - loop over modes (scalar, tensors, etc). For each mode: */
  for (index_md = 0; index_md < ppt->md_size; index_md++) {

    if (ppt->perturbations_verbose > 1)
      printf("Evolving mode %d/%d\n",index_md+1,ppt->md_size);

    /** - --> loop over initial conditions and wavenumbers; for each of them, evolve perturbations and compute source functions with perturbations_solve() */

    for (index_ic = 0; index_ic < ppt->ic_size[index_md]; index_ic++) {

      if (ppt->perturbations_verbose > 1) {
        printf("Evolving ic %d/%d\n",index_ic+1,ppt->ic_size[index_md]);
        printf("evolving %d wavenumbers\n",ppt->k_size[index_md]);
      }

      /* integrating backwards is slightly more optimal for parallel runs */
      //for (index_k = 0; index_k < ppt->k_size; index_k++) {
      for (index_k = ppt->k_size[index_md]-1; index_k >=0; index_k--) {

        class_run_parallel(with_arguments(ppr,pba,pth,ppt,index_md,index_ic,index_k),

          if (ppt->perturbations_verbose > 2) {
            printf("evolving mode k=%e /Mpc  (%d/%d)",ppt->k[index_md][index_k],index_k+1,ppt->k_size[index_md]);
            if (pba->sgnK != 0)
              printf(" (for scalar modes, corresponds to nu=%e)",sqrt(ppt->k[index_md][index_k]*ppt->k[index_md][index_k]+pba->K)/sqrt(pba->sgnK*pba->K));
            printf("\n");
          }

          struct perturbations_workspace pw;
          class_call(perturbations_workspace_init(ppr,
                                                  pba,
                                                  pth,
                                                  ppt,
                                                  index_md,
                                                  &pw),
                     ppt->error_message,
                     ppt->error_message);

          class_call(perturbations_solve(ppr,
                                         pba,
                                         pth,
                                         ppt,
                                         index_md,
                                         index_ic,
                                         index_k,
                                         &pw),
                     ppt->error_message,
                     ppt->error_message);

          class_call(perturbations_workspace_free(ppt,index_md,&pw),
                     ppt->error_message,
                     ppt->error_message);
          return _SUCCESS_;

        );

      } /* end of loop over wavenumbers */

    } /* end of loop over initial conditions */

  } /* end loop over modes */

  class_finish_parallel();


  /** - spline the source array with respect to the time variable */

  if (ppt->ln_tau_size > 1) {

    class_setup_parallel();

    for (index_md = 0; index_md < ppt->md_size; index_md++) {

      for (index_ic = 0; index_ic < ppt->ic_size[index_md]; index_ic++) {

        for (index_tp = 0; index_tp < ppt->tp_size[index_md]; index_tp++) {

          class_run_parallel(with_arguments(ppt, index_md, index_ic, index_tp),
            class_call(array_spline_table_lines(ppt->ln_tau,
                                                ppt->ln_tau_size,
                                                ppt->late_sources[index_md][index_ic * ppt->tp_size[index_md] + index_tp],
                                                ppt->k_size[index_md],
                                                ppt->ddlate_sources[index_md][index_ic*ppt->tp_size[index_md] + index_tp],
                                                _SPLINE_EST_DERIV_,
                                                ppt->error_message),
                       ppt->error_message,
                       ppt->error_message);
            return _SUCCESS_;
          );

        } /* end of loop over type of source function*/

      } /* end of loop over initial condition */

    } /* end of loop over mode */

    class_finish_parallel();
  }

  ppt->is_allocated = _TRUE_;

  return _SUCCESS_;
}

/**
 * Free all memory space allocated by input.
 *
 * Called by perturbations_free(), during shooting and if shooting failed
 *
 * @param ppt Input: perturbation structure with input pointers to be freed
 * @return the error status
 */

int perturbations_free_input(struct perturbations* ppt) {

  if (ppt->alpha_idm_dr != NULL)
    free(ppt->alpha_idm_dr);
  if (ppt->beta_idr != NULL)
    free(ppt->beta_idr);

  return _SUCCESS_;
}

/**
 * Free all memory space allocated by perturbations_init().
 *
 * To be called at the end of each run, only when no further calls to
 * perturbations_sources_at_tau() are needed.
 *
 * @param ppt Input: perturbation structure to be freed
 * @return the error status
 */

int perturbations_free(
                       struct perturbations * ppt
                       ) {

  int index_md,index_ic,index_tp;
  int filenum;

  perturbations_free_input(ppt);

  if (ppt->has_perturbations == _TRUE_) {

    for (index_md = 0; index_md < ppt->md_size; index_md++) {

      for (index_ic = 0; index_ic < ppt->ic_size[index_md]; index_ic++) {

        for (index_tp = 0; index_tp < ppt->tp_size[index_md]; index_tp++) {

          free(ppt->sources[index_md][index_ic*ppt->tp_size[index_md]+index_tp]);
          if (ppt->ln_tau_size > 1)
            free(ppt->ddlate_sources[index_md][index_ic*ppt->tp_size[index_md]+index_tp]);

        }
      }

      free(ppt->sources[index_md]);
      free(ppt->late_sources[index_md]);
      free(ppt->ddlate_sources[index_md]);

      free(ppt->k[index_md]);

    }

    free(ppt->tau_sampling);
    if (ppt->ln_tau_size > 1)
      free(ppt->ln_tau);

    free(ppt->tp_size);

    free(ppt->ic_size);

    free(ppt->k);

    free(ppt->k_size_cmb);

    free(ppt->k_size_cl);

    free(ppt->k_size);

    free(ppt->sources);
    free(ppt->late_sources);
    free(ppt->ddlate_sources);

    /** Stuff related to perturbations output: */

    /** - Free non-NULL pointers */
    if (ppt->k_output_values_num > 0 )
      free(ppt->index_k_output_values);

    for (filenum = 0; filenum<_MAX_NUMBER_OF_K_FILES_; filenum++){
      if (ppt->scalar_perturbations_data[filenum] != NULL)
        free(ppt->scalar_perturbations_data[filenum]);
      if (ppt->vector_perturbations_data[filenum] != NULL)
        free(ppt->vector_perturbations_data[filenum]);
      if (ppt->tensor_perturbations_data[filenum] != NULL)
        free(ppt->tensor_perturbations_data[filenum]);
    }

  }

  ppt->is_allocated = _FALSE_;
  return _SUCCESS_;

}

/**
 * Initialize all indices and allocate most arrays in perturbations structure.
 *
 * @param ppr Input: pointer to precision structure
 * @param pba Input: pointer to background structure
 * @param pth Input: pointer to thermodynamics structure
 * @param ppt Input/Output: Initialized perturbation structure
 * @return the error status
 */

int perturbations_indices(
                          struct precision * ppr,
                          struct background * pba,
                          struct thermodynamics * pth,
                          struct perturbations * ppt
                          ) {

  /** Summary: */

  /** - define local variables */

  int index_type;
  int index_md;
  int index_ic;
  int index_type_common;
  int filenum;

  /** - count modes (scalar, vector, tensor) and assign corresponding indices */

  index_md = 0;
  class_define_index(ppt->index_md_scalars,ppt->has_scalars,index_md,1);
  class_define_index(ppt->index_md_vectors,ppt->has_vectors,index_md,1);
  class_define_index(ppt->index_md_tensors,ppt->has_tensors,index_md,1);
  ppt->md_size = index_md;

  /* Copy l_max_g from precision structure for use in output functions */
  ppt->l_max_g = ppr->l_max_g;

  class_test(index_md == 0,
             ppt->error_message,
             "you should have at least one out of {scalars, vectors, tensors} !!!");

  /** - allocate array of number of types for each mode, ppt->tp_size[index_md] */

  class_alloc(ppt->tp_size,ppt->md_size*sizeof(int),ppt->error_message);

  /** - allocate array of number of initial conditions for each mode, ppt->ic_size[index_md] */

  class_alloc(ppt->ic_size,ppt->md_size*sizeof(int),ppt->error_message);

  /** - allocate array of arrays of source functions for each mode, ppt->source[index_md] */

  class_alloc(ppt->sources,       ppt->md_size * sizeof(double *),ppt->error_message);
  class_alloc(ppt->late_sources,  ppt->md_size * sizeof(double *),ppt->error_message);
  class_alloc(ppt->ddlate_sources,ppt->md_size * sizeof(double *),ppt->error_message);

  /** - initialize variables for the output of k values */

  ppt->index_k_output_values=NULL;

  ppt->number_of_scalar_titles=0;
  ppt->number_of_vector_titles=0;
  ppt->number_of_tensor_titles=0;

  for (filenum = 0; filenum<_MAX_NUMBER_OF_K_FILES_; filenum++){
    ppt->scalar_perturbations_data[filenum] = NULL;
    ppt->vector_perturbations_data[filenum] = NULL;
    ppt->tensor_perturbations_data[filenum] = NULL;
  }

  /** - initialization of all flags to false (will eventually be set to true later) */

  ppt->has_cmb = _FALSE_;
  ppt->has_lss = _FALSE_;

  ppt->has_idm_dr = _FALSE_;

  ppt->has_source_t = _FALSE_;
  ppt->has_source_p = _FALSE_;
  ppt->has_source_delta_m = _FALSE_;
  ppt->has_source_delta_cb = _FALSE_;
  ppt->has_source_delta_tot = _FALSE_;
  ppt->has_source_delta_g = _FALSE_;
  ppt->has_source_delta_b = _FALSE_;
  ppt->has_source_delta_cdm = _FALSE_;
  ppt->has_source_delta_idm = _FALSE_;
  ppt->has_source_delta_dcdm = _FALSE_;
  ppt->has_source_delta_fld = _FALSE_;
  ppt->has_source_delta_scf = _FALSE_;
  ppt->has_source_delta_dr = _FALSE_;
  ppt->has_source_delta_ur = _FALSE_;
  ppt->has_source_delta_idr = _FALSE_;
  ppt->has_source_delta_ncdm = _FALSE_;
  ppt->has_source_delta_tot = _FALSE_;
  ppt->has_source_theta_m = _FALSE_;
  ppt->has_source_theta_cb = _FALSE_;
  ppt->has_source_theta_tot = _FALSE_;
  ppt->has_source_theta_g = _FALSE_;
  ppt->has_source_theta_b = _FALSE_;
  ppt->has_source_theta_cdm = _FALSE_;
  ppt->has_source_theta_idm = _FALSE_;
  ppt->has_source_theta_dcdm = _FALSE_;
  ppt->has_source_theta_fld = _FALSE_;
  ppt->has_source_theta_scf = _FALSE_;
  ppt->has_source_theta_dr = _FALSE_;
  ppt->has_source_theta_ur = _FALSE_;
  ppt->has_source_theta_idr = _FALSE_;
  ppt->has_source_theta_ncdm = _FALSE_;
  ppt->has_source_theta_tot = _FALSE_;
  ppt->has_source_phi = _FALSE_;
  ppt->has_source_phi_prime = _FALSE_;
  ppt->has_source_phi_plus_psi = _FALSE_;
  ppt->has_source_psi = _FALSE_;
  ppt->has_source_h = _FALSE_;
  ppt->has_source_h_prime = _FALSE_;
  ppt->has_source_eta = _FALSE_;
  ppt->has_source_eta_prime = _FALSE_;
  ppt->has_source_H_T_Nb_prime = _FALSE_;
  ppt->has_source_k2gamma_Nb = _FALSE_;

  /** - source flags and indices, for sources that all modes have in
      common (temperature, polarization, ...). For temperature, the
      term t2 is always non-zero, while other terms are non-zero only
      for scalars and vectors. For polarization, the term e is always
      non-zero, while the term b is only for vectors and tensors. */

  if (ppt->has_cl_cmb_temperature == _TRUE_) {
    ppt->has_source_t = _TRUE_;
    ppt->has_cmb = _TRUE_;
  }

  if (ppt->has_cl_cmb_polarization == _TRUE_) {
    ppt->has_source_p = _TRUE_;
    ppt->has_cmb = _TRUE_;
  }

  index_type = 0;
  class_define_index(ppt->index_tp_t2,ppt->has_source_t,index_type,1);
  class_define_index(ppt->index_tp_p,ppt->has_source_p,index_type,1);
  index_type_common = index_type;

  /* indices for perturbed recombination */

  class_define_index(ppt->index_tp_perturbed_recombination_delta_temp,ppt->has_perturbed_recombination,index_type,1);
  class_define_index(ppt->index_tp_perturbed_recombination_delta_chi,ppt->has_perturbed_recombination,index_type,1);




  /** - define k values with perturbations_get_k_list() */

  class_call(perturbations_get_k_list(ppr,
                                      pba,
                                      pth,
                                      ppt),
             ppt->error_message,
             ppt->error_message);

  /** - loop over modes. Initialize flags and indices which are specific to each mode. */

  for (index_md = 0; index_md < ppt->md_size; index_md++) {

    /** - (a) scalars */

    if (_scalars_) {

      /** - --> source flags and indices, for sources that are specific to scalars */

      if ((ppt->has_cl_cmb_lensing_potential == _TRUE_) || (ppt->has_cl_lensing_potential)) {
        ppt->has_lss = _TRUE_;
        ppt->has_source_phi_plus_psi = _TRUE_;
      }

      if ((ppt->has_pk_matter == _TRUE_) || (ppt->has_nl_corrections_based_on_delta_m)) {
        ppt->has_lss = _TRUE_;
        ppt->has_source_delta_m = _TRUE_;

        if (pba->has_ncdm == _TRUE_){
          ppt->has_source_delta_cb = _TRUE_;
        }
      }

      if (ppt->has_density_transfers == _TRUE_) {
        ppt->has_lss = _TRUE_;
        ppt->has_source_delta_tot = _TRUE_;
        ppt->has_source_delta_m = _TRUE_;
        ppt->has_source_delta_g = _TRUE_;
        ppt->has_source_delta_b = _TRUE_;
        if (pba->has_cdm == _TRUE_)
          ppt->has_source_delta_cdm = _TRUE_;
        if (pba->has_idm == _TRUE_)
          ppt->has_source_delta_idm = _TRUE_;
        if (pba->has_dcdm == _TRUE_)
          ppt->has_source_delta_dcdm = _TRUE_;
        if (pba->has_fld == _TRUE_)
          ppt->has_source_delta_fld = _TRUE_;
        if (pba->has_scf == _TRUE_)
          ppt->has_source_delta_scf = _TRUE_;
        if (pba->has_ur == _TRUE_)
          ppt->has_source_delta_ur = _TRUE_;
        if (pba->has_idr == _TRUE_)
          ppt->has_source_delta_idr = _TRUE_;
        if (pba->has_dr == _TRUE_)
          ppt->has_source_delta_dr = _TRUE_;
        if (pba->has_ncdm == _TRUE_)
          ppt->has_source_delta_ncdm = _TRUE_;
        // Thanks to the following lines, (phi,psi) are also stored as sources
        // (Obtained directly in newtonian gauge, infereed from (h,eta) in synchronous gauge).
        // If density transfer functions are requested in the (default) CLASS format,
        // (phi, psi) will be appended to the delta_i's in the final output.
        ppt->has_source_phi = _TRUE_;
        ppt->has_source_psi = _TRUE_;
      }

      if (ppt->has_velocity_transfers == _TRUE_) {
        ppt->has_lss = _TRUE_;
        ppt->has_source_theta_tot = _TRUE_;
        ppt->has_source_theta_g = _TRUE_;
        ppt->has_source_theta_b = _TRUE_;
        if ((pba->has_cdm == _TRUE_) && (ppt->gauge != synchronous))
          ppt->has_source_theta_cdm = _TRUE_;
        if (pba->has_idm == _TRUE_)
          ppt->has_source_theta_idm = _TRUE_;
        if (pba->has_dcdm == _TRUE_)
          ppt->has_source_theta_dcdm = _TRUE_;
        if (pba->has_fld == _TRUE_)
          ppt->has_source_theta_fld = _TRUE_;
        if (pba->has_scf == _TRUE_)
          ppt->has_source_theta_scf = _TRUE_;
        if (pba->has_ur == _TRUE_)
          ppt->has_source_theta_ur = _TRUE_;
        if (pba->has_idr == _TRUE_)
          ppt->has_source_theta_idr = _TRUE_;
        if (pba->has_dr == _TRUE_)
          ppt->has_source_theta_dr = _TRUE_;
        if (pba->has_ncdm == _TRUE_)
          ppt->has_source_theta_ncdm = _TRUE_;
      }

      if (ppt->has_cl_number_count == _TRUE_) {
        ppt->has_lss = _TRUE_;
        if (ppt->has_nc_density == _TRUE_) {
          ppt->has_source_delta_m = _TRUE_;
        }
        if (ppt->has_nc_rsd == _TRUE_) {
          ppt->has_source_theta_m = _TRUE_;
          if (pba->has_ncdm == _TRUE_)
            /* we may not need theta_cb at all, rsd always defined for
               the total matter, but at least this is made
               available */
            ppt->has_source_theta_cb = _TRUE_;
        }

        if (ppt->has_nc_lens == _TRUE_) {
          ppt->has_source_phi_plus_psi = _TRUE_;
        }
        if (ppt->has_nc_gr == _TRUE_) {
          ppt->has_source_phi = _TRUE_;
          ppt->has_source_psi = _TRUE_;
          ppt->has_source_phi_prime = _TRUE_;
          ppt->has_source_phi_plus_psi = _TRUE_;
        }
      }

      if (ppt->has_metricpotential_transfers == _TRUE_ ) {
        if (ppt->gauge == newtonian) {
          ppt->has_source_phi = _TRUE_;
          ppt->has_source_psi = _TRUE_;
          ppt->has_source_phi_prime = _TRUE_;
        }
        if (ppt->gauge == synchronous) {
          ppt->has_source_h = _TRUE_;
          ppt->has_source_h_prime = _TRUE_;
          ppt->has_source_eta = _TRUE_;
          ppt->has_source_eta_prime = _TRUE_;
        }
        ppt->has_source_H_T_Nb_prime = _TRUE_;
        ppt->has_source_k2gamma_Nb = _TRUE_;
      }

      if (ppt->has_Nbody_gauge_transfers == _TRUE_){
        if (ppt->gauge == synchronous) {
          ppt->has_source_h_prime = _TRUE_;
          ppt->has_source_eta_prime = _TRUE_;
        }
        ppt->has_source_H_T_Nb_prime = _TRUE_;
        /** gamma is not neccessary for converting output to Nbody gauge but is included anyway. */
        ppt->has_source_k2gamma_Nb = _TRUE_;
      }

      index_type = index_type_common;
      class_define_index(ppt->index_tp_t0,         ppt->has_source_t,         index_type,1);
      class_define_index(ppt->index_tp_t1,         ppt->has_source_t,         index_type,1);
      class_define_index(ppt->index_tp_delta_m,    ppt->has_source_delta_m,   index_type,1);
      class_define_index(ppt->index_tp_delta_cb,   ppt->has_source_delta_cb,  index_type,1);
      class_define_index(ppt->index_tp_delta_tot,  ppt->has_source_delta_tot, index_type,1);
      class_define_index(ppt->index_tp_delta_g,    ppt->has_source_delta_g,   index_type,1);
      class_define_index(ppt->index_tp_delta_b,    ppt->has_source_delta_b,   index_type,1);
      class_define_index(ppt->index_tp_delta_cdm,  ppt->has_source_delta_cdm, index_type,1);
      class_define_index(ppt->index_tp_delta_idm,  ppt->has_source_delta_idm, index_type,1);
      class_define_index(ppt->index_tp_delta_dcdm, ppt->has_source_delta_dcdm,index_type,1);
      class_define_index(ppt->index_tp_delta_fld,  ppt->has_source_delta_fld, index_type,1);
      class_define_index(ppt->index_tp_delta_scf,  ppt->has_source_delta_scf, index_type,1);
      class_define_index(ppt->index_tp_delta_dr,   ppt->has_source_delta_dr,  index_type,1);
      class_define_index(ppt->index_tp_delta_ur,   ppt->has_source_delta_ur,  index_type,1);
      class_define_index(ppt->index_tp_delta_idr,  ppt->has_source_delta_idr, index_type,1);
      class_define_index(ppt->index_tp_delta_ncdm1,ppt->has_source_delta_ncdm,index_type,pba->N_ncdm);
      class_define_index(ppt->index_tp_theta_m,    ppt->has_source_theta_m,   index_type,1);
      class_define_index(ppt->index_tp_theta_cb,   ppt->has_source_theta_cb,  index_type,1);
      class_define_index(ppt->index_tp_theta_tot,  ppt->has_source_theta_tot, index_type,1);
      class_define_index(ppt->index_tp_theta_g,    ppt->has_source_theta_g,   index_type,1);
      class_define_index(ppt->index_tp_theta_b,    ppt->has_source_theta_b,   index_type,1);
      class_define_index(ppt->index_tp_theta_cdm,  ppt->has_source_theta_cdm, index_type,1);
      class_define_index(ppt->index_tp_theta_idm,  ppt->has_source_theta_idm, index_type,1);
      class_define_index(ppt->index_tp_theta_dcdm, ppt->has_source_theta_dcdm,index_type,1);
      class_define_index(ppt->index_tp_theta_fld,  ppt->has_source_theta_fld, index_type,1);
      class_define_index(ppt->index_tp_theta_scf,  ppt->has_source_theta_scf, index_type,1);
      class_define_index(ppt->index_tp_theta_dr,   ppt->has_source_theta_dr,  index_type,1);
      class_define_index(ppt->index_tp_theta_ur,   ppt->has_source_theta_ur,  index_type,1);
      class_define_index(ppt->index_tp_theta_idr,  ppt->has_source_theta_idr, index_type,1);
      class_define_index(ppt->index_tp_theta_ncdm1,ppt->has_source_theta_ncdm,index_type,pba->N_ncdm);
      class_define_index(ppt->index_tp_phi,        ppt->has_source_phi,       index_type,1);
      class_define_index(ppt->index_tp_phi_prime,  ppt->has_source_phi_prime, index_type,1);
      class_define_index(ppt->index_tp_phi_plus_psi,ppt->has_source_phi_plus_psi,index_type,1);
      class_define_index(ppt->index_tp_psi,        ppt->has_source_psi,       index_type,1);
      class_define_index(ppt->index_tp_h,          ppt->has_source_h,         index_type,1);
      class_define_index(ppt->index_tp_h_prime,    ppt->has_source_h_prime,   index_type,1);
      class_define_index(ppt->index_tp_eta,        ppt->has_source_eta,       index_type,1);
      class_define_index(ppt->index_tp_eta_prime,  ppt->has_source_eta_prime, index_type,1);
      class_define_index(ppt->index_tp_H_T_Nb_prime,ppt->has_source_H_T_Nb_prime,index_type,1);
      class_define_index(ppt->index_tp_k2gamma_Nb, ppt->has_source_k2gamma_Nb,index_type,1);
      ppt->tp_size[index_md] = index_type;

      class_test(index_type == 0,
                 ppt->error_message,
                 "inconsistent input: you asked for scalars, so you should have at least one non-zero scalar source type (temperature, polarization, lensing/gravitational potential, ...). Please adjust your input.");

      /** - --> count scalar initial conditions (for scalars: ad, cdi, nid, niv; for tensors: only one) and assign corresponding indices */

      index_ic = 0;
      class_define_index(ppt->index_ic_ad, ppt->has_ad, index_ic,1);
      class_define_index(ppt->index_ic_bi, ppt->has_bi, index_ic,1);
      class_define_index(ppt->index_ic_cdi,ppt->has_cdi,index_ic,1);
      class_define_index(ppt->index_ic_nid,ppt->has_nid,index_ic,1);
      class_define_index(ppt->index_ic_niv,ppt->has_niv,index_ic,1);
      ppt->ic_size[index_md] = index_ic;

      class_test(index_ic == 0,
                 ppt->error_message,
                 "you should have at least one adiabatic or isocurvature initial condition...} !!!");

    }

    /** - (b) vectors */

    if (_vectors_) {

      /** - --> source flags and indices, for sources that are specific to vectors */

      index_type = index_type_common;
      class_define_index(ppt->index_tp_t1,ppt->has_source_t,index_type,1);
      ppt->tp_size[index_md] = index_type;

      /*
        class_test(index_type == 0,
        ppt->error_message,
        "inconsistent input: you asked for vectors, so you should have at least one non-zero vector source type (temperature or polarization). Please adjust your input.");
      */

      /** - --> initial conditions for vectors*/

      index_ic = 0;
      /* not coded yet */
      ppt->ic_size[index_md] = index_ic;

    }

    /** - (c) tensors */
    if (_tensors_) {

      /** - --> source flags and indices, for sources that are specific to tensors */

      index_type = index_type_common;
      /* nothing specific, unlike for vectors and scalars! */
      ppt->tp_size[index_md] = index_type;

      /*
        class_test(index_type == 0,
        ppt->error_message,
        "inconsistent input: you asked for tensors, so you should have at least one non-zero tensor source type (temperature or polarization). Please adjust your input.");
      */

      /** - --> only one initial condition for tensors*/

      index_ic = 0;
      class_define_index(ppt->index_ic_ten,_TRUE_,index_ic,1);
      ppt->ic_size[index_md] = index_ic;

    }

    /** - (d) for each mode, allocate array of arrays of source functions for each initial conditions and wavenumber, (ppt->source[index_md])[index_ic][index_type] */

    class_alloc(ppt->sources[index_md],
                ppt->ic_size[index_md] * ppt->tp_size[index_md] * sizeof(double *),
                ppt->error_message);

    class_alloc(ppt->late_sources[index_md],
                ppt->ic_size[index_md] * ppt->tp_size[index_md] * sizeof(double *),
                ppt->error_message);

    class_alloc(ppt->ddlate_sources[index_md],
                ppt->ic_size[index_md] * ppt->tp_size[index_md] * sizeof(double *),
                ppt->error_message);

  }

  /* Allocate the titles and data sections for the output file */
  ppt->number_of_scalar_titles=0;
  ppt->number_of_vector_titles=0;
  ppt->number_of_tensor_titles=0;
  for (filenum = 0; filenum<_MAX_NUMBER_OF_K_FILES_; filenum++){
    ppt->scalar_perturbations_data[filenum] = NULL;
    ppt->vector_perturbations_data[filenum] = NULL;
    ppt->tensor_perturbations_data[filenum] = NULL;
  }

  return _SUCCESS_;

}

/**
 * Define time sampling for source functions.
 *
 * For each type, compute the list of values of tau at which sources
 * will be sampled.  Knowing the number of tau values, allocate all
 * arrays of source functions.
 *
 * @param ppr Input: pointer to precision structure
 * @param pba Input: pointer to background structure
 * @param pth Input: pointer to thermodynamics structure
 * @param ppt Input/Output: Initialized perturbation structure
 * @return the error status
 */

int perturbations_timesampling_for_sources(
                                           struct precision * ppr,
                                           struct background * pba,
                                           struct thermodynamics * pth,
                                           struct perturbations * ppt
                                           ) {

  /** Summary: */

  /** - define local variables */

  int counter;
  int index_md;
  int index_tp;
  int index_ic;
  int index_tau;
  int index_ln_tau;
  int last_index_back;
  int last_index_thermo;
  int first_index_back;
  int first_index_thermo;

  double tau;
  double tau_ini;
  double tau_lower;
  double tau_upper;
  double tau_mid;

  double timescale_source;
  double rate_thermo;
  double rate_isw_squared;
  double a_prime_over_a;
  double a_primeprime_over_a;
  double * pvecback;
  double * pvecthermo;

  /** - allocate background/thermodynamics vectors */

  class_alloc(pvecback,pba->bg_size*sizeof(double),ppt->error_message);
  class_alloc(pvecthermo,pth->th_size*sizeof(double),ppt->error_message);

  /** - check validity of age_fraction precision parameter */
  class_test((ppr->perturbations_sampling_boost_above_age_fraction < 0.) || (ppr->perturbations_sampling_boost_above_age_fraction > 1.),
             ppt->error_message,
             "The precision parameter perturbations_sampling_boost_above_age_fraction should be between 0 and 1, not %e",
             ppr->perturbations_sampling_boost_above_age_fraction);

  /** - first, just count the number of sampling points in order to allocate the array containing all values */

  /** - (a) if CMB requested, first sampling point = when the universe
      stops being opaque; otherwise, start sampling gravitational
      potential at recombination [however, if perturbed recombination
      is requested, we also need to start the system before
      recombination. Otherwise, the initial conditions for gas
      temperature and ionization fraction perturbations (delta_T = 1/3
      delta_b, delta_x_e) are not valid]. */

  if ((ppt->has_cmb == _TRUE_)||(ppt->has_perturbed_recombination == _TRUE_)) {

    /* using bisection, search time tau such that the ratio of thermo
       to Hubble time scales tau_c/tau_h=aH/kappa' is equal to
       start_sources_at_tau_c_over_tau_h */

    tau_lower = pth->tau_ini;

    class_call(background_at_tau(pba,
                                 tau_lower,
                                 short_info,
                                 inter_normal,
                                 &first_index_back,
                                 pvecback),
               pba->error_message,
               ppt->error_message);

    class_call(thermodynamics_at_z(pba,
                                   pth,
                                   1./pvecback[pba->index_bg_a]-1.,  /* redshift z=1/a-1 */
                                   inter_normal,
                                   &first_index_thermo,
                                   pvecback,
                                   pvecthermo),
               pth->error_message,
               ppt->error_message);

    class_test(pvecback[pba->index_bg_a]*
               pvecback[pba->index_bg_H]/
               pvecthermo[pth->index_th_dkappa] >
               ppr->start_sources_at_tau_c_over_tau_h,
               ppt->error_message,
               "your choice of initial time for computing sources is inappropriate: it corresponds to an earlier time than the one at which the integration of thermodynamical variables started (tau=%g). You should increase either 'start_sources_at_tau_c_over_tau_h' or 'recfast_z_initial'\n",
               tau_lower);


    tau_upper = pth->tau_rec;

    class_call(background_at_tau(pba,
                                 tau_upper,
                                 short_info,
                                 inter_normal,
                                 &first_index_back,
                                 pvecback),
               pba->error_message,
               ppt->error_message);

    class_call(thermodynamics_at_z(pba,
                                   pth,
                                   1./pvecback[pba->index_bg_a]-1.,  /* redshift z=1/a-1 */
                                   inter_normal,
                                   &first_index_thermo,
                                   pvecback,
                                   pvecthermo),
               pth->error_message,
               ppt->error_message);

    class_test(pvecback[pba->index_bg_a]*
               pvecback[pba->index_bg_H]/
               pvecthermo[pth->index_th_dkappa] <
               ppr->start_sources_at_tau_c_over_tau_h,
               ppt->error_message,
               "your choice of initial time for computing sources is inappropriate: it corresponds to a time after recombination. You should decrease 'start_sources_at_tau_c_over_tau_h'\n");

    tau_mid = 0.5*(tau_lower + tau_upper);

    while (tau_upper - tau_lower > ppr->tol_tau_approx) {

      class_call(background_at_tau(pba,
                                   tau_mid,
                                   short_info,
                                   inter_normal,
                                   &first_index_back,
                                   pvecback),
                 pba->error_message,
                 ppt->error_message);

      class_call(thermodynamics_at_z(pba,
                                     pth,
                                     1./pvecback[pba->index_bg_a]-1.,  /* redshift z=1/a-1 */
                                     inter_normal,
                                     &first_index_thermo,
                                     pvecback,
                                     pvecthermo),
                 pth->error_message,
                 ppt->error_message);


      if (pvecback[pba->index_bg_a]*
          pvecback[pba->index_bg_H]/
          pvecthermo[pth->index_th_dkappa] >
          ppr->start_sources_at_tau_c_over_tau_h)

        tau_upper = tau_mid;
      else
        tau_lower = tau_mid;

      tau_mid = 0.5*(tau_lower + tau_upper);

    }

    tau_ini = tau_mid;

  }
  else {

    /* check the time corresponding to the highest redshift requested
       in output plus 1, tau(z_max_pk+1). This margin of 1 aims at
       adding a few sampled values above z_max_pk, to make
       interpolations more relia=ble up to z_max_pk, without boundary
       effects. */
    class_call(background_tau_of_z(pba,
                                   ppt->z_max_pk+1,
                                   &tau_ini),
               pba->error_message,
               ppt->error_message);

    /* obsolete: previous choice was to start always at recombination time */
    /* tau_ini = pth->tau_rec; */

    /* set values of first_index_back/thermo */
    class_call(background_at_tau(pba,
                                 tau_ini,
                                 short_info,
                                 inter_normal,
                                 &first_index_back,
                                 pvecback),
               pba->error_message,
               ppt->error_message);

    class_call(thermodynamics_at_z(pba,
                                   pth,
                                   1./pvecback[pba->index_bg_a]-1.,  /* redshift z=1/a-1 */
                                   inter_normal,
                                   &first_index_thermo,
                                   pvecback,
                                   pvecthermo),
               pth->error_message,
               ppt->error_message);
  }

  /** - (b) next sampling point = previous + ppr->perturbations_sampling_stepsize * timescale_source, where:
      - --> if CMB requested:
      timescale_source1 = \f$ |g/\dot{g}| = |\dot{\kappa}-\ddot{\kappa}/\dot{\kappa}|^{-1} \f$;
      timescale_source2 = \f$ |2\ddot{a}/a-(\dot{a}/a)^2|^{-1/2} \f$ (to sample correctly the late ISW effect; and
      timescale_source=1/(1/timescale_source1+1/timescale_source2); repeat till today.
      - --> if CMB not requested:
      timescale_source = 1/aH; repeat till today.
  */

  counter = 1;
  last_index_back = first_index_back;
  last_index_thermo = first_index_thermo;
  tau = tau_ini;

  while (tau < pba->conformal_age) {

    class_call(background_at_tau(pba,
                                 tau,
                                 short_info,
                                 inter_closeby,
                                 &last_index_back,
                                 pvecback),
               pba->error_message,
               ppt->error_message);

    class_call(thermodynamics_at_z(pba,
                                   pth,
                                   1./pvecback[pba->index_bg_a]-1.,  /* redshift z=1/a-1 */
                                   inter_closeby,
                                   &last_index_thermo,
                                   pvecback,
                                   pvecthermo),
               pth->error_message,
               ppt->error_message);

    if (ppt->has_cmb == _TRUE_) {

      /* variation rate of thermodynamics variables */
      rate_thermo = pvecthermo[pth->index_th_rate];

      /* variation rate of metric due to late ISW effect (important at late times) */
      a_prime_over_a = pvecback[pba->index_bg_H] * pvecback[pba->index_bg_a];
      a_primeprime_over_a = pvecback[pba->index_bg_H_prime] * pvecback[pba->index_bg_a]
        + 2. * a_prime_over_a * a_prime_over_a;
      rate_isw_squared = fabs(2.*a_primeprime_over_a-a_prime_over_a*a_prime_over_a);

      /* compute rate */
      timescale_source = sqrt(rate_thermo*rate_thermo+rate_isw_squared);
    }
    else {
      /* variation rate given by Hubble time */
      a_prime_over_a = pvecback[pba->index_bg_H] * pvecback[pba->index_bg_a];

      timescale_source = a_prime_over_a;
    }

    /* check it is non-zero */
    class_test(timescale_source == 0.,
               ppt->error_message,
               "null evolution rate, integration is diverging");

    /* compute inverse rate */
    timescale_source = 1./timescale_source;

    /* added in v3.2.2: age fraction (between 0 and 1 ) such that,
       when tau > conformal_age * age_fraction, the time sampling of
       sources is twice finer, in order to boost the accuracy of the
       lensing line-of-sight integrals without changing that of
       unlensed CMB observables */
    if (tau > pba->conformal_age * ppr->perturbations_sampling_boost_above_age_fraction) {
      timescale_source /= 2.;
    }

    class_test(fabs(ppr->perturbations_sampling_stepsize*timescale_source/tau) < ppr->smallest_allowed_variation,
               ppt->error_message,
               "integration step =%e < machine precision : leads either to numerical error or infinite loop",ppr->perturbations_sampling_stepsize*timescale_source);

    tau = tau + ppr->perturbations_sampling_stepsize*timescale_source;
    counter++;

  }

  /** - --> infer total number of time steps, ppt->tau_size */
  ppt->tau_size = counter;

  /** - --> allocate array of time steps, ppt->tau_sampling[index_tau] */
  class_alloc(ppt->tau_sampling,ppt->tau_size * sizeof(double),ppt->error_message);

  /** - --> repeat the same steps, now filling the array with each tau value: */

  /** - --> (b.1.) first sampling point = when the universe stops being opaque */

  counter = 0;
  ppt->tau_sampling[counter]=tau_ini;

  /** - --> (b.2.) next sampling point = previous + ppr->perturbations_sampling_stepsize * timescale_source, where
      timescale_source1 = \f$ |g/\dot{g}| = |\dot{\kappa}-\ddot{\kappa}/\dot{\kappa}|^{-1} \f$;
      timescale_source2 = \f$ |2\ddot{a}/a-(\dot{a}/a)^2|^{-1/2} \f$ (to sample correctly the late ISW effect; and
      timescale_source=1/(1/timescale_source1+1/timescale_source2); repeat till today.
      If CMB not requested:
      timescale_source = 1/aH; repeat till today.  */

  last_index_back = first_index_back;
  last_index_thermo = first_index_thermo;
  tau = tau_ini;

  while (tau < pba->conformal_age) {

    class_call(background_at_tau(pba,
                                 tau,
                                 short_info,
                                 inter_closeby,
                                 &last_index_back,
                                 pvecback),
               pba->error_message,
               ppt->error_message);

    class_call(thermodynamics_at_z(pba,
                                   pth,
                                   1./pvecback[pba->index_bg_a]-1.,  /* redshift z=1/a-1 */
                                   inter_closeby,
                                   &last_index_thermo,
                                   pvecback,
                                   pvecthermo),
               pth->error_message,
               ppt->error_message);

    if (ppt->has_cmb == _TRUE_) {

      /* variation rate of thermodynamics variables */
      rate_thermo = pvecthermo[pth->index_th_rate];

      /* variation rate of metric due to late ISW effect (important at late times) */
      a_prime_over_a = pvecback[pba->index_bg_H] * pvecback[pba->index_bg_a];
      a_primeprime_over_a = pvecback[pba->index_bg_H_prime] * pvecback[pba->index_bg_a]
        + 2. * a_prime_over_a * a_prime_over_a;
      rate_isw_squared = fabs(2.*a_primeprime_over_a-a_prime_over_a*a_prime_over_a);

      /* compute rate */
      timescale_source = sqrt(rate_thermo*rate_thermo+rate_isw_squared);
    }
    else {
      a_prime_over_a = pvecback[pba->index_bg_H] * pvecback[pba->index_bg_a];
      timescale_source = a_prime_over_a;
    }

    /* check it is non-zero */
    class_test(timescale_source == 0.,
               ppt->error_message,
               "null evolution rate, integration is diverging");

    /* compute inverse rate */
    timescale_source = 1./timescale_source;

    /* added in v3.2.2: age fraction (between 0 and 1 ) such that,
       when tau > conformal_age * age_fraction, the time sampling of
       sources is twice finer, in order to boost the accuracy of the
       lensing line-of-sight integrals without changing that of
       unlensed CMB observables */
    if (tau > pba->conformal_age * ppr->perturbations_sampling_boost_above_age_fraction) {
      timescale_source /= 2.;
    }

    class_test(fabs(ppr->perturbations_sampling_stepsize*timescale_source/tau) < ppr->smallest_allowed_variation,
               ppt->error_message,
               "integration step =%e < machine precision : leads either to numerical error or infinite loop",ppr->perturbations_sampling_stepsize*timescale_source);

    tau = tau + ppr->perturbations_sampling_stepsize*timescale_source;
    counter++;
    ppt->tau_sampling[counter]=tau;

  }

  /** - last sampling point = exactly today */
  ppt->tau_sampling[counter] = pba->conformal_age;

  free(pvecback);
  free(pvecthermo);

  /** - check the maximum redshift z_max_pk at which the Fourier
      transfer functions \f$ T_i(k,z)\f$ should be computable by
      interpolation. If it is equal to zero, only \f$ T_i(k,z=0)\f$
      needs to be computed. If it is higher, we will store a table of
      log(tau) in the relevant time range, generously encompassing the
      range 0<z<z_max_pk, and used for the intepolation of sources */

  /* if z_max_pk<0, return error */
  class_test(ppt->z_max_pk < 0,
             ppt->error_message,
             "asked for negative redshift z=%e",ppt->z_max_pk);

  /* if z_max_pk=0, there is just one value to store */
  if (ppt->z_max_pk == 0.) {
    ppt->ln_tau_size=1;
  }

  /* if z_max_pk>0, store several values (with a comfortable margin above z_max_pk) in view of interpolation */
  else{
    /* find the first relevant value of tau (last value in the table tau_sampling before tau(z_max)) and infer the number of values of tau at which P(k) must be stored */

    class_call(background_tau_of_z(pba,ppt->z_max_pk,&tau_lower),
               pba->error_message,
               ppt->error_message);

    index_tau=0;
    class_test((tau_lower <= ppt->tau_sampling[index_tau]),
               ppt->error_message,
               "you asked for zmax=%e, i.e. taumin=%e, smaller than or equal to the first possible value =%e; it should be strictly bigger for a successfull interpolation",ppt->z_max_pk,tau_lower,ppt->tau_sampling[0]);

    /* skip all values of tau such that z>z_max_pk */
    while (ppt->tau_sampling[index_tau] < tau_lower){
      index_tau++;
    }
    index_tau --;

    /* now we are at the largest value of tau such that z>z_max_pk. */
    class_test(index_tau<0,
               ppt->error_message,
               "by construction, this should never happen, a bug must have been introduced somewhere");

    /* whenever possible, take a few more values in to avoid boundary effects in the interpolation */
    if (index_tau>0) index_tau--;
    if (index_tau>0) index_tau--;
    if (index_tau>0) index_tau--;
    if (index_tau>0) index_tau--;
    ppt->ln_tau_size=ppt->tau_size-index_tau;

    /* allocate and fill array of log(tau).
       The arrays tau_sampling[] and ln_tau[] refer
       to the same times, but their indices are shifted by
       (-ppt->ln_tau_size+ppt->tau_size), such that index_ln_tau=0
       corresponds to index_tau=ppt->tau_size-ppt->ln_tau_size a*/
    class_alloc(ppt->ln_tau,ppt->ln_tau_size * sizeof(double),ppt->error_message);

    for (index_ln_tau=0; index_ln_tau<ppt->ln_tau_size; index_ln_tau++) {
      ppt->ln_tau[index_ln_tau]=log(ppt->tau_sampling[index_ln_tau-ppt->ln_tau_size+ppt->tau_size]);
    }
  }

  /** - loop over modes, initial conditions and types. For each of
      them, allocate array of source functions. */

  for (index_md = 0; index_md < ppt->md_size; index_md++) {
    for (index_ic = 0; index_ic < ppt->ic_size[index_md]; index_ic++) {
      for (index_tp = 0; index_tp < ppt->tp_size[index_md]; index_tp++) {

        class_alloc(ppt->sources[index_md][index_ic*ppt->tp_size[index_md]+index_tp],
                    ppt->k_size[index_md] * ppt->tau_size * sizeof(double),
                    ppt->error_message);

        if (ppt->ln_tau_size > 1) {
          /* late_sources is just a pointer to the end of sources (starting from the relevant time index) */
          ppt->late_sources[index_md][index_ic*ppt->tp_size[index_md]+index_tp] = &(ppt->sources[index_md]
                                                                                    [index_ic * ppt->tp_size[index_md] + index_tp]
                                                                                    [(ppt->tau_size-ppt->ln_tau_size) * ppt->k_size[index_md]]);

          class_alloc(ppt->ddlate_sources[index_md][index_ic*ppt->tp_size[index_md]+index_tp],
                      ppt->k_size[index_md] * ppt->ln_tau_size * sizeof(double),
                      ppt->error_message);
        }
      }
    }
  }

  return _SUCCESS_;
}

/**
 * Define the number of comoving wavenumbers using the information
 * passed in the precision structure.
 *
 * @param ppr        Input: pointer to precision structure
 * @param pba        Input: pointer to background structure
 * @param pth        Input: pointer to thermodynamics structure
 * @param ppt        Input: pointer to perturbation structure
 * @return the error status
 */

int perturbations_get_k_list(
                             struct precision * ppr,
                             struct background * pba,
                             struct thermodynamics * pth,
                             struct perturbations * ppt
                             ) {
  int index_k, index_k_output, index_mode;
  double k,k_min=0.,k_rec,step,tau1;
  double * k_max_cmb;
  double * k_max_cl;
  double k_max=0.;
  double scale2;
  double *tmp_k_list;
  int newk_size, index_newk, add_k_output_value;

  /** Summary: */

  class_test(ppr->k_step_transition == 0.,
             ppt->error_message,
             "stop to avoid division by zero");

  class_test(pth->rs_rec == 0.,
             ppt->error_message,
             "stop to avoid division by zero");

  /** - allocate arrays related to k list for each mode */

  class_alloc(ppt->k_size_cmb,
              ppt->md_size*sizeof(int),
              ppt->error_message);
  class_alloc(ppt->k_size_cl,
              ppt->md_size*sizeof(int),
              ppt->error_message);
  class_alloc(ppt->k_size,
              ppt->md_size*sizeof(int),
              ppt->error_message);
  class_alloc(ppt->k,
              ppt->md_size*sizeof(double*),
              ppt->error_message);

  class_calloc(k_max_cmb,
               ppt->md_size,
               sizeof(double),
               ppt->error_message);
  class_calloc(k_max_cl,
               ppt->md_size,
               sizeof(double),
               ppt->error_message);

  /** - scalar modes */

  if (ppt->has_scalars == _TRUE_) {

    /* first value */
    if (pba->sgnK == 0) {
      /* K<0 (flat)  : start close to zero */
      k_min=ppr->k_min_tau0/pba->conformal_age;
    }
    else if (pba->sgnK == -1) {
      /* K<0 (open)  : start close to sqrt(-K)
         (in transfer modules, for scalars, this will correspond to q close to zero;
         for vectors and tensors, this value is even smaller than the minimum necessary value) */
      k_min=sqrt(-pba->K+pow(ppr->k_min_tau0/pba->conformal_age/pth->angular_rescaling,2));

    }
    else if (pba->sgnK == 1) {
      /* K>0 (closed): start from q=sqrt(k2+(1+m)K) equal to 3sqrt(K), i.e. k=sqrt((8-m)K) */
      k_min = sqrt((8.-1.e-4)*pba->K);
    }

    /** - --> find k_max (as well as k_max_cmb[ppt->index_md_scalars], k_max_cl[ppt->index_md_scalars]) */

    k_rec = 2. * _PI_ / pth->rs_rec; /* comoving scale corresponding to sound horizon at recombination */

    k_max_cmb[ppt->index_md_scalars] = k_min;
    k_max_cl[ppt->index_md_scalars] = k_min;
    k_max = k_min;

    if (ppt->has_cls == _TRUE_) {

      /* find k_max_cmb[ppt->index_md_scalars] : */

      /* choose a k_max_cmb[ppt->index_md_scalars] corresponding to a wavelength on the last
         scattering surface seen today under an angle smaller than
         pi/lmax: this is equivalent to
         k_max_cl[ppt->index_md_scalars]*[comvoving.ang.diameter.distance] > l_max */

      k_max_cmb[ppt->index_md_scalars] = ppr->k_max_tau0_over_l_max*ppt->l_scalar_max
        /pba->conformal_age/pth->angular_rescaling;
      k_max_cl[ppt->index_md_scalars] = k_max_cmb[ppt->index_md_scalars];
      k_max     = k_max_cmb[ppt->index_md_scalars];

      /* find k_max_cl[ppt->index_md_scalars] : */

      /* if we need density/lensing Cl's, we must impose a stronger condition,
         such that the minimum wavelength on the shell corresponding
         to the center of smallest redshift bin is seen under an
         angle smaller than pi/lmax. So we must multiply our previous
         k_max_cl[ppt->index_md_scalars] by the ratio tau0/(tau0-tau[center of smallest
         redshift bin]). Note that we could do the same with the
         lensing potential if we needed a very precise C_l^phi-phi at
         large l. We don't do it by default, because the lensed ClT,
         ClE would be marginally affected. */

      if ((ppt->has_cl_number_count == _TRUE_) || (ppt->has_cl_lensing_potential == _TRUE_)) {

        class_call(background_tau_of_z(pba,
                                       ppt->selection_mean[0],
                                       &tau1),
                   pba->error_message,
                   ppt->error_message);

        k_max_cl[ppt->index_md_scalars] = MAX(k_max_cl[ppt->index_md_scalars],ppr->k_max_tau0_over_l_max*ppt->l_lss_max/(pba->conformal_age-tau1)); // to be very accurate we should use angular diameter distance to given redshift instead of comoving radius: would implement corrections depending on curvature
        k_max    = k_max_cl[ppt->index_md_scalars];
      }
    }

    /* find k_max: */

    if ((ppt->has_pk_matter == _TRUE_) || (ppt->has_density_transfers == _TRUE_) || (ppt->has_velocity_transfers == _TRUE_))
      k_max = MAX(k_max,ppt->k_max_for_pk);

    if (ppt->has_nl_corrections_based_on_delta_m == _TRUE_)
      k_max = MAX(k_max,ppr->nonlinear_min_k_max);

    if ((ppt->has_cl_cmb_lensing_potential == _TRUE_) && (ppt->want_lcmb_full_limber == _TRUE_))
      k_max = MAX(k_max, ppr->k_max_limber_over_l_max_scalars * ppt->l_scalar_max);

    /** - --> test that result for k_min, k_max make sense */

    class_test(k_min<0.,
               ppt->error_message,
               "buggy definition of k_min");

    class_test(k_max<0.,
               ppt->error_message,
               "buggy definition of k_max");

    class_test(k_max<k_min,
               ppt->error_message,
               "buggy definition of k_min and/or k_max");

    /* if K>0, the transfer function will be calculated for discrete
       integer values of nu=3,4,5,... where nu=sqrt(k2+(1+m)K) and
       m=0,1,2 for scalars/vectors/tensors. However we are free to
       define in the perturbation module some arbitrary values of k:
       later on, the transfer module will interpolate at values of k
       corresponding exactly to integer values of nu. Hence, apart
       from the value of k_min and the step size in the vicinity of
       k_min, we define exactly the same sampling in the three cases
       K=0, K<0, K>0 */

    /* allocate array with, for the moment, the largest possible size */

    /* the following is a boost on k_per_decade_for_pk for the interacting idm-idr cases (relevant for large k and a_idm_dr) */
    if ((pth->has_idm_dr==_TRUE_)&&(pth->n_index_idm_dr>=2)){
      class_alloc(ppt->k[ppt->index_md_scalars],
                  ((int)((k_max_cmb[ppt->index_md_scalars]-k_min)/k_rec/MIN(ppr->k_step_super,ppr->k_step_sub))+
                   (int)(MAX(ppr->k_per_decade_for_pk*ppr->idmdr_boost_k_per_decade_for_pk*pth->n_index_idm_dr,ppr->k_per_decade_for_bao)*log(k_max/k_min)/log(10.))+3)
                  *sizeof(double),ppt->error_message);
    }
    else {
      class_alloc(ppt->k[ppt->index_md_scalars],
                  ((int)((k_max_cmb[ppt->index_md_scalars]-k_min)/k_rec/MIN(ppr->k_step_super,ppr->k_step_sub))+
                   (int)(MAX(ppr->k_per_decade_for_pk,ppr->k_per_decade_for_bao)*log(k_max/k_min)/log(10.))+3)
                  *sizeof(double),ppt->error_message);
    }

    /* first value */

    index_k=0;
    k = k_min;
    ppt->k[ppt->index_md_scalars][index_k] = k;
    index_k++;

    /* values until k_max_cmb[ppt->index_md_scalars] */

    while (k < k_max_cmb[ppt->index_md_scalars]) {

      /* the linear step is not constant, it has a step-like shape,
         centered around the characteristic scale set by the sound
         horizon at recombination (associated to the comoving wavenumber
         k_rec) */

      step = (ppr->k_step_super
              + 0.5 * (tanh((k-k_rec)/k_rec/ppr->k_step_transition)+1.)
              * (ppr->k_step_sub-ppr->k_step_super)) * k_rec;

      /* there is one other thing to take into account in the step
         size. There are two other characteristic scales that matter for
         the sampling: the Hubble scale today, k0=a0H0, and eventually
         curvature scale sqrt(|K|). We define "scale2" as the sum of the
         squared Hubble radius and squared curvature radius. We need to
         increase the sampling for k<sqrt(scale2), in order to get the
         first mutipoles accurate enough. The formula below reduces it
         gradually in the k-->0 limit, by up to a factor 10. The actual
         stepsize is still fixed by k_step_super, this is just a
         reduction factor. */

      scale2 = pow(pba->H0,2)+fabs(pba->K);

      step *= (k*k/scale2+1.)/(k*k/scale2+1./ppr->k_step_super_reduction);

      class_test(step / k < ppr->smallest_allowed_variation,
                 ppt->error_message,
                 "k step =%e < machine precision : leads either to numerical error or infinite loop",
                 step * k_rec);

      k += step;

      class_test(k <= ppt->k[ppt->index_md_scalars][index_k-1],
                 ppt->error_message,
                 "consecutive values of k should differ and should be in growing order");

      ppt->k[ppt->index_md_scalars][index_k] = k;

      index_k++;
    }

    ppt->k_size_cmb[ppt->index_md_scalars] = index_k;

    /* values until k_max_cl[ppt->index_md_scalars] */

    while (k < k_max_cl[ppt->index_md_scalars]) {

      k *= pow(10.,1./(ppr->k_per_decade_for_pk
                       +(ppr->k_per_decade_for_bao-ppr->k_per_decade_for_pk)
                       *(1.-tanh(pow((log(k)-log(ppr->k_bao_center*k_rec))/log(ppr->k_bao_width),4)))));

      ppt->k[ppt->index_md_scalars][index_k] = k;
      index_k++;
    }

    ppt->k_size_cl[ppt->index_md_scalars] = index_k;

    /* values until k_max; find ppt->k_size_pk along the way */

    ppt->k_size_pk = 0;

    while (k < k_max) {
      if ((pth->has_idm_dr==_TRUE_)&&(pth->n_index_idm_dr>=2)){
        k *= pow(10.,1./(ppr->k_per_decade_for_pk*ppr->idmdr_boost_k_per_decade_for_pk*pth->n_index_idm_dr
                         +(ppr->k_per_decade_for_bao-ppr->k_per_decade_for_pk*ppr->idmdr_boost_k_per_decade_for_pk*pth->n_index_idm_dr)
                         *(1.-tanh(pow((log(k)-log(ppr->k_bao_center*k_rec))/log(ppr->k_bao_width),4)))));
      }
      else {
        k *= pow(10.,1./(ppr->k_per_decade_for_pk
                         +(ppr->k_per_decade_for_bao-ppr->k_per_decade_for_pk)
                         *(1.-tanh(pow((log(k)-log(ppr->k_bao_center*k_rec))/log(ppr->k_bao_width),4)))));
      }

      ppt->k[ppt->index_md_scalars][index_k] = k;

      index_k++;

      if ((ppt->k_size_pk == 0) && (k>ppt->k_max_for_pk))
        ppt->k_size_pk = index_k;
    }

    ppt->k_size[ppt->index_md_scalars] = index_k;

    class_realloc(ppt->k[ppt->index_md_scalars],
                  ppt->k_size[ppt->index_md_scalars]*sizeof(double),
                  ppt->error_message);
  }

  /** - vector modes */

  if (ppt->has_vectors == _TRUE_) {

    /* first value */
    if (pba->sgnK == 0) {
      /* K<0 (flat)  : start close to zero */
      k_min=ppr->k_min_tau0/pba->conformal_age;
    }
    else if (pba->sgnK == -1) {
      /* K<0 (open)  : start close to sqrt(-K)
         (in transfer modules, for scalars, this will correspond to q close to zero;
         for vectors and tensors, this value is even smaller than the minimum necessary value) */
      k_min=sqrt(-pba->K+pow(ppr->k_min_tau0/pba->conformal_age/pth->angular_rescaling,2));

    }
    else if (pba->sgnK == 1) {
      /* K>0 (closed): start from q=sqrt(k2+(1+m)K) equal to 3sqrt(K), i.e. k=sqrt((8-m)K) */
      k_min = sqrt((7.-1.e-4)*pba->K);
    }

    /** - --> find k_max (as well as k_max_cmb[ppt->index_md_vectors], k_max_cl[ppt->index_md_vectors]) */

    k_rec = 2. * _PI_ / pth->rs_rec; /* comoving scale corresponding to sound horizon at recombination */

    k_max_cmb[ppt->index_md_vectors] = k_min;
    k_max_cl[ppt->index_md_vectors] = k_min;
    k_max = k_min;

    if (ppt->has_cls == _TRUE_) {

      /* find k_max_cmb: */

      /* choose a k_max_cmb corresponding to a wavelength on the last
         scattering surface seen today under an angle smaller than
         pi/lmax: this is equivalent to
         k_max_cl*[comvoving.ang.diameter.distance] > l_max */

      k_max_cmb[ppt->index_md_vectors] = ppr->k_max_tau0_over_l_max*ppt->l_vector_max
        /pba->conformal_age/pth->angular_rescaling;
      k_max_cl[ppt->index_md_vectors]  = k_max_cmb[ppt->index_md_vectors];
      k_max     = k_max_cmb[ppt->index_md_vectors];
    }

    /** - --> test that result for k_min, k_max make sense */

    class_test(k_min<0.,
               ppt->error_message,
               "buggy definition of k_min");

    class_test(k_max<0.,
               ppt->error_message,
               "buggy definition of k_max");

    class_test(k_max<k_min,
               ppt->error_message,
               "buggy definition of k_min and/or k_max");

    /* if K>0, the transfer function will be calculated for discrete
       integer values of nu=3,4,5,... where nu=sqrt(k2+(1+m)K) and
       m=0,1,2 for scalars/vectors/tensors. However we are free to
       define in the perturbation module some arbitrary values of k:
       later on, the transfer module will interpolate at values of k
       corresponding exactly to integer values of nu. Hence, apart
       from the value of k_min and the step size in the vicinity of
       k_min, we define exactly the same sampling in the three cases
       K=0, K<0, K>0 */

    /* allocate array with, for the moment, the largest possible size */
    class_alloc(ppt->k[ppt->index_md_vectors],
                ((int)((k_max_cmb[ppt->index_md_vectors]-k_min)/k_rec/MIN(ppr->k_step_super,ppr->k_step_sub))+1)
                *sizeof(double),ppt->error_message);

    /* first value */

    index_k=0;
    k = k_min;
    ppt->k[ppt->index_md_vectors][index_k] = k;
    index_k++;

    /* values until k_max_cmb[ppt->index_md_vectors] */

    while (k < k_max_cmb[ppt->index_md_vectors]) {

      /* the linear step is not constant, it has a step-like shape,
         centered around the characteristic scale set by the sound
         horizon at recombination (associated to the comoving wavenumber
         k_rec) */

      step = (ppr->k_step_super
              + 0.5 * (tanh((k-k_rec)/k_rec/ppr->k_step_transition)+1.)
              * (ppr->k_step_sub-ppr->k_step_super)) * k_rec;

      /* there is one other thing to take into account in the step
         size. There are two other characteristic scales that matter for
         the sampling: the Hubble scale today, k0=a0H0, and eventually
         curvature scale sqrt(|K|). We define "scale2" as the sum of the
         squared Hubble radius and squared curvature radius. We need to
         increase the sampling for k<sqrt(scale2), in order to get the
         first mutipoles accurate enough. The formula below reduces it
         gradually in the k-->0 limit, by up to a factor 10. The actual
         stepsize is still fixed by k_step_super, this is just a
         reduction factor. */

      scale2 = pow(pba->H0,2)+fabs(pba->K);

      step *= (k*k/scale2+1.)/(k*k/scale2+1./ppr->k_step_super_reduction);

      class_test(step / k < ppr->smallest_allowed_variation,
                 ppt->error_message,
                 "k step =%e < machine precision : leads either to numerical error or infinite loop",
                 step * k_rec);

      k += step;

      class_test(k <= ppt->k[ppt->index_md_scalars][index_k-1],
                 ppt->error_message,
                 "consecutive values of k should differ and should be in growing order");

      ppt->k[ppt->index_md_vectors][index_k] = k;

      index_k++;
    }

    ppt->k_size_cmb[ppt->index_md_vectors] = index_k;
    ppt->k_size_cl[ppt->index_md_vectors] = index_k;
    ppt->k_size[ppt->index_md_vectors] = index_k;

    class_realloc(ppt->k[ppt->index_md_vectors],
                  ppt->k_size[ppt->index_md_vectors]*sizeof(double),
                  ppt->error_message);
  }

  /** - tensor modes */

  if (ppt->has_tensors == _TRUE_) {

    /* first value */
    if (pba->sgnK == 0) {
      /* K<0 (flat)  : start close to zero */
      k_min=ppr->k_min_tau0/pba->conformal_age;
    }
    else if (pba->sgnK == -1) {
      /* K<0 (open)  : start close to sqrt(-K)
         (in transfer modules, for scalars, this will correspond to q close to zero;
         for vectors and tensors, this value is even smaller than the minimum necessary value) */
      k_min=sqrt(-pba->K+pow(ppr->k_min_tau0/pba->conformal_age/pth->angular_rescaling,2));

    }
    else if (pba->sgnK == 1) {
      /* K>0 (closed): start from q=sqrt(k2+(1+m)K) equal to 3sqrt(K), i.e. k=sqrt((8-m)K) */
      k_min = sqrt((6.-1.e-4)*pba->K);
    }

    /** - --> find k_max (as well as k_max_cmb[ppt->index_md_tensors], k_max_cl[ppt->index_md_tensors]) */

    k_rec = 2. * _PI_ / pth->rs_rec; /* comoving scale corresponding to sound horizon at recombination */

    k_max_cmb[ppt->index_md_tensors] = k_min;
    k_max_cl[ppt->index_md_tensors] = k_min;
    k_max = k_min;

    if (ppt->has_cls == _TRUE_) {

      /* find k_max_cmb[ppt->index_md_tensors]: */

      /* choose a k_max_cmb[ppt->index_md_tensors] corresponding to a wavelength on the last
         scattering surface seen today under an angle smaller than
         pi/lmax: this is equivalent to
         k_max_cl[ppt->index_md_tensors]*[comvoving.ang.diameter.distance] > l_max */

      k_max_cmb[ppt->index_md_tensors] = ppr->k_max_tau0_over_l_max*ppt->l_tensor_max
        /pba->conformal_age/pth->angular_rescaling;
      k_max_cl[ppt->index_md_tensors]  = k_max_cmb[ppt->index_md_tensors];
      k_max     = k_max_cmb[ppt->index_md_tensors];
    }

    /** - --> test that result for k_min, k_max make sense */

    class_test(k_min<0.,
               ppt->error_message,
               "buggy definition of k_min");

    class_test(k_max<0.,
               ppt->error_message,
               "buggy definition of k_max");

    class_test(k_max<k_min,
               ppt->error_message,
               "buggy definition of k_min and/or k_max");

    /* if K>0, the transfer function will be calculated for discrete
       integer values of nu=3,4,5,... where nu=sqrt(k2+(1+m)K) and
       m=0,1,2 for scalars/vectors/tensors. However we are free to
       define in the perturbation module some arbitrary values of k:
       later on, the transfer module will interpolate at values of k
       corresponding exactly to integer values of nu. Hence, apart
       from the value of k_min and the step size in the vicinity of
       k_min, we define exactly the same sampling in the three cases
       K=0, K<0, K>0 */

    /* allocate array with, for the moment, the largest possible size */
    class_alloc(ppt->k[ppt->index_md_tensors],
                ((int)((k_max_cmb[ppt->index_md_tensors]-k_min)/k_rec/MIN(ppr->k_step_super,ppr->k_step_sub))+1)
                *sizeof(double),ppt->error_message);

    /* first value */

    index_k=0;
    k = k_min;
    ppt->k[ppt->index_md_tensors][index_k] = k;
    index_k++;

    /* values until k_max_cmb[ppt->index_md_tensors] */

    while (k < k_max_cmb[ppt->index_md_tensors]) {

      /* the linear step is not constant, it has a step-like shape,
         centered around the characteristic scale set by the sound
         horizon at recombination (associated to the comoving wavenumber
         k_rec) */

      step = (ppr->k_step_super
              + 0.5 * (tanh((k-k_rec)/k_rec/ppr->k_step_transition)+1.)
              * (ppr->k_step_sub-ppr->k_step_super)) * k_rec;

      /* there is one other thing to take into account in the step
         size. There are two other characteristic scales that matter for
         the sampling: the Hubble scale today, k0=a0H0, and eventually
         curvature scale sqrt(|K|). We define "scale2" as the sum of the
         squared Hubble radius and squared curvature radius. We need to
         increase the sampling for k<sqrt(scale2), in order to get the
         first mutipoles accurate enough. The formula below reduces it
         gradually in the k-->0 limit, by up to a factor 10. The actual
         stepsize is still fixed by k_step_super, this is just a
         reduction factor. */

      scale2 = pow(pba->H0,2)+fabs(pba->K);

      step *= (k*k/scale2+1.)/(k*k/scale2+1./ppr->k_step_super_reduction);

      class_test(step / k < ppr->smallest_allowed_variation,
                 ppt->error_message,
                 "k step =%e < machine precision : leads either to numerical error or infinite loop",
                 step * k_rec);

      k += step;

      class_test(k <= ppt->k[ppt->index_md_tensors][index_k-1],
                 ppt->error_message,
                 "consecutive values of k should differ and should be in growing order");

      ppt->k[ppt->index_md_tensors][index_k] = k;

      index_k++;
    }

    ppt->k_size_cmb[ppt->index_md_tensors] = index_k;
    ppt->k_size_cl[ppt->index_md_tensors] = index_k;
    ppt->k_size[ppt->index_md_tensors] = index_k;

    class_realloc(ppt->k[ppt->index_md_tensors],
                  ppt->k_size[ppt->index_md_tensors]*sizeof(double),
                  ppt->error_message);
  }

  /* Set default of the array (do NOT remove) */
  //ppt->index_k_output_values = NULL;

  /** - If user asked for k_output_values, add those to all k lists: */
  if (ppt->k_output_values_num > 0) {

    /* Allocate storage */
    class_alloc(ppt->index_k_output_values,sizeof(double)*ppt->md_size*ppt->k_output_values_num,ppt->error_message);

    /** - --> Find indices in ppt->k[index_md] corresponding to 'k_output_values'.
        We are assuming that ppt->k is sorted and growing, and we have made sure
        that ppt->k_output_values is also sorted and growing.*/
    for (index_mode=0; index_mode<ppt->md_size; index_mode++){

      newk_size = ppt->k_size[index_mode]+ppt->k_output_values_num;

      class_alloc(tmp_k_list,sizeof(double)*newk_size,ppt->error_message);

      index_k=0;
      index_k_output=0;
      for (index_newk=0; index_newk<newk_size; index_newk++){
        /** - --> Decide if we should add k_output_value now. This has to be this complicated, since we
            can only compare the k-values when both indices are in range.*/
        if (index_k >= ppt->k_size[index_mode])
          add_k_output_value = _TRUE_;
        else if (index_k_output >= ppt->k_output_values_num)
          add_k_output_value = _FALSE_;
        else if (ppt->k_output_values[index_k_output] < ppt->k[index_mode][index_k])
          add_k_output_value = _TRUE_;
        else
          add_k_output_value = _FALSE_;

        if (add_k_output_value == _TRUE_){
          tmp_k_list[index_newk] = ppt->k_output_values[index_k_output];
          ppt->index_k_output_values[index_mode*ppt->k_output_values_num+index_k_output]=index_newk;
          index_k_output++;
        }
        else{
          tmp_k_list[index_newk] = ppt->k[index_mode][index_k];
          index_k++;
        }
      }

      free(ppt->k[index_mode]);
      ppt->k[index_mode] = tmp_k_list;
      ppt->k_size[index_mode] = newk_size;

      index_k = newk_size-1;
      while (ppt->k[index_mode][index_k] > k_max_cl[index_mode])
        index_k--;
      ppt->k_size_cl[index_mode] = MIN(index_k+2,ppt->k_size[index_mode]);

      index_k = newk_size-1;
      while (ppt->k[index_mode][index_k] > k_max_cmb[index_mode])
        index_k--;
      ppt->k_size_cmb[index_mode] = MIN(index_k+2,ppt->k_size[index_mode]);

      /** - --> The two MIN statements are here because in a normal run, the cl and cmb
          arrays contain a single k value larger than their respective k_max.
          We are mimicking this behavior. */
    }
  }

  /* For testing, can be useful to print the k list in a file:

     FILE * out=fopen("output/k","w");

     for (index_k=0; index_k < ppt->k_size[0]; index_k++) {

     fprintf(out,"%e\n",ppt->k[0][index_k],pba->K);

     }
     fclose(out);
  */

  /** - finally, find the global k_min and k_max for the ensemble of all modes 9scalars, vectors, tensors) */

  ppt->k_min = _HUGE_;
  ppt->k_max = 0.;
  if (ppt->has_scalars == _TRUE_) {
    ppt->k_min = MIN(ppt->k_min,ppt->k[ppt->index_md_scalars][0]); /* first value, inferred from perturbations structure */
    ppt->k_max = MAX(ppt->k_max,ppt->k[ppt->index_md_scalars][ppt->k_size[ppt->index_md_scalars]-1]); /* last value, inferred from perturbations structure */
  }
  if (ppt->has_vectors == _TRUE_) {
    ppt->k_min = MIN(ppt->k_min,ppt->k[ppt->index_md_vectors][0]); /* first value, inferred from perturbations structure */
    ppt->k_max = MAX(ppt->k_max,ppt->k[ppt->index_md_vectors][ppt->k_size[ppt->index_md_vectors]-1]); /* last value, inferred from perturbations structure */
  }
  if (ppt->has_tensors == _TRUE_) {
    ppt->k_min = MIN(ppt->k_min,ppt->k[ppt->index_md_tensors][0]); /* first value, inferred from perturbations structure */
    ppt->k_max = MAX(ppt->k_max,ppt->k[ppt->index_md_tensors][ppt->k_size[ppt->index_md_tensors]-1]); /* last value, inferred from perturbations structure */
  }

  free(k_max_cmb);
  free(k_max_cl);

  return _SUCCESS_;

}

/**
 * Initialize a perturbations_workspace structure. All fields are allocated
 * here, with the exception of the perturbations_vector '-->pv' field, which
 * is allocated separately in perturbations_vector_init. We allocate one
 * such perturbations_workspace structure per thread and per mode
 * (scalar/../tensor). Then, for each thread, all initial conditions
 * and wavenumbers will use the same workspace.
 *
 * @param ppr        Input: pointer to precision structure
 * @param pba        Input: pointer to background structure
 * @param pth        Input: pointer to the thermodynamics structure
 * @param ppt        Input: pointer to the perturbation structure
 * @param index_md Input: index of mode under consideration (scalar/.../tensor)
 * @param ppw        Input/Output: pointer to perturbations_workspace structure which fields are allocated or filled here
 * @return the error status
 */

int perturbations_workspace_init(
                                 struct precision * ppr,
                                 struct background * pba,
                                 struct thermodynamics * pth,
                                 struct perturbations * ppt,
                                 int index_md,
                                 struct perturbations_workspace * ppw
                                 ) {

  /** Summary: */

  /** - define local variables */

  int index_mt=0;
  int index_ap;
  int l;

  /** - Compute maximum l_max for any multipole */;
  if (_scalars_) {
    ppw->max_l_max = MAX(ppr->l_max_g, ppr->l_max_pol_g);
    if (pba->has_ur == _TRUE_) ppw->max_l_max = MAX(ppw->max_l_max, ppr->l_max_ur);
    if ((pba->has_idr == _TRUE_) && (ppt->idr_nature == idr_free_streaming)) ppw->max_l_max = MAX(ppw->max_l_max, ppr->l_max_idr);
    if (pba->has_ncdm == _TRUE_) ppw->max_l_max = MAX(ppw->max_l_max, ppr->l_max_ncdm);
    if (pba->has_dr == _TRUE_) ppw->max_l_max = MAX(ppw->max_l_max, ppr->l_max_dr);
  }
  if (_tensors_) {
    ppw->max_l_max = MAX(ppr->l_max_g_ten, ppr->l_max_pol_g_ten);
    if (pba->has_ur == _TRUE_) ppw->max_l_max = MAX(ppw->max_l_max, ppr->l_max_ur);
    if (pba->has_ncdm == _TRUE_) ppw->max_l_max = MAX(ppw->max_l_max, ppr->l_max_ncdm);
  }

  /** - Allocate \f$ s_l\f$[ ] array for freestreaming of multipoles (see arXiv:1305.3261) and initialize
      to 1.0, which is the K=0 value. */
  class_alloc(ppw->s_l, sizeof(double)*(ppw->max_l_max+1),ppt->error_message);
  for (l=0; l<=ppw->max_l_max; l++){
    ppw->s_l[l] = 1.0;
  }

  /** - define indices of metric perturbations obeying constraint
      equations (this can be done once and for all, because the
      vector of metric perturbations is the same whatever the
      approximation scheme, unlike the vector of quantities to
      be integrated, which is allocated separately in
      perturbations_vector_init) */

  if (_scalars_) {

    /* newtonian gauge */

    if (ppt->gauge == newtonian) {
      class_define_index(ppw->index_mt_psi,_TRUE_,index_mt,1); /* psi */
      class_define_index(ppw->index_mt_phi_prime,_TRUE_,index_mt,1); /* phi' */
    }

    /* synchronous gauge (note that eta is counted in the vector of
       quantities to be integrated, while here we only consider
       quantities obeying to constraint equations) */

    if (ppt->gauge == synchronous) {
      class_define_index(ppw->index_mt_h_prime,_TRUE_,index_mt,1);       /* h' */
      class_define_index(ppw->index_mt_h_prime_prime,_TRUE_,index_mt,1); /* h'' */
      class_define_index(ppw->index_mt_eta_prime,_TRUE_,index_mt,1);     /* eta' */
      class_define_index(ppw->index_mt_alpha,_TRUE_,index_mt,1);         /* alpha = (h' + 6 tau') / (2 k**2) */
      class_define_index(ppw->index_mt_alpha_prime,_TRUE_,index_mt,1);   /* alpha' */

    }

  }

  if (_vectors_) {

    /* newtonian gauge */

    if (ppt->gauge == newtonian) {

      class_define_index(ppw->index_mt_V_prime,_TRUE_,index_mt,1);

    }

    if (ppt->gauge == synchronous) {

      class_define_index(ppw->index_mt_hv_prime_prime,_TRUE_,index_mt,1);

    }

  }

  if (_tensors_) {
    class_define_index(ppw->index_mt_gw_prime_prime,_TRUE_,index_mt,1);
  }

  ppw->mt_size = index_mt;

  /** - allocate some workspace in which we will store temporarily the
      values of background, thermodynamics, metric and source
      quantities at a given time */

  class_alloc(ppw->pvecback,pba->bg_size*sizeof(double),ppt->error_message);
  class_alloc(ppw->pvecthermo,pth->th_size*sizeof(double),ppt->error_message);
  class_alloc(ppw->pvecmetric,ppw->mt_size*sizeof(double),ppt->error_message);

  /** - count number of approximations, initialize their indices, and allocate their flags */
  index_ap=0;

  class_define_index(ppw->index_ap_tca,_TRUE_,index_ap,1);
  class_define_index(ppw->index_ap_rsa,_TRUE_,index_ap,1);

  if (_scalars_) {

    class_define_index(ppw->index_ap_ufa,pba->has_ur,index_ap,1);
    class_define_index(ppw->index_ap_ncdmfa,pba->has_ncdm,index_ap,1);
    class_define_index(ppw->index_ap_tca_idm_dr,pba->has_idr,index_ap,1);
    class_define_index(ppw->index_ap_rsa_idr,pba->has_idr,index_ap,1);
  }

  ppw->ap_size=index_ap;

  if (ppw->ap_size > 0)
    class_alloc(ppw->approx,ppw->ap_size*sizeof(int),ppt->error_message);

  /** - For definiteness, initialize approximation flags to arbitrary
      values (correct values are overwritten in
      pertub_find_approximation_switches) */

  if (_scalars_) {

    ppw->approx[ppw->index_ap_tca]=(int)tca_on;
    ppw->approx[ppw->index_ap_rsa]=(int)rsa_off;

    if (pba->has_idr == _TRUE_)
      ppw->approx[ppw->index_ap_rsa_idr]=(int)rsa_idr_off;
    if (pba->has_idr == _TRUE_)
      ppw->approx[ppw->index_ap_tca_idm_dr]=(int)tca_idm_dr_off;
    if (pth->has_idm_dr == _TRUE_)
      ppw->approx[ppw->index_ap_tca_idm_dr]=(int)tca_idm_dr_on;

    if (pba->has_ur == _TRUE_) {
      ppw->approx[ppw->index_ap_ufa]=(int)ufa_off;
    }
    if (pba->has_ncdm == _TRUE_) {
      ppw->approx[ppw->index_ap_ncdmfa]=(int)ncdmfa_off;
    }
  }

  if (_tensors_) {

    ppw->approx[ppw->index_ap_tca]=(int)tca_on;
    ppw->approx[ppw->index_ap_rsa]=(int)rsa_off;
  }

  /** - allocate fields where some of the perturbations are stored */

  if (_scalars_) {

    if ((ppt->has_density_transfers == _TRUE_) || (ppt->has_velocity_transfers == _TRUE_) || (ppt->has_source_delta_m == _TRUE_)) {

      class_alloc(ppw->delta_ncdm,pba->N_ncdm*sizeof(double),ppt->error_message);
      class_alloc(ppw->theta_ncdm,pba->N_ncdm*sizeof(double),ppt->error_message);
      class_alloc(ppw->shear_ncdm,pba->N_ncdm*sizeof(double),ppt->error_message);

    }

  }

  return _SUCCESS_;
}

/**
 * Free the perturbations_workspace structure (with the exception of the
 * perturbations_vector '-->pv' field, which is freed separately in
 * perturbations_vector_free).
 *
 * @param ppt        Input: pointer to the perturbation structure
 * @param index_md Input: index of mode under consideration (scalar/.../tensor)
 * @param ppw        Input: pointer to perturbations_workspace structure to be freed
 * @return the error status
 */

int perturbations_workspace_free (
                                  struct perturbations * ppt,
                                  int index_md,
                                  struct perturbations_workspace * ppw
                                  ) {

  free(ppw->s_l);
  free(ppw->pvecback);
  free(ppw->pvecthermo);
  free(ppw->pvecmetric);
  if (ppw->ap_size > 0)
    free(ppw->approx);

  if (_scalars_) {

    if ((ppt->has_density_transfers == _TRUE_) || (ppt->has_velocity_transfers == _TRUE_) || (ppt->has_source_delta_m == _TRUE_)) {
      free(ppw->delta_ncdm);
      free(ppw->theta_ncdm);
      free(ppw->shear_ncdm);
    }
  }

  return _SUCCESS_;
}

/**
 * Solve the perturbation evolution for a given mode, initial
 * condition and wavenumber, and compute the corresponding source
 * functions.
 *
 * For a given mode, initial condition and wavenumber, this function
 * finds the time ranges over which the perturbations can be described
 * within a given approximation. For each such range, it initializes
 * (or redistributes) perturbations using perturbations_vector_init(), and
 * integrates over time. Whenever a "source sampling time" is passed,
 * the source terms are computed and stored in the source table using
 * perturbations_sources().
 *
 * @param ppr        Input: pointer to precision structure
 * @param pba        Input: pointer to background structure
 * @param pth        Input: pointer to the thermodynamics structure
 * @param ppt        Input/Output: pointer to the perturbation structure (output source functions S(k,tau) written here)
 * @param index_md Input: index of mode under consideration (scalar/.../tensor)
 * @param index_ic   Input: index of initial condition under consideration (ad, iso...)
 * @param index_k    Input: index of wavenumber
 * @param ppw        Input: pointer to perturbations_workspace structure containing index values and workspaces
 * @return the error status
 */

int perturbations_solve(
                        struct precision * ppr,
                        struct background * pba,
                        struct thermodynamics * pth,
                        struct perturbations * ppt,
                        int index_md,
                        int index_ic,
                        int index_k,
                        struct perturbations_workspace * ppw
                        ) {

  /** Summary: */

  /** - define local variables */

  /* contains all fixed parameters, indices and workspaces used by the perturbations_derivs function */
  struct perturbations_parameters_and_workspace ppaw;

  /* conformal time */
  double tau,tau_lower,tau_upper,tau_mid;

  /* multipole */
  int l;

  /* index running over time */
  int index_tau;

  /* number of values in the tau_sampling array that should be considered for a given mode */
  int tau_actual_size;

  /* running index over types (temperature, etc) */
  int index_tp;

  /* Fourier mode */
  double k;

  /* number of time intervals where the approximation scheme is uniform */
  int interval_number;

  /* index running over such time intervals */
  int index_interval;

  /* number of time intervals where each particular approximation is uniform */
  int * interval_number_of;

  /* edge of intervals where approximation scheme is uniform: tau_ini, tau_switch_1, ..., tau_end */
  double * interval_limit;

  /* array of approximation scheme within each interval: interval_approx[index_interval][index_ap] */
  int ** interval_approx;

  /* index running over approximations */
  int index_ap;

  /* approximation scheme within previous interval: previous_approx[index_ap] */
  int * previous_approx;

  int n_ncdm,is_early_enough;

  /* function pointer to ODE evolver and names of possible evolvers */


  auto generic_evolver = &(evolver_ndf15);


  /* Related to the perturbation output */
  int (*perhaps_print_variables)(double, double*, double*, void*, char*);
  int index_ikout;

  /** - initialize indices relevant for back/thermo tables search */
  ppw->last_index_back=0;
  ppw->last_index_thermo=0;
  ppw->inter_mode = inter_normal;

  /** - get wavenumber value */
  k = ppt->k[index_md][index_k];

  class_test(k == 0.,
             ppt->error_message,
             "stop to avoid division by zero");

  /** - If non-zero curvature, update array of free-streaming coefficients ppw->s_l */
  if (pba->has_curvature == _TRUE_){
    for (l = 0; l<=ppw->max_l_max; l++){
      ppw->s_l[l] = sqrt(MAX(1.0-pba->K*(l*l-1.0)/k/k,0.));
    }
  }

  /** - maximum value of tau for which sources are calculated for this wavenumber */

  /* by default, today */
  tau_actual_size = ppt->tau_size;

  /** - using bisection, compute minimum value of tau for which this
      wavenumber is integrated */

  /* will be at least the first time in the background table */
  tau_lower = pba->tau_table[0];

  class_call(background_at_tau(pba,
                               tau_lower,
                               normal_info,
                               inter_normal,
                               &(ppw->last_index_back),
                               ppw->pvecback),
             pba->error_message,
             ppt->error_message);

  class_call(thermodynamics_at_z(pba,
                                 pth,
                                 1./ppw->pvecback[pba->index_bg_a]-1.,
                                 inter_normal,
                                 &(ppw->last_index_thermo),
                                 ppw->pvecback,
                                 ppw->pvecthermo),
             pth->error_message,
             ppt->error_message);

  /* check that this initial time is indeed OK given imposed
     conditions on kappa' and on k/aH */

  class_test(ppw->pvecback[pba->index_bg_a]*
             ppw->pvecback[pba->index_bg_H]/
             ppw->pvecthermo[pth->index_th_dkappa] >
             ppr->start_small_k_at_tau_c_over_tau_h, ppt->error_message, "your choice of initial time for integrating wavenumbers is inappropriate: it corresponds to a time before that at which the background has been integrated. You should increase 'start_small_k_at_tau_c_over_tau_h' up to at least %g, or decrease 'a_ini_over_a_today_default'\n",
             ppw->pvecback[pba->index_bg_a]*
             ppw->pvecback[pba->index_bg_H]/
             ppw->pvecthermo[pth->index_th_dkappa]);

  class_test(k/ppw->pvecback[pba->index_bg_a]/ppw->pvecback[pba->index_bg_H] >
             ppr->start_large_k_at_tau_h_over_tau_k,
             ppt->error_message,
             "your choice of initial time for integrating wavenumbers is inappropriate: it corresponds to a time before that at which the background has been integrated. You should increase 'start_large_k_at_tau_h_over_tau_k' up to at least %g, or decrease 'a_ini_over_a_today_default'\n",
             ppt->k[index_md][ppt->k_size[index_md]-1]/ppw->pvecback[pba->index_bg_a]/ ppw->pvecback[pba->index_bg_H]);

  if (pba->has_ncdm == _TRUE_) {
    for (n_ncdm=0; n_ncdm < pba->N_ncdm; n_ncdm++) {
      class_test(fabs(ppw->pvecback[pba->index_bg_p_ncdm1+n_ncdm]/ppw->pvecback[pba->index_bg_rho_ncdm1+n_ncdm]-1./3.)>ppr->tol_ncdm_initial_w,
                 ppt->error_message,
                 "your choice of initial time for integrating wavenumbers is inappropriate: it corresponds to a time at which the ncdm species number %d is not ultra-relativistic anymore, with w=%g, p=%g and rho=%g\n",
                 n_ncdm,
                 ppw->pvecback[pba->index_bg_p_ncdm1+n_ncdm]/ppw->pvecback[pba->index_bg_rho_ncdm1+n_ncdm],
                 ppw->pvecback[pba->index_bg_p_ncdm1+n_ncdm],
                 ppw->pvecback[pba->index_bg_rho_ncdm1+n_ncdm]);
    }
  }

  /* is at most the time at which sources must be sampled */
  tau_upper = ppt->tau_sampling[0];

  /* start bisection */
  tau_mid = 0.5*(tau_lower + tau_upper);

  while ((tau_upper - tau_lower)/tau_lower > ppr->tol_tau_approx) {

    is_early_enough = _TRUE_;

    class_call(background_at_tau(pba,
                                 tau_mid,
                                 normal_info,
                                 inter_normal,
                                 &(ppw->last_index_back),
                                 ppw->pvecback),
               pba->error_message,
               ppt->error_message);

    /* if there are non-cold relics, check that they are relativistic enough */
    if (pba->has_ncdm == _TRUE_) {
      for (n_ncdm=0; n_ncdm < pba->N_ncdm; n_ncdm++) {
        if (fabs(ppw->pvecback[pba->index_bg_p_ncdm1+n_ncdm]/ppw->pvecback[pba->index_bg_rho_ncdm1+n_ncdm]-1./3.) > ppr->tol_ncdm_initial_w)
          is_early_enough = _FALSE_;
      }
    }

    /* also check that the two conditions on (aH/kappa') and (aH/k) are fulfilled */
    if (is_early_enough == _TRUE_) {

      class_call(thermodynamics_at_z(pba,
                                     pth,
                                     1./ppw->pvecback[pba->index_bg_a]-1.,  /* redshift z=1/a-1 */
                                     inter_normal,
                                     &(ppw->last_index_thermo),
                                     ppw->pvecback,
                                     ppw->pvecthermo),
                 pth->error_message,
                 ppt->error_message);

      if ((ppw->pvecback[pba->index_bg_a]*
           ppw->pvecback[pba->index_bg_H]/
           ppw->pvecthermo[pth->index_th_dkappa] >
           ppr->start_small_k_at_tau_c_over_tau_h) ||
          (k/ppw->pvecback[pba->index_bg_a]/ppw->pvecback[pba->index_bg_H] >
           ppr->start_large_k_at_tau_h_over_tau_k))

        is_early_enough = _FALSE_;
    }

    if (is_early_enough == _TRUE_)
      tau_lower = tau_mid;
    else
      tau_upper = tau_mid;

    tau_mid = 0.5*(tau_lower + tau_upper);

  }

  tau = tau_mid;

  /** - find the number of intervals over which approximation scheme is constant */

  class_alloc(interval_number_of,ppw->ap_size*sizeof(int),ppt->error_message);

  ppw->inter_mode = inter_normal;

  class_call(perturbations_find_approximation_number(ppr,
                                                     pba,
                                                     pth,
                                                     ppt,
                                                     index_md,
                                                     k,
                                                     ppw,
                                                     tau,
                                                     ppt->tau_sampling[tau_actual_size-1],
                                                     &interval_number,
                                                     interval_number_of),
             ppt->error_message,
             ppt->error_message);

  class_alloc(interval_limit,(interval_number+1)*sizeof(double),ppt->error_message);

  class_alloc(interval_approx,interval_number*sizeof(int*),ppt->error_message);

  for (index_interval=0; index_interval<interval_number; index_interval++)
    class_alloc(interval_approx[index_interval],ppw->ap_size*sizeof(int),ppt->error_message);

  class_call(perturbations_find_approximation_switches(ppr,
                                                       pba,
                                                       pth,
                                                       ppt,
                                                       index_md,
                                                       k,
                                                       ppw,
                                                       tau,
                                                       ppt->tau_sampling[tau_actual_size-1],
                                                       ppr->tol_tau_approx,
                                                       interval_number,
                                                       interval_number_of,
                                                       interval_limit,
                                                       interval_approx),
             ppt->error_message,
             ppt->error_message);

  free(interval_number_of);

  /** - fill the structure containing all fixed parameters, indices
      and workspaces needed by perturbations_derivs */

  ppaw.ppr = ppr;
  ppaw.pba = pba;
  ppaw.pth = pth;
  ppaw.ppt = ppt;
  ppaw.index_md = index_md;
  ppaw.index_ic = index_ic;
  ppaw.index_k = index_k;
  ppaw.k = k;
  ppaw.ppw = ppw;
  ppaw.ppw->inter_mode = inter_closeby;
  ppaw.ppw->last_index_back = 0;
  ppaw.ppw->last_index_thermo = 0;

  /** - check whether we need to print perturbations to a file for this wavenumber */

  perhaps_print_variables = NULL;
  ppw->index_ikout = -1;
  for (index_ikout=0; index_ikout<ppt->k_output_values_num; index_ikout++){
    if (ppt->index_k_output_values[index_md*ppt->k_output_values_num+index_ikout] == index_k){
      ppw->index_ikout = index_ikout;
      perhaps_print_variables = perturbations_print_variables;
    }
  }

  /** - loop over intervals over which approximation scheme is uniform. For each interval: */

  for (index_interval=0; index_interval<interval_number; index_interval++) {

    /** - --> (a) fix the approximation scheme */

    for (index_ap=0; index_ap<ppw->ap_size; index_ap++)
      ppw->approx[index_ap]=interval_approx[index_interval][index_ap];

    /** - --> (b) get the previous approximation scheme. If the current
        interval starts from the initial time tau_ini, the previous
        approximation is set to be a NULL pointer, so that the
        function perturbations_vector_init() knows that perturbations must
        be initialized */

    if (index_interval==0) {
      previous_approx=NULL;
    }
    else {
      previous_approx=interval_approx[index_interval-1];
    }

    /** - --> (c) define the vector of perturbations to be integrated
        over. If the current interval starts from the initial time
        tau_ini, fill the vector with initial conditions for each
        mode. If it starts from an approximation switching point,
        redistribute correctly the perturbations from the previous to
        the new vector of perturbations. */

    class_call(perturbations_vector_init(ppr,
                                         pba,
                                         pth,
                                         ppt,
                                         index_md,
                                         index_ic,
                                         k,
                                         interval_limit[index_interval],
                                         ppw,
                                         previous_approx),
               ppt->error_message,
               ppt->error_message);

    /** - --> (d) integrate the perturbations over the current interval. */

    if (ppr->evolver == rk){
      generic_evolver = evolver_rk;
    }
    else {
      generic_evolver = evolver_ndf15;
    }

    class_call(generic_evolver(perturbations_derivs,
                               interval_limit[index_interval],
                               interval_limit[index_interval+1],
                               ppw->pv->y,
                               ppw->pv->used_in_sources,
                               ppw->pv->pt_size,
                               &ppaw,
                               ppr->tol_perturbations_integration,
                               ppr->smallest_allowed_variation,
                               perturbations_timescale,
                               ppr->perturbations_integration_stepsize,
                               ppt->tau_sampling,
                               tau_actual_size,
                               perturbations_sources,
                               perhaps_print_variables,
                               ppt->error_message),
               ppt->error_message,
               ppt->error_message);

  }

  /** - if perturbations were printed in a file, close the file */

  //if (perhaps_print_variables != NULL)
  //  fclose(ppw->perturbations_output_file);

  /** - fill the source terms array with zeros for all times between
      the last integrated time tau_max and tau_today. */

  for (index_tau = tau_actual_size; index_tau < ppt->tau_size; index_tau++) {
    for (index_tp = 0; index_tp < ppt->tp_size[index_md]; index_tp++) {
      ppt->sources[index_md]
        [index_ic * ppt->tp_size[index_md] + index_tp]
        [index_tau * ppt->k_size[index_md] + index_k] = 0.;
    }
  }

  /** - free quantities allocated at the beginning of the routine */

  class_call(perturbations_vector_free(ppw->pv),
             ppt->error_message,
             ppt->error_message);

  for (index_interval=0; index_interval<interval_number; index_interval++)
    free(interval_approx[index_interval]);

  free(interval_approx);

  free(interval_limit);

  return _SUCCESS_;
}

/**
 * Fill array of strings with the name of the 'k_output_values'
 * functions (transfer functions as a function of time, for fixed
 * values of k).
 *
 * @param pba  Input: pointer to the background structure
 * @param ppt  Input/Output: pointer to the perturbation structure
 * @return the error status
 */

int perturbations_prepare_k_output(struct background * pba,
                                   struct perturbations * ppt
                                   ){
  int n_ncdm;
  char tmp[40];

  ppt->scalar_titles[0]='\0';
  ppt->vector_titles[0]='\0';
  ppt->tensor_titles[0]='\0';


  if (ppt->k_output_values_num > 0) {

    /** Write titles for all perturbations that we would like to print/store. */
    if (ppt->has_scalars == _TRUE_){

      class_store_columntitle(ppt->scalar_titles,"tau [Mpc]",_TRUE_);
      class_store_columntitle(ppt->scalar_titles,"a",_TRUE_);
      class_store_columntitle(ppt->scalar_titles,"delta_g",_TRUE_);
      class_store_columntitle(ppt->scalar_titles,"theta_g",_TRUE_);
      class_store_columntitle(ppt->scalar_titles,"shear_g",_TRUE_);
      /* Higher photon temperature multipoles Fr3, Fr4, ..., Fr{l_max_g} */
      if (ppt->l_max_g > 2) {
        int l;
        char multipole_title[20];
        for (l = 3; l <= ppt->l_max_g; l++) {
          sprintf(multipole_title, "Fr%d_g", l);
          class_store_columntitle(ppt->scalar_titles, multipole_title, _TRUE_);
        }
      }
      class_store_columntitle(ppt->scalar_titles,"pol0_g",_TRUE_);
      class_store_columntitle(ppt->scalar_titles,"pol1_g",_TRUE_);
      class_store_columntitle(ppt->scalar_titles,"pol2_g",_TRUE_);
      class_store_columntitle(ppt->scalar_titles,"delta_b",_TRUE_);
      class_store_columntitle(ppt->scalar_titles,"theta_b",_TRUE_);
      class_store_columntitle(ppt->scalar_titles,"psi",_TRUE_);
      class_store_columntitle(ppt->scalar_titles,"phi",_TRUE_);
      /* Perturbed recombination */
      class_store_columntitle(ppt->scalar_titles,"delta_Tb",ppt->has_perturbed_recombination);
      class_store_columntitle(ppt->scalar_titles,"delta_chi",ppt->has_perturbed_recombination);
      /* Ultrarelativistic species */
      class_store_columntitle(ppt->scalar_titles,"delta_ur",pba->has_ur);
      class_store_columntitle(ppt->scalar_titles,"theta_ur",pba->has_ur);
      class_store_columntitle(ppt->scalar_titles,"shear_ur",pba->has_ur);
      /* Interacting dark radiation */
      class_store_columntitle(ppt->scalar_titles,"delta_idr",pba->has_idr);
      class_store_columntitle(ppt->scalar_titles,"theta_idr",pba->has_idr);
      if ((pba->has_idr == _TRUE_)&&(ppt->idr_nature == idr_free_streaming))
        class_store_columntitle(ppt->scalar_titles,"shear_idr",_TRUE_);
      /* Cold dark matter */
      class_store_columntitle(ppt->scalar_titles,"delta_cdm",pba->has_cdm);
      class_store_columntitle(ppt->scalar_titles,"theta_cdm",pba->has_cdm);
      /* Interacting dark matter */
      class_store_columntitle(ppt->scalar_titles,"delta_idm",pba->has_idm);
      class_store_columntitle(ppt->scalar_titles,"theta_idm",pba->has_idm);
      /* Non-cold dark matter */
      if ((pba->has_ncdm == _TRUE_) && ((ppt->has_density_transfers == _TRUE_) || (ppt->has_velocity_transfers == _TRUE_) || (ppt->has_source_delta_m == _TRUE_))) {
        for (n_ncdm=0; n_ncdm < pba->N_ncdm; n_ncdm++){
          class_sprintf(tmp,"delta_ncdm[%d]",n_ncdm);
          class_store_columntitle(ppt->scalar_titles,tmp,_TRUE_);
          class_sprintf(tmp,"theta_ncdm[%d]",n_ncdm);
          class_store_columntitle(ppt->scalar_titles,tmp,_TRUE_);
          class_sprintf(tmp,"shear_ncdm[%d]",n_ncdm);
          class_store_columntitle(ppt->scalar_titles,tmp,_TRUE_);
          class_sprintf(tmp,"cs2_ncdm[%d]",n_ncdm);
          class_store_columntitle(ppt->scalar_titles,tmp,_TRUE_);
        }
      }
      /* Decaying cold dark matter */
      class_store_columntitle(ppt->scalar_titles, "delta_dcdm", pba->has_dcdm);
      class_store_columntitle(ppt->scalar_titles, "theta_dcdm", pba->has_dcdm);
      /* Decay radiation */
      class_store_columntitle(ppt->scalar_titles, "delta_dr", pba->has_dr);
      class_store_columntitle(ppt->scalar_titles, "theta_dr", pba->has_dr);
      class_store_columntitle(ppt->scalar_titles, "shear_dr", pba->has_dr);
      /* Scalar field scf */
      class_store_columntitle(ppt->scalar_titles, "delta_scf", pba->has_scf);
      class_store_columntitle(ppt->scalar_titles, "theta_scf", pba->has_scf);
      /** Fluid */
      class_store_columntitle(ppt->scalar_titles, "delta_rho_fld", pba->has_fld);
      class_store_columntitle(ppt->scalar_titles, "rho_plus_p_theta_fld", pba->has_fld);
      class_store_columntitle(ppt->scalar_titles, "delta_p_fld", pba->has_fld);

      ppt->number_of_scalar_titles =
        get_number_of_titles(ppt->scalar_titles);
    }

    if (ppt->has_tensors == _TRUE_){

      class_store_columntitle(ppt->tensor_titles,"tau [Mpc]",_TRUE_);
      class_store_columntitle(ppt->tensor_titles,"a",_TRUE_);
      class_store_columntitle(ppt->tensor_titles,"delta_g",_TRUE_);
      class_store_columntitle(ppt->tensor_titles,"shear_g",_TRUE_);
      class_store_columntitle(ppt->tensor_titles,"l4_g",_TRUE_);
      class_store_columntitle(ppt->tensor_titles,"pol0_g",_TRUE_);
      class_store_columntitle(ppt->tensor_titles,"pol2_g",_TRUE_);
      class_store_columntitle(ppt->tensor_titles,"pol4_g",_TRUE_);
      class_store_columntitle(ppt->tensor_titles,"H (gw)",_TRUE_);
      class_store_columntitle(ppt->tensor_titles,"Hdot (gwdot)",_TRUE_);

      class_store_columntitle(ppt->tensor_titles,"delta_ur",ppt->evolve_tensor_ur);
      class_store_columntitle(ppt->tensor_titles,"shear_ur",ppt->evolve_tensor_ur);
      class_store_columntitle(ppt->tensor_titles,"l4_ur",ppt->evolve_tensor_ur);

      if (ppt->evolve_tensor_ncdm == _TRUE_) {
        for (n_ncdm=0; n_ncdm < pba->N_ncdm; n_ncdm++){
          class_sprintf(tmp,"delta_ncdm[%d]",n_ncdm);
          class_store_columntitle(ppt->tensor_titles,tmp,_TRUE_);
          class_sprintf(tmp,"theta_ncdm[%d]",n_ncdm);
          class_store_columntitle(ppt->tensor_titles,tmp,_TRUE_);
          class_sprintf(tmp,"shear_ncdm[%d]",n_ncdm);
          class_store_columntitle(ppt->tensor_titles,tmp,_TRUE_);
        }
      }

      ppt->number_of_tensor_titles =
        get_number_of_titles(ppt->tensor_titles);

    }

  }
  return _SUCCESS_;

}

/**
 * For a given mode and wavenumber, find the number of intervals of
 * time between tau_ini and tau_end such that the approximation
 * scheme (and the number of perturbation equations) is uniform.
 *
 * @param ppr                Input: pointer to precision structure
 * @param pba                Input: pointer to background structure
 * @param pth                Input: pointer to the thermodynamics structure
 * @param ppt                Input: pointer to the perturbation structure
 * @param index_md           Input: index of mode under consideration (scalar/.../tensor)
 * @param k                  Input: index of wavenumber
 * @param ppw                Input: pointer to perturbations_workspace structure containing index values and workspaces
 * @param tau_ini            Input: initial time of the perturbation integration
 * @param tau_end            Input: final time of the perturbation integration
 * @param interval_number    Output: total number of intervals
 * @param interval_number_of Output: number of intervals with respect to each particular approximation
 * @return the error status
 */

int perturbations_find_approximation_number(
                                            struct precision * ppr,
                                            struct background * pba,
                                            struct thermodynamics * pth,
                                            struct perturbations * ppt,
                                            int index_md,
                                            double k,
                                            struct perturbations_workspace * ppw,
                                            double tau_ini,
                                            double tau_end,
                                            int * interval_number,
                                            int * interval_number_of /* interval_number_of[index_ap] (already allocated) */
                                            ){

  /** Summary: */
  /* index running over approximations */
  int index_ap;

  /* value of a given approximation at tau_ini and tau_end */
  int flag_ini,flag_end;

  /** - fix default number of intervals to one (if no approximation switch) */

  *interval_number=1;

  /** - loop over each approximation and add the number of approximation switching times */

  for (index_ap=0; index_ap<ppw->ap_size; index_ap++) {

    class_call(perturbations_approximations(ppr,
                                            pba,
                                            pth,
                                            ppt,
                                            index_md,
                                            k,
                                            tau_ini,
                                            ppw),
               ppt->error_message,
               ppt->error_message);

    flag_ini = ppw->approx[index_ap];

    class_call(perturbations_approximations(ppr,
                                            pba,
                                            pth,
                                            ppt,
                                            index_md,
                                            k,
                                            tau_end,
                                            ppw),
               ppt->error_message,
               ppt->error_message);

    flag_end = ppw->approx[index_ap];

    class_test(flag_end<flag_ini,
               ppt->error_message,
               "For each approximation scheme, the declaration of approximation labels in the enumeration must follow chronological order, e.g: enum approx_flags {flag1, flag2, flag3} with flag1 being the initial one and flag3 the final one");

    *interval_number += flag_end-flag_ini;

    interval_number_of[index_ap] = flag_end-flag_ini+1;
  }

  return _SUCCESS_;

}

/**
 * For a given mode and wavenumber, find the values of time at which
 * the approximation changes.
 *
 * @param ppr                Input: pointer to precision structure
 * @param pba                Input: pointer to background structure
 * @param pth                Input: pointer to the thermodynamics structure
 * @param ppt                Input: pointer to the perturbation structure
 * @param index_md           Input: index of mode under consideration (scalar/.../tensor)
 * @param k                  Input: index of wavenumber
 * @param ppw                Input: pointer to perturbations_workspace structure containing index values and workspaces
 * @param tau_ini            Input: initial time of the perturbation integration
 * @param tau_end            Input: final time of the perturbation integration
 * @param precision          Input: tolerance on output values
 * @param interval_number    Input: total number of intervals
 * @param interval_number_of Input: number of intervals with respect to each particular approximation
 * @param interval_limit     Output: value of time at the boundary of the intervals: tau_ini, tau_switch1, ..., tau_end
 * @param interval_approx    Output: value of approximations in each interval
 * @return the error status
 */

int perturbations_find_approximation_switches(
                                              struct precision * ppr,
                                              struct background * pba,
                                              struct thermodynamics * pth,
                                              struct perturbations * ppt,
                                              int index_md,
                                              double k,
                                              struct perturbations_workspace * ppw,
                                              double tau_ini,
                                              double tau_end,
                                              double precision,
                                              int interval_number,
                                              int * interval_number_of,
                                              double * interval_limit, /* interval_limit[index_interval] (already allocated) */
                                              int ** interval_approx   /* interval_approx[index_interval][index_ap] (already allocated) */
                                              ){

  /** Summary: */

  int index_ap;
  int index_switch;
  int index_switch_tot;
  int num_switch;
  double tau_min,lower_bound,upper_bound;
  double mid=0;
  double * unsorted_tau_switch;
  double next_tau_switch;
  int flag_ini;
  int num_switching_at_given_time;

  /** - write in output arrays the initial time and approximation */

  interval_limit[0]=tau_ini;

  class_call(perturbations_approximations(ppr,
                                          pba,
                                          pth,
                                          ppt,
                                          index_md,
                                          k,
                                          tau_ini,
                                          ppw),
             ppt->error_message,
             ppt->error_message);

  for (index_ap=0; index_ap<ppw->ap_size; index_ap++)
    interval_approx[0][index_ap]=ppw->approx[index_ap];

  /** - if there are no approximation switches, just write final time and return */

  if (interval_number == 1) {

    interval_limit[1]=tau_end;

  }

  /** - if there are switches, consider approximations one after each
      other.  Find switching time by bisection. Store all switches in
      arbitrary order in array unsorted_tau_switch[ ] */

  else {

    class_alloc(unsorted_tau_switch,(interval_number-1)*sizeof(double),ppt->error_message);

    index_switch_tot=0;

    for (index_ap=0; index_ap<ppw->ap_size; index_ap++) {

      if (interval_number_of[index_ap] > 1) {

        num_switch = interval_number_of[index_ap]-1;

        tau_min = tau_ini;

        flag_ini = interval_approx[0][index_ap];

        for (index_switch=0; index_switch<num_switch; index_switch++) {

          lower_bound=tau_min;
          upper_bound=tau_end;
          mid = 0.5*(lower_bound+upper_bound);

          while (upper_bound - lower_bound > precision) {

            class_call(perturbations_approximations(ppr,
                                                    pba,
                                                    pth,
                                                    ppt,
                                                    index_md,
                                                    k,
                                                    mid,
                                                    ppw),
                       ppt->error_message,
                       ppt->error_message);

            if (ppw->approx[index_ap] > flag_ini+index_switch) {
              upper_bound=mid;
            }
            else {
              lower_bound=mid;
            }

            mid = 0.5*(lower_bound+upper_bound);

          }

          unsorted_tau_switch[index_switch_tot]=mid;
          index_switch_tot++;

          tau_min=mid;

        }
      }
    }

    class_test(index_switch_tot != (interval_number-1),
               ppt->error_message,
               "bug in approximation switch search routine: should have %d = %d",
               index_switch_tot,interval_number-1);

    /** - now sort interval limits in correct order */

    index_switch_tot=1;

    while (index_switch_tot < interval_number) {

      next_tau_switch=tau_end;
      for (index_switch=0; index_switch<interval_number-1; index_switch++) {
        if ((unsorted_tau_switch[index_switch] > interval_limit[index_switch_tot-1]) &&
            (unsorted_tau_switch[index_switch] < next_tau_switch)) {
          next_tau_switch=unsorted_tau_switch[index_switch];
        }
      }
      interval_limit[index_switch_tot]=next_tau_switch;
      index_switch_tot++;
    }

    interval_limit[index_switch_tot]=tau_end;

    class_test(index_switch_tot != interval_number,
               ppt->error_message,
               "most probably two approximation switching time were found to be equal, which cannot be handled\n");

    /** - store each approximation in chronological order */

    for (index_switch=1; index_switch<interval_number; index_switch++) {

      class_call(perturbations_approximations(ppr,
                                              pba,
                                              pth,
                                              ppt,
                                              index_md,
                                              k,
                                              0.5*(interval_limit[index_switch]+interval_limit[index_switch+1]),
                                              ppw),

                 ppt->error_message,
                 ppt->error_message);

      for (index_ap=0; index_ap<ppw->ap_size; index_ap++) {
        interval_approx[index_switch][index_ap]=ppw->approx[index_ap];

        /* check here that approximation does not go backward (remember
           that by definition the value of an approximation can only
           increase) */
        class_test(interval_approx[index_switch][index_ap] < interval_approx[index_switch-1][index_ap],
                   ppt->error_message,
                   "The approximation with label %d is not defined correctly: it goes backward (from %d to %d) for k=%e and between tau=%e and %e; this cannot be handled\n",
                   index_ap,
                   interval_approx[index_switch-1][index_ap],
                   interval_approx[index_switch][index_ap],
                   k,
                   0.5*(interval_limit[index_switch-1]+interval_limit[index_switch]),
                   0.5*(interval_limit[index_switch]+interval_limit[index_switch+1])
                   );
      }

      /* check here that more than one approximation is not switched on at a given time */
      num_switching_at_given_time=0;
      for (index_ap=0; index_ap<ppw->ap_size; index_ap++) {
        if (interval_approx[index_switch][index_ap] != interval_approx[index_switch-1][index_ap])
          num_switching_at_given_time++;
      }
      class_test(num_switching_at_given_time != 1,
                 ppt->error_message,
                 "for k=%e, at tau=%g, you switch %d approximations at the same time, this cannot be handled. Usually happens in two cases: triggers for different approximations coincide, or one approx is reversible\n",
                 k,
                 interval_limit[index_switch],
                 num_switching_at_given_time);

      if (ppt->perturbations_verbose>2) {

        if (_scalars_) {

          if ((interval_approx[index_switch-1][ppw->index_ap_tca]==(int)tca_on) &&
              (interval_approx[index_switch][ppw->index_ap_tca]==(int)tca_off))
            fprintf(stdout,"Mode k=%e: will switch off tight-coupling approximation at tau=%e\n",k,interval_limit[index_switch]);
          //fprintf(stderr,"Mode k=%e: will switch off tight-coupling approximation at tau=%e\n",k,interval_limit[index_switch]);  //TBC

          if ((interval_approx[index_switch-1][ppw->index_ap_rsa]==(int)rsa_off) &&
              (interval_approx[index_switch][ppw->index_ap_rsa]==(int)rsa_on))
            fprintf(stdout,"Mode k=%e: will switch on radiation streaming approximation at tau=%e\n",k,interval_limit[index_switch]);

          if (pba->has_idr == _TRUE_){
            if ((interval_approx[index_switch-1][ppw->index_ap_rsa_idr]==(int)rsa_idr_off) &&
                (interval_approx[index_switch][ppw->index_ap_rsa_idr]==(int)rsa_idr_on))
              fprintf(stdout,"Mode k=%e: will switch on dark radiation streaming approximation at tau=%e\n",k,interval_limit[index_switch]);
          }

          if (pth->has_idm_dr == _TRUE_){
            if ((interval_approx[index_switch-1][ppw->index_ap_tca_idm_dr]==(int)tca_idm_dr_on) &&
                (interval_approx[index_switch][ppw->index_ap_tca_idm_dr]==(int)tca_idm_dr_off))
              fprintf(stdout,"Mode k=%e: will switch off dark tight-coupling approximation at tau=%e\n",k,interval_limit[index_switch]);
          }

          if (pba->has_ur == _TRUE_) {
            if ((interval_approx[index_switch-1][ppw->index_ap_ufa]==(int)ufa_off) &&
                (interval_approx[index_switch][ppw->index_ap_ufa]==(int)ufa_on)) {
              fprintf(stdout,"Mode k=%e: will switch on ur fluid approximation at tau=%e\n",k,interval_limit[index_switch]);
            }
          }
          if (pba->has_ncdm == _TRUE_) {
            if ((interval_approx[index_switch-1][ppw->index_ap_ncdmfa]==(int)ncdmfa_off) &&
                (interval_approx[index_switch][ppw->index_ap_ncdmfa]==(int)ncdmfa_on)) {
              fprintf(stdout,"Mode k=%e: will switch on ncdm fluid approximation at tau=%e\n",k,interval_limit[index_switch]);
            }
          }
        }

        if (_tensors_) {

          if ((interval_approx[index_switch-1][ppw->index_ap_tca]==(int)tca_on) &&
              (interval_approx[index_switch][ppw->index_ap_tca]==(int)tca_off))
            fprintf(stdout,"Mode k=%e: will switch off tight-coupling approximation for tensors at tau=%e\n",k,interval_limit[index_switch]);

          if ((interval_approx[index_switch-1][ppw->index_ap_rsa]==(int)rsa_off) &&
              (interval_approx[index_switch][ppw->index_ap_rsa]==(int)rsa_on))
            fprintf(stdout,"Mode k=%e: will switch on radiation streaming approximation for tensors at tau=%e\n",k,interval_limit[index_switch]);

        }
      }
    }

    free(unsorted_tau_switch);

    class_call(perturbations_approximations(ppr,
                                            pba,
                                            pth,
                                            ppt,
                                            index_md,
                                            k,
                                            tau_end,
                                            ppw),

               ppt->error_message,
               ppt->error_message);
  }

  return _SUCCESS_;
}

/**
 * Initialize the field '-->pv' of a perturbations_workspace structure, which
 * is a perturbations_vector structure. This structure contains indices and
 * values of all quantities which need to be integrated with respect
 * to time (and only them: quantities fixed analytically or obeying
 * constraint equations are NOT included in this vector). This routine
 * distinguishes between two cases:
 *
 * --> the input pa_old is set to the NULL pointer:
 *
 * This happens when we start integrating over a new wavenumber and we
 * want to set initial conditions for the perturbations. Then, it is
 * assumed that ppw-->pv is not yet allocated. This routine allocates
 * it, defines all indices, and then fills the vector ppw-->pv-->y with
 * the initial conditions defined in perturbations_initial_conditions.
 *
 * --> the input pa_old is not set to the NULL pointer and describes
 * some set of approximations:
 *
 * This happens when we need to change approximation scheme while
 * integrating over a given wavenumber. The new approximation
 * described by ppw-->pa is then different from pa_old. Then, this
 * routine allocates a new vector with a new size and new index
 * values; it fills this vector with initial conditions taken from the
 * previous vector passed as an input in ppw-->pv, and eventually with
 * some analytic approximations for the new variables appearing at
 * this time; then the new vector comes in replacement of the old one,
 * which is freed.
 *
 * @param ppr        Input: pointer to precision structure
 * @param pba        Input: pointer to background structure
 * @param pth        Input: pointer to the thermodynamics structure
 * @param ppt        Input: pointer to the perturbation structure
 * @param index_md Input: index of mode under consideration (scalar/.../tensor)
 * @param index_ic   Input: index of initial condition under consideration (ad, iso...)
 * @param k          Input: wavenumber
 * @param tau        Input: conformal time
 * @param ppw        Input/Output: workspace containing in input the approximation scheme, the background/thermodynamics/metric quantities, and eventually the previous vector y; and in output the new vector y.
 * @param pa_old     Input: NULL is we need to set y to initial conditions for a new wavenumber; points towards a perturbations_approximations if we want to switch of approximation.
 * @return the error status
 */

int perturbations_vector_init(
                              struct precision * ppr,
                              struct background * pba,
                              struct thermodynamics * pth,
                              struct perturbations * ppt,
                              int index_md,
                              int index_ic,
                              double k,
                              double tau,
                              struct perturbations_workspace * ppw, /* ppw->pv unallocated if pa_old = NULL, allocated and filled otherwise */
                              int * pa_old
                              ) {

  /** Summary: */

  /** - define local variables */

  struct perturbations_vector * ppv;

  int index_pt;
  int l;
  int n_ncdm,index_q,ncdm_l_size;
  double rho_plus_p_ncdm,q,q2,epsilon,a,factor;

  /** - allocate a new perturbations_vector structure to which ppw-->pv will point at the end of the routine */

  class_alloc(ppv,sizeof(struct perturbations_vector),ppt->error_message);

  /** - initialize pointers to NULL (they will be allocated later if
      needed), relevant for perturbations_vector_free() */
  ppv->l_max_ncdm = NULL;
  ppv->q_size_ncdm = NULL;

  /** - define all indices in this new vector (depends on approximation scheme, described by the input structure ppw-->pa) */

  index_pt = 0;

  if (_scalars_) {

    /* reject inconsistent values of the number of mutipoles in photon temperature hierarchy */
    class_test(ppr->l_max_g < 4,
               ppt->error_message,
               "ppr->l_max_g should be at least 4, i.e. we must integrate at least over photon density, velocity, shear, third and fourth momentum");

    /* reject inconsistent values of the number of mutipoles in photon polarization hierarchy */
    class_test(ppr->l_max_pol_g < 4,
               ppt->error_message,
               "ppr->l_max_pol_g should be at least 4");

    /* reject inconsistent values of the number of mutipoles in decay radiation hierarchy */
    if (pba->has_dr == _TRUE_) {
      class_test(ppr->l_max_dr < 4,
                 ppt->error_message,
                 "ppr->l_max_dr should be at least 4, i.e. we must integrate at least over neutrino/relic density, velocity, shear, third and fourth momentum");
    }

    /* reject inconsistent values of the number of mutipoles in ultra relativistic neutrino hierarchy */
    if (pba->has_ur == _TRUE_) {
      class_test(ppr->l_max_ur < 4,
                 ppt->error_message,
                 "ppr->l_max_ur should be at least 4, i.e. we must integrate at least over neutrino/relic density, velocity, shear, third and fourth momentum");
    }

    if (pba->has_idr == _TRUE_){
      class_test(((ppr->l_max_idr < 4)&&(ppt->idr_nature == idr_free_streaming)),
                 ppt->error_message,
                 "ppr->l_max_idr should be at least 4, i.e. we must integrate at least over interacting dark radiation density, velocity, shear, third and fourth momentum");
    }

    /* photons */

    if (ppw->approx[ppw->index_ap_rsa] == (int)rsa_off) { /* if radiation streaming approximation is off */

      /* temperature */

      ppv->l_max_g = ppr->l_max_g;

      class_define_index(ppv->index_pt_delta_g,_TRUE_,index_pt,1); /* photon density */
      class_define_index(ppv->index_pt_theta_g,_TRUE_,index_pt,1); /* photon velocity */

      if (ppw->approx[ppw->index_ap_tca] == (int)tca_off) {

        class_define_index(ppv->index_pt_shear_g,_TRUE_,index_pt,1); /* photon shear */
        class_define_index(ppv->index_pt_l3_g,_TRUE_,index_pt,ppv->l_max_g-2); /* higher momenta */

        /* polarization */

        ppv->l_max_pol_g = ppr->l_max_pol_g;

        class_define_index(ppv->index_pt_pol0_g,_TRUE_,index_pt,1);
        class_define_index(ppv->index_pt_pol1_g,_TRUE_,index_pt,1);
        class_define_index(ppv->index_pt_pol2_g,_TRUE_,index_pt,1);
        class_define_index(ppv->index_pt_pol3_g,_TRUE_,index_pt,ppv->l_max_pol_g-2);
      }
    }

    /* baryons */

    class_define_index(ppv->index_pt_delta_b,_TRUE_,index_pt,1); /* baryon density */
    class_define_index(ppv->index_pt_theta_b,_TRUE_,index_pt,1); /* baryon velocity */

    /* cdm */

    class_define_index(ppv->index_pt_delta_cdm,pba->has_cdm,index_pt,1); /* cdm density */
    class_define_index(ppv->index_pt_theta_cdm,pba->has_cdm && (ppt->gauge == newtonian),index_pt,1); /* cdm velocity */

    /* idm */
    class_define_index(ppv->index_pt_delta_idm,pba->has_idm,index_pt,1); /* idm density */
    class_define_index(ppv->index_pt_theta_idm,pba->has_idm,index_pt,1); /* idm velocity */

    /* dcdm */

    class_define_index(ppv->index_pt_delta_dcdm,pba->has_dcdm,index_pt,1); /* dcdm density */
    class_define_index(ppv->index_pt_theta_dcdm,pba->has_dcdm,index_pt,1); /* dcdm velocity */

    /* ultra relativistic decay radiation */
    if (pba->has_dr==_TRUE_){
      ppv->l_max_dr = ppr->l_max_dr;
      class_define_index(ppv->index_pt_F0_dr,_TRUE_,index_pt,ppv->l_max_dr+1); /* all momenta in Boltzmann hierarchy  */
    }

    /* fluid */

    if (pba->use_ppf == _FALSE_) {
      class_define_index(ppv->index_pt_delta_fld,pba->has_fld,index_pt,1); /* fluid density */
      class_define_index(ppv->index_pt_theta_fld,pba->has_fld,index_pt,1); /* fluid velocity */
    }
    else {
      class_define_index(ppv->index_pt_Gamma_fld,pba->has_fld,index_pt,1); /* Gamma variable of PPF scheme */
    }

    /* scalar field */

    class_define_index(ppv->index_pt_phi_scf,pba->has_scf,index_pt,1); /* scalar field density */
    class_define_index(ppv->index_pt_phi_prime_scf,pba->has_scf,index_pt,1); /* scalar field velocity */

    /* perturbed recombination: the indices are defined once tca is off. */
    if ( (ppt->has_perturbed_recombination == _TRUE_) && (ppw->approx[ppw->index_ap_tca] == (int)tca_off) ){
      class_define_index(ppv->index_pt_perturbed_recombination_delta_temp,_TRUE_,index_pt,1);
      class_define_index(ppv->index_pt_perturbed_recombination_delta_chi,_TRUE_,index_pt,1);
    }

    /* ultra relativistic neutrinos */

    if (pba->has_ur && (ppw->approx[ppw->index_ap_rsa] == (int)rsa_off)) {

      class_define_index(ppv->index_pt_delta_ur,_TRUE_,index_pt,1); /* density of ultra-relativistic neutrinos/relics */
      class_define_index(ppv->index_pt_theta_ur,_TRUE_,index_pt,1); /* velocity of ultra-relativistic neutrinos/relics */
      class_define_index(ppv->index_pt_shear_ur,_TRUE_,index_pt,1); /* shear of ultra-relativistic neutrinos/relics */

      if (ppw->approx[ppw->index_ap_ufa] == (int)ufa_off) {
        ppv->l_max_ur = ppr->l_max_ur;
        class_define_index(ppv->index_pt_l3_ur,_TRUE_,index_pt,ppv->l_max_ur-2); /* additional momenta in Boltzmann hierarchy (beyond l=0,1,2,3) */
      }
    }

    /* interacting dark radiation */

    if (pba->has_idr == _TRUE_){
      if (ppw->approx[ppw->index_ap_rsa_idr]==(int)rsa_idr_off) {
        class_define_index(ppv->index_pt_delta_idr,_TRUE_,index_pt,1); /* density of interacting dark radiation */
        class_define_index(ppv->index_pt_theta_idr,_TRUE_,index_pt,1); /* velocity of interacting dark radiation */
        if (ppt->idr_nature == idr_free_streaming){
          if (ppw->approx[ppw->index_ap_tca_idm_dr] == (int)tca_idm_dr_off){
            class_define_index(ppv->index_pt_shear_idr,_TRUE_,index_pt,1); /* shear of interacting dark radiation */
            ppv->l_max_idr = ppr->l_max_idr;
            class_define_index(ppv->index_pt_l3_idr,_TRUE_,index_pt,ppv->l_max_idr-2); /* additional momenta in Boltzmann hierarchy (beyond l=0,1,2,3) */
          }
        }
      }
    }


    /* non-cold dark matter */

    if (pba->has_ncdm == _TRUE_) {
      ppv->index_pt_psi0_ncdm1 = index_pt; /* density of ultra-relativistic neutrinos/relics */
      ppv->N_ncdm = pba->N_ncdm;
      class_alloc(ppv->l_max_ncdm,ppv->N_ncdm*sizeof(double),ppt->error_message);
      class_alloc(ppv->q_size_ncdm,ppv->N_ncdm*sizeof(double),ppt->error_message);

      for (n_ncdm = 0; n_ncdm < pba->N_ncdm; n_ncdm++){
        // Set value of ppv->l_max_ncdm:
        if (ppw->approx[ppw->index_ap_ncdmfa] == (int)ncdmfa_off){
          /* reject inconsistent values of the number of mutipoles in ultra relativistic neutrino hierarchy */
          class_test(ppr->l_max_ncdm < 4,
                     ppt->error_message,
                     "ppr->l_max_ncdm=%d should be at least 4, i.e. we must integrate at least over first four momenta of non-cold dark matter perturbed phase-space distribution",n_ncdm);
          //Copy value from precision parameter:
          ppv->l_max_ncdm[n_ncdm] = ppr->l_max_ncdm;
          ppv->q_size_ncdm[n_ncdm] = pba->q_size_ncdm[n_ncdm];
        }
        else{
          // In the fluid approximation, hierarchy is cut at lmax = 2 and q dependence is integrated out:
          ppv->l_max_ncdm[n_ncdm] = 2;
          ppv->q_size_ncdm[n_ncdm] = 1;
        }
        index_pt += (ppv->l_max_ncdm[n_ncdm]+1)*ppv->q_size_ncdm[n_ncdm];
      }
    }

    /* metric (only quantities to be integrated, not those obeying constraint equations) */

    /* metric perturbation eta of synchronous gauge */
    class_define_index(ppv->index_pt_eta,ppt->gauge == synchronous,index_pt,1);

    /* metric perturbation phi of newtonian gauge (we could fix it
       using Einstein equations as a constraint equation for phi, but
       integration is numerically more stable if we actually evolve
       phi) */
    class_define_index(ppv->index_pt_phi,ppt->gauge == newtonian,index_pt,1);

  }

  if (_vectors_) {

    /* Vector baryon velocity: v_b^{(1)}. */
    class_define_index(ppv->index_pt_theta_b,_TRUE_,index_pt,1);

    /* eventually reject inconsistent values of the number of mutipoles in photon temperature hierarchy and polarization*/

    if (ppw->approx[ppw->index_ap_rsa] == (int)rsa_off) { /* if radiation streaming approximation is off */
      if (ppw->approx[ppw->index_ap_tca] == (int)tca_off) { /* if tight-coupling approximation is off */

        ppv->l_max_g = ppr->l_max_g_ten;

        class_define_index(ppv->index_pt_delta_g,_TRUE_,index_pt,1); /* photon density */
        class_define_index(ppv->index_pt_theta_g,_TRUE_,index_pt,1); /* photon velocity */
        class_define_index(ppv->index_pt_shear_g,_TRUE_,index_pt,1); /* photon shear */
        class_define_index(ppv->index_pt_l3_g,_TRUE_,index_pt,ppv->l_max_g-2); /* photon l=3 */

        ppv->l_max_pol_g = ppr->l_max_pol_g_ten;

        class_define_index(ppv->index_pt_pol0_g,_TRUE_,index_pt,1); /* photon polarization, l=0 */
        class_define_index(ppv->index_pt_pol1_g,_TRUE_,index_pt,1); /* photon polarization, l=1 */
        class_define_index(ppv->index_pt_pol2_g,_TRUE_,index_pt,1); /* photon polarization, l=2 */
        class_define_index(ppv->index_pt_pol3_g,_TRUE_,index_pt,ppv->l_max_pol_g-2); /* photon polarization, l=3 */
      }
    }

    /** - (a) metric perturbations V or \f$ h_v \f$ depending on gauge */
    if (ppt->gauge == synchronous){
      class_define_index(ppv->index_pt_hv_prime,_TRUE_,index_pt,1);
    }
    if (ppt->gauge == newtonian){
      class_define_index(ppv->index_pt_V,_TRUE_,index_pt,1);
    }

  }

  if (_tensors_) {

    /* reject inconsistent values of the number of mutipoles in photon temperature hierarchy */
    class_test(ppr->l_max_g_ten < 4,
               ppt->error_message,
               "ppr->l_max_g_ten should be at least 4, i.e. we must integrate at least over photon density, velocity, shear, third momentum");

    /* reject inconsistent values of the number of mutipoles in photon polarization hierarchy */
    class_test(ppr->l_max_pol_g_ten < 4,
               ppt->error_message,
               "ppr->l_max_pol_g_ten should be at least 4");

    if (ppw->approx[ppw->index_ap_rsa] == (int)rsa_off) { /* if radiation streaming approximation is off */
      if (ppw->approx[ppw->index_ap_tca] == (int)tca_off) { /* if tight-coupling approximation is off */

        ppv->l_max_g = ppr->l_max_g_ten;

        class_define_index(ppv->index_pt_delta_g,_TRUE_,index_pt,1); /* photon density */
        class_define_index(ppv->index_pt_theta_g,_TRUE_,index_pt,1); /* photon velocity */
        class_define_index(ppv->index_pt_shear_g,_TRUE_,index_pt,1); /* photon shear */
        class_define_index(ppv->index_pt_l3_g,_TRUE_,index_pt,ppv->l_max_g-2); /* photon l=3 */

        ppv->l_max_pol_g = ppr->l_max_pol_g_ten;

        class_define_index(ppv->index_pt_pol0_g,_TRUE_,index_pt,1); /* photon polarization, l=0 */
        class_define_index(ppv->index_pt_pol1_g,_TRUE_,index_pt,1); /* photon polarization, l=1 */
        class_define_index(ppv->index_pt_pol2_g,_TRUE_,index_pt,1); /* photon polarization, l=2 */
        class_define_index(ppv->index_pt_pol3_g,_TRUE_,index_pt,ppv->l_max_pol_g-2); /* photon polarization, l=3 */
      }
    }

    /* ultra relativistic neutrinos */

    class_define_index(ppv->index_pt_delta_ur,ppt->evolve_tensor_ur,index_pt,1); /* ur density  */
    class_define_index(ppv->index_pt_theta_ur,ppt->evolve_tensor_ur,index_pt,1); /* ur velocity */
    class_define_index(ppv->index_pt_shear_ur,ppt->evolve_tensor_ur,index_pt,1); /* ur shear */
    ppv->l_max_ur = ppr->l_max_ur;
    class_define_index(ppv->index_pt_l3_ur,ppt->evolve_tensor_ur,index_pt,ppv->l_max_ur-2); /* additional momenta in Boltzmann hierarchy (beyond l=0,1,2,3) */

    if (ppt->evolve_tensor_ncdm == _TRUE_) {
      ppv->index_pt_psi0_ncdm1 = index_pt;
      ppv->N_ncdm = pba->N_ncdm;
      class_alloc(ppv->l_max_ncdm,ppv->N_ncdm*sizeof(double),ppt->error_message);
      class_alloc(ppv->q_size_ncdm,ppv->N_ncdm*sizeof(double),ppt->error_message);

      for (n_ncdm = 0; n_ncdm < pba->N_ncdm; n_ncdm++){
        // Set value of ppv->l_max_ncdm:
        class_test(ppr->l_max_ncdm < 4,
                   ppt->error_message,
                   "ppr->l_max_ncdm=%d should be at least 4, i.e. we must integrate at least over first four momenta of non-cold dark matter perturbed phase-space distribution",n_ncdm);
        //Copy value from precision parameter:
        ppv->l_max_ncdm[n_ncdm] = ppr->l_max_ncdm;
        ppv->q_size_ncdm[n_ncdm] = pba->q_size_ncdm[n_ncdm];

        index_pt += (ppv->l_max_ncdm[n_ncdm]+1)*ppv->q_size_ncdm[n_ncdm];
      }
    }


    /** - (b) metric perturbation h is a propagating degree of freedom, so h and hdot are included
        in the vector of ordinary perturbations, no in that of metric perturbations */

    class_define_index(ppv->index_pt_gw,_TRUE_,index_pt,1);     /* tensor metric perturbation h (gravitational waves) */
    class_define_index(ppv->index_pt_gwdot,_TRUE_,index_pt,1);  /* its time-derivative */

  }

  ppv->pt_size = index_pt;

  /** - allocate vectors for storing the values of all these
      quantities and their time-derivatives at a given time */

  class_calloc(ppv->y,ppv->pt_size,sizeof(double),ppt->error_message);
  class_alloc(ppv->dy,ppv->pt_size*sizeof(double),ppt->error_message);
  class_alloc(ppv->used_in_sources,ppv->pt_size*sizeof(int),ppt->error_message);

  /** - specify which perturbations are needed in the evaluation of source terms */

  /* take all of them by default */
  for (index_pt=0; index_pt<ppv->pt_size; index_pt++)
    ppv->used_in_sources[index_pt] = _TRUE_;

  /* indicate which ones are not needed (this is just for saving time,
     omitting perturbations in this list will not change the
     results!) */

  if (_scalars_) {

    if (ppw->approx[ppw->index_ap_rsa] == (int)rsa_off) {

      if (ppw->approx[ppw->index_ap_tca] == (int)tca_off) {

        /* we don't need temperature multipoles above l=2 (but they are
           defined only when rsa and tca are off) */

        for (index_pt=ppv->index_pt_l3_g; index_pt <= ppv->index_pt_delta_g+ppv->l_max_g; index_pt++)
          ppv->used_in_sources[index_pt]=_FALSE_;

        /* for polarization, we only need l=0,2 (but l =1,3, ... are
           defined only when rsa and tca are off) */

        ppv->used_in_sources[ppv->index_pt_pol1_g]=_FALSE_;

        for (index_pt=ppv->index_pt_pol3_g; index_pt <= ppv->index_pt_pol0_g+ppv->l_max_pol_g; index_pt++)
          ppv->used_in_sources[index_pt]=_FALSE_;

      }

    }

    if (pba->has_ur == _TRUE_) {

      if (ppw->approx[ppw->index_ap_rsa] == (int)rsa_off) {

        if (ppw->approx[ppw->index_ap_ufa] == (int)ufa_off) {

          /* we don't need ur multipoles above l=2 (but they are
             defined only when rsa and ufa are off) */

          for (index_pt=ppv->index_pt_l3_ur; index_pt <= ppv->index_pt_delta_ur+ppv->l_max_ur; index_pt++)
            ppv->used_in_sources[index_pt]=_FALSE_;

        }
      }
    }

    if (pba->has_idr == _TRUE_) {

      /* we don't need interacting dark radiation multipoles
         above l=2 (but they are defined only when rsa_idr
         and tca_idm_dr are off) */

      if (ppw->approx[ppw->index_ap_rsa_idr] == (int)rsa_idr_off){
        if (ppt->idr_nature == idr_free_streaming){
          if (ppw->approx[ppw->index_ap_tca_idm_dr] == (int)tca_idm_dr_off){
            for (index_pt=ppv->index_pt_l3_idr; index_pt <= ppv->index_pt_delta_idr+ppv->l_max_idr; index_pt++)
              ppv->used_in_sources[index_pt]=_FALSE_;
          }
        }
      }
    }

    if (pba->has_ncdm == _TRUE_) {

      /* we don't need ncdm multipoles above l=2 (but they are
         defined only when ncdmfa is off) */

      index_pt = ppv->index_pt_psi0_ncdm1;
      for (n_ncdm = 0; n_ncdm < ppv-> N_ncdm; n_ncdm++){
        for (index_q=0; index_q < ppv->q_size_ncdm[n_ncdm]; index_q++){
          for (l=0; l<=ppv->l_max_ncdm[n_ncdm]; l++){
            if (l>2) ppv->used_in_sources[index_pt]=_FALSE_;
            index_pt++;
          }
        }
      }
    }
  }

  if (_tensors_) {

    if (ppw->approx[ppw->index_ap_rsa] == (int)rsa_off) { /* if radiation streaming approximation is off */
      if (ppw->approx[ppw->index_ap_tca] == (int)tca_off) {

        /* we don't need temperature multipoles above except l=0,2,4 */

        ppv->used_in_sources[ppv->index_pt_theta_g]=_FALSE_;
        ppv->used_in_sources[ppv->index_pt_l3_g]=_FALSE_;

        for (index_pt=ppv->index_pt_delta_g+5; index_pt <= ppv->index_pt_delta_g+ppv->l_max_g; index_pt++)
          ppv->used_in_sources[index_pt]=_FALSE_;

        /* same for polarization, we only need l=0,2,4 */

        ppv->used_in_sources[ppv->index_pt_pol1_g]=_FALSE_;
        ppv->used_in_sources[ppv->index_pt_pol3_g]=_FALSE_;

        for (index_pt=ppv->index_pt_pol0_g+5; index_pt <= ppv->index_pt_pol0_g+ppv->l_max_pol_g; index_pt++)
          ppv->used_in_sources[index_pt]=_FALSE_;
      }
    }

    /* we need h' but not h */
    ppv->used_in_sources[ppv->index_pt_gw]=_FALSE_;

  }

  /** - case of setting initial conditions for a new wavenumber */

  if (pa_old == NULL) {

    if (ppt->perturbations_verbose>2)
      fprintf(stdout,"Mode k=%e: initializing vector at tau=%e\n",k,tau);

    if (_scalars_) {

      /** - --> (a) check that current approximation scheme is consistent
          with initial conditions */

      class_test(ppw->approx[ppw->index_ap_rsa] == (int)rsa_on,
                 ppt->error_message,
                 "scalar initial conditions assume radiation streaming approximation turned off");

      if (pba->has_idr == _TRUE_) {
        class_test(ppw->approx[ppw->index_ap_rsa_idr] == (int)rsa_idr_on,
                   ppt->error_message,
                   "scalar initial conditions assume dark radiation approximation turned off");

      }

      /* we do not need to do a check for tca_idm_dr, as the initial conditions are consistent with any tca_idm_dr */

      if (pba->has_ur == _TRUE_) {

        class_test(ppw->approx[ppw->index_ap_ufa] == (int)ufa_on,
                   ppt->error_message,
                   "scalar initial conditions assume ur fluid approximation turned off");

      }

      if (pba->has_ncdm == _TRUE_) {

        class_test(ppw->approx[ppw->index_ap_ncdmfa] == (int)ncdmfa_on,
                   ppt->error_message,
                   "scalar initial conditions assume ncdm fluid approximation turned off");

      }

      class_test(ppw->approx[ppw->index_ap_tca] == (int)tca_off,
                 ppt->error_message,
                 "scalar initial conditions assume tight-coupling approximation turned on");

    }

    if (_tensors_) {

      class_test(ppw->approx[ppw->index_ap_tca] == (int)tca_off,
                 ppt->error_message,
                 "tensor initial conditions assume tight-coupling approximation turned on");

      class_test(ppw->approx[ppw->index_ap_rsa] == (int)rsa_on,
                 ppt->error_message,
                 "tensor initial conditions assume radiation streaming approximation turned off");

    }

    /** - --> (b) let ppw-->pv points towards the perturbations_vector structure
        that we just created */

    ppw->pv = ppv;

    /** - --> (c) fill the vector ppw-->pv-->y with appropriate initial conditions */

    class_call(perturbations_initial_conditions(ppr,
                                                pba,
                                                ppt,
                                                index_md,
                                                index_ic,
                                                k,
                                                tau,
                                                ppw),
               ppt->error_message,
               ppt->error_message);

  }

  /** - case of switching approximation while a wavenumber is being integrated */

  else {

    /** - --> (a) for the scalar mode: */

    if (_scalars_) {

      /** - ---> (a.1.) check that the change of approximation scheme makes
          sense (note: before calling this routine there is already a
          check that we wish to change only one approximation flag at
          a time) */

      class_test((pa_old[ppw->index_ap_tca] == (int)tca_off) && (ppw->approx[ppw->index_ap_tca] == (int)tca_on),
                 ppt->error_message,
                 "at tau=%g: the tight-coupling approximation can be switched off, not on",tau);

      if (pth->has_idm_dr == _TRUE_){
        class_test((pa_old[ppw->index_ap_tca_idm_dr] == (int)tca_idm_dr_off) && (ppw->approx[ppw->index_ap_tca_idm_dr] == (int)tca_idm_dr_on),
                   ppt->error_message,
                   "at tau=%g: the dark tight-coupling approximation can be switched off, not on",tau);
      }

      /** - ---> (a.2.) some variables (b, cdm, fld, ...) are not affected by
          any approximation. They need to be reconducted whatever
          the approximation switching is. We treat them here. Below
          we will treat other variables case by case. */

      ppv->y[ppv->index_pt_delta_b] =
        ppw->pv->y[ppw->pv->index_pt_delta_b];

      ppv->y[ppv->index_pt_theta_b] =
        ppw->pv->y[ppw->pv->index_pt_theta_b];

      if (pba->has_cdm == _TRUE_) {

        ppv->y[ppv->index_pt_delta_cdm] =
          ppw->pv->y[ppw->pv->index_pt_delta_cdm];

        if (ppt->gauge == newtonian) {
          ppv->y[ppv->index_pt_theta_cdm] =
            ppw->pv->y[ppw->pv->index_pt_theta_cdm];
        }
      }

      if (pba->has_idm == _TRUE_) {

        ppv->y[ppv->index_pt_delta_idm] =
          ppw->pv->y[ppw->pv->index_pt_delta_idm];

        ppv->y[ppv->index_pt_theta_idm] =
          ppw->pv->y[ppw->pv->index_pt_theta_idm];
      }

      if (pba->has_dcdm == _TRUE_) {

        ppv->y[ppv->index_pt_delta_dcdm] =
          ppw->pv->y[ppw->pv->index_pt_delta_dcdm];

        ppv->y[ppv->index_pt_theta_dcdm] =
          ppw->pv->y[ppw->pv->index_pt_theta_dcdm];
      }

      if (pba->has_dr == _TRUE_){
        for (l=0; l <= ppv->l_max_dr; l++)
          ppv->y[ppv->index_pt_F0_dr+l] =
            ppw->pv->y[ppw->pv->index_pt_F0_dr+l];
      }

      if (pba->has_fld == _TRUE_) {

        if (pba->use_ppf == _FALSE_) {
          ppv->y[ppv->index_pt_delta_fld] =
            ppw->pv->y[ppw->pv->index_pt_delta_fld];

          ppv->y[ppv->index_pt_theta_fld] =
            ppw->pv->y[ppw->pv->index_pt_theta_fld];
        }
        else {
          ppv->y[ppv->index_pt_Gamma_fld] =
            ppw->pv->y[ppw->pv->index_pt_Gamma_fld];
        }
      }

      if (pba->has_scf == _TRUE_) {

        ppv->y[ppv->index_pt_phi_scf] =
          ppw->pv->y[ppw->pv->index_pt_phi_scf];

        ppv->y[ppv->index_pt_phi_prime_scf] =
          ppw->pv->y[ppw->pv->index_pt_phi_prime_scf];
      }

      if (ppt->gauge == synchronous)
        ppv->y[ppv->index_pt_eta] =
          ppw->pv->y[ppw->pv->index_pt_eta];

      if (ppt->gauge == newtonian)
        ppv->y[ppv->index_pt_phi] =
          ppw->pv->y[ppw->pv->index_pt_phi];

      /* -- case of switching off tight coupling
         approximation. Provide correct initial conditions to new set
         of variables */

      if ((pa_old[ppw->index_ap_tca] == (int)tca_on) && (ppw->approx[ppw->index_ap_tca] == (int)tca_off)) {

        if (ppt->perturbations_verbose>2)
          fprintf(stdout,"Mode k=%e: switch off tight-coupling approximation at tau=%e\n",k,tau);

        ppv->y[ppv->index_pt_delta_g] =
          ppw->pv->y[ppw->pv->index_pt_delta_g];

        ppv->y[ppv->index_pt_theta_g] =
          ppw->pv->y[ppw->pv->index_pt_theta_g];

        /* tight-coupling approximation for shear_g (previously
           computed in perturbations_derivs: perturbations_derivs is always
           called at the end of generic_evolver, in order to update
           all quantities in ppw to the time at which the
           approximation is switched off) */
        ppv->y[ppv->index_pt_shear_g] = ppw->tca_shear_g;

        ppv->y[ppv->index_pt_l3_g] = 6./7.*k/ppw->pvecthermo[pth->index_th_dkappa]*ppw->s_l[3]*ppv->y[ppv->index_pt_shear_g];        /* second-order tight-coupling approximation for l=3 */
        ppv->y[ppv->index_pt_pol0_g] = 2.5*ppv->y[ppv->index_pt_shear_g];                                                            /* first-order tight-coupling approximation for polarization, l=0 */
        ppv->y[ppv->index_pt_pol1_g] = k/ppw->pvecthermo[pth->index_th_dkappa]*(5.-2.*ppw->s_l[2])/6.*ppv->y[ppv->index_pt_shear_g]; /* second-order tight-coupling approximation for polarization, l=1 */
        ppv->y[ppv->index_pt_pol2_g] = 0.5*ppv->y[ppv->index_pt_shear_g];                                                            /* first-order tight-coupling approximation for polarization, l=2 */
        ppv->y[ppv->index_pt_pol3_g] = k/ppw->pvecthermo[pth->index_th_dkappa]*3.*ppw->s_l[3]/14.*ppv->y[ppv->index_pt_shear_g];     /* second-order tight-coupling approximation for polarization, l=3 */

        if (pba->has_ur == _TRUE_) {

          ppv->y[ppv->index_pt_delta_ur] =
            ppw->pv->y[ppw->pv->index_pt_delta_ur];

          ppv->y[ppv->index_pt_theta_ur] =
            ppw->pv->y[ppw->pv->index_pt_theta_ur];

          ppv->y[ppv->index_pt_shear_ur] =
            ppw->pv->y[ppw->pv->index_pt_shear_ur];

          if (ppw->approx[ppw->index_ap_ufa] == (int)ufa_off) {

            ppv->y[ppv->index_pt_l3_ur] =
              ppw->pv->y[ppw->pv->index_pt_l3_ur];

            for (l=4; l <= ppv->l_max_ur; l++)
              ppv->y[ppv->index_pt_delta_ur+l] =
                ppw->pv->y[ppw->pv->index_pt_delta_ur+l];

          }
        }

        if (pba->has_idr == _TRUE_){

          if (ppw->approx[ppw->index_ap_rsa_idr]==(int)rsa_idr_off){

            ppv->y[ppv->index_pt_delta_idr] =
              ppw->pv->y[ppw->pv->index_pt_delta_idr];

            ppv->y[ppv->index_pt_theta_idr] =
              ppw->pv->y[ppw->pv->index_pt_theta_idr];

            if (ppt->idr_nature == idr_free_streaming){

              if (ppw->approx[ppw->index_ap_tca_idm_dr] == (int)tca_idm_dr_off){

                ppv->y[ppv->index_pt_shear_idr] =
                  ppw->pv->y[ppw->pv->index_pt_shear_idr];

                ppv->y[ppv->index_pt_l3_idr] =
                  ppw->pv->y[ppw->pv->index_pt_l3_idr];

                for (l=4; l <= ppv->l_max_idr; l++)
                  ppv->y[ppv->index_pt_delta_idr+l] =
                    ppw->pv->y[ppw->pv->index_pt_delta_idr+l];
              }
            }
          }
        }

        if (pba->has_ncdm == _TRUE_) {
          index_pt = 0;
          for (n_ncdm = 0; n_ncdm < ppv->N_ncdm; n_ncdm++){
            for (index_q=0; index_q < ppv->q_size_ncdm[n_ncdm]; index_q++){
              for (l=0; l<=ppv->l_max_ncdm[n_ncdm];l++){
                // This is correct with or without ncdmfa, since ppv->lmax_ncdm is set accordingly.
                ppv->y[ppv->index_pt_psi0_ncdm1+index_pt] =
                  ppw->pv->y[ppw->pv->index_pt_psi0_ncdm1+index_pt];
                index_pt++;
              }
            }
          }
        }

        /* perturbed recombination */
        /* the initial conditions are set when tca is switched off (current block) */
        if (ppt->has_perturbed_recombination == _TRUE_){
          ppv->y[ppv->index_pt_perturbed_recombination_delta_temp] = 1./3.*ppv->y[ppw->pv->index_pt_delta_b];
          ppv->y[ppv->index_pt_perturbed_recombination_delta_chi] =0.;
        }

      }  // end of block tca ON -> tca OFF

      /* perturbed recombination */
      /* For any other transition in the approximation scheme, we should just copy the value of the perturbations, provided tca is already off (otherwise the indices are not yet allocated). For instance, we do not want to copy the values in the (k,tau) region where both UFA and TCA are engaged.*/

      if ((ppt->has_perturbed_recombination == _TRUE_)&&(pa_old[ppw->index_ap_tca]==(int)tca_off)){
        ppv->y[ppv->index_pt_perturbed_recombination_delta_temp] =
          ppw->pv->y[ppw->pv->index_pt_perturbed_recombination_delta_temp];
        ppv->y[ppv->index_pt_perturbed_recombination_delta_chi] =
          ppw->pv->y[ppw->pv->index_pt_perturbed_recombination_delta_chi];
      }

      /* -- case of switching on radiation streaming
         approximation. Provide correct initial conditions to new set
         of variables */

      if ((pa_old[ppw->index_ap_rsa] == (int)rsa_off) && (ppw->approx[ppw->index_ap_rsa] == (int)rsa_on)) {

        if (ppt->perturbations_verbose>2)
          fprintf(stdout,"Mode k=%e: switch on radiation streaming approximation at tau=%e with Omega_r=%g\n",k,tau,ppw->pvecback[pba->index_bg_Omega_r]);

        if (pba->has_idr == _TRUE_){

          if (ppw->approx[ppw->index_ap_rsa_idr]==(int)rsa_idr_off){

            ppv->y[ppv->index_pt_delta_idr] =
              ppw->pv->y[ppw->pv->index_pt_delta_idr];

            ppv->y[ppv->index_pt_theta_idr] =
              ppw->pv->y[ppw->pv->index_pt_theta_idr];

            if (ppt->idr_nature == idr_free_streaming){

              if (ppw->approx[ppw->index_ap_tca_idm_dr] == (int)tca_idm_dr_off){

                ppv->y[ppv->index_pt_shear_idr] =
                  ppw->pv->y[ppw->pv->index_pt_shear_idr];

                ppv->y[ppv->index_pt_l3_idr] =
                  ppw->pv->y[ppw->pv->index_pt_l3_idr];

                for (l=4; l <= ppv->l_max_idr; l++)
                  ppv->y[ppv->index_pt_delta_idr+l] =
                    ppw->pv->y[ppw->pv->index_pt_delta_idr+l];
              }
            }
          }
        }

        if (pba->has_ncdm == _TRUE_) {
          index_pt = 0;
          for (n_ncdm = 0; n_ncdm < ppv->N_ncdm; n_ncdm++){
            for (index_q=0; index_q < ppv->q_size_ncdm[n_ncdm]; index_q++){
              for (l=0; l<=ppv->l_max_ncdm[n_ncdm]; l++){
                ppv->y[ppv->index_pt_psi0_ncdm1+index_pt] =
                  ppw->pv->y[ppw->pv->index_pt_psi0_ncdm1+index_pt];
                index_pt++;
              }
            }
          }
        }
      }

      /* -- case of switching on ur fluid
         approximation. Provide correct initial conditions to new set
         of variables */

      if (pba->has_ur == _TRUE_) {

        if ((pa_old[ppw->index_ap_ufa] == (int)ufa_off) && (ppw->approx[ppw->index_ap_ufa] == (int)ufa_on)) {

          if (ppt->perturbations_verbose>2)
            fprintf(stdout,"Mode k=%e: switch on ur fluid approximation at tau=%e\n",k,tau);

          if (ppw->approx[ppw->index_ap_rsa] == (int)rsa_off) {

            ppv->y[ppv->index_pt_delta_g] =
              ppw->pv->y[ppw->pv->index_pt_delta_g];

            ppv->y[ppv->index_pt_theta_g] =
              ppw->pv->y[ppw->pv->index_pt_theta_g];
          }

          if ((ppw->approx[ppw->index_ap_tca] == (int)tca_off) && (ppw->approx[ppw->index_ap_rsa] == (int)rsa_off)) {

            ppv->y[ppv->index_pt_shear_g] =
              ppw->pv->y[ppw->pv->index_pt_shear_g];

            ppv->y[ppv->index_pt_l3_g] =
              ppw->pv->y[ppw->pv->index_pt_l3_g];

            for (l = 4; l <= ppw->pv->l_max_g; l++) {

              ppv->y[ppv->index_pt_delta_g+l] =
                ppw->pv->y[ppw->pv->index_pt_delta_g+l];
            }

            ppv->y[ppv->index_pt_pol0_g] =
              ppw->pv->y[ppw->pv->index_pt_pol0_g];

            ppv->y[ppv->index_pt_pol1_g] =
              ppw->pv->y[ppw->pv->index_pt_pol1_g];

            ppv->y[ppv->index_pt_pol2_g] =
              ppw->pv->y[ppw->pv->index_pt_pol2_g];

            ppv->y[ppv->index_pt_pol3_g] =
              ppw->pv->y[ppw->pv->index_pt_pol3_g];

            for (l = 4; l <= ppw->pv->l_max_pol_g; l++) {

              ppv->y[ppv->index_pt_pol0_g+l] =
                ppw->pv->y[ppw->pv->index_pt_pol0_g+l];
            }

          }

          if (ppw->approx[ppw->index_ap_rsa] == (int)rsa_off) {

            ppv->y[ppv->index_pt_delta_ur] =
              ppw->pv->y[ppw->pv->index_pt_delta_ur];

            ppv->y[ppv->index_pt_theta_ur] =
              ppw->pv->y[ppw->pv->index_pt_theta_ur];

            ppv->y[ppv->index_pt_shear_ur] =
              ppw->pv->y[ppw->pv->index_pt_shear_ur];
          }

          if (pba->has_idr == _TRUE_){

            if (ppw->approx[ppw->index_ap_rsa_idr]==(int)rsa_idr_off){

              ppv->y[ppv->index_pt_delta_idr] =
                ppw->pv->y[ppw->pv->index_pt_delta_idr];

              ppv->y[ppv->index_pt_theta_idr] =
                ppw->pv->y[ppw->pv->index_pt_theta_idr];

              if (ppt->idr_nature == idr_free_streaming){

                if (ppw->approx[ppw->index_ap_tca_idm_dr] == (int)tca_idm_dr_off){

                  ppv->y[ppv->index_pt_shear_idr] =
                    ppw->pv->y[ppw->pv->index_pt_shear_idr];

                  ppv->y[ppv->index_pt_l3_idr] =
                    ppw->pv->y[ppw->pv->index_pt_l3_idr];

                  for (l=4; l <= ppv->l_max_idr; l++)
                    ppv->y[ppv->index_pt_delta_idr+l] =
                      ppw->pv->y[ppw->pv->index_pt_delta_idr+l];
                }
              }
            }
          }

          if (pba->has_ncdm == _TRUE_) {
            index_pt = 0;
            for (n_ncdm = 0; n_ncdm < ppv->N_ncdm; n_ncdm++){
              for (index_q=0; index_q < ppv->q_size_ncdm[n_ncdm]; index_q++){
                for (l=0; l<=ppv->l_max_ncdm[n_ncdm]; l++){
                  /* This is correct even when ncdmfa == off, since ppv->l_max_ncdm and
                     ppv->q_size_ncdm is updated.*/
                  ppv->y[ppv->index_pt_psi0_ncdm1+index_pt] =
                    ppw->pv->y[ppw->pv->index_pt_psi0_ncdm1+index_pt];
                  index_pt++;
                }
              }
            }
          }
        }
      }

      /* Case of switching on rsa for interacting dark radiation */
      if (pba->has_idr == _TRUE_) {
        if ((pa_old[ppw->index_ap_rsa_idr] == (int)rsa_idr_off) && (ppw->approx[ppw->index_ap_rsa_idr] == (int)rsa_idr_on)) {

          if (ppt->perturbations_verbose>2)
            fprintf(stdout,"Mode k=%e: switch on dark radiation approximation at tau=%e\n",k,tau);

          if (ppw->approx[ppw->index_ap_rsa] == (int)rsa_off) {

            ppv->y[ppv->index_pt_delta_g] =
              ppw->pv->y[ppw->pv->index_pt_delta_g];

            ppv->y[ppv->index_pt_theta_g] =
              ppw->pv->y[ppw->pv->index_pt_theta_g];
          }

          if ((ppw->approx[ppw->index_ap_tca] == (int)tca_off) && (ppw->approx[ppw->index_ap_rsa] == (int)rsa_off)) {

            ppv->y[ppv->index_pt_shear_g] =
              ppw->pv->y[ppw->pv->index_pt_shear_g];

            ppv->y[ppv->index_pt_l3_g] =
              ppw->pv->y[ppw->pv->index_pt_l3_g];

            for (l = 4; l <= ppw->pv->l_max_g; l++) {

              ppv->y[ppv->index_pt_delta_g+l] =
                ppw->pv->y[ppw->pv->index_pt_delta_g+l];
            }

            ppv->y[ppv->index_pt_pol0_g] =
              ppw->pv->y[ppw->pv->index_pt_pol0_g];

            ppv->y[ppv->index_pt_pol1_g] =
              ppw->pv->y[ppw->pv->index_pt_pol1_g];

            ppv->y[ppv->index_pt_pol2_g] =
              ppw->pv->y[ppw->pv->index_pt_pol2_g];

            ppv->y[ppv->index_pt_pol3_g] =
              ppw->pv->y[ppw->pv->index_pt_pol3_g];

            for (l = 4; l <= ppw->pv->l_max_pol_g; l++) {

              ppv->y[ppv->index_pt_pol0_g+l] =
                ppw->pv->y[ppw->pv->index_pt_pol0_g+l];
            }

          }

          if (pba->has_ur == _TRUE_) {

            if (ppw->approx[ppw->index_ap_rsa] == (int)rsa_off) {


              ppv->y[ppv->index_pt_delta_ur] =
                ppw->pv->y[ppw->pv->index_pt_delta_ur];

              ppv->y[ppv->index_pt_theta_ur] =
                ppw->pv->y[ppw->pv->index_pt_theta_ur];

              ppv->y[ppv->index_pt_shear_ur] =
                ppw->pv->y[ppw->pv->index_pt_shear_ur];

              if (ppw->approx[ppw->index_ap_ufa] == (int)ufa_off) {

                ppv->y[ppv->index_pt_l3_ur] =
                  ppw->pv->y[ppw->pv->index_pt_l3_ur];

                for (l=4; l <= ppv->l_max_ur; l++)
                  ppv->y[ppv->index_pt_delta_ur+l] =
                    ppw->pv->y[ppw->pv->index_pt_delta_ur+l];

              }
            }
          }

          if (pba->has_ncdm == _TRUE_) {
            index_pt = 0;
            for (n_ncdm = 0; n_ncdm < ppv->N_ncdm; n_ncdm++){
              for (index_q=0; index_q < ppv->q_size_ncdm[n_ncdm]; index_q++){
                for (l=0; l<=ppv->l_max_ncdm[n_ncdm]; l++){
                  /* This is correct even when ncdmfa == off, since ppv->l_max_ncdm and
                     ppv->q_size_ncdm is updated.*/
                  ppv->y[ppv->index_pt_psi0_ncdm1+index_pt] =
                    ppw->pv->y[ppw->pv->index_pt_psi0_ncdm1+index_pt];
                  index_pt++;
                }
              }
            }
          }

        }
      }

      if (pth->has_idm_dr == _TRUE_) {

        /* Case of switching off interacting dark radiation tight coupling approximation */

        if ((pa_old[ppw->index_ap_tca_idm_dr] == (int)tca_idm_dr_on) && (ppw->approx[ppw->index_ap_tca_idm_dr] == (int)tca_idm_dr_off)) {

          if (ppt->perturbations_verbose>2)
            fprintf(stdout,"Mode k=%e: switch off dark tight coupling approximation at tau=%e\n",k,tau);

          if (ppw->approx[ppw->index_ap_rsa_idr] == (int)rsa_idr_off) {

            ppv->y[ppv->index_pt_delta_idr] =
              ppw->pv->y[ppw->pv->index_pt_delta_idr];

            ppv->y[ppv->index_pt_theta_idr] =
              ppw->pv->y[ppw->pv->index_pt_theta_idr];

            /* idr is always free streaming if tca_idm_dr is on */
            if (ppt->idr_nature == idr_free_streaming){
              ppv->y[ppv->index_pt_shear_idr] = ppw->tca_shear_idm_dr;
              ppv->y[ppv->index_pt_l3_idr] = 6./7.*k*ppv->y[ppv->index_pt_shear_idr]/ppw->pvecthermo[pth->index_th_dmu_idm_dr]/ppt->alpha_idm_dr[1];
            }
          }

          if (ppw->approx[ppw->index_ap_rsa] == (int)rsa_off) {

            ppv->y[ppv->index_pt_delta_g] =
              ppw->pv->y[ppw->pv->index_pt_delta_g];

            ppv->y[ppv->index_pt_theta_g] =
              ppw->pv->y[ppw->pv->index_pt_theta_g];
          }

          if ((ppw->approx[ppw->index_ap_tca] == (int)tca_off) && (ppw->approx[ppw->index_ap_rsa] == (int)rsa_off)) {

            ppv->y[ppv->index_pt_shear_g] =
              ppw->pv->y[ppw->pv->index_pt_shear_g];

            ppv->y[ppv->index_pt_l3_g] =
              ppw->pv->y[ppw->pv->index_pt_l3_g];

            for (l = 4; l <= ppw->pv->l_max_g; l++) {

              ppv->y[ppv->index_pt_delta_g+l] =
                ppw->pv->y[ppw->pv->index_pt_delta_g+l];
            }

            ppv->y[ppv->index_pt_pol0_g] =
              ppw->pv->y[ppw->pv->index_pt_pol0_g];

            ppv->y[ppv->index_pt_pol1_g] =
              ppw->pv->y[ppw->pv->index_pt_pol1_g];

            ppv->y[ppv->index_pt_pol2_g] =
              ppw->pv->y[ppw->pv->index_pt_pol2_g];

            ppv->y[ppv->index_pt_pol3_g] =
              ppw->pv->y[ppw->pv->index_pt_pol3_g];

            for (l = 4; l <= ppw->pv->l_max_pol_g; l++) {

              ppv->y[ppv->index_pt_pol0_g+l] =
                ppw->pv->y[ppw->pv->index_pt_pol0_g+l];
            }

          }

          if (pba->has_ur == _TRUE_) {

            if (ppw->approx[ppw->index_ap_rsa] == (int)rsa_off) {


              ppv->y[ppv->index_pt_delta_ur] =
                ppw->pv->y[ppw->pv->index_pt_delta_ur];

              ppv->y[ppv->index_pt_theta_ur] =
                ppw->pv->y[ppw->pv->index_pt_theta_ur];

              ppv->y[ppv->index_pt_shear_ur] =
                ppw->pv->y[ppw->pv->index_pt_shear_ur];

              if (ppw->approx[ppw->index_ap_ufa] == (int)ufa_off) {

                ppv->y[ppv->index_pt_l3_ur] =
                  ppw->pv->y[ppw->pv->index_pt_l3_ur];

                for (l=4; l <= ppv->l_max_ur; l++)
                  ppv->y[ppv->index_pt_delta_ur+l] =
                    ppw->pv->y[ppw->pv->index_pt_delta_ur+l];

              }
            }
          }

          if (pba->has_ncdm == _TRUE_) {
            index_pt = 0;
            for (n_ncdm = 0; n_ncdm < ppv->N_ncdm; n_ncdm++){
              for (index_q=0; index_q < ppv->q_size_ncdm[n_ncdm]; index_q++){
                for (l=0; l<=ppv->l_max_ncdm[n_ncdm]; l++){
                  /* This is correct even when ncdmfa == off, since ppv->l_max_ncdm and
                     ppv->q_size_ncdm is updated. */
                  ppv->y[ppv->index_pt_psi0_ncdm1+index_pt] =
                    ppw->pv->y[ppw->pv->index_pt_psi0_ncdm1+index_pt];
                  index_pt++;
                }
              }
            }
          }
        }
      }

      /* -- case of switching on ncdm fluid
         approximation. Provide correct initial conditions to new set
         of variables */

      if (pba->has_ncdm == _TRUE_) {

        if ((pa_old[ppw->index_ap_ncdmfa] == (int)ncdmfa_off) && (ppw->approx[ppw->index_ap_ncdmfa] == (int)ncdmfa_on)) {

          if (ppt->perturbations_verbose>2)
            fprintf(stdout,"Mode k=%e: switch on ncdm fluid approximation at tau=%e\n",k,tau);

          if (ppw->approx[ppw->index_ap_rsa] == (int)rsa_off) {

            ppv->y[ppv->index_pt_delta_g] =
              ppw->pv->y[ppw->pv->index_pt_delta_g];

            ppv->y[ppv->index_pt_theta_g] =
              ppw->pv->y[ppw->pv->index_pt_theta_g];
          }

          if ((ppw->approx[ppw->index_ap_tca] == (int)tca_off) && (ppw->approx[ppw->index_ap_rsa] == (int)rsa_off)) {

            ppv->y[ppv->index_pt_shear_g] =
              ppw->pv->y[ppw->pv->index_pt_shear_g];

            ppv->y[ppv->index_pt_l3_g] =
              ppw->pv->y[ppw->pv->index_pt_l3_g];

            for (l = 4; l <= ppw->pv->l_max_g; l++) {

              ppv->y[ppv->index_pt_delta_g+l] =
                ppw->pv->y[ppw->pv->index_pt_delta_g+l];
            }

            ppv->y[ppv->index_pt_pol0_g] =
              ppw->pv->y[ppw->pv->index_pt_pol0_g];

            ppv->y[ppv->index_pt_pol1_g] =
              ppw->pv->y[ppw->pv->index_pt_pol1_g];

            ppv->y[ppv->index_pt_pol2_g] =
              ppw->pv->y[ppw->pv->index_pt_pol2_g];

            ppv->y[ppv->index_pt_pol3_g] =
              ppw->pv->y[ppw->pv->index_pt_pol3_g];

            for (l = 4; l <= ppw->pv->l_max_pol_g; l++) {

              ppv->y[ppv->index_pt_pol0_g+l] =
                ppw->pv->y[ppw->pv->index_pt_pol0_g+l];
            }

          }

          if (pba->has_ur == _TRUE_) {

            if (ppw->approx[ppw->index_ap_rsa] == (int)rsa_off) {


              ppv->y[ppv->index_pt_delta_ur] =
                ppw->pv->y[ppw->pv->index_pt_delta_ur];

              ppv->y[ppv->index_pt_theta_ur] =
                ppw->pv->y[ppw->pv->index_pt_theta_ur];

              ppv->y[ppv->index_pt_shear_ur] =
                ppw->pv->y[ppw->pv->index_pt_shear_ur];

              if (ppw->approx[ppw->index_ap_ufa] == (int)ufa_off) {

                ppv->y[ppv->index_pt_l3_ur] =
                  ppw->pv->y[ppw->pv->index_pt_l3_ur];

                for (l=4; l <= ppv->l_max_ur; l++)
                  ppv->y[ppv->index_pt_delta_ur+l] =
                    ppw->pv->y[ppw->pv->index_pt_delta_ur+l];

              }
            }
          }

          if (pba->has_idr == _TRUE_){
            if (ppw->approx[ppw->index_ap_rsa_idr] == (int)rsa_idr_off){

              ppv->y[ppv->index_pt_delta_idr] =
                ppw->pv->y[ppw->pv->index_pt_delta_idr];

              ppv->y[ppv->index_pt_theta_idr] =
                ppw->pv->y[ppw->pv->index_pt_theta_idr];

              if (ppt->idr_nature == idr_free_streaming){

                if (ppw->approx[ppw->index_ap_tca_idm_dr] == (int)tca_idm_dr_off){

                  ppv->y[ppv->index_pt_shear_idr] =
                    ppw->pv->y[ppw->pv->index_pt_shear_idr];

                  ppv->y[ppv->index_pt_l3_idr] =
                    ppw->pv->y[ppw->pv->index_pt_l3_idr];

                  for (l=4; l <= ppv->l_max_idr; l++)
                    ppv->y[ppv->index_pt_delta_idr+l] =
                      ppw->pv->y[ppw->pv->index_pt_delta_idr+l];
                }
              }
            }
          }


          a = ppw->pvecback[pba->index_bg_a];
          index_pt = ppw->pv->index_pt_psi0_ncdm1;
          for (n_ncdm = 0; n_ncdm < ppv->N_ncdm; n_ncdm++){
            // We are in the fluid approximation, so ncdm_l_size is always 3.
            ncdm_l_size = ppv->l_max_ncdm[n_ncdm]+1;
            rho_plus_p_ncdm = ppw->pvecback[pba->index_bg_rho_ncdm1+n_ncdm]+
              ppw->pvecback[pba->index_bg_p_ncdm1+n_ncdm];
            for (l=0; l<=2; l++){
              ppv->y[ppv->index_pt_psi0_ncdm1+ncdm_l_size*n_ncdm+l] = 0.0;
            }
            factor = pba->factor_ncdm[n_ncdm]/pow(a,4);
            for (index_q=0; index_q < ppw->pv->q_size_ncdm[n_ncdm]; index_q++){
              // Integrate over distributions:
              q = pba->q_ncdm[n_ncdm][index_q];
              q2 = q*q;
              epsilon = sqrt(q2+a*a*pba->M_ncdm[n_ncdm]*pba->M_ncdm[n_ncdm]);
              ppv->y[ppv->index_pt_psi0_ncdm1+ncdm_l_size*n_ncdm] +=
                pba->w_ncdm[n_ncdm][index_q]*q2*epsilon*
                ppw->pv->y[index_pt];

              ppv->y[ppv->index_pt_psi0_ncdm1+ncdm_l_size*n_ncdm+1] +=
                pba->w_ncdm[n_ncdm][index_q]*q2*q*
                ppw->pv->y[index_pt+1];

              ppv->y[ppv->index_pt_psi0_ncdm1+ncdm_l_size*n_ncdm+2] +=
                pba->w_ncdm[n_ncdm][index_q]*q2*q2/epsilon*
                ppw->pv->y[index_pt+2];

              //Jump to next momentum bin in ppw->pv->y:
              index_pt += (ppw->pv->l_max_ncdm[n_ncdm]+1);
            }
            ppv->y[ppv->index_pt_psi0_ncdm1+ncdm_l_size*n_ncdm] *=factor/ppw->pvecback[pba->index_bg_rho_ncdm1+n_ncdm];
            ppv->y[ppv->index_pt_psi0_ncdm1+ncdm_l_size*n_ncdm+1] *=k*factor/rho_plus_p_ncdm;
            ppv->y[ppv->index_pt_psi0_ncdm1+ncdm_l_size*n_ncdm+2] *=2.0/3.0*factor/rho_plus_p_ncdm;
          }
        }
      }
    }

    /** - --> (b) for the vector mode */

    if (_vectors_) {

      /** - ---> (b.1.) check that the change of approximation scheme makes
          sense (note: before calling this routine there is already a
          check that we wish to change only one approximation flag at
          a time) */

      class_test((pa_old[ppw->index_ap_tca] == (int)tca_off) && (ppw->approx[ppw->index_ap_tca] == (int)tca_on),
                 ppt->error_message,
                 "at tau=%g: the tight-coupling approximation can be switched off, not on",tau);

      /** - ---> (b.2.) some variables (gw, gwdot, ...) are not affected by
          any approximation. They need to be reconducted whatever
          the approximation switching is. We treat them here. Below
          we will treat other variables case by case. */

      if (ppt->gauge == synchronous){

        ppv->y[ppv->index_pt_hv_prime] =
          ppw->pv->y[ppw->pv->index_pt_hv_prime];

      }
      if (ppt->gauge == newtonian){

        ppv->y[ppv->index_pt_V] =
          ppw->pv->y[ppw->pv->index_pt_V];

      }

      ppv->y[ppv->index_pt_theta_b] =
        ppw->pv->y[ppw->pv->index_pt_theta_b];


      /* -- case of switching off tight coupling
         approximation. Provide correct initial conditions to new set
         of variables */

      if ((pa_old[ppw->index_ap_tca] == (int)tca_on) && (ppw->approx[ppw->index_ap_tca] == (int)tca_off)) {

        if (ppt->perturbations_verbose>2)
          fprintf(stdout,"Mode k=%e: switch off tight-coupling approximation at tau=%e\n",k,tau);

        ppv->y[ppv->index_pt_delta_g] = 0.0; //TBC
        //-4./3.*ppw->pv->y[ppw->pv->index_pt_gwdot]/ppw->pvecthermo[pth->index_th_dkappa];

        ppv->y[ppv->index_pt_pol0_g] = 0.0; //TBC
        //1./3.*ppw->pv->y[ppw->pv->index_pt_gwdot]/ppw->pvecthermo[pth->index_th_dkappa];
      }

      /* -- case of switching on radiation streaming
         approximation. Provide correct initial conditions to new set
         of variables */

      if ((pa_old[ppw->index_ap_rsa] == (int)rsa_off) && (ppw->approx[ppw->index_ap_rsa] == (int)rsa_on)) {

        if (ppt->perturbations_verbose>2)
          fprintf(stdout,"Mode k=%e: switch on radiation streaming approximation at tau=%e with Omega_r=%g\n",k,tau,ppw->pvecback[pba->index_bg_Omega_r]);

      }

    }

    /** - --> (c) for the tensor mode */

    if (_tensors_) {

      /** - ---> (c.1.) check that the change of approximation scheme makes
          sense (note: before calling this routine there is already a
          check that we wish to change only one approximation flag at
          a time) */

      class_test((pa_old[ppw->index_ap_tca] == (int)tca_off) && (ppw->approx[ppw->index_ap_tca] == (int)tca_on),
                 ppt->error_message,
                 "at tau=%g: the tight-coupling approximation can be switched off, not on",tau);

      /** - ---> (c.2.) some variables (gw, gwdot, ...) are not affected by
          any approximation. They need to be reconducted whatever
          the approximation switching is. We treat them here. Below
          we will treat other variables case by case. */


      ppv->y[ppv->index_pt_gw] =
        ppw->pv->y[ppw->pv->index_pt_gw];

      ppv->y[ppv->index_pt_gwdot] =
        ppw->pv->y[ppw->pv->index_pt_gwdot];

      if (ppt->evolve_tensor_ur == _TRUE_){

        /* For now, neutrinos go here. */
        ppv->y[ppv->index_pt_delta_ur] =
          ppw->pv->y[ppw->pv->index_pt_delta_ur];

        ppv->y[ppv->index_pt_theta_ur] =
          ppw->pv->y[ppw->pv->index_pt_theta_ur];

        ppv->y[ppv->index_pt_shear_ur] =
          ppw->pv->y[ppw->pv->index_pt_shear_ur];

        ppv->y[ppv->index_pt_l3_ur] =
          ppw->pv->y[ppw->pv->index_pt_l3_ur];

        for (l=4; l <= ppv->l_max_ur; l++)
          ppv->y[ppv->index_pt_delta_ur+l] =
            ppw->pv->y[ppw->pv->index_pt_delta_ur+l];

      }

      if (ppt->evolve_tensor_ncdm == _TRUE_){

        index_pt = 0;
        for (n_ncdm = 0; n_ncdm < ppv->N_ncdm; n_ncdm++){
          for (index_q=0; index_q < ppv->q_size_ncdm[n_ncdm]; index_q++){
            for (l=0; l<=ppv->l_max_ncdm[n_ncdm];l++){
              // This is correct with or without ncdmfa, since ppv->lmax_ncdm is set accordingly.
              ppv->y[ppv->index_pt_psi0_ncdm1+index_pt] =
                ppw->pv->y[ppw->pv->index_pt_psi0_ncdm1+index_pt];
              index_pt++;
            }
          }
        }
      }

      /* -- case of switching off tight coupling
         approximation. Provide correct initial conditions to new set
         of variables */

      if ((pa_old[ppw->index_ap_tca] == (int)tca_on) && (ppw->approx[ppw->index_ap_tca] == (int)tca_off)) {

        if (ppt->perturbations_verbose>2)
          fprintf(stdout,"Mode k=%e: switch off tight-coupling approximation at tau=%e\n",k,tau);

        ppv->y[ppv->index_pt_delta_g] = -4./3.*ppw->pv->y[ppw->pv->index_pt_gwdot]/ppw->pvecthermo[pth->index_th_dkappa];

        ppv->y[ppv->index_pt_pol0_g] = 1./3.*ppw->pv->y[ppw->pv->index_pt_gwdot]/ppw->pvecthermo[pth->index_th_dkappa];
      }

      /* -- case of switching on radiation streaming
         approximation. Provide correct initial conditions to new set
         of variables */

      if ((pa_old[ppw->index_ap_rsa] == (int)rsa_off) && (ppw->approx[ppw->index_ap_rsa] == (int)rsa_on)) {

        if (ppt->perturbations_verbose>2)
          fprintf(stdout,"Mode k=%e: switch on radiation streaming approximation at tau=%e with Omega_r=%g\n",k,tau,ppw->pvecback[pba->index_bg_Omega_r]);

      }
    }

    /** - --> (d) free the previous vector of perturbations */

    class_call(perturbations_vector_free(ppw->pv),
               ppt->error_message,
               ppt->error_message);

    /** - --> (e) let ppw-->pv points towards the perturbations_vector structure
        that we just created */

    ppw->pv = ppv;

  }

  return _SUCCESS_;
}

/**
 * Free the perturbations_vector structure.
 *
 * @param pv        Input: pointer to perturbations_vector structure to be freed
 * @return the error status
 */

int perturbations_vector_free(
                              struct perturbations_vector * pv
                              ) {

  if (pv->l_max_ncdm != NULL) free(pv->l_max_ncdm);
  if (pv->q_size_ncdm != NULL) free(pv->q_size_ncdm);
  free(pv->y);
  free(pv->dy);
  free(pv->used_in_sources);
  free(pv);

  return _SUCCESS_;
}

/**
 * For each mode, wavenumber and initial condition, this function
 * initializes in the vector all values of perturbed variables (in a
 * given gauge). It is assumed here that all values have previously been
 * set to zero, only non-zero values are set here.
 *
 * @param ppr        Input: pointer to precision structure
 * @param pba        Input: pointer to background structure
 * @param ppt        Input: pointer to the perturbation structure
 * @param index_md   Input: index of mode under consideration (scalar/.../tensor)
 * @param index_ic   Input: index of initial condition under consideration (ad, iso...)
 * @param k          Input: wavenumber
 * @param tau        Input: conformal time
 * @param ppw        Input/Output: workspace containing in input the approximation scheme, the background/thermodynamics/metric quantities, and eventually the previous vector y; and in output the new vector y.
 * @return the error status
 */

int perturbations_initial_conditions(struct precision * ppr,
                                     struct background * pba,
                                     struct perturbations * ppt,
                                     int index_md,
                                     int index_ic,
                                     double k,
                                     double tau,
                                     struct perturbations_workspace * ppw
                                     ) {
  /** Summary: */

  /** --> Declare local variables */

  double a,a_prime_over_a;
  double w_fld,dw_over_da_fld,integral_fld;
  double delta_ur=0.,theta_ur=0.,shear_ur=0.,l3_ur=0.,eta=0.,delta_cdm=0.,alpha, alpha_prime;
  double delta_dr=0;
  double q,epsilon,k2;
  int index_q,n_ncdm,idx;
  double rho_r,rho_m,rho_nu,rho_m_over_rho_r, rho_cdm =0.;
  double fracnu,fracg,fracb,fraccdm = 0.,fracidm = 0.;
  double om;
  double ktau_two,ktau_three;
  double f_dr;

  double delta_tot;
  double velocity_tot;
  double s2_squared;

  /** --> For scalars */

  if (_scalars_) {

    /** - (a) compute relevant background quantities: compute rho_r,
        rho_m, rho_nu (= all relativistic except photons), and their
        ratio. */

    class_call(background_at_tau(pba,
                                 tau,
                                 normal_info,
                                 inter_normal,
                                 &(ppw->last_index_back),
                                 ppw->pvecback),
               pba->error_message,
               ppt->error_message);

    a = ppw->pvecback[pba->index_bg_a];

    a_prime_over_a = ppw->pvecback[pba->index_bg_H]*a;

    /* 8piG/3 rho_r(t_i) */
    rho_r = ppw->pvecback[pba->index_bg_rho_g];

    /* 8piG/3 rho_m(t_i) */
    rho_m = ppw->pvecback[pba->index_bg_rho_b];

    /* 8piG/3 rho_nu(t_i) (all neutrinos and collisionless relics being relativistic at that time) */
    rho_nu = 0.;

    if (pba->has_cdm == _TRUE_) {
      rho_m += ppw->pvecback[pba->index_bg_rho_cdm];
    }

    if (pba->has_idm == _TRUE_) {
      rho_m += ppw->pvecback[pba->index_bg_rho_idm];
    }

    if (pba->has_dcdm == _TRUE_) {
      rho_m += ppw->pvecback[pba->index_bg_rho_dcdm];
    }

    if (pba->has_dr == _TRUE_) {
      rho_r += ppw->pvecback[pba->index_bg_rho_dr];
      rho_nu += ppw->pvecback[pba->index_bg_rho_dr];
    }

    if (pba->has_ur == _TRUE_) {
      rho_r += ppw->pvecback[pba->index_bg_rho_ur];
      rho_nu += ppw->pvecback[pba->index_bg_rho_ur];
    }

    if (pba->has_idr == _TRUE_) {
      rho_r += ppw->pvecback[pba->index_bg_rho_idr];
      rho_nu += ppw->pvecback[pba->index_bg_rho_idr];
    }

    if (pba->has_ncdm == _TRUE_) {
      for (n_ncdm=0; n_ncdm<pba->N_ncdm; n_ncdm++){
        rho_r += ppw->pvecback[pba->index_bg_rho_ncdm1 + n_ncdm];
        rho_nu += ppw->pvecback[pba->index_bg_rho_ncdm1 + n_ncdm];
      }
    }

    class_test(rho_r == 0.,
               ppt->error_message,
               "stop to avoid division by zero");

    /* f_nu = Omega_nu(t_i) / Omega_r(t_i) */
    fracnu = rho_nu/rho_r;

    /* f_g = Omega_g(t_i) / Omega_r(t_i) */
    fracg = ppw->pvecback[pba->index_bg_rho_g]/rho_r;

    /* f_b = Omega_b(t_i) / Omega_m(t_i) */
    fracb = ppw->pvecback[pba->index_bg_rho_b]/rho_m;

    /* f_cdm = Omega_cdm(t_i) / Omega_m(t_i) */
    if (pba->has_cdm == _TRUE_)
      fraccdm = ppw->pvecback[pba->index_bg_rho_cdm]/rho_m;

    /* f_idm = Omega_idm(t_i) / Omega_m(t_i) */
    if (pba->has_idm == _TRUE_){
      fracidm =  ppw->pvecback[pba->index_bg_rho_idm]/rho_m;
    }

    /* Omega_m(t_i) / Omega_r(t_i) */
    rho_m_over_rho_r = rho_m/rho_r;

    /* omega = Omega_m(t_i) a(t_i) H(t_i) / sqrt(Omega_r(t_i))
       = Omega_m(t_0) a(t_0) H(t_0) / sqrt(Omega_r(t_0)) assuming rho_m in a-3 and rho_r in a^-4
       = (8piG/3 rho_m(t_i)) a(t_i) / sqrt(8piG/3 rho_r(t_i))  in Mpc-1
       This (a priori strange) parameter is the relevant one for expressing a
       as a function of tau during radiation and matter domination (but not DE domination).
       Indeed the exact solution of Friedmann when there is only radiation and matter in
       the universe is
       a = [H(t_0)^2 Omega_m(t_0) a(t_0)^3 / 4] x [tau^2 + 4 tau / omega]
    */
    om = a*rho_m/sqrt(rho_r);

    /* (k tau)^2, (k tau)^3 */
    ktau_two=k*k*tau*tau;
    ktau_three=k*tau*ktau_two;


    /* curvature-dependent factors */

    s2_squared = 1.-3.*pba->K/k/k;

    /** - (b) starts by setting everything in synchronous gauge. If
        another gauge is needed, we will perform a gauge
        transformation below. */

    /** - --> (b.1.) adiabatic */

    if ((ppt->has_ad == _TRUE_) && (index_ic == ppt->index_ic_ad)) {

      /* The following formulas are valid at leading order in
         (k*tau) and (om*tau), and order zero in
         tight-coupling. Identical to first order terms in CRS,
         except for normalization (when ppr->curvature_ini=1, tau=1:
         leads to factor 1/2 difference between CRS formulas with
         beta1=0). Identical to CAMB when om set to zero in theta_g,
         theta_ur, shear_ur, tau

         In the non-flat case the relation R=eta is still valid
         outside the horizon for adiabatic IC. Hence eta is still
         set to ppr->curvature_ini at leading order.  Factors s2
         appear through the solution of Einstein equations and
         equations of motion. */

      /* photon density */
      ppw->pv->y[ppw->pv->index_pt_delta_g] = - ktau_two/3. * (1.-om*tau/5.)
        * ppr->curvature_ini * s2_squared;

      /* photon velocity */
      ppw->pv->y[ppw->pv->index_pt_theta_g] = - k*ktau_three/36. * (1.-3.*(1.+5.*fracb-fracnu)/20./(1.-fracnu)*om*tau)
        * ppr->curvature_ini * s2_squared;

      /* tighly-coupled baryons */
      ppw->pv->y[ppw->pv->index_pt_delta_b] = 3./4.*ppw->pv->y[ppw->pv->index_pt_delta_g]; /* baryon density */
      ppw->pv->y[ppw->pv->index_pt_theta_b] = ppw->pv->y[ppw->pv->index_pt_theta_g]; /* baryon velocity */

      if (pba->has_cdm == _TRUE_) {
        ppw->pv->y[ppw->pv->index_pt_delta_cdm] = 3./4.*ppw->pv->y[ppw->pv->index_pt_delta_g]; /* cdm density */
        /* cdm velocity vanishes in the synchronous gauge */
      }

      /* interacting dark matter */
      if (pba->has_idm == _TRUE_) {
        ppw->pv->y[ppw->pv->index_pt_delta_idm] = 3./4.*ppw->pv->y[ppw->pv->index_pt_delta_g]; /* idm density */
        ppw->pv->y[ppw->pv->index_pt_theta_idm] = ppw->pv->y[ppw->pv->index_pt_theta_g];
      }

      if (pba->has_dcdm == _TRUE_) {
        ppw->pv->y[ppw->pv->index_pt_delta_dcdm] = 3./4.*ppw->pv->y[ppw->pv->index_pt_delta_g]; /* dcdm density */
        /* dcdm velocity velocity vanishes initially in the synchronous gauge */

      }

      /* fluid (assumes wa=0, if this is not the case the
         fluid will catch anyway the attractor solution) */
      if (pba->has_fld == _TRUE_) {

        class_call(background_w_fld(pba,a,&w_fld,&dw_over_da_fld,&integral_fld), pba->error_message, ppt->error_message);

        if (pba->use_ppf == _FALSE_) {
          ppw->pv->y[ppw->pv->index_pt_delta_fld] = - ktau_two/4.*(1.+w_fld)*(4.-3.*pba->cs2_fld)/(4.-6.*w_fld+3.*pba->cs2_fld) * ppr->curvature_ini * s2_squared; /* from 1004.5509 */ //TBC: curvature

          ppw->pv->y[ppw->pv->index_pt_theta_fld] = - k*ktau_three/4.*pba->cs2_fld/(4.-6.*w_fld+3.*pba->cs2_fld) * ppr->curvature_ini * s2_squared; /* from 1004.5509 */ //TBC:curvature
        }
        /* if use_ppf == _TRUE_, y[ppw->pv->index_pt_Gamma_fld] will be automatically set to zero, and this is what we want (although one could probably work out some small nonzero initial conditions: TODO) */
      }

      if (pba->has_scf == _TRUE_) {
        /** - ---> Canonical field (solving for the perturbations):
         *  initial perturbations set to zero, they should reach the attractor soon enough.
         *  - --->  TODO: Incorporate the attractor IC from 1004.5509.
         *  delta_phi \f$ = -(a/k)^2/\phi'(\rho + p)\theta \f$,
         *  delta_phi_prime \f$ = a^2/\phi' \f$ (delta_rho_phi + V'delta_phi),
         *  and assume theta, delta_rho as for perfect fluid
         *  with \f$ c_s^2 = 1 \f$ and w = 1/3 (ASSUMES radiation TRACKING)
         */

        ppw->pv->y[ppw->pv->index_pt_phi_scf] = 0.;
        /*  a*a/k/k/ppw->pvecback[pba->index_bg_phi_prime_scf]*k*ktau_three/4.*1./(4.-6.*(1./3.)+3.*1.) * (ppw->pvecback[pba->index_bg_rho_scf] + ppw->pvecback[pba->index_bg_p_scf])* ppr->curvature_ini * s2_squared; */

        ppw->pv->y[ppw->pv->index_pt_phi_prime_scf] = 0.;
        /* delta_fld expression * rho_scf with the w = 1/3, c_s = 1
           a*a/ppw->pvecback[pba->index_bg_phi_prime_scf]*( - ktau_two/4.*(1.+1./3.)*(4.-3.*1.)/(4.-6.*(1/3.)+3.*1.)*ppw->pvecback[pba->index_bg_rho_scf] - ppw->pvecback[pba->index_bg_dV_scf]*ppw->pv->y[ppw->pv->index_pt_phi_scf])* ppr->curvature_ini * s2_squared; */
      }

      /* all relativistic relics: ur, early ncdm, dr */

      if ((pba->has_ur == _TRUE_) || (pba->has_ncdm == _TRUE_) || (pba->has_dr == _TRUE_) || (pba->has_idr == _TRUE_)) {

        delta_ur = ppw->pv->y[ppw->pv->index_pt_delta_g]; /* density of ultra-relativistic neutrinos/relics */

        /* velocity of ultra-relativistic neutrinos/relics */ //TBC
        theta_ur = - k*ktau_three/36./(4.*fracnu+15.) * (4.*fracnu+11.+12.*s2_squared-3.*(8.*fracnu*fracnu+50.*fracnu+275.)/20./(2.*fracnu+15.)*tau*om) * ppr->curvature_ini * s2_squared;

        shear_ur = ktau_two/(45.+12.*fracnu) * (3.*s2_squared-1.) * (1.+(4.*fracnu-5.)/4./(2.*fracnu+15.)*tau*om) * ppr->curvature_ini;//TBC /s2_squared; /* shear of ultra-relativistic neutrinos/relics */  //TBC:0

        l3_ur = ktau_three*2./7./(12.*fracnu+45.)* ppr->curvature_ini;//TBC

        if (pba->has_dr == _TRUE_) delta_dr = delta_ur;
      }

      /* synchronous metric perturbation eta */
      //eta = ppr->curvature_ini * (1.-ktau_two/12./(15.+4.*fracnu)*(5.+4.*fracnu - (16.*fracnu*fracnu+280.*fracnu+325)/10./(2.*fracnu+15.)*tau*om)) /  s2_squared;
      //eta = ppr->curvature_ini * s2_squared * (1.-ktau_two/12./(15.+4.*fracnu)*(15.*s2_squared-10.+4.*s2_squared*fracnu - (16.*fracnu*fracnu+280.*fracnu+325)/10./(2.*fracnu+15.)*tau*om));
      eta = ppr->curvature_ini * (1.-ktau_two/12./(15.+4.*fracnu)*(5.+4.*s2_squared*fracnu - (16.*fracnu*fracnu+280.*fracnu+325)/10./(2.*fracnu+15.)*tau*om));

    }

    /* isocurvature initial conditions taken from Bucher, Moodely,
       Turok 99, with just a different normalization convention for
       tau and the scale factor. [k tau] from BMT99 is left invariant
       because it is the ratio [k/aH]. But [Omega_i,0 tau] from BMT99
       must be replaced by [frac_i*om*tau/4]. Some doubts remain about
       the niv formulas, that should be recheked at some point. We
       also checked that for bi,cdi,nid, everything coincides exactly
       with the CAMB formulas. */

    /** - --> (b.2.) Cold dark matter Isocurvature */

    if ((ppt->has_cdi == _TRUE_) && (index_ic == ppt->index_ic_cdi)) {

      class_test((pba->has_idr == _TRUE_),
                 ppt->error_message,
                 "only adiabatic ic in presence of interacting dark radiation");

      class_test(pba->has_cdm == _FALSE_,
                 ppt->error_message,
                 "not consistent to ask for CDI in absence of CDM!");

      class_test((pba->has_idm == _TRUE_),
                 ppt->error_message,
                 "only adiabatic ic in presence of interacting dark matter");
      ppw->pv->y[ppw->pv->index_pt_delta_g] = ppr->entropy_ini*fraccdm*om*tau*(-2./3.+om*tau/4.);
      ppw->pv->y[ppw->pv->index_pt_theta_g] = -ppr->entropy_ini*fraccdm*om*ktau_two/12.;

      ppw->pv->y[ppw->pv->index_pt_delta_b] = 3./4.*ppw->pv->y[ppw->pv->index_pt_delta_g];
      ppw->pv->y[ppw->pv->index_pt_theta_b] = ppw->pv->y[ppw->pv->index_pt_theta_g];

      ppw->pv->y[ppw->pv->index_pt_delta_cdm] = ppr->entropy_ini+3./4.*ppw->pv->y[ppw->pv->index_pt_delta_g];

      if ((pba->has_ur == _TRUE_) || (pba->has_ncdm == _TRUE_)) {

        delta_ur = ppw->pv->y[ppw->pv->index_pt_delta_g];
        theta_ur = ppw->pv->y[ppw->pv->index_pt_theta_g];
        shear_ur = -ppr->entropy_ini*fraccdm*ktau_two*tau*om/6./(2.*fracnu+15.);

      }

      eta = -ppr->entropy_ini*fraccdm*om*tau*(1./6.-om*tau/16.);

    }

    /** - --> (b.3.) Baryon Isocurvature */

    if ((ppt->has_bi == _TRUE_) && (index_ic == ppt->index_ic_bi)) {

      class_test((pba->has_idr == _TRUE_),
                 ppt->error_message,
                 "only adiabatic ic in presence of interacting dark radiation");

      ppw->pv->y[ppw->pv->index_pt_delta_g] = ppr->entropy_ini*fracb*om*tau*(-2./3.+om*tau/4.);
      ppw->pv->y[ppw->pv->index_pt_theta_g] = -ppr->entropy_ini*fracb*om*ktau_two/12.;

      ppw->pv->y[ppw->pv->index_pt_delta_b] = ppr->entropy_ini+3./4.*ppw->pv->y[ppw->pv->index_pt_delta_g];
      ppw->pv->y[ppw->pv->index_pt_theta_b] = ppw->pv->y[ppw->pv->index_pt_theta_g];

      if (pba->has_cdm == _TRUE_) {

        ppw->pv->y[ppw->pv->index_pt_delta_cdm] = 3./4.*ppw->pv->y[ppw->pv->index_pt_delta_g];

      }

      if ((pba->has_ur == _TRUE_) || (pba->has_ncdm == _TRUE_)) {

        delta_ur = ppw->pv->y[ppw->pv->index_pt_delta_g];
        theta_ur = ppw->pv->y[ppw->pv->index_pt_theta_g];
        shear_ur = -ppr->entropy_ini*fracb*ktau_two*tau*om/6./(2.*fracnu+15.);

      }

      eta = -ppr->entropy_ini*fracb*om*tau*(1./6.-om*tau/16.);

    }

    /** - --> (b.4.) Neutrino density Isocurvature */

    if ((ppt->has_nid == _TRUE_) && (index_ic == ppt->index_ic_nid)) {

      class_test((pba->has_ur == _FALSE_) && (pba->has_ncdm == _FALSE_),
                 ppt->error_message,
                 "not consistent to ask for NID in absence of ur or ncdm species!");

      class_test((pba->has_idr == _TRUE_),
                 ppt->error_message,
                 "only adiabatic ic in presence of interacting dark radiation");

      ppw->pv->y[ppw->pv->index_pt_delta_g] = ppr->entropy_ini*fracnu/fracg*(-1.+ktau_two/6.);
      ppw->pv->y[ppw->pv->index_pt_theta_g] = -ppr->entropy_ini*fracnu/fracg*k*k*tau*(1./4.-fracb/fracg*3./16.*om*tau);

      ppw->pv->y[ppw->pv->index_pt_delta_b] = ppr->entropy_ini*fracnu/fracg/8.*ktau_two;
      ppw->pv->y[ppw->pv->index_pt_theta_b] = ppw->pv->y[ppw->pv->index_pt_theta_g];

      if (pba->has_cdm == _TRUE_) {

        ppw->pv->y[ppw->pv->index_pt_delta_cdm] = -ppr->entropy_ini*fracnu*fracb/fracg/80.*ktau_two*om*tau;

      }

      delta_ur = ppr->entropy_ini*(1.-ktau_two/6.);
      theta_ur = ppr->entropy_ini*k*k*tau/4.;
      shear_ur = ppr->entropy_ini*ktau_two/(4.*fracnu+15.)/2.;

      eta = -ppr->entropy_ini*fracnu/(4.*fracnu+15.)/6.*ktau_two;

    }

    /** - --> (b.5.) Neutrino velocity Isocurvature */

    if ((ppt->has_niv == _TRUE_) && (index_ic == ppt->index_ic_niv)) {

      class_test((pba->has_ur == _FALSE_) && (pba->has_ncdm == _FALSE_),
                 ppt->error_message,
                 "not consistent to ask for NIV in absence of ur or ncdm species!");

      class_test((pba->has_idr == _TRUE_),
                 ppt->error_message,
                 "only adiabatic ic in presence of interacting dark radiation");

      ppw->pv->y[ppw->pv->index_pt_delta_g] = ppr->entropy_ini*k*tau*fracnu/fracg*
        (1. - 3./16.*fracb*(2.+fracg)/fracg*om*tau); /* small diff wrt camb */

      ppw->pv->y[ppw->pv->index_pt_theta_g] = ppr->entropy_ini*fracnu/fracg*3./4.*k*
        (-1.+3./4.*fracb/fracg*om*tau+3./16.*om*om*tau*tau*fracb/fracg/fracg*(fracg-3.*fracb)+ktau_two/6.);

      ppw->pv->y[ppw->pv->index_pt_delta_b] = 3./4.*ppw->pv->y[ppw->pv->index_pt_delta_g]; /* small diff wrt camb */
      ppw->pv->y[ppw->pv->index_pt_theta_b] = ppw->pv->y[ppw->pv->index_pt_theta_g];

      if (pba->has_cdm == _TRUE_) {

        ppw->pv->y[ppw->pv->index_pt_delta_cdm] = -ppr->entropy_ini*9./64.*fracnu*fracb/fracg*k*tau*om*tau;

      }

      delta_ur = -ppr->entropy_ini*k*tau*(1.+3./16.*fracb*fracnu/fracg*om*tau);  /* small diff wrt camb */
      theta_ur = ppr->entropy_ini*3./4.*k*(1. - 1./6.*ktau_two*(4.*fracnu+9.)/(4.*fracnu+5.));
      shear_ur = ppr->entropy_ini/(4.*fracnu+15.)*k*tau*(1. + 3.*om*tau*fracnu/(4.*fracnu+15.)); /* small diff wrt camb */

      eta = ppr->entropy_ini*fracnu*k*tau*(-1./(4.*fracnu+5.) + (-3./64.*fracb/fracg+15./4./(4.*fracnu+15.)/(4.*fracnu+5.)*om*tau)); /* small diff wrt camb */

    }

    /** - (c) If the needed gauge is really the synchronous gauge, we need to affect the previously computed value of eta to the actual variable eta */

    if (ppt->gauge == synchronous) {

      ppw->pv->y[ppw->pv->index_pt_eta] = eta;
    }


    /** - (d) If the needed gauge is the newtonian gauge, we must compute alpha and then perform a gauge transformation for each variable */

    if (ppt->gauge == newtonian) {

      /* alpha is like in Ma & Bertschinger: (h'+6 eta')/(2k^2). We obtain it from the first two Einstein equations:

         alpha = [eta + 3/2 (a'/a)^2 (delta_rho/rho_c) / k^2 /s_2^2 + 3/2 (a'/a)^3 3 ((rho+p)theta/rho_c) / k^4 / s_2^2] / (a'/a)
         = [eta + 3/2 (a'/a)^2 / k^2 /s_2^2 {delta_tot + 3 (a'/a) /k^2 velocity_tot}] / (a'/a)

         with

         delta_tot = (delta_rho/rho_c)
         = [rho_r delta_r + rho_m delta_m] / (rho_r + rho_m)
         = [delta_r + (rho_m/rho_r) delta_m] / (1 + rho_m/rho_r)
         = [(f_g delta_g + f_nu delta_nu) + (rho_m/rho_r) (f_b delta_b + f_cdm delta_cdm)] / (1 + rho_m/rho_r)

         velocity_tot = ((rho+p)theta/rho_c)
         = [(4/3) rho_r theta_r + rho_m theta_m] / (rho_r + rho_m)
         = [(4/3) theta_r + (rho_m/rho_r) theta_m] / (1 + rho_m/rho_r)
         = [(4/3) (f_g theta_g + f_nu theta_nu) + (rho_m/rho_r) (f_b delta_b + f_cdm 0)] / (1 + rho_m/rho_r)
      */

      if (pba->has_cdm == _TRUE_) {
        delta_cdm += ppw->pvecback[pba->index_bg_rho_cdm] * ppw->pv->y[ppw->pv->index_pt_delta_cdm];
        rho_cdm += ppw->pvecback[pba->index_bg_rho_cdm];
      }
      if (pba->has_idm == _TRUE_) {
        delta_cdm += ppw->pvecback[pba->index_bg_rho_idm] * ppw->pv->y[ppw->pv->index_pt_delta_idm];
        rho_cdm += ppw->pvecback[pba->index_bg_rho_idm];
      }
      if (pba->has_dcdm == _TRUE_){
        delta_cdm += ppw->pvecback[pba->index_bg_rho_dcdm] * ppw->pv->y[ppw->pv->index_pt_delta_dcdm];
        rho_cdm += ppw->pvecback[pba->index_bg_rho_dcdm];
      }


      if (rho_cdm > 0 ) {
        delta_cdm /= rho_cdm;
        fraccdm = rho_cdm/rho_m;
      }

      // note: if there are no neutrinos, fracnu, delta_ur and theta_ur below will consistently be zero.

      delta_tot = (fracg*ppw->pv->y[ppw->pv->index_pt_delta_g]+fracnu*delta_ur+rho_m_over_rho_r*(fracb*ppw->pv->y[ppw->pv->index_pt_delta_b]+fraccdm*delta_cdm))/(1.+rho_m_over_rho_r);

      velocity_tot = ((4./3.)*(fracg*ppw->pv->y[ppw->pv->index_pt_theta_g]+fracnu*theta_ur) + rho_m_over_rho_r*fracb*ppw->pv->y[ppw->pv->index_pt_theta_b])/(1.+rho_m_over_rho_r);

      if (ppt->has_idm_dr == _TRUE_ ) {
        delta_tot += rho_m_over_rho_r*fracidm*ppw->pv->y[ppw->pv->index_pt_delta_idm]/(1.+rho_m_over_rho_r);
        velocity_tot += rho_m_over_rho_r*fracidm*ppw->pv->y[ppw->pv->index_pt_theta_idm]/(1.+rho_m_over_rho_r);
      }

      alpha = (eta + 3./2.*a_prime_over_a*a_prime_over_a/k/k/s2_squared*(delta_tot + 3.*a_prime_over_a/k/k*velocity_tot))/a_prime_over_a;

      ppw->pv->y[ppw->pv->index_pt_phi] = eta - a_prime_over_a*alpha;

      ppw->pv->y[ppw->pv->index_pt_delta_g] -= 4.*a_prime_over_a*alpha;
      ppw->pv->y[ppw->pv->index_pt_theta_g] += k*k*alpha;

      ppw->pv->y[ppw->pv->index_pt_delta_b] -= 3.*a_prime_over_a*alpha;
      ppw->pv->y[ppw->pv->index_pt_theta_b] += k*k*alpha;

      if (pba->has_cdm == _TRUE_) {
        ppw->pv->y[ppw->pv->index_pt_delta_cdm] -= 3.*a_prime_over_a*alpha;
        ppw->pv->y[ppw->pv->index_pt_theta_cdm] = k*k*alpha;
      }

      if (pba->has_idm == _TRUE_){
        ppw->pv->y[ppw->pv->index_pt_delta_idm] -= 3.*a_prime_over_a*alpha;
        ppw->pv->y[ppw->pv->index_pt_theta_idm] += k*k*alpha;
      }

      if (pba->has_dcdm == _TRUE_) {
        ppw->pv->y[ppw->pv->index_pt_delta_dcdm] -= (3.*a_prime_over_a + a*pba->Gamma_dcdm)*alpha;
        ppw->pv->y[ppw->pv->index_pt_theta_dcdm] = k*k*alpha;
      }

      /* fluid */
      if ((pba->has_fld == _TRUE_) && (pba->use_ppf == _FALSE_)) {

        class_call(background_w_fld(pba,a,&w_fld,&dw_over_da_fld,&integral_fld), pba->error_message, ppt->error_message);

        ppw->pv->y[ppw->pv->index_pt_delta_fld] -= 3*(1.+w_fld)*a_prime_over_a*alpha;
        ppw->pv->y[ppw->pv->index_pt_theta_fld] += k*k*alpha;
      }

      /* scalar field: check */
      if (pba->has_scf == _TRUE_) {
        alpha_prime = 0.0;
        /* - 2. * a_prime_over_a * alpha + eta
           - 4.5 * (a2/k2) * ppw->rho_plus_p_shear; */

        ppw->pv->y[ppw->pv->index_pt_phi_scf] += alpha*ppw->pvecback[pba->index_bg_phi_prime_scf];
        ppw->pv->y[ppw->pv->index_pt_phi_prime_scf] +=
          (-2.*a_prime_over_a*alpha*ppw->pvecback[pba->index_bg_phi_prime_scf]
           -a*a* dV_scf(pba,ppw->pvecback[pba->index_bg_phi_scf])*alpha
           +ppw->pvecback[pba->index_bg_phi_prime_scf]*alpha_prime);
      }

      if ((pba->has_ur == _TRUE_) || (pba->has_ncdm == _TRUE_) || (pba->has_dr == _TRUE_)  || (pba->has_idr == _TRUE_)) {

        delta_ur -= 4.*a_prime_over_a*alpha;
        theta_ur += k*k*alpha;
        /* shear and l3 are gauge invariant */

        if (pba->has_dr == _TRUE_)
          delta_dr += (-4.*a_prime_over_a + a*pba->Gamma_dcdm*ppw->pvecback[pba->index_bg_rho_dcdm]/ppw->pvecback[pba->index_bg_rho_dr])*alpha;

      }

    } /* end of gauge transformation to newtonian gauge */

      /** - (e) In any gauge, we should now implement the relativistic initial conditions in ur and ncdm variables */

    if (pba->has_ur == _TRUE_) {

      ppw->pv->y[ppw->pv->index_pt_delta_ur] = delta_ur;

      ppw->pv->y[ppw->pv->index_pt_theta_ur] = theta_ur;

      ppw->pv->y[ppw->pv->index_pt_shear_ur] = shear_ur;

      ppw->pv->y[ppw->pv->index_pt_l3_ur] = l3_ur;

    }

    if (pba->has_idr == _TRUE_){
      if (ppw->approx[ppw->index_ap_rsa_idr]==(int)rsa_idr_off) { // TODO: check if needed?
        ppw->pv->y[ppw->pv->index_pt_delta_idr] = delta_ur;
        ppw->pv->y[ppw->pv->index_pt_theta_idr] = theta_ur;
        if (ppt->idr_nature == idr_free_streaming){
          if (ppw->approx[ppw->index_ap_tca_idm_dr] == (int)tca_idm_dr_off){
            ppw->pv->y[ppw->pv->index_pt_shear_idr] = shear_ur;
            ppw->pv->y[ppw->pv->index_pt_l3_idr] = l3_ur;
          }
        }
      }
    }

    if (pba->has_ncdm == _TRUE_) {
      idx = ppw->pv->index_pt_psi0_ncdm1;
      for (n_ncdm=0; n_ncdm < pba->N_ncdm; n_ncdm++){

        for (index_q=0; index_q < ppw->pv->q_size_ncdm[n_ncdm]; index_q++) {

          q = pba->q_ncdm[n_ncdm][index_q];

          epsilon = sqrt(q*q+a*a*pba->M_ncdm[n_ncdm]*pba->M_ncdm[n_ncdm]);

          ppw->pv->y[idx] = -0.25 * delta_ur * pba->dlnf0_dlnq_ncdm[n_ncdm][index_q];

          ppw->pv->y[idx+1] =  -epsilon/3./q/k*theta_ur* pba->dlnf0_dlnq_ncdm[n_ncdm][index_q];

          ppw->pv->y[idx+2] = -0.5 * shear_ur * pba->dlnf0_dlnq_ncdm[n_ncdm][index_q];

          ppw->pv->y[idx+3] = -0.25 * l3_ur * pba->dlnf0_dlnq_ncdm[n_ncdm][index_q];

          //Jump to next momentum bin:
          idx += (ppw->pv->l_max_ncdm[n_ncdm]+1);

        }
      }
    }

    if (pba->has_dr == _TRUE_) {

      f_dr = pow(pow(a,2)/pba->H0,2)*ppw->pvecback[pba->index_bg_rho_dr];

      ppw->pv->y[ppw->pv->index_pt_F0_dr] = delta_dr*f_dr;

      ppw->pv->y[ppw->pv->index_pt_F0_dr+1] = 4./(3.*k)*theta_ur*f_dr;

      ppw->pv->y[ppw->pv->index_pt_F0_dr+2] = 2.*shear_ur*f_dr;

      ppw->pv->y[ppw->pv->index_pt_F0_dr+3] = l3_ur*f_dr;

    }

  }
  /** --> For tensors */

  if (_tensors_) {

    /** tensor initial conditions take into account the fact that
        scalar (resp. tensor) \f$ C_l\f$'s are related to the real space
        power spectrum of curvature (resp. of the tensor part of
        metric perturbations)

        \f[ <R(x) R(x)>  \ \  \sum_{ij} <h_{ij}(x) h^{ij}(x)> \f]

        In momentum space it is conventional to use the modes R(k)
        and h(k) where the quantity h obeying to the equation of
        propagation:

        \f[ h'' + \frac{2a'}{a} h + [k2+2K] h = 12\pi Ga2 (\rho+p) \sigma = 8\pi Ga2 p \pi \f]

        and the power spectra in real space and momentum space are related through:

        \f[ <R(x) R(x)> = \int \frac{dk}{k} \left[ \frac{k^3}{2\pi^2} <R(k)R(k)^*>\right] = \int \frac{dk}{k} \mathcal{P}_R(k) \f]
        \f[\sum_{ij} <h_{ij}(x) h^{ij}(x)> = \frac{dk}{k} \left[ \frac{k^3}{2\pi^2} F\left(\frac{k^2}{K}\right) <h(k)h(k)^*>\right] = \int \frac{dk}{k} F\left(\frac{k^2}{K}\right) \mathcal{P}_h(k) \f]

        where \f$ \mathcal{P}_R\f$ and \f$ \mathcal{P}_h\f$ are the dimensionless spectrum of
        curvature R, and F is a function of k2/K, where K is the curvature
        parameter. F is equal to one in flat space (K=0), and coming
        from the contraction of the laplacian eigentensor \f$ Q_{ij}\f$ with
        itself. We will give F explicitly below.

        Similarly the scalar (S) and tensor (T) \f$ C_l\f$'s are given by

        \f[ C_l^S = 4\pi \int \frac{dk}{k} [\Delta_l^S(q)]^2 \mathcal{P}_R(k) \f]
        \f[ C_l^T = 4\pi \int \frac{dk}{k} [\Delta_l^T(q)]^2 F\left(\frac{k^2}{K}\right) \mathcal{P}_h(k) \f]

        The usual convention for the tensor-to-scalar ratio
        \f$ r = A_t / A_s \f$ at pivot scale
        = 16 epsilon in single-field inflation
        is such that for constant \f$ \mathcal{P}_R(k)\f$ and \f$ \mathcal{P}_h(k)\f$,

        \f[ r = 6 \frac{\mathcal{P}_h(k)}{\mathcal{P}_R(k)} \f]

        so

        \f[ \mathcal{P}_h(k) = \frac{\mathcal{P}_R(k) r}{6} = \frac{A_s r}{6} = \frac{A_t}{6} \f]

        A priori it would make sense to say that for a power-law
        primordial spectrum there is an extra factor \f$ (k/k_{pivot})^{n_t} \f$
        (and eventually running and so on and so forth...)

        However it has been shown that the minimal models of
        inflation in a negatively curved bubble lead to
        \f$ \mathcal{P}_h(k)=\tanh(\pi*\nu/2)\f$. In open models it is customary to
        define the tensor tilt in a non-flat universe as a deviation
        from this behavior rather than from true scale-invariance in
        the above sense.

        Hence we should have

        \f[ \mathcal{P}_h(k) = \frac{A_t}{6} [ \tanh(\pi*\frac{\nu}{2})]  (k/k_{pivot})^{(n_t+...)}\f]

        where the brackets \f[ [...] \f] mean "if K<0"

        Then

        \f[ C_l^T = 4\pi \int \frac{dk}{k} [\Delta_l^T(q)]^2 F\left(\frac{k^2}{K}\right) \frac{A_t}{6} [\tanh(\pi*\frac{\nu}{2})] (k/k_{pivot})^{(n_t+...)} \f]

        In the code, it is then a matter of choice to write:

        - In the primordial module: \f$ \mathcal{P}_h(k) = \frac{A_t}{6} \tanh{(\pi*\frac{\nu}{2})} (k/k^*)^{n_T}\f$
        - In the perturbation initial conditions: \f$ h = 1\f$
        - In the harmonic module: \f$ C_l^T = \frac{4}{\pi} \int \frac{dk}{k} [\Delta_l^T(q)]^2 F\left(\frac{k^2}{K}\right) \mathcal{P}_h(k) \f$

        or:

        - In the primordial module: \f$ \mathcal{P}_h(k) = A_t (k/k^*)^{n_T} \f$
        - In the perturbation initial conditions: \f$ h = \sqrt{[F\left(\frac{k^2}{K}\right) / 6] \tanh{(\pi*\frac{\nu}{2})}} \f$
        - In the harmonic module: \f$ C_l^T = \frac{4}{\pi} \int \frac{dk}{k} [\Delta_l^T(q)]^2 \mathcal{P}_h(k) \f$

        We choose this last option, such that the primordial and
        harmonic module differ minimally in flat and non-flat space. Then we must impose

        \f[ h = \sqrt{\left(\frac{F}{6}\right) \tanh{(\pi*\frac{\nu}{2})}} \f]

        The factor F is found to be given by:

        \f[ \sum_{ij}<h_{ij}(x) h^{ij}(x)> = \int \frac{dk}{k}  \frac{k2(k2-K)}{(k2+3K)(k2+2K)} \mathcal{P}_h(k) \f]

        Introducing as usual \f$ q2 = k2 - 3K \f$  and using qdq = kdk this gives

        \f[ \sum_{ij}<h_{ij}(x) h^{ij}(x)> = \int \frac{dk}{k} \frac{(q2-3K)(q2-4K)}{q2(q2-K)} \mathcal{P}_h(k) \f]

        Using qdq = kdk this is equivalent to

        \f[ \sum_{ij}<h_{ij}(x) h^{ij}(x)> = \int \frac{dq}{q} \frac{q2-4K}{q2-K} \mathcal{P}_h(k(q)) \f]

        Finally, introducing \f$ \nu=q/\sqrt{|K|}\f$ and sgnK=SIGN(k)\f$=\pm 1\f$, this could also be written

        \f[ \sum_{ij}<h_{ij}(x) h^{ij}(x)> = \int \frac{d\nu}{\nu} \frac{(\nu2-4sgnK)}{(\nu2-sgnK)} \mathcal{P}_h(k(\nu)) \f]

        Equation (43,44) of Hu, Seljak, White, Zaldarriaga is
        equivalent to absorbing the above factor
        \f$ (\nu2-4sgnK)/(\nu2-sgnK)\f$ in the definition of the primordial
        spectrum. Since the initial condition should be written in terms of k rather than nu, they should read

        \f[ h = \sqrt{ [k2(k2-K)]/[(k2+3K)(k2+2K)] / 6 * \tanh{(\pi*\frac{\nu}{2})} } \f]

        We leave the freedom to multiply by an arbitrary number
        ppr->gw_ini. The standard convention corresponding to
        standard definitions of r, \f$ A_T\f$, \f$ n_T\f$ is however ppr->gw_ini=1.
        *
        */

    if (index_ic == ppt->index_ic_ten) {
      ppw->pv->y[ppw->pv->index_pt_gw] = ppr->gw_ini/_SQRT6_;
    }

    k2 = k*k;

    if (pba->sgnK != 0) {
      ppw->pv->y[ppw->pv->index_pt_gw] *= sqrt(k2*(k2-pba->K)/(k2+3.*pba->K)/(k2+2.*pba->K));
    }

    if (pba->sgnK == -1) {
      if (k*k+3*pba->K >= 0.) {
        ppw->pv->y[ppw->pv->index_pt_gw] *= sqrt(tanh(_PI_/2.*sqrt(k2+3*pba->K)/sqrt(-pba->K)));
      }
      else {
        ppw->pv->y[ppw->pv->index_pt_gw] = 0.;
      }
    }

  }

  return _SUCCESS_;
}

/**
 * Evaluate background/thermodynamics at \f$ \tau \f$, infer useful flags / time scales for integrating perturbations.
 *
 * Evaluate background quantities at \f$ \tau \f$, as well as thermodynamics for scalar mode; infer useful flags and time scales for integrating the perturbations:
 * - check whether tight-coupling approximation is needed.
 * - check whether radiation (photons, massless neutrinos...) perturbations are needed.
 * - choose step of integration: step = ppr->perturbations_integration_stepsize * min_time_scale, where min_time_scale = smallest time scale involved in the equations. There are three time scales to compare:
 *     -# that of recombination, \f$ \tau_c = 1/\kappa' \f$
 *     -# Hubble time scale, \f$ \tau_h = a/a' \f$
 *     -# Fourier mode, \f$ \tau_k = 1/k \f$
 *
 * So, in general, min_time_scale = \f$ \min(\tau_c, \tau_b, \tau_h, \tau_k) \f$.
 *
 * However, if \f$ \tau_c \ll \tau_h \f$ and \f$ \tau_c
 * \ll \tau_k \f$, we can use the tight-coupling regime for photons
 * and write equations in such way that the time scale \f$
 * \tau_c \f$ becomes irrelevant (no effective mass term in \f$
 * 1/\tau_c \f$).  Then, the smallest
 * scale in the equations is only \f$ \min(\tau_h, \tau_k) \f$.
 * In practise, it is sufficient to use only the condition \f$ \tau_c \ll \tau_h \f$.
 *
 * Also, if \f$ \rho_{matter} \gg \rho_{radiation} \f$ and \f$ k \gg
 * aH \f$, we can switch off radiation perturbations (i.e. switch on
 * the free-streaming approximation) and then the smallest scale is
 * simply \f$ \tau_h \f$.
 *
 * @param ppr        Input: pointer to precision structure
 * @param pba        Input: pointer to background structure
 * @param pth        Input: pointer to thermodynamics structure
 * @param ppt        Input: pointer to the perturbation structure
 * @param index_md   Input: index of mode under consideration (scalar/.../tensor)
 * @param k          Input: wavenumber
 * @param tau        Input: conformal time
 * @param ppw        Input/Output: in output contains the approximation to be used at this time
 * @return the error status
 */

int perturbations_approximations(
                                 struct precision * ppr,
                                 struct background * pba,
                                 struct thermodynamics * pth,
                                 struct perturbations * ppt,
                                 int index_md,
                                 double k,
                                 double tau,
                                 struct perturbations_workspace * ppw
                                 ) {
  /** Summary: */

  /** - define local variables */

  /* (a) time scale of Fourier mode, \f$ \tau_k = 1/k \f$ */
  double tau_k;
  /* (b) time scale of expansion, \f$ \tau_h = a/a' \f$ */
  double tau_h;
  /* (c) time scale of recombination, \f$ \tau_{\gamma} = 1/\kappa' \f$ */
  double tau_c = 0.;

  /* in case of idm_g there is a third condition for the tca, tau_c * dmu_idm_g << 1 which we need to take into account - see 1802.06589 */
  double tau_dmu_idm_g = 0., tau_dmu_idm_dr = 0.;
  /* in case of idm_b there is a fourth condition */
  double tau_R_idm_b;
  /** - compute Fourier mode time scale = \f$ \tau_k = 1/k \f$ */


  class_test(k == 0.,
             ppt->error_message,
             "stop to avoid division by zero");

  tau_k = 1./k;

  /** - evaluate background quantities with background_at_tau() and
      Hubble time scale \f$ \tau_h = a/a' \f$ */

  class_call(background_at_tau(pba,tau, normal_info, (interpolation_method)ppw->inter_mode, &(ppw->last_index_back), ppw->pvecback),
             pba->error_message,
             ppt->error_message);

  class_test(ppw->pvecback[pba->index_bg_H]*ppw->pvecback[pba->index_bg_a] == 0.,
             ppt->error_message,
             "aH=0, stop to avoid division by zero");

  tau_h = 1./(ppw->pvecback[pba->index_bg_H]*ppw->pvecback[pba->index_bg_a]);

  /** - for scalar modes: */

  if (_scalars_) {

    /** - --> (a) evaluate thermodynamical quantities with thermodynamics_at_z() */

    class_call(thermodynamics_at_z(pba,
                                   pth,
                                   1./ppw->pvecback[pba->index_bg_a]-1.,  /* redshift z=1/a-1 */
                                   (interpolation_method)ppw->inter_mode,
                                   &(ppw->last_index_thermo),
                                   ppw->pvecback,
                                   ppw->pvecthermo),
               pth->error_message,
               ppt->error_message);

    /* in case of idm_g, calculate relevant quantities */
    if (pth->has_idm_g == _TRUE_) {
      class_test(ppw->pvecthermo[pth->index_th_dmu_idm_g] == 0.,
                 ppt->error_message,
                 "dmu_idm_g = 0 - stop to avoid division by 0")
        tau_dmu_idm_g = 1./ppw->pvecthermo[pth->index_th_dmu_idm_g];
    }

    /** - ---> (b.1.) if \f$ \kappa'=0 \f$, recombination is finished; tight-coupling approximation must be off */

    if (ppw->pvecthermo[pth->index_th_dkappa] == 0.) {

      ppw->approx[ppw->index_ap_tca] = (int)tca_off;

    }

    /** - ---> (b.2.) if \f$ \kappa' \neq 0 \f$, recombination is not finished: check tight-coupling approximation */

    else {

      /** - ----> (b.2.a) compute recombination time scale for photons, \f$ \tau_{\gamma} = 1/ \kappa' \f$ */
      tau_c = 1./ppw->pvecthermo[pth->index_th_dkappa];

      class_test(tau_c < 0.,
                 ppt->error_message,
                 "tau_c = 1/kappa' should always be positive unless there is something wrong in the thermodynamics module. However you have here tau_c=%e at z=%e, conformal time=%e x_e=%e. (This could come from the interpolation of a too poorly sampled reionisation history?).\n",
                 tau_c,
                 1./ppw->pvecback[pba->index_bg_a]-1.,
                 tau,
                 ppw->pvecthermo[pth->index_th_xe]);

      /** - ----> (b.2.b) check whether tight-coupling approximation should be on */

      if ((tau_c/tau_h < ppr->tight_coupling_trigger_tau_c_over_tau_h) &&
          (tau_c/tau_k < ppr->tight_coupling_trigger_tau_c_over_tau_k)) {
        ppw->approx[ppw->index_ap_tca] = (int)tca_on;
      }
      else {
        ppw->approx[ppw->index_ap_tca] = (int)tca_off;
      }


      /* for idm_g there is a third condition for the tca */
      if (pth->has_idm_g == _TRUE_) {
        if (tau_c/tau_dmu_idm_g >= ppr->tight_coupling_trigger_tau_c_over_tau_dmu_idm_g) {
          if (ppw->approx[ppw->index_ap_tca] == (int)tca_on && ppt->perturbations_verbose > 2)   {
            printf("switched off tca for k = %5.e because of idm_g at tau = %5.e\n", k, tau);
          }
          ppw->approx[ppw->index_ap_tca] = (int)tca_off;
        }
      }
    }
    /* for idm_b there is a fourth condition for the tca */
    if (pth->has_idm_b == _TRUE_) {
      tau_R_idm_b = 1./ppw->pvecthermo[pth->index_th_R_idm_b];
      if (tau_c/tau_R_idm_b >= ppr->tight_coupling_trigger_tau_c_over_tau_R_idm_b) {
        if (ppw->approx[ppw->index_ap_tca] == (int)tca_on && ppt->perturbations_verbose > 2)   {
          printf("switched off tca for k = %5.e because of idm_b at tau = %5.e\n", k, tau);
        }
        ppw->approx[ppw->index_ap_tca] = (int)tca_off;
      }
    }

    if (pth->has_idm_dr == _TRUE_){
      if (ppw->pvecthermo[pth->index_th_dmu_idm_dr] == 0.){
        ppw->approx[ppw->index_ap_tca_idm_dr] = (int)tca_idm_dr_off;
      }
      else{
        tau_dmu_idm_dr = 1./ppw->pvecthermo[pth->index_th_dmu_idm_dr];

        class_test(tau_dmu_idm_dr < 0.,
                   ppt->error_message,
                   "negative tau_idm_dr=1/dmu_idm_dr=%e at z=%e, conformal time=%e.\n",
                   tau_dmu_idm_dr,
                   1./ppw->pvecback[pba->index_bg_a]-1.,
                   tau);

        if ((tau_dmu_idm_dr / tau_h < ppr->idm_dr_tight_coupling_trigger_tau_c_over_tau_h) &&
            (tau_dmu_idm_dr / tau_k < ppr->idm_dr_tight_coupling_trigger_tau_c_over_tau_k) &&
            (pth->n_index_idm_dr>=2) && (ppt->idr_nature == idr_free_streaming)) {
          ppw->approx[ppw->index_ap_tca_idm_dr] = (int)tca_idm_dr_on;
        }
        else{
          ppw->approx[ppw->index_ap_tca_idm_dr] = (int)tca_idm_dr_off;
        }
      }
    }

    /** - --> (c) free-streaming approximations */

    if ((tau/tau_k > ppr->radiation_streaming_trigger_tau_over_tau_k) &&
        (tau > pth->tau_free_streaming) &&
        (ppr->radiation_streaming_approximation != rsa_none)) {

      ppw->approx[ppw->index_ap_rsa] = (int)rsa_on;
    }
    else {
      ppw->approx[ppw->index_ap_rsa] = (int)rsa_off;
    }

    /* interacting dark radiation free streaming approximation*/
    if (pba->has_idr == _TRUE_){

      if ((tau/tau_k > ppr->idr_streaming_trigger_tau_over_tau_k) &&
          (tau > pth->tau_idr_free_streaming) &&
          (pth->has_idm_dr == _FALSE_ || pth->n_index_idm_dr >= 2) &&
          (ppr->idr_streaming_approximation != rsa_idr_none)){

        ppw->approx[ppw->index_ap_rsa_idr] = (int)rsa_idr_on;
      }
      else{
        ppw->approx[ppw->index_ap_rsa_idr] = (int)rsa_idr_off;
      }
    }

    if (pba->has_ur == _TRUE_) {

      if ((tau/tau_k > ppr->ur_fluid_trigger_tau_over_tau_k) &&
          (ppr->ur_fluid_approximation != ufa_none)) {

        ppw->approx[ppw->index_ap_ufa] = (int)ufa_on;
      }
      else {
        ppw->approx[ppw->index_ap_ufa] = (int)ufa_off;
      }
    }

    if (pba->has_ncdm == _TRUE_) {

      if ((tau/tau_k > ppr->ncdm_fluid_trigger_tau_over_tau_k) &&
          (ppr->ncdm_fluid_approximation != ncdmfa_none)) {

        ppw->approx[ppw->index_ap_ncdmfa] = (int)ncdmfa_on;
      }
      else {
        ppw->approx[ppw->index_ap_ncdmfa] = (int)ncdmfa_off;
      }
    }
  }

  /** - for tensor modes: */

  if (_tensors_) {

    /** - --> (a) evaluate thermodynamical quantities with thermodynamics_at_z() */

    class_call(thermodynamics_at_z(pba,
                                   pth,
                                   1./ppw->pvecback[pba->index_bg_a]-1.,  /* redshift z=1/a-1 */
                                   (interpolation_method)ppw->inter_mode,
                                   &(ppw->last_index_thermo),
                                   ppw->pvecback,
                                   ppw->pvecthermo),
               pth->error_message,
               ppt->error_message);

    /** - ---> (b.1.) if \f$ \kappa'=0 \f$, recombination is finished; tight-coupling approximation must be off */

    if (ppw->pvecthermo[pth->index_th_dkappa] == 0.) {

      ppw->approx[ppw->index_ap_tca] = (int)tca_off;

    }

    /** - ---> (b.2.) if \f$ \kappa' \neq 0 \f$, recombination is not finished: check tight-coupling approximation */

    else {

      /** - ----> (b.2.a) compute recombination time scale for photons, \f$ \tau_{\gamma} = 1/ \kappa' \f$ */
      tau_c = 1./ppw->pvecthermo[pth->index_th_dkappa];

      /** - ----> (b.2.b) check whether tight-coupling approximation should be on */
      if ((tau_c/tau_h < ppr->tight_coupling_trigger_tau_c_over_tau_h) &&
          (tau_c/tau_k < ppr->tight_coupling_trigger_tau_c_over_tau_k)) {
        ppw->approx[ppw->index_ap_tca] = (int)tca_on;
      }
      else {
        ppw->approx[ppw->index_ap_tca] = (int)tca_off;
      }
    }

    if ((tau/tau_k > ppr->radiation_streaming_trigger_tau_over_tau_k) &&
        (tau > pth->tau_free_streaming) &&
        (ppr->radiation_streaming_approximation != rsa_none)) {

      ppw->approx[ppw->index_ap_rsa] = (int)rsa_on;
    }
    else {
      ppw->approx[ppw->index_ap_rsa] = (int)rsa_off;
    }
  }

  return _SUCCESS_;
}

/**
 * Compute typical timescale over which the perturbation equations
 * vary. Some integrators (e.g. Runge-Kunta) benefit from calling this
 * routine at each step in order to adapt the next step.
 *
 * This is one of the few functions in the code which is passed to the generic_integrator() routine.
 * Since generic_integrator() should work with functions passed from various modules, the format of the arguments
 * is a bit special:
 * - fixed parameters and workspaces are passed through a generic pointer.
 *   generic_integrator() doesn't know the content of this pointer.
 * - the error management is a bit special: errors are not written as usual to pth->error_message, but to a generic
 *   error_message passed in the list of arguments.
 *
 * @param tau                      Input: conformal time
 * @param parameters_and_workspace Input: fixed parameters (e.g. indices), workspace, approximation used, etc.
 * @param timescale                Output: perturbation variation timescale (given the approximation used)
 * @param error_message            Output: error message
 */

int perturbations_timescale(
                            double tau,
                            void * parameters_and_workspace,
                            double * timescale,
                            ErrorMsg error_message
                            ) {
  /** Summary: */

  /** - define local variables */

  /* (a) time scale of Fourier mode, \f$ \tau_k = 1/k \f$ */
  double tau_k;
  /* (b) time scale of expansion, \f$ \tau_h = a/a' \f$ */
  double tau_h;
  /* (c) time scale of recombination, \f$ \tau_{\gamma} = 1/\kappa' \f$ */
  double tau_c;

  /* various pointers allowing to extract the fields of the
     parameter_and_workspace input structure */
  struct perturbations_parameters_and_workspace * pppaw;
  struct background * pba;
  struct thermodynamics * pth;
  struct perturbations * ppt;
  struct perturbations_workspace * ppw;
  double * pvecback;
  double * pvecthermo;

  /** - extract the fields of the parameter_and_workspace input structure */
  pppaw = (struct perturbations_parameters_and_workspace *)parameters_and_workspace;
  pba = pppaw->pba;
  pth = pppaw->pth;
  ppt = pppaw->ppt;
  ppw = pppaw->ppw;
  pvecback = ppw->pvecback;
  pvecthermo = ppw->pvecthermo;

  /** - compute Fourier mode time scale = \f$ \tau_k = 1/k \f$ */

  class_test(pppaw->k == 0.,
             ppt->error_message,
             "stop to avoid division by zero");

  tau_k = 1./pppaw->k;

  /** - evaluate background quantities with background_at_tau() and
      Hubble time scale \f$ \tau_h = a/a' \f$ */

  class_call(background_at_tau(pba,tau, normal_info, (interpolation_method)ppw->inter_mode, &(ppw->last_index_back), pvecback),
             pba->error_message,
             error_message);

  class_test(pvecback[pba->index_bg_H]*pvecback[pba->index_bg_a] == 0.,
             error_message,
             "aH=0, stop to avoid division by zero");

  tau_h = 1./(pvecback[pba->index_bg_H]*pvecback[pba->index_bg_a]);

  /** - for scalars modes: */

  if ((ppt->has_scalars == _TRUE_) && (pppaw->index_md == ppt->index_md_scalars)) {

    *timescale = tau_h;

    if ((ppw->approx[ppw->index_ap_rsa] == (int)rsa_off) || (pba->has_ncdm == _TRUE_))
      *timescale = MIN(tau_k,*timescale);

    if (ppw->approx[ppw->index_ap_tca] == (int)tca_off) {

      class_call(thermodynamics_at_z(pba,
                                     pth,
                                     1./pvecback[pba->index_bg_a]-1.,  /* redshift z=1/a-1 */
                                     (interpolation_method)ppw->inter_mode,
                                     &(ppw->last_index_thermo),
                                     pvecback,
                                     pvecthermo),
                 pth->error_message,
                 error_message);

      if (pvecthermo[pth->index_th_dkappa] != 0.) {

        /** - -->  compute recombination time scale for photons, \f$ \tau_{\gamma} = 1/ \kappa' \f$ */

        tau_c = 1./pvecthermo[pth->index_th_dkappa];

        *timescale = MIN(tau_c,*timescale);

      }
    }

  }

  /** - for vector modes: */

  if ((ppt->has_vectors == _TRUE_) && (pppaw->index_md == ppt->index_md_vectors)) {

    *timescale = MIN(tau_h,tau_k);

    if (ppw->approx[ppw->index_ap_tca] == (int)tca_off) {

      class_call(thermodynamics_at_z(pba,
                                     pth,
                                     1./pvecback[pba->index_bg_a]-1.,  /* redshift z=1/a-1 */
                                     (interpolation_method)ppw->inter_mode,
                                     &(ppw->last_index_thermo),
                                     pvecback,
                                     pvecthermo),
                 pth->error_message,
                 error_message);

      if (pvecthermo[pth->index_th_dkappa] != 0.) {

        /** - -->  compute recombination time scale for photons, \f$ \tau_{\gamma} = 1/ \kappa' \f$ */

        tau_c = 1./pvecthermo[pth->index_th_dkappa];

        *timescale = MIN(tau_c,*timescale);

      }
    }
  }

  /** - for tensor modes: */

  if ((ppt->has_tensors == _TRUE_) && (pppaw->index_md == ppt->index_md_tensors)) {

    *timescale = MIN(tau_h,tau_k);

    if (ppw->approx[ppw->index_ap_tca] == (int)tca_off) {

      class_call(thermodynamics_at_z(pba,
                                     pth,
                                     1./pvecback[pba->index_bg_a]-1.,  /* redshift z=1/a-1 */
                                     (interpolation_method)ppw->inter_mode,
                                     &(ppw->last_index_thermo),
                                     pvecback,
                                     pvecthermo),
                 pth->error_message,
                 error_message);

      if (pvecthermo[pth->index_th_dkappa] != 0.) {

        /** - --> compute recombination time scale for photons, \f$ \tau_{\gamma} = 1/ \kappa' \f$ */

        tau_c = 1./pvecthermo[pth->index_th_dkappa];

        *timescale = MIN(tau_c,*timescale);

      }
    }
  }

  return _SUCCESS_;
}


/**
 * Compute metric perturbations (those not integrated over time) using Einstein equations
 *
 * @param ppr        Input: pointer to precision structure
 * @param pba        Input: pointer to background structure
 * @param pth        Input: pointer to thermodynamics structure
 * @param ppt        Input: pointer to the perturbation structure
 * @param index_md   Input: index of mode under consideration (scalar/.../tensor)
 * @param k          Input: wavenumber
 * @param tau        Input: conformal time
 * @param y          Input: vector of perturbations (those integrated over time) (already allocated)
 * @param ppw        Input/Output: in output contains the updated metric perturbations
 * @return the error status
 */

int perturbations_einstein(
                           struct precision * ppr,
                           struct background * pba,
                           struct thermodynamics * pth,
                           struct perturbations * ppt,
                           int index_md,
                           double k,
                           double tau,
                           double * y,
                           struct perturbations_workspace * ppw
                           ) {
  /** Summary: */

  /** - define local variables */

  double k2,a,a2,a_prime_over_a;
  double s2_squared;
  double shear_g = 0.;
  double shear_idr = 0.;

  /** - define wavenumber and scale factor related quantities */

  k2 = k*k;
  a = ppw->pvecback[pba->index_bg_a];
  a2 = a * a;
  a_prime_over_a = ppw->pvecback[pba->index_bg_H]*a;
  s2_squared = 1.-3.*pba->K/k2;

  /** - sum up perturbations from all species */
  class_call(perturbations_total_stress_energy(ppr,pba,pth,ppt,index_md,k,y,ppw),
             ppt->error_message,
             ppt->error_message);

  /** - for scalar modes: */

  if (_scalars_) {

    /** - --> infer metric perturbations from Einstein equations */

    /* newtonian gauge */
    if (ppt->gauge == newtonian) {

      /* in principle we could get phi from the constrain equation:

         ppw->pvecmetric[ppw->index_mt_phi] = -1.5 * (a2/k2/k2/s2/s2) * (k2 * delta_rho + 3.*a_prime_over_a * rho_plus_p_theta);

         with s2_squared = sqrt(1-3K/k2) = ppw->s_l[2]*ppw->s_l[2]

         This was the case in class v1.3. However the integration is
         more stable is we treat phi as a dynamical variable
         y[ppw->pv->index_pt_phi], which derivative is given by the
         second equation below (credits to Guido Walter Pettinari). */

      /* equation for psi */
      ppw->pvecmetric[ppw->index_mt_psi] = y[ppw->pv->index_pt_phi] - 4.5 * (a2/k2) * ppw->rho_plus_p_shear;

      /* equation for phi' */
      ppw->pvecmetric[ppw->index_mt_phi_prime] = -a_prime_over_a * ppw->pvecmetric[ppw->index_mt_psi] + 1.5 * (a2/k2) * ppw->rho_plus_p_theta;

      /* eventually, infer radiation streaming approximation for
         gamma and ur (this is exactly the right place to do it
         because the result depends on h_prime) */

      if (ppw->approx[ppw->index_ap_rsa] == (int)rsa_on) {

        class_call(perturbations_rsa_delta_and_theta(ppr,pba,pth,ppt,k,y,a_prime_over_a,ppw->pvecthermo,ppw,ppt->error_message),
                   ppt->error_message,
                   ppt->error_message);
      }

      if ((pba->has_idr)&&(ppw->approx[ppw->index_ap_rsa_idr] == (int)rsa_idr_on)){

        class_call(perturbations_rsa_idr_delta_and_theta(ppr,pba,pth,ppt,k,y,a_prime_over_a,ppw->pvecthermo,ppw,ppt->error_message),
                   ppt->error_message,
                   ppt->error_message);
      }
    }

    /* synchronous gauge */
    if (ppt->gauge == synchronous) {

      /* first equation involving total density fluctuation */
      ppw->pvecmetric[ppw->index_mt_h_prime] =
        ( k2 * s2_squared * y[ppw->pv->index_pt_eta] + 1.5 * a2 * ppw->delta_rho)/(0.5*a_prime_over_a);  /* h' */

      /* eventually, infer radiation streaming approximation for
         gamma and ur (this is exactly the right place to do it
         because the result depends on h_prime) */

      if (ppw->approx[ppw->index_ap_rsa] == (int)rsa_on) {

        class_call(perturbations_rsa_delta_and_theta(ppr,pba,pth,ppt,k,y,a_prime_over_a,ppw->pvecthermo,ppw,ppt->error_message),
                   ppt->error_message,
                   ppt->error_message);
      }

      if ((pba->has_idr==_TRUE_)&&(ppw->approx[ppw->index_ap_rsa_idr] == (int)rsa_idr_on)) {

        class_call(perturbations_rsa_idr_delta_and_theta(ppr,pba,pth,ppt,k,y,a_prime_over_a,ppw->pvecthermo,ppw,ppt->error_message),
                   ppt->error_message,
                   ppt->error_message);

        ppw->rho_plus_p_theta += 4./3.*ppw->pvecback[pba->index_bg_rho_idr]*ppw->rsa_theta_idr;
      }

      /* second equation involving total velocity */
      ppw->pvecmetric[ppw->index_mt_eta_prime] = (1.5 * a2 * ppw->rho_plus_p_theta + 0.5 * pba->K * ppw->pvecmetric[ppw->index_mt_h_prime])/k2/s2_squared;  /* eta' */

      /* third equation involving total pressure */
      ppw->pvecmetric[ppw->index_mt_h_prime_prime] =
        - 2. * a_prime_over_a * ppw->pvecmetric[ppw->index_mt_h_prime]
        + 2. * k2 * s2_squared * y[ppw->pv->index_pt_eta]
        - 9. * a2 * ppw->delta_p;

      /* alpha = (h'+6eta')/2k^2 */
      ppw->pvecmetric[ppw->index_mt_alpha] = (ppw->pvecmetric[ppw->index_mt_h_prime] + 6.*ppw->pvecmetric[ppw->index_mt_eta_prime])/2./k2;

      /* eventually, infer first-order tight-coupling approximation for photon
         shear, then correct the total shear */
      if (ppw->approx[ppw->index_ap_tca] == (int)tca_on) {

        if (pth->has_idm_g == _TRUE_) {
          shear_g = 16./45./(ppw->pvecthermo[pth->index_th_dkappa] + ppw->pvecthermo[pth->index_th_dmu_idm_g])*(y[ppw->pv->index_pt_theta_g]+k2*ppw->pvecmetric[ppw->index_mt_alpha]);
        }
        else {
          shear_g = 16./45./ppw->pvecthermo[pth->index_th_dkappa]*(y[ppw->pv->index_pt_theta_g]+k2*ppw->pvecmetric[ppw->index_mt_alpha]);
        }

        ppw->rho_plus_p_shear += 4./3.*ppw->pvecback[pba->index_bg_rho_g]*shear_g;

      }

      if (pth->has_idm_dr == _TRUE_) {
        if (ppw->approx[ppw->index_ap_tca_idm_dr] == (int)tca_idm_dr_on){

          shear_idr = 0.5*8./15./ppw->pvecthermo[pth->index_th_dmu_idm_dr]/ppt->alpha_idm_dr[0]*(y[ppw->pv->index_pt_theta_idr]+k2*ppw->pvecmetric[ppw->index_mt_alpha]);

          ppw->rho_plus_p_shear += 4./3.*ppw->pvecback[pba->index_bg_rho_idr]*shear_idr;
        }
      }

      /* fourth equation involving total shear */
      ppw->pvecmetric[ppw->index_mt_alpha_prime] =  //TBC
        - 2. * a_prime_over_a * ppw->pvecmetric[ppw->index_mt_alpha]
        + y[ppw->pv->index_pt_eta]
        - 4.5 * (a2/k2) * ppw->rho_plus_p_shear;

    }

    /* transform (delta_m, theta_m) of the current gauge into
       gauge-independent variables (you could comment this out if you
       really want gauge-dependent results) */

    if (ppt->has_matter_source_in_current_gauge == _FALSE_) {
      if (ppt->has_source_delta_m == _TRUE_) {
        ppw->delta_m += 3. *ppw->pvecback[pba->index_bg_a]*ppw->pvecback[pba->index_bg_H] * ppw->theta_m/k2;
        // note: until 2.4.3 there was a typo, the factor was (-2 H'/H) instead
        // of (3 aH). There is the same typo in the CLASSgal paper
        // 1307.1459v1,v2,v3. It came from a confusion between (1+w_total)
        // and (1+w_matter)=1 [the latter is the relevant one here].
        //
        // note2: at this point this gauge-invariant variable is only
        // valid if all matter components are pressureless and
        // stable. This relation will be generalized soon to the case
        // of decaying dark matter.
      }

      if (ppt->has_source_delta_cb == _TRUE_) {
        ppw->delta_cb += 3. *ppw->pvecback[pba->index_bg_a]*ppw->pvecback[pba->index_bg_H] * ppw->theta_cb/k2;//check gauge transformation
      }

      if (ppt->has_source_theta_m == _TRUE_) {
        if  (ppt->gauge == synchronous) {
          ppw->theta_m += ppw->pvecmetric[ppw->index_mt_alpha]*k2;
        }
      }
      if (ppt->has_source_theta_cb == _TRUE_){
        if  (ppt->gauge == synchronous) {
          ppw->theta_cb += ppw->pvecmetric[ppw->index_mt_alpha]*k2; //check gauge transformation
        }
      }
    }
  }
  /** - for vector modes */

  if (_vectors_) {

    if (ppt->gauge == newtonian) {

      ppw->pvecmetric[ppw->index_mt_V_prime] = -2.*a_prime_over_a*y[ppw->pv->index_pt_V] - 3.*ppw->vector_source_pi/k;

    }

    if (ppt->gauge == synchronous) {

      // assuming    vector_source_pi = p_class a^2 pi_T^{(1)} and  vector_source_v = (rho_class+p_class)a^2 v^{(1)}

      // from Hu and White:
      ppw->pvecmetric[ppw->index_mt_hv_prime_prime] = -2.*a_prime_over_a*y[ppw->pv->index_pt_hv_prime] - 3.*ppw->vector_source_pi/k2;

      // what we suspect:
      //ppw->pvecmetric[ppw->index_mt_hv_prime_prime] = -2.*a_prime_over_a*y[ppw->pv->index_pt_hv_prime] - 3.*ppw->vector_source_pi;

      // if we use the other equation:
      //ppw->pvecmetric[ppw->index_mt_hv_prime] = -2./k/ (1.-2.*pba->K/k2) * 3. * ppw->vector_source_v;

    }

  }

  /** - for tensor modes */

  if (_tensors_) {

    /* single einstein equation for tensor perturbations */
    ppw->pvecmetric[ppw->index_mt_gw_prime_prime] = -2.*a_prime_over_a*y[ppw->pv->index_pt_gwdot]-(k2+2.*pba->K)*y[ppw->pv->index_pt_gw]+ppw->gw_source;

  }

  return _SUCCESS_;

}

int perturbations_total_stress_energy(
                                      struct precision * ppr,
                                      struct background * pba,
                                      struct thermodynamics * pth,
                                      struct perturbations * ppt,
                                      int index_md,
                                      double k,
                                      double * y,
                                      struct perturbations_workspace * ppw
                                      ) {
  /** Summary: */

  /** - define local variables */

  double a,a2,a_prime_over_a,k2;
  double rho_m=0.;
  double delta_rho_m=0.;
  double rho_plus_p_m=0.;
  double rho_plus_p_theta_m=0.;
  double delta_g=0.;
  double theta_g=0.;
  double shear_g=0.;
  double delta_ur=0.;
  double theta_ur=0.;
  double shear_ur=0.;
  double delta_idr=0.;
  double theta_idr=0.;
  double shear_idr=0.;
  double rho_delta_ncdm=0.;
  double rho_plus_p_theta_ncdm=0.;
  double rho_plus_p_shear_ncdm=0.;
  double delta_p_ncdm=0.;
  double factor;
  double rho_plus_p_ncdm;
  int index_q,n_ncdm,idx;
  double epsilon,q,q2,cg2_ncdm,w_ncdm,rho_ncdm_bg,p_ncdm_bg,pseudo_p_ncdm;
  double w_fld,dw_over_da_fld,integral_fld;
  double gwncdm;
  double rho_relativistic;
  double rho_dr_over_f;
  double delta_rho_scf, delta_p_scf, psi;
  /** Variables used for FLD and PPF */
  double c_gamma_k_H_square;
  double Gamma_prime_plus_a_prime_over_a_Gamma, s2sq=1.;
  double w_prime_fld, ca2_fld;
  double alpha, alpha_prime, metric_euler;
  double rho_t, p_t, rho_t_prime, p_t_prime;
  double rho_fld, p_fld, rho_fld_prime, p_fld_prime;
  double X, Y, Z, X_prime, Y_prime, Z_prime;
  double Gamma_fld, S, S_prime, theta_t, theta_t_prime, rho_plus_p_theta_fld_prime;
  double delta_p_b_over_rho_b;

  /** - wavenumber and scale factor related quantities */

  a = ppw->pvecback[pba->index_bg_a];
  a2 = a * a;
  a_prime_over_a = ppw->pvecback[pba->index_bg_H]*a;
  k2 = k*k;

  /** - for scalar modes */

  if (_scalars_) {

    /** - --> (a) deal with approximation schemes */

    /** - ---> (a.1.) photons */

    if (ppw->approx[ppw->index_ap_tca] == (int)tca_off) {

      if (ppw->approx[ppw->index_ap_rsa] == (int)rsa_off) {

        /** - ----> (a.1.1.) no approximation */

        delta_g = y[ppw->pv->index_pt_delta_g];
        theta_g = y[ppw->pv->index_pt_theta_g];
        shear_g = y[ppw->pv->index_pt_shear_g];

      }
      else {

        /** - ----> (a.1.2.) radiation streaming approximation */

        delta_g = 0.; /* actual free streaming approximation imposed after evaluation of einstein equations */
        theta_g = 0.; /* actual free streaming approximation imposed after evaluation of einstein equations */
        shear_g = 0.; /* shear always neglected in radiation streaming approximation */
      }
    }
    else {

      /** - ----> (a.1.3.) tight coupling approximation */

      delta_g = y[ppw->pv->index_pt_delta_g];
      theta_g = y[ppw->pv->index_pt_theta_g];

      /* first-order tight-coupling approximation for photon shear */
      if (ppt->gauge == newtonian) {
        if (pth->has_idm_g == _TRUE_) {
          shear_g = 16./45./(ppw->pvecthermo[pth->index_th_dkappa] + ppw->pvecthermo[pth->index_th_dmu_idm_g])*y[ppw->pv->index_pt_theta_g];
        }
        else {
          shear_g = 16./45./ppw->pvecthermo[pth->index_th_dkappa]*y[ppw->pv->index_pt_theta_g];
        }

      }
      else {
        shear_g = 0.; /* in the synchronous gauge, the expression of
                         shear_g (at first-order in a tight-coupling
                         expansion) is a function of h' and eta'; but h'
                         and eta' are calculated in perturbations_einstein()
                         as a function of delta_g and theta_g.  Hence,
                         we set shear_g temporarily to zero, and set it
                         to the right first-order value in
                         perturbations_einstein(), just before using the
                         Einstein equation for the shear. */
      }
    }

    /** - ---> (a.2.) ur */

    if (pba->has_ur == _TRUE_) {

      if (ppw->approx[ppw->index_ap_rsa] == (int)rsa_off) {

        delta_ur = y[ppw->pv->index_pt_delta_ur];
        theta_ur = y[ppw->pv->index_pt_theta_ur];
        shear_ur = y[ppw->pv->index_pt_shear_ur];

      }

      else {

        delta_ur = 0.; /* actual free streaming approximation imposed after evaluation of 1st einstein equation */
        theta_ur = 0.; /* actual free streaming approximation imposed after evaluation of 1st einstein equation */
        shear_ur = 0.; /* shear always neglected in free streaming approximation */

      }

    }

    /** - ---> (a.3.) baryon pressure perturbation */

    if ((ppt->has_perturbed_recombination == _TRUE_) &&(ppw->approx[ppw->index_ap_tca] == (int)tca_off)) {
      delta_p_b_over_rho_b = ppw->pvecthermo[pth->index_th_wb]*(y[ppw->pv->index_pt_delta_b]+ y[ppw->pv->index_pt_perturbed_recombination_delta_temp]);
    }
    else {
      delta_p_b_over_rho_b = ppw->pvecthermo[pth->index_th_cb2]*y[ppw->pv->index_pt_delta_b];
    }

    /** - ---> (a.4.) interacting dark radiation */

    if (pba->has_idr == _TRUE_) {
      if (ppw->approx[ppw->index_ap_rsa_idr] == (int)rsa_idr_off) {
        delta_idr = y[ppw->pv->index_pt_delta_idr];
        theta_idr = y[ppw->pv->index_pt_theta_idr];

        if (ppt->idr_nature == idr_free_streaming){
          if (ppw->approx[ppw->index_ap_tca_idm_dr] == (int)tca_idm_dr_on){
            if (ppt->gauge == newtonian)
              shear_idr = 0.5 *(8./15./ppw->pvecthermo[pth->index_th_dmu_idm_dr]/ppt->alpha_idm_dr[0]*(y[ppw->pv->index_pt_theta_idr])) ;
            else
              shear_idr = 0.; /* this is set in perturbations_einstein, so here it's set to 0 */
          }
          else{
            shear_idr = y[ppw->pv->index_pt_shear_idr];
          }
        }
      }
      else{
        delta_idr = 0.;
        theta_idr = 0.;
        shear_idr = 0.;
      }
    }

    /** - --> (b) compute the total density, velocity and shear perturbations */

    /* photon and baryon contribution */
    ppw->delta_rho = ppw->pvecback[pba->index_bg_rho_g]*delta_g
      + ppw->pvecback[pba->index_bg_rho_b]*y[ppw->pv->index_pt_delta_b]; // contribution to total perturbed stress-energy
    ppw->rho_plus_p_theta = 4./3.*ppw->pvecback[pba->index_bg_rho_g]*theta_g
      + ppw->pvecback[pba->index_bg_rho_b]*y[ppw->pv->index_pt_theta_b]; // contribution to total perturbed stress-energy
    ppw->rho_plus_p_shear = 4./3.*ppw->pvecback[pba->index_bg_rho_g]*shear_g; // contribution to total perturbed stress-energy
    ppw->delta_p = 1./3.*ppw->pvecback[pba->index_bg_rho_g]*delta_g
      + ppw->pvecback[pba->index_bg_rho_b]*delta_p_b_over_rho_b; // contribution to total perturbed stress-energy
    ppw->rho_plus_p_tot = 4./3. * ppw->pvecback[pba->index_bg_rho_g] + ppw->pvecback[pba->index_bg_rho_b];

    if (ppt->has_source_delta_m == _TRUE_) {
      delta_rho_m = ppw->pvecback[pba->index_bg_rho_b]*y[ppw->pv->index_pt_delta_b]; // contribution to delta rho_matter
      rho_m = ppw->pvecback[pba->index_bg_rho_b];
    }
    if ((ppt->has_source_delta_m == _TRUE_) || (ppt->has_source_theta_m == _TRUE_)) {
      rho_plus_p_theta_m = ppw->pvecback[pba->index_bg_rho_b]*y[ppw->pv->index_pt_theta_b]; // contribution to [(rho+p)theta]_matter
      rho_plus_p_m = ppw->pvecback[pba->index_bg_rho_b];
    }

    /* cdm contribution */
    if (pba->has_cdm == _TRUE_) {
      ppw->delta_rho += ppw->pvecback[pba->index_bg_rho_cdm]*y[ppw->pv->index_pt_delta_cdm]; // contribution to total perturbed stress-energy
      if (ppt->gauge == newtonian)
        ppw->rho_plus_p_theta = ppw->rho_plus_p_theta + ppw->pvecback[pba->index_bg_rho_cdm]*y[ppw->pv->index_pt_theta_cdm]; // contribution to total perturbed stress-energy

      ppw->rho_plus_p_tot += ppw->pvecback[pba->index_bg_rho_cdm];

      if (ppt->has_source_delta_m == _TRUE_) {
        delta_rho_m += ppw->pvecback[pba->index_bg_rho_cdm]*y[ppw->pv->index_pt_delta_cdm]; // contribution to delta rho_matter
        rho_m += ppw->pvecback[pba->index_bg_rho_cdm];
      }
      if ((ppt->has_source_delta_m == _TRUE_) || (ppt->has_source_theta_m == _TRUE_)) {
        if (ppt->gauge == newtonian)
          rho_plus_p_theta_m += ppw->pvecback[pba->index_bg_rho_cdm]*y[ppw->pv->index_pt_theta_cdm]; // contribution to [(rho+p)theta]_matter
        rho_plus_p_m += ppw->pvecback[pba->index_bg_rho_cdm];
      }
    }

    /* idm contribution */
    if (pba->has_idm == _TRUE_) {
      ppw->delta_rho += ppw->pvecback[pba->index_bg_rho_idm]*y[ppw->pv->index_pt_delta_idm];
      ppw->rho_plus_p_theta += ppw->pvecback[pba->index_bg_rho_idm]*y[ppw->pv->index_pt_theta_idm];
      ppw->rho_plus_p_tot += ppw->pvecback[pba->index_bg_rho_idm];

      if (ppt->has_source_delta_m == _TRUE_) {
        delta_rho_m += ppw->pvecback[pba->index_bg_rho_idm]*y[ppw->pv->index_pt_delta_idm]; // contribution to delta rho_matter
        rho_m += ppw->pvecback[pba->index_bg_rho_idm];
      }
      if ((ppt->has_source_delta_m == _TRUE_) || (ppt->has_source_theta_m == _TRUE_)) {
        rho_plus_p_theta_m += ppw->pvecback[pba->index_bg_rho_idm]*y[ppw->pv->index_pt_theta_idm]; // contribution to [(rho+p)theta]_matter
        rho_plus_p_m += ppw->pvecback[pba->index_bg_rho_idm];
      }
    }

    /* dcdm contribution */
    if (pba->has_dcdm == _TRUE_) {
      ppw->delta_rho += ppw->pvecback[pba->index_bg_rho_dcdm]*y[ppw->pv->index_pt_delta_dcdm];
      ppw->rho_plus_p_theta += ppw->pvecback[pba->index_bg_rho_dcdm]*y[ppw->pv->index_pt_theta_dcdm];

      ppw->rho_plus_p_tot += ppw->pvecback[pba->index_bg_rho_dcdm];

      if (ppt->has_source_delta_m == _TRUE_) {
        delta_rho_m += ppw->pvecback[pba->index_bg_rho_dcdm]*y[ppw->pv->index_pt_delta_dcdm]; // contribution to delta rho_matter
        rho_m += ppw->pvecback[pba->index_bg_rho_dcdm];
      }
      if ((ppt->has_source_delta_m == _TRUE_) || (ppt->has_source_theta_m == _TRUE_)) {
        rho_plus_p_theta_m += ppw->pvecback[pba->index_bg_rho_dcdm]*y[ppw->pv->index_pt_theta_dcdm]; // contribution to [(rho+p)theta]_matter
        rho_plus_p_m += ppw->pvecback[pba->index_bg_rho_dcdm];
      }
    }

    /* ultra-relativistic decay radiation */

    if (pba->has_dr == _TRUE_) {
      /* We have delta_rho_dr = rho_dr * F0_dr / f, where F follows the
         convention in astro-ph/9907388 and f is defined as
         f = rho_dr*a^4/rho_crit_today. In CLASS density units
         rho_crit_today = H0^2.
      */
      rho_dr_over_f = pow(pba->H0/a2,2);
      ppw->delta_rho += rho_dr_over_f*y[ppw->pv->index_pt_F0_dr];
      ppw->rho_plus_p_theta += 4./3.*3./4*k*rho_dr_over_f*y[ppw->pv->index_pt_F0_dr+1];
      ppw->rho_plus_p_shear += 2./3.*rho_dr_over_f*y[ppw->pv->index_pt_F0_dr+2];
      ppw->delta_p += 1./3.*rho_dr_over_f*y[ppw->pv->index_pt_F0_dr];

      ppw->rho_plus_p_tot += 4./3. * ppw->pvecback[pba->index_bg_rho_dr];
    }

    /* ultra-relativistic neutrino/relics contribution */

    if (pba->has_ur == _TRUE_) {
      ppw->delta_rho = ppw->delta_rho + ppw->pvecback[pba->index_bg_rho_ur]*delta_ur;
      ppw->rho_plus_p_theta = ppw->rho_plus_p_theta + 4./3.*ppw->pvecback[pba->index_bg_rho_ur]*theta_ur;
      ppw->rho_plus_p_shear = ppw->rho_plus_p_shear + 4./3.*ppw->pvecback[pba->index_bg_rho_ur]*shear_ur;
      ppw->delta_p += 1./3.*ppw->pvecback[pba->index_bg_rho_ur]*delta_ur;

      ppw->rho_plus_p_tot += 4./3. * ppw->pvecback[pba->index_bg_rho_ur];
    }

    /* interacting dark radiation */
    if (pba->has_idr == _TRUE_) {
      ppw->delta_rho += ppw->pvecback[pba->index_bg_rho_idr]*delta_idr;
      ppw->rho_plus_p_theta += 4./3.*ppw->pvecback[pba->index_bg_rho_idr]*theta_idr;
      if (ppt->idr_nature==idr_free_streaming)
        ppw->rho_plus_p_shear += 4./3.*ppw->pvecback[pba->index_bg_rho_idr]*shear_idr;
      ppw->delta_p += 1./3. * ppw->pvecback[pba->index_bg_rho_idr]*delta_idr;
      ppw->rho_plus_p_tot += 4./3. * ppw->pvecback[pba->index_bg_rho_idr];
    }

    /* infer delta_cb abd theta_cb (perturbations from CDM and baryons) before adding ncdm */
    if ((ppt->has_source_delta_m == _TRUE_) && (ppt->has_source_delta_cb == _TRUE_))
      ppw->delta_cb = delta_rho_m/rho_m;

    if (((ppt->has_source_delta_m == _TRUE_) || (ppt->has_source_theta_m == _TRUE_)) &&
        ((ppt->has_source_delta_cb == _TRUE_) || (ppt->has_source_theta_cb == _TRUE_)))
      ppw->theta_cb = rho_plus_p_theta_m/rho_plus_p_m;


    /* non-cold dark matter contribution */
    if (pba->has_ncdm == _TRUE_) {
      idx = ppw->pv->index_pt_psi0_ncdm1;
      if (ppw->approx[ppw->index_ap_ncdmfa] == (int)ncdmfa_on){
        // The perturbations are evolved integrated:
        for (n_ncdm=0; n_ncdm < pba->N_ncdm; n_ncdm++){
          rho_ncdm_bg = ppw->pvecback[pba->index_bg_rho_ncdm1+n_ncdm];
          p_ncdm_bg = ppw->pvecback[pba->index_bg_p_ncdm1+n_ncdm];
          pseudo_p_ncdm = ppw->pvecback[pba->index_bg_pseudo_p_ncdm1+n_ncdm];

          rho_plus_p_ncdm = rho_ncdm_bg + p_ncdm_bg;
          w_ncdm = p_ncdm_bg/rho_ncdm_bg;
          cg2_ncdm = w_ncdm*(1.0-1.0/(3.0+3.0*w_ncdm)*(3.0*w_ncdm-2.0+pseudo_p_ncdm/p_ncdm_bg));
          if ((ppt->has_source_delta_ncdm == _TRUE_) || (ppt->has_source_theta_ncdm == _TRUE_) || (ppt->has_source_delta_m == _TRUE_)) {
            ppw->delta_ncdm[n_ncdm] = y[idx];
            ppw->theta_ncdm[n_ncdm] = y[idx+1];
            ppw->shear_ncdm[n_ncdm] = y[idx+2];
          }

          ppw->delta_rho += rho_ncdm_bg*y[idx];
          ppw->rho_plus_p_theta += rho_plus_p_ncdm*y[idx+1];
          ppw->rho_plus_p_shear += rho_plus_p_ncdm*y[idx+2];
          ppw->delta_p += cg2_ncdm*rho_ncdm_bg*y[idx];

          ppw->rho_plus_p_tot += rho_plus_p_ncdm;

          idx += ppw->pv->l_max_ncdm[n_ncdm]+1;
        }
      }
      else{
        // We must integrate to find perturbations:
        for (n_ncdm=0; n_ncdm < pba->N_ncdm; n_ncdm++){
          rho_delta_ncdm = 0.0;
          rho_plus_p_theta_ncdm = 0.0;
          rho_plus_p_shear_ncdm = 0.0;
          delta_p_ncdm = 0.0;
          factor = pba->factor_ncdm[n_ncdm]/pow(a,4);

          for (index_q=0; index_q < ppw->pv->q_size_ncdm[n_ncdm]; index_q ++) {

            q = pba->q_ncdm[n_ncdm][index_q];
            q2 = q*q;
            epsilon = sqrt(q2+pba->M_ncdm[n_ncdm]*pba->M_ncdm[n_ncdm]*a2);

            rho_delta_ncdm += q2*epsilon*pba->w_ncdm[n_ncdm][index_q]*y[idx];
            rho_plus_p_theta_ncdm += q2*q*pba->w_ncdm[n_ncdm][index_q]*y[idx+1];
            rho_plus_p_shear_ncdm += q2*q2/epsilon*pba->w_ncdm[n_ncdm][index_q]*y[idx+2];
            delta_p_ncdm += q2*q2/epsilon*pba->w_ncdm[n_ncdm][index_q]*y[idx];

            //Jump to next momentum bin:
            idx+=(ppw->pv->l_max_ncdm[n_ncdm]+1);
          }

          rho_delta_ncdm *= factor;
          rho_plus_p_theta_ncdm *= k*factor;
          rho_plus_p_shear_ncdm *= 2.0/3.0*factor;
          delta_p_ncdm *= factor/3.;

          if ((ppt->has_source_delta_ncdm == _TRUE_) || (ppt->has_source_theta_ncdm == _TRUE_) || (ppt->has_source_delta_m == _TRUE_)) {
            ppw->delta_ncdm[n_ncdm] = rho_delta_ncdm/ppw->pvecback[pba->index_bg_rho_ncdm1+n_ncdm];
            ppw->theta_ncdm[n_ncdm] = rho_plus_p_theta_ncdm/
              (ppw->pvecback[pba->index_bg_rho_ncdm1+n_ncdm]+ppw->pvecback[pba->index_bg_p_ncdm1+n_ncdm]);
            ppw->shear_ncdm[n_ncdm] = rho_plus_p_shear_ncdm/
              (ppw->pvecback[pba->index_bg_rho_ncdm1+n_ncdm]+ppw->pvecback[pba->index_bg_p_ncdm1+n_ncdm]);
          }

          ppw->delta_rho += rho_delta_ncdm;
          ppw->rho_plus_p_theta += rho_plus_p_theta_ncdm;
          ppw->rho_plus_p_shear += rho_plus_p_shear_ncdm;
          ppw->delta_p += delta_p_ncdm;

          ppw->rho_plus_p_tot += ppw->pvecback[pba->index_bg_rho_ncdm1+n_ncdm]+ppw->pvecback[pba->index_bg_p_ncdm1+n_ncdm];
        }
      }
      if (ppt->has_source_delta_m == _TRUE_) {
        for (n_ncdm=0; n_ncdm < pba->N_ncdm; n_ncdm++){
          delta_rho_m += ppw->pvecback[pba->index_bg_rho_ncdm1+n_ncdm]*ppw->delta_ncdm[n_ncdm]; // contribution to delta rho_matter
          rho_m += ppw->pvecback[pba->index_bg_rho_ncdm1+n_ncdm];
        }
      }
      if ((ppt->has_source_delta_m == _TRUE_) || (ppt->has_source_theta_m == _TRUE_)) {
        for (n_ncdm=0; n_ncdm < pba->N_ncdm; n_ncdm++){
          rho_plus_p_theta_m += (ppw->pvecback[pba->index_bg_rho_ncdm1+n_ncdm]+ppw->pvecback[pba->index_bg_p_ncdm1+n_ncdm])
            *ppw->theta_ncdm[n_ncdm]; // contribution to [(rho+p)theta]_matter
          rho_plus_p_m += (ppw->pvecback[pba->index_bg_rho_ncdm1+n_ncdm]+ppw->pvecback[pba->index_bg_p_ncdm1+n_ncdm]);
        }
      }
    }

    /* scalar field contribution.
       In Newtonian gauge, delta_scf depends on the metric perturbation psi which is inferred
       from rho_plus_p_shear. So the contribution from the scalar field must be below all
       species with non-zero shear.
    */
    if (pba->has_scf == _TRUE_) {

      if (ppt->gauge == synchronous){
        delta_rho_scf =  1./3.*
          (1./a2*ppw->pvecback[pba->index_bg_phi_prime_scf]*y[ppw->pv->index_pt_phi_prime_scf]
           + ppw->pvecback[pba->index_bg_dV_scf]*y[ppw->pv->index_pt_phi_scf]);
        delta_p_scf = 1./3.*
          (1./a2*ppw->pvecback[pba->index_bg_phi_prime_scf]*y[ppw->pv->index_pt_phi_prime_scf]
           - ppw->pvecback[pba->index_bg_dV_scf]*y[ppw->pv->index_pt_phi_scf]);
      }
      else{
        /* equation for psi */
        psi = y[ppw->pv->index_pt_phi] - 4.5 * (a2/k/k) * ppw->rho_plus_p_shear;

        delta_rho_scf =  1./3.*
          (1./a2*ppw->pvecback[pba->index_bg_phi_prime_scf]*y[ppw->pv->index_pt_phi_prime_scf]
           + ppw->pvecback[pba->index_bg_dV_scf]*y[ppw->pv->index_pt_phi_scf]
           - 1./a2*pow(ppw->pvecback[pba->index_bg_phi_prime_scf],2)*psi);
        delta_p_scf =  1./3.*
          (1./a2*ppw->pvecback[pba->index_bg_phi_prime_scf]*y[ppw->pv->index_pt_phi_prime_scf]
           - ppw->pvecback[pba->index_bg_dV_scf]*y[ppw->pv->index_pt_phi_scf]
           - 1./a2*pow(ppw->pvecback[pba->index_bg_phi_prime_scf],2)*psi);
      }

      ppw->delta_rho += delta_rho_scf;

      ppw->rho_plus_p_theta +=  1./3.*
        k*k/a2*ppw->pvecback[pba->index_bg_phi_prime_scf]*y[ppw->pv->index_pt_phi_scf];

      ppw->delta_p += delta_p_scf;

      ppw->rho_plus_p_tot += ppw->pvecback[pba->index_bg_rho_scf]+ppw->pvecback[pba->index_bg_p_scf];

    }

    /* add your extra species here */

    /* fluid contribution */
    if (pba->has_fld == _TRUE_) {

      class_call(background_w_fld(pba,a,&w_fld,&dw_over_da_fld,&integral_fld), pba->error_message, ppt->error_message);
      w_prime_fld = dw_over_da_fld * a_prime_over_a * a;

      if (pba->use_ppf == _FALSE_) {
        ppw->delta_rho_fld = ppw->pvecback[pba->index_bg_rho_fld]*y[ppw->pv->index_pt_delta_fld];
        ppw->rho_plus_p_theta_fld = (1.+w_fld)*ppw->pvecback[pba->index_bg_rho_fld]*y[ppw->pv->index_pt_theta_fld];
        ca2_fld = w_fld - w_prime_fld / 3. / (1.+w_fld) / a_prime_over_a;
        /** We must gauge transform the pressure perturbation from the fluid rest-frame to the gauge we are working in */
        ppw->delta_p_fld = pba->cs2_fld * ppw->delta_rho_fld + (pba->cs2_fld-ca2_fld)*(3*a_prime_over_a*ppw->rho_plus_p_theta_fld/k/k);
      }
      else {
        s2sq = ppw->s_l[2]*ppw->s_l[2];
        c_gamma_k_H_square = pow(pba->c_gamma_over_c_fld*k/a_prime_over_a,2)*pba->cs2_fld;
        /** The equation is too stiff for Runge-Kutta when c_gamma_k_H_square is large.
            Use the asymptotic solution Gamma=Gamma'=0 in that case.
        */
        if (c_gamma_k_H_square > ppr->c_gamma_k_H_square_max)
          Gamma_fld = 0.;
        else
          Gamma_fld = y[ppw->pv->index_pt_Gamma_fld];

        if (ppt->gauge == synchronous){
          alpha = (y[ppw->pv->index_pt_eta]+1.5*a2/k2/s2sq*(ppw->delta_rho+3*a_prime_over_a/k2*ppw->rho_plus_p_theta)-Gamma_fld)/a_prime_over_a;
          alpha_prime = -2. * a_prime_over_a * alpha + y[ppw->pv->index_pt_eta] - 4.5 * (a2/k2) * ppw->rho_plus_p_shear;
          metric_euler = 0.;
        }
        else{
          alpha = 0.;
          alpha_prime = 0.;
          metric_euler = k2*y[ppw->pv->index_pt_phi] - 4.5*a2*ppw->rho_plus_p_shear;
        }
        ppw->S_fld = ppw->pvecback[pba->index_bg_rho_fld]*(1.+w_fld)*1.5*a2/k2/a_prime_over_a*
          (ppw->rho_plus_p_theta/ppw->rho_plus_p_tot+k2*alpha);
        // note that the last terms in the ratio do not include fld, that's correct, it's the whole point of the PPF scheme
        /** We must now check the stiffness criterion again and set Gamma_prime_fld accordingly. */
        if (c_gamma_k_H_square > ppr->c_gamma_k_H_square_max){
          ppw->Gamma_prime_fld = 0.;
        }
        else{
          ppw->Gamma_prime_fld = a_prime_over_a*(ppw->S_fld/(1.+c_gamma_k_H_square) - (1.+c_gamma_k_H_square)*Gamma_fld);
        }
        Gamma_prime_plus_a_prime_over_a_Gamma = ppw->Gamma_prime_fld+a_prime_over_a*Gamma_fld;
        // delta and theta in both gauges gauge:
        ppw->rho_plus_p_theta_fld = ppw->pvecback[pba->index_bg_rho_fld]*(1.+w_fld)*ppw->rho_plus_p_theta/ppw->rho_plus_p_tot-
          k2*2./3.*a_prime_over_a/a2/(1+4.5*a2/k2/s2sq*ppw->rho_plus_p_tot)*
          (ppw->S_fld-Gamma_prime_plus_a_prime_over_a_Gamma/a_prime_over_a);
        ppw->delta_rho_fld = -2./3.*k2*s2sq/a2*Gamma_fld-3*a_prime_over_a/k2*ppw->rho_plus_p_theta_fld;

        /** Now construct the pressure perturbation, see 1903.xxxxx. */
        /** Construct energy density and pressure for DE (_fld) and the rest (_t).
            Also compute derivatives. */
        rho_fld = ppw->pvecback[pba->index_bg_rho_fld];
        p_fld = w_fld*rho_fld;
        rho_fld_prime = -3*a_prime_over_a*(rho_fld+p_fld);
        p_fld_prime = w_prime_fld*rho_fld-3*a_prime_over_a*(1+w_fld)*p_fld;
        rho_t = ppw->pvecback[pba->index_bg_rho_tot] - rho_fld;
        p_t = ppw->pvecback[pba->index_bg_p_tot] - p_fld;
        rho_t_prime = -3*a_prime_over_a*(rho_t+p_t);
        p_t_prime = ppw->pvecback[pba->index_bg_p_tot_prime]-p_fld_prime;
        /** Compute background quantities X,Y,Z and their derivatives. */
        X = c_gamma_k_H_square;
        X_prime = -2*X*(a_prime_over_a + ppw->pvecback[pba->index_bg_H_prime]/ppw->pvecback[pba->index_bg_H]);
        Y = 4.5*a2/k2/s2sq*(rho_t+p_t);
        Y_prime = Y*(2.*a_prime_over_a+(rho_t_prime+p_t_prime)/(rho_t+p_t));
        Z = 2./3.*k2*ppw->pvecback[pba->index_bg_H]/a;
        Z_prime = Z*(ppw->pvecback[pba->index_bg_H_prime]/ppw->pvecback[pba->index_bg_H] - a_prime_over_a);
        /** Construct theta_t and its derivative from the Euler equation */
        theta_t = ppw->rho_plus_p_theta/ppw->rho_plus_p_tot;
        theta_t_prime = -a_prime_over_a*theta_t-(p_t_prime*theta_t-k2*ppw->delta_p +k2*ppw->rho_plus_p_shear)/ppw->rho_plus_p_tot+metric_euler;
        S = ppw->S_fld;
        S_prime = -Z_prime/Z*S+1./Z*(rho_fld_prime+p_fld_prime)*(theta_t+k2*alpha)+1./Z*(rho_fld+p_fld)*(theta_t_prime+k2*alpha_prime);
        /** Analytic derivative of the equation for ppw->rho_plus_p_theta_fld above. */
        rho_plus_p_theta_fld_prime = Z_prime*(S-1./(1.+Y)*(S/(1.+1./X)+Gamma_fld*X)) +
          Z*(S_prime + Y_prime/(1.+Y*Y+2*Y)*(S/(1.+1./X)+Gamma_fld*X)-
             1./(1.+Y)*(S_prime/(1.+1./X)+S*X_prime/(1.+X*X+2*X)+ppw->Gamma_prime_fld*X+Gamma_fld*X_prime))-
          k2*alpha_prime*(rho_fld+p_fld)-k2*alpha*(rho_fld_prime+p_fld_prime);

        /** We can finally compute the pressure perturbation using the Euler equation for theta_fld */
        ppw->delta_p_fld = (rho_plus_p_theta_fld_prime+4*a_prime_over_a* ppw->rho_plus_p_theta_fld - (rho_fld+p_fld)*metric_euler)/k2;
      }

      ppw->delta_rho += ppw->delta_rho_fld;
      ppw->rho_plus_p_theta += ppw->rho_plus_p_theta_fld;
      ppw->delta_p += ppw->delta_p_fld;

      ppw->rho_plus_p_tot += (1.+w_fld)*ppw->pvecback[pba->index_bg_rho_fld];

    }

    /* don't add more species here, add them before the fluid contribution: because of the PPF scheme, the fluid must be the last one! */

    /* store delta_m in the current gauge. In perturbations_einstein, this
       will be transformed later on into the gauge-independent variable D
       = delta_m + 3 a H \theta_m/k^2 .  */

    if (ppt->has_source_delta_m == _TRUE_)
      ppw->delta_m = delta_rho_m/rho_m;

    /* store theta_m in the current gauge. In perturbations_einstein, this
       will be transformed later on into the gauge-independent variable
       Theta . Note that computing theta_m is necessary also if we want
       the delta_m source only, because the gauge-invariant delta_m
       involves theta_m in the current gauge. */

    if ((ppt->has_source_delta_m == _TRUE_) || (ppt->has_source_theta_m == _TRUE_))
      ppw->theta_m = rho_plus_p_theta_m/rho_plus_p_m;

    /* could include Lambda contribution to rho_tot (not done to match CMBFAST/CAMB definition) */

  }

  /** - for vector modes */

  if (_vectors_) {

    ppw->vector_source_pi = 0.;
    ppw->vector_source_v = 0.;

    /** - --> photon contribution to vector sources: */
    if (ppw->approx[ppw->index_ap_rsa] == (int)rsa_off) { /* if radiation streaming approximation is off */
      if (ppw->approx[ppw->index_ap_tca] == (int)tca_off) { /* if tight-coupling approximation is off */

        ppw->vector_source_v += 4./3.*a2*ppw->pvecback[pba->index_bg_rho_g]
          * (-1./4.*_SQRT2_)
          * (y[ppw->pv->index_pt_delta_g]+2.*y[ppw->pv->index_pt_delta_g]+y[ppw->pv->index_pt_shear_g]);

        ppw->vector_source_pi += 1./3.*a2*ppw->pvecback[pba->index_bg_rho_g]
          * (6.*_SQRT2_/5./sqrt(1.-2.*pba->K/k/k))
          * (4./3./k*y[ppw->pv->index_pt_theta_g]+y[ppw->pv->index_pt_l3_g]);

      }
    }

    /** - --> baryons */


  }

  /** - for tensor modes */

  if (_tensors_) {

    ppw->gw_source = 0.0;

    /** - --> photon contribution to gravitational wave source: */
    if (ppw->approx[ppw->index_ap_rsa] == (int)rsa_off) { /* if radiation streaming approximation is off */
      if (ppw->approx[ppw->index_ap_tca] == (int)tca_off) { /* if tight-coupling approximation is off */

        ppw->gw_source += (-_SQRT6_*4*a2*ppw->pvecback[pba->index_bg_rho_g]*
                           (1./15.*y[ppw->pv->index_pt_delta_g]+
                            4./21.*y[ppw->pv->index_pt_shear_g]+
                            1./35.*y[ppw->pv->index_pt_l3_g+1]));
      }
    }

    /** - --> ur contribution to gravitational wave source: */
    if (ppt->evolve_tensor_ur == _TRUE_){

      rho_relativistic = 0.;

      if (ppt->tensor_method == tm_exact)
        rho_relativistic += ppw->pvecback[pba->index_bg_rho_ur];

      if (ppt->tensor_method == tm_massless_approximation) {

        if (pba->has_ur == _TRUE_)
          rho_relativistic += ppw->pvecback[pba->index_bg_rho_ur];

        if (pba->has_ncdm == _TRUE_) {
          for (n_ncdm = 0; n_ncdm < pba->N_ncdm; n_ncdm++) {
            /* (3 p_ncdm1) is the "relativistic" contribution to rho_ncdm1 */
            rho_relativistic += 3.*ppw->pvecback[pba->index_bg_p_ncdm1+n_ncdm];
          }
        }
      }

      ppw->gw_source += (-_SQRT6_*4*a2*rho_relativistic*
                         (1./15.*y[ppw->pv->index_pt_delta_ur]+
                          4./21.*y[ppw->pv->index_pt_shear_ur]+
                          1./35.*y[ppw->pv->index_pt_l3_ur+1]));
    }

    /** - --> ncdm contribution to gravitational wave source: */
    if (ppt->evolve_tensor_ncdm == _TRUE_){

      idx = ppw->pv->index_pt_psi0_ncdm1;

      // We must integrate to find perturbations:
      for (n_ncdm=0; n_ncdm < pba->N_ncdm; n_ncdm++){

        gwncdm = 0.;

        factor = pba->factor_ncdm[n_ncdm]/pow(a,4);

        for (index_q=0; index_q < ppw->pv->q_size_ncdm[n_ncdm]; index_q ++) {

          q = pba->q_ncdm[n_ncdm][index_q];
          q2 = q*q;
          epsilon = sqrt(q2+pba->M_ncdm[n_ncdm]*pba->M_ncdm[n_ncdm]*a2);

          gwncdm += q2*q2/epsilon*pba->w_ncdm[n_ncdm][index_q]*(1./15.*y[idx]+2./21.*y[idx+2]+1./35.*y[idx+4]);

          //Jump to next momentum bin:
          idx+=(ppw->pv->l_max_ncdm[n_ncdm]+1);
        }

        gwncdm *= -_SQRT6_*4*a2*factor;

        ppw->gw_source += gwncdm;

      }
    }
  }

  return _SUCCESS_;
}

/**
 * Compute the source functions (three terms for temperature, one for
 * E or B modes, etc.)
 *
 * This is one of the few functions in the code which is passed to
 * the generic_integrator() routine. Since generic_integrator()
 * should work with functions passed from various modules, the format
 * of the arguments is a bit special:
 *
 * - fixed parameters and workspaces are passed through a generic
 * pointer.  generic_integrator() doesn't know the content of this
 * pointer.
 *
 * - the error management is a bit special: errors are not written as
 * usual to pth->error_message, but to a generic error_message passed
 * in the list of arguments.
 *
 * @param tau                      Input: conformal time
 * @param y                        Input: vector of perturbations
 * @param dy                       Input: vector of time derivative of perturbations
 * @param index_tau                Input: index in the array tau_sampling
 * @param parameters_and_workspace Input/Output: in input, all parameters needed by perturbations_derivs, in output, source terms
 * @param error_message            Output: error message
 * @return the error status
 */

int perturbations_sources(
                          double tau,
                          double * y,
                          double * dy,
                          int index_tau,
                          void * parameters_and_workspace,
                          ErrorMsg error_message
                          ) {
  /** Summary: */

  /** - define local variables */

  double P;
  int index_tp;

  struct perturbations_parameters_and_workspace * pppaw;
  struct precision * ppr;
  struct background * pba;
  struct thermodynamics * pth;
  struct perturbations * ppt;
  int index_md;
  int index_ic;
  int index_k;
  double k;
  double z;
  struct perturbations_workspace * ppw;
  double * pvecback;
  double * pvecthermo;
  double * pvecmetric;

  double delta_g, delta_rho_scf, rho_plus_p_theta_scf;
  double a_prime_over_a=0.;  /* (a'/a) */
  double a_prime_over_a_prime=0.;  /* (a'/a)' */
  double w_fld,dw_over_da_fld,integral_fld;
  int switch_isw = 1;

  double a, a2, f_dr;

  double H_T_Nb_prime=0., rho_tot;
  double theta_over_k2,theta_shift;

  double theta_b, theta_b_prime;
  double dkappa, ddkappa, exp_m_kappa, g, g_prime;
  double theta_idm = 0., theta_idm_prime = 0.;
  double dmu_idm_g = 0., ddmu_idm_g = 0., exp_mu_idm_g = 0.;
  /** - rename structure fields (just to avoid heavy notations) */

  pppaw = (struct perturbations_parameters_and_workspace *)parameters_and_workspace;
  ppr = pppaw->ppr;
  pba = pppaw->pba;
  pth = pppaw->pth;
  ppt = pppaw->ppt;
  index_md = pppaw->index_md;
  index_ic = pppaw->index_ic;
  index_k = pppaw->index_k;
  k = pppaw->k;
  ppw = pppaw->ppw;

  pvecback = ppw->pvecback;
  pvecthermo = ppw->pvecthermo;
  pvecmetric = ppw->pvecmetric;

  /** - get background/thermo quantities in this point */

  class_call(background_at_tau(pba,
                               tau,
                               normal_info,
                               inter_closeby,
                               &(ppw->last_index_back),
                               pvecback),
             pba->error_message,
             error_message);

  /* redshift (remember that a in the code stands for (a/a_0)) */
  z = 1./pvecback[pba->index_bg_a]-1.;

  class_call(thermodynamics_at_z(pba,
                                 pth,
                                 z,  /* redshift z=1/a-1 */
                                 inter_closeby,
                                 &(ppw->last_index_thermo),
                                 pvecback,
                                 pvecthermo),
             pth->error_message,
             error_message);

  a = ppw->pvecback[pba->index_bg_a];
  a2 = a * a;

  a_prime_over_a = pvecback[pba->index_bg_a] * pvecback[pba->index_bg_H]; /* (a'/a)=aH */
  a_prime_over_a_prime = pvecback[pba->index_bg_H_prime] * pvecback[pba->index_bg_a] + pow(pvecback[pba->index_bg_H] * pvecback[pba->index_bg_a],2); /* (a'/a)' = aH'+(aH)^2 */

  dkappa = pvecthermo[pth->index_th_dkappa];
  ddkappa = pvecthermo[pth->index_th_ddkappa];
  exp_m_kappa = pvecthermo[pth->index_th_exp_m_kappa];
  g = pvecthermo[pth->index_th_g];
  g_prime = pvecthermo[pth->index_th_dg];

  if (pba->has_idm == _TRUE_) {
    theta_idm= y[ppw->pv->index_pt_theta_idm];
    theta_idm_prime = dy[ppw->pv->index_pt_theta_idm];
  }
  if (pth->has_idm_g == _TRUE_) {
    dmu_idm_g = pvecthermo[pth->index_th_dmu_idm_g];
    ddmu_idm_g = pvecthermo[pth->index_th_ddmu_idm_g];
    exp_mu_idm_g = pvecthermo[pth->index_th_exp_mu_idm_g];
  }

  /** - for scalars */
  if (_scalars_) {

    theta_b = y[ppw->pv->index_pt_theta_b];
    theta_b_prime = dy[ppw->pv->index_pt_theta_b];

    /** - --> compute metric perturbations */

    class_call(perturbations_einstein(ppr,
                                      pba,
                                      pth,
                                      ppt,
                                      index_md,
                                      k,
                                      tau,
                                      y,
                                      ppw),
               ppt->error_message,
               error_message);

    /** - --> compute quantities depending on approximation schemes */

    if (ppw->approx[ppw->index_ap_rsa] == (int)rsa_on) {

      delta_g = ppw->rsa_delta_g;
      P = 0.;

    }
    else {

      delta_g = y[ppw->pv->index_pt_delta_g];
      if (ppw->approx[ppw->index_ap_tca] == (int)tca_on)
        P = 5.* ppw->s_l[2] * ppw->tca_shear_g/8.; /* (2.5+0.5+2)shear_g/8 */
      else
        P = (y[ppw->pv->index_pt_pol0_g] + y[ppw->pv->index_pt_pol2_g] + 2.* ppw->s_l[2] *y[ppw->pv->index_pt_shear_g])/8.;

    }

    /** - --> for each type, compute source terms */

    /* scalar temperature */
    if (ppt->has_source_t == _TRUE_) {

      /* check whether integrated Sachs-Wolf term should be included */
      if ((ppt->switch_eisw == 0) && (z >= ppt->eisw_lisw_split_z)){
        switch_isw = 0;
      }
      if ((ppt->switch_lisw == 0) && (z < ppt->eisw_lisw_split_z)) {
        switch_isw=0;
      }

      /* newtonian gauge: simplest form, not efficient numerically */
      /*
        if (ppt->gauge == newtonian) {
        _set_source_(ppt->index_tp_t0) = pvecthermo[pth->index_th_exp_m_kappa] * pvecmetric[ppw->index_mt_phi_prime] + pvecthermo[pth->index_th_g] * delta_g / 4.;
        _set_source_(ppt->index_tp_t1) = pvecthermo[pth->index_th_exp_m_kappa] * k* pvecmetric[ppw->index_mt_psi] + pvecthermo[pth->index_th_g] * y[ppw->pv->index_pt_theta_b]/k;
        _set_source_(ppt->index_tp_t2) = pvecthermo[pth->index_th_g] * P;
        }
      */

      /* newtonian gauge: slightly more complicated form, but more efficient numerically */

      if (ppt->gauge == newtonian) {
        if (pth->has_idm_g == _TRUE_ ){
          _set_source_(ppt->index_tp_t0) =
            ppt->switch_sw * g * (delta_g / 4. + pvecmetric[ppw->index_mt_psi])
            + switch_isw * ( g * (y[ppw->pv->index_pt_phi]-pvecmetric[ppw->index_mt_psi])
                             + exp_m_kappa * exp_mu_idm_g * 2. * pvecmetric[ppw->index_mt_phi_prime])
            + ppt->switch_dop /k/k * ( g *(dkappa * theta_b + dmu_idm_g*theta_idm)
                                       + exp_mu_idm_g * exp_m_kappa * (ddkappa*theta_b + ddmu_idm_g* theta_idm + dkappa * theta_b_prime + dmu_idm_g * theta_idm_prime) );

          _set_source_(ppt->index_tp_t1) = switch_isw * exp_m_kappa * exp_mu_idm_g * k* (pvecmetric[ppw->index_mt_psi]-y[ppw->pv->index_pt_phi]);

        }
        else {
          _set_source_(ppt->index_tp_t0) =
            ppt->switch_sw * g * (delta_g / 4. + pvecmetric[ppw->index_mt_psi])
            + switch_isw * ( g * (y[ppw->pv->index_pt_phi]-pvecmetric[ppw->index_mt_psi])
                             + exp_m_kappa * 2. * pvecmetric[ppw->index_mt_phi_prime])
            + ppt->switch_dop /k/k * ( g * theta_b_prime  + g_prime * theta_b);

          _set_source_(ppt->index_tp_t1) = switch_isw * exp_m_kappa * k* (pvecmetric[ppw->index_mt_psi]-y[ppw->pv->index_pt_phi]);
        }

        _set_source_(ppt->index_tp_t2) = ppt->switch_pol * g * P;
      }


      /* synchronous gauge: simplest form, not efficient numerically */
      /*
        if (ppt->gauge == synchronous) {
        _set_source_(ppt->index_tp_t0) = - pvecthermo[pth->index_th_exp_m_kappa] * pvecmetric[ppw->index_mt_h_prime] / 6. + pvecthermo[pth->index_th_g] / 4. * delta_g;
        _set_source_(ppt->index_tp_t1) = pvecthermo[pth->index_th_g] * y[ppw->pv->index_pt_theta_b] / k;
        _set_source_(ppt->index_tp_t2) = pvecthermo[pth->index_th_exp_m_kappa] * k*k* 2./3. * ppw->s_l[2] * pvecmetric[ppw->index_mt_alpha] + pvecthermo[pth->index_th_g] * P;
        }
      */

      /* synchronous gauge: slightly more complicated form, but more efficient numerically */

      if (ppt->gauge == synchronous) {

        theta_b += pvecmetric[ppw->index_mt_alpha] *k*k;            // absorb alpha in here to make the formulas readable
        theta_b_prime += pvecmetric[ppw->index_mt_alpha_prime] *k*k;

        if (pth->has_idm_g == _TRUE_) {
          theta_idm += pvecmetric[ppw->index_mt_alpha] *k*k;
          theta_idm_prime += pvecmetric[ppw->index_mt_alpha_prime] *k*k;

          _set_source_(ppt->index_tp_t0) =
            ppt->switch_sw * g * (delta_g/4. + pvecmetric[ppw->index_mt_alpha_prime])
            + switch_isw * ( g * (y[ppw->pv->index_pt_eta]
                                  - pvecmetric[ppw->index_mt_alpha_prime]
                                  - 2 * a_prime_over_a * pvecmetric[ppw->index_mt_alpha])
                             +  exp_m_kappa * exp_mu_idm_g * 2. * (pvecmetric[ppw->index_mt_eta_prime]
                                                                   - a_prime_over_a_prime * pvecmetric[ppw->index_mt_alpha]
                                                                   - a_prime_over_a * pvecmetric[ppw->index_mt_alpha_prime]))
            + ppt->switch_dop  /k/k * ( g * ( dkappa * theta_b + dmu_idm_g * theta_idm)
                                        + exp_mu_idm_g * exp_m_kappa
                                        * ( ddkappa * theta_b + ddmu_idm_g * theta_idm
                                            + dkappa * theta_b_prime + dmu_idm_g * theta_idm_prime) );


          _set_source_(ppt->index_tp_t1) =
            switch_isw * exp_m_kappa * exp_mu_idm_g * k * (pvecmetric[ppw->index_mt_alpha_prime]
                                                           + 2. * a_prime_over_a * pvecmetric[ppw->index_mt_alpha]
                                                           - y[ppw->pv->index_pt_eta]);

        }
        else {
          _set_source_(ppt->index_tp_t0) =
            ppt->switch_sw * g * (delta_g/4. + pvecmetric[ppw->index_mt_alpha_prime])
            + switch_isw * ( g * (y[ppw->pv->index_pt_eta]
                                  - pvecmetric[ppw->index_mt_alpha_prime]
                                  - 2 * a_prime_over_a * pvecmetric[ppw->index_mt_alpha])
                             + exp_m_kappa * 2. * (pvecmetric[ppw->index_mt_eta_prime]
                                                   - a_prime_over_a_prime * pvecmetric[ppw->index_mt_alpha]
                                                   - a_prime_over_a * pvecmetric[ppw->index_mt_alpha_prime]))
            + ppt->switch_dop /k/k * ( g * theta_b_prime + g_prime * theta_b );


          _set_source_(ppt->index_tp_t1) =
            switch_isw * exp_m_kappa * k * (pvecmetric[ppw->index_mt_alpha_prime]
                                            + 2. * a_prime_over_a * pvecmetric[ppw->index_mt_alpha]
                                            - y[ppw->pv->index_pt_eta]);
        }
        _set_source_(ppt->index_tp_t2) =
          ppt->switch_pol * g * P;
      }

    }

    /* scalar polarization */
    if (ppt->has_source_p == _TRUE_) {

      /* all gauges. Note that the correct formula for the E source
         should have a minus sign, as shown in Hu & White. We put a
         plus sign to comply with the 'historical convention'
         established in CMBFAST and CAMB. */

      _set_source_(ppt->index_tp_p) = sqrt(6.) * g * P;

    }

    /* now, non-CMB sources */

    if ((ppt->has_Nbody_gauge_transfers == _TRUE_) || (ppt->has_source_H_T_Nb_prime == _TRUE_) || (ppt->has_source_k2gamma_Nb == _TRUE_)) {

      /* H_T_prime in N-body gauge. (H_T=3zeta where zeta is the comoving curvature perturbation.).
         See equation A.5 in 1811.00904.*/
      H_T_Nb_prime = 3*a_prime_over_a/ppw->rho_plus_p_tot*(-ppw->delta_p+
                                                           pvecback[pba->index_bg_p_tot_prime]*ppw->rho_plus_p_theta/ppw->rho_plus_p_tot/k/k+
                                                           ppw->rho_plus_p_shear);
      if (ppt->has_source_H_T_Nb_prime == _TRUE_) {
        _set_source_(ppt->index_tp_H_T_Nb_prime) = H_T_Nb_prime;
      }

      /** gamma in N-body gauge. Eq. A.2 in 1811.00904 gives k2gamma =
          (a'/a)H_T' + k2(phi-psi) - H_T''. The last term is cubersome
          to calculate (one would need finite derivatives) but usually
          small. Here we only compute an approximate k2gamma without
          this last term. If needed, the term could be restored: you
          can see how T. Tram did it in a previous commit
          beec79548877e1e43403d1f4de5ddee6741a3c16 (28.02.2019) - then
          it had to go to harmonic.c, now it could stay in this
          module. Later this feature was removed for simplicity. Note
          that to compute the transfer functions in the N-body gauge
          we do not need k2gamma anyway. */

      if (ppt->has_source_k2gamma_Nb == _TRUE_){
        _set_source_(ppt->index_tp_k2gamma_Nb) = -a_prime_over_a*H_T_Nb_prime+9./2.*a2*ppw->rho_plus_p_shear;
      }
    }

    /* Bardeen potential -PHI_H = phi in Newtonian gauge */
    if (ppt->has_source_phi == _TRUE_) {

      if (ppt->gauge == newtonian)
        _set_source_(ppt->index_tp_phi) = y[ppw->pv->index_pt_phi];

      if (ppt->gauge == synchronous)
        _set_source_(ppt->index_tp_phi) = y[ppw->pv->index_pt_eta] - a_prime_over_a * pvecmetric[ppw->index_mt_alpha];

    }

    /* its derivative phi' */
    if (ppt->has_source_phi_prime == _TRUE_) {

      if (ppt->gauge == newtonian)
        _set_source_(ppt->index_tp_phi_prime) = dy[ppw->pv->index_pt_phi];

      if (ppt->gauge == synchronous)
        _set_source_(ppt->index_tp_phi_prime) = dy[ppw->pv->index_pt_eta]
          - a_prime_over_a_prime * pvecmetric[ppw->index_mt_alpha]
          - a_prime_over_a * pvecmetric[ppw->index_mt_alpha_prime];
    }

    /* diff of Bardeen potentials PHI_A-PHI_H = psi + phi in newtonian gauge */
    if (ppt->has_source_phi_plus_psi == _TRUE_) {

      if (ppt->gauge == newtonian)
        _set_source_(ppt->index_tp_phi_plus_psi) =
          y[ppw->pv->index_pt_phi] + pvecmetric[ppw->index_mt_psi];

      if (ppt->gauge == synchronous)
        _set_source_(ppt->index_tp_phi_plus_psi) =
          y[ppw->pv->index_pt_eta] + pvecmetric[ppw->index_mt_alpha_prime];

    }

    /* Bardeen potential PHI_A = psi in newtonian gauge */
    if (ppt->has_source_psi == _TRUE_) {

      if (ppt->gauge == newtonian)
        _set_source_(ppt->index_tp_psi) =
          pvecmetric[ppw->index_mt_psi];

      if (ppt->gauge == synchronous)
        _set_source_(ppt->index_tp_psi) =
          a_prime_over_a * pvecmetric[ppw->index_mt_alpha] + pvecmetric[ppw->index_mt_alpha_prime];
    }

    /* the metric potentials h and eta in synchronous gauge */
    if (ppt->gauge == synchronous) {

      /* cdm is always on in synchronous gauge, see error message above that checks gauge and has_cdm */
      if (ppt->has_source_h == _TRUE_)
        _set_source_(ppt->index_tp_h) = - 2 * y[ppw->pv->index_pt_delta_cdm];

      if (ppt->has_source_h_prime == _TRUE_)
        _set_source_(ppt->index_tp_h_prime) = pvecmetric[ppw->index_mt_h_prime];

      if (ppt->has_source_eta == _TRUE_)
        _set_source_(ppt->index_tp_eta) = y[ppw->pv->index_pt_eta];

      if (ppt->has_source_eta_prime == _TRUE_)
        _set_source_(ppt->index_tp_eta_prime) = dy[ppw->pv->index_pt_eta];

    }

    /* total matter overdensity (gauge-invariant, defined as in arXiv:1307.1459) */
    if (ppt->has_source_delta_m == _TRUE_) {
      _set_source_(ppt->index_tp_delta_m) = ppw->delta_m;
    }

    /* cdm and baryon over density */
    if (ppt->has_source_delta_cb == _TRUE_) {
      _set_source_(ppt->index_tp_delta_cb) = ppw->delta_cb;
    }

    /* compute the corrections that have to be applied to each (delta_i, theta_i) in N-body gauge */
	if (ppt->has_Nbody_gauge_transfers == _TRUE_){
      theta_over_k2 = ppw->rho_plus_p_theta/ppw->rho_plus_p_tot/k/k;
      theta_shift = H_T_Nb_prime;
      if (ppt->gauge == synchronous) theta_shift += pvecmetric[ppw->index_mt_alpha]*k*k;
	}
	else{
	  theta_over_k2 = 0.;
	  theta_shift = 0.;
	}

    /* delta_tot */
    if (ppt->has_source_delta_tot == _TRUE_)  {

      /** We follow the (debatable) CMBFAST/CAMB convention of not including rho_lambda in rho_tot */
      if (pba->has_lambda == _TRUE_){
        rho_tot = pvecback[pba->index_bg_rho_tot] - pvecback[pba->index_bg_rho_lambda];
      }
      else{
        rho_tot = pvecback[pba->index_bg_rho_tot];
      }

      _set_source_(ppt->index_tp_delta_tot) = ppw->delta_rho/rho_tot
        + 3*a_prime_over_a*(1+pvecback[pba->index_bg_p_tot]/pvecback[pba->index_bg_rho_tot])*theta_over_k2;
    }

    /* delta_g */
    if (ppt->has_source_delta_g == _TRUE_)  {
      _set_source_(ppt->index_tp_delta_g) = delta_g
        + 4.*a_prime_over_a*theta_over_k2; // N-body gauge correction
    }

    /* delta_baryon */
    if (ppt->has_source_delta_b == _TRUE_) {
      _set_source_(ppt->index_tp_delta_b) = y[ppw->pv->index_pt_delta_b]
        + 3.*a_prime_over_a*theta_over_k2; // N-body gauge correction
    }

    /* delta_cdm */
    if (ppt->has_source_delta_cdm == _TRUE_) {
      _set_source_(ppt->index_tp_delta_cdm) = y[ppw->pv->index_pt_delta_cdm]
        + 3.*a_prime_over_a*theta_over_k2; // N-body gauge correction
    }

    /* delta_idm */
    if (ppt->has_source_delta_idm == _TRUE_) {
      _set_source_(ppt->index_tp_delta_idm) = y[ppw->pv->index_pt_delta_idm]
        + 3.*a_prime_over_a*theta_over_k2; // N-body gauge correction
    }

    /* delta_dcdm */
    if (ppt->has_source_delta_dcdm == _TRUE_) {
      _set_source_(ppt->index_tp_delta_dcdm) = y[ppw->pv->index_pt_delta_dcdm]
        + (3.*a_prime_over_a+a*pba->Gamma_dcdm)*theta_over_k2; // N-body gauge correction;
    }

    /* delta_fld */
    if (ppt->has_source_delta_fld == _TRUE_) {
      _set_source_(ppt->index_tp_delta_fld) = ppw->delta_rho_fld/pvecback[pba->index_bg_rho_fld]
        + 3.*a_prime_over_a*(1.+pvecback[pba->index_bg_w_fld])*theta_over_k2; // N-body gauge correction
    }

    /* delta_scf */
    if (ppt->has_source_delta_scf == _TRUE_) {
      if (ppt->gauge == synchronous){
        delta_rho_scf =  1./3.*
          (1./a2*ppw->pvecback[pba->index_bg_phi_prime_scf]*y[ppw->pv->index_pt_phi_prime_scf]
           + ppw->pvecback[pba->index_bg_dV_scf]*y[ppw->pv->index_pt_phi_scf])
          + 3.*a_prime_over_a*(1.+pvecback[pba->index_bg_p_scf]/pvecback[pba->index_bg_rho_scf])*theta_over_k2; // N-body gauge correction
      }
      else{
        delta_rho_scf =  1./3.*
          (1./a2*ppw->pvecback[pba->index_bg_phi_prime_scf]*y[ppw->pv->index_pt_phi_prime_scf]
           + ppw->pvecback[pba->index_bg_dV_scf]*y[ppw->pv->index_pt_phi_scf]
           - 1./a2*pow(ppw->pvecback[pba->index_bg_phi_prime_scf],2)*ppw->pvecmetric[ppw->index_mt_psi])
          + 3.*a_prime_over_a*(1.+pvecback[pba->index_bg_p_scf]/pvecback[pba->index_bg_rho_scf])*theta_over_k2; // N-body gauge correction
      }
      _set_source_(ppt->index_tp_delta_scf) = delta_rho_scf/pvecback[pba->index_bg_rho_scf];
    }

    /* delta_dr */
    if (ppt->has_source_delta_dr == _TRUE_) {
      f_dr = pow(a2/pba->H0,2)*pvecback[pba->index_bg_rho_dr];
      _set_source_(ppt->index_tp_delta_dr) = y[ppw->pv->index_pt_F0_dr]/f_dr
        + 4.*a_prime_over_a*theta_over_k2; // N-body gauge correction
    }

    /* delta_ur */
    if (ppt->has_source_delta_ur == _TRUE_) {
      if (ppw->approx[ppw->index_ap_rsa]==(int)rsa_off)
        _set_source_(ppt->index_tp_delta_ur) = y[ppw->pv->index_pt_delta_ur]
          + 4.*a_prime_over_a*theta_over_k2; // N-body gauge correction
      else
        _set_source_(ppt->index_tp_delta_ur) = ppw->rsa_delta_ur
          + 4.*a_prime_over_a*theta_over_k2; // N-body gauge correction
    }

    /* delta_idr */
    if (ppt->has_source_delta_idr == _TRUE_) {
      if (ppw->approx[ppw->index_ap_rsa_idr]==(int)rsa_idr_off)
        _set_source_(ppt->index_tp_delta_idr) = y[ppw->pv->index_pt_delta_idr]
          + 4.*a_prime_over_a*theta_over_k2; // N-body gauge correction
      else
        _set_source_(ppt->index_tp_delta_idr) = ppw->rsa_delta_idr
          + 4.*a_prime_over_a*theta_over_k2; // N-body gauge correction
    }

    /* delta_ncdm1 */
    if (ppt->has_source_delta_ncdm == _TRUE_) {
      for (index_tp = ppt->index_tp_delta_ncdm1; index_tp < ppt->index_tp_delta_ncdm1+pba->N_ncdm; index_tp++) {
        _set_source_(index_tp) = ppw->delta_ncdm[index_tp - ppt->index_tp_delta_ncdm1]
          + 3.*a_prime_over_a*(1+pvecback[index_tp - ppt->index_tp_delta_ncdm1 + pba->index_bg_p_ncdm1]
                               /pvecback[index_tp - ppt->index_tp_delta_ncdm1 + pba->index_bg_rho_ncdm1])*theta_over_k2; // N-body gauge correction
      }
    }

    /* total velocity  */
    if (ppt->has_source_theta_tot == _TRUE_) {
      _set_source_(ppt->index_tp_theta_tot) = ppw->rho_plus_p_theta/(pvecback[pba->index_bg_rho_tot]+pvecback[pba->index_bg_p_tot])
        + theta_shift; // N-body gauge correction
    }

    /* total matter velocity (gauge-invariant, defined as in arXiv:1307.1459) */
    if (ppt->has_source_theta_m == _TRUE_) {
      _set_source_(ppt->index_tp_theta_m) = ppw->theta_m;
    }

    /* cdm and baryon velocity */
    if (ppt->has_source_theta_cb == _TRUE_) {
      _set_source_(ppt->index_tp_theta_cb) = ppw->theta_cb;
    }

    /* total velocity */
    if (ppt->has_source_theta_tot == _TRUE_) {
      _set_source_(ppt->index_tp_theta_tot) = ppw->rho_plus_p_theta/ppw->rho_plus_p_tot
        + theta_shift; // N-body gauge correction
    }

    /* theta_g */
    if (ppt->has_source_theta_g == _TRUE_) {
      if (ppw->approx[ppw->index_ap_rsa]==(int)rsa_off)
        _set_source_(ppt->index_tp_theta_g) = y[ppw->pv->index_pt_theta_g]
          + theta_shift; // N-body gauge correction
      else
        _set_source_(ppt->index_tp_theta_g) = ppw->rsa_theta_g
          + theta_shift; // N-body gauge correction
    }

    /* theta_baryon */
    if (ppt->has_source_theta_b == _TRUE_) {
      _set_source_(ppt->index_tp_theta_b) = y[ppw->pv->index_pt_theta_b]
        + theta_shift; // N-body gauge correction
    }

    /* theta_cdm */
    if (ppt->has_source_theta_cdm == _TRUE_) {
      _set_source_(ppt->index_tp_theta_cdm) = y[ppw->pv->index_pt_theta_cdm]
        + theta_shift; // N-body gauge correction
    }

    /* theta_idm */
    if (ppt->has_source_theta_idm == _TRUE_) {
      _set_source_(ppt->index_tp_theta_idm) = y[ppw->pv->index_pt_theta_idm]
        + theta_shift; // N-body gauge correction
    }

    /* theta_dcdm */
    if (ppt->has_source_theta_dcdm == _TRUE_) {
      _set_source_(ppt->index_tp_theta_dcdm) = y[ppw->pv->index_pt_theta_dcdm]
        + theta_shift; // N-body gauge correction
    }

    /* theta_fld */
    if (ppt->has_source_theta_fld == _TRUE_) {

      class_call(background_w_fld(pba,a,&w_fld,&dw_over_da_fld,&integral_fld), pba->error_message, ppt->error_message);

      _set_source_(ppt->index_tp_theta_fld) = ppw->rho_plus_p_theta_fld/(1.+w_fld)/pvecback[pba->index_bg_rho_fld]
        + theta_shift; // N-body gauge correction
    }

    /* theta_scf */
    if (ppt->has_source_theta_scf == _TRUE_) {

      rho_plus_p_theta_scf = 1./3.*
        k*k/a2*ppw->pvecback[pba->index_bg_phi_prime_scf]*y[ppw->pv->index_pt_phi_scf];

      _set_source_(ppt->index_tp_theta_scf) = rho_plus_p_theta_scf/(pvecback[pba->index_bg_rho_scf]+pvecback[pba->index_bg_p_scf])
        + theta_shift; // N-body gauge correction
    }

    /* theta_dr */
    if (ppt->has_source_theta_dr == _TRUE_) {

      f_dr = pow(a2/pba->H0,2)*pvecback[pba->index_bg_rho_dr];

      _set_source_(ppt->index_tp_theta_dr) = 3./4.*k*y[ppw->pv->index_pt_F0_dr+1]/f_dr
        + theta_shift; // N-body gauge correction
    }

    /* theta_ur */
    if (ppt->has_source_theta_ur == _TRUE_) {
      if (ppw->approx[ppw->index_ap_rsa]==(int)rsa_off)
        _set_source_(ppt->index_tp_theta_ur) = y[ppw->pv->index_pt_theta_ur]
          + theta_shift; // N-body gauge correction
      else
        _set_source_(ppt->index_tp_theta_ur) = ppw->rsa_theta_ur
          + theta_shift; // N-body gauge correction
    }

    /* theta_idr */
    if (ppt->has_source_theta_idr == _TRUE_) {
      if (ppw->approx[ppw->index_ap_rsa_idr]==(int)rsa_idr_off)
        _set_source_(ppt->index_tp_theta_idr) = y[ppw->pv->index_pt_theta_idr]
          + theta_shift; // N-body gauge correction
      else
        _set_source_(ppt->index_tp_theta_idr) = ppw->rsa_theta_idr
          + theta_shift; // N-body gauge correction
    }

    /* theta_ncdm1 */
    if (ppt->has_source_theta_ncdm == _TRUE_) {
      for (index_tp = ppt->index_tp_theta_ncdm1; index_tp < ppt->index_tp_theta_ncdm1+pba->N_ncdm; index_tp++) {
        _set_source_(index_tp) = ppw->theta_ncdm[index_tp - ppt->index_tp_theta_ncdm1]
          + theta_shift; // N-body gauge correction
      }
    }
  }

  /** - for tensors */
  if (_tensors_) {

    /** - --> compute quantities depending on approximation schemes */
    if (ppw->approx[ppw->index_ap_rsa] == (int)rsa_off) {
      if (ppw->approx[ppw->index_ap_tca] == (int)tca_off) {

        P = -(1./10.*y[ppw->pv->index_pt_delta_g]
              +2./7.*y[ppw->pv->index_pt_shear_g]
              +3./70.*y[ppw->pv->index_pt_delta_g+4]
              -3./5.*y[ppw->pv->index_pt_pol0_g]
              +6./7.*y[ppw->pv->index_pt_pol2_g]
              -3./70.*y[ppw->pv->index_pt_pol0_g+4])
          /sqrt(6.);

      }
      else {
        P = 2./5.*_SQRT6_*y[ppw->pv->index_pt_gwdot]/ppw->pvecthermo[pth->index_th_dkappa]; //TBC
      }
    }
    else {
      P = 0.;
    }

    /* tensor temperature */
    if (ppt->has_source_t == _TRUE_) {
      _set_source_(ppt->index_tp_t2) = - y[ppw->pv->index_pt_gwdot] * pvecthermo[pth->index_th_exp_m_kappa] + pvecthermo[pth->index_th_g] * P;
    }

    /* tensor polarization */
    if (ppt->has_source_p == _TRUE_) {

      /* Note that the correct formula for the polarization source
         should have a minus sign, as shown in Hu & White. We put a
         plus sign to comply with the 'historical convention'
         established in CMBFAST and CAMB. */

      _set_source_(ppt->index_tp_p) = sqrt(6.) * pvecthermo[pth->index_th_g] * P;
    }
  }

  return _SUCCESS_;

}


/**
 * When testing the code or a cosmological model, it can be useful to
 * output perturbations at each step of integration (and not just the
 * delta's at each source sampling point, which is achieved simply by
 * asking for matter transfer functions). Then this function can be
 * passed to the generic_evolver routine.
 *
 * By default, instead of passing this function to generic_evolver,
 * one passes a null pointer. Then this function is just not used.
 *
 * @param tau                      Input: conformal time
 * @param y                        Input: vector of perturbations
 * @param dy                       Input: vector of its derivatives (already allocated)
 * @param parameters_and_workspace Input: fixed parameters (e.g. indices)
 * @param error_message            Output: error message
 *
 */

int perturbations_print_variables(double tau,
                                  double * y,
                                  double * dy,
                                  void * parameters_and_workspace,
                                  ErrorMsg error_message
                                  ) {

  struct perturbations_parameters_and_workspace * pppaw;
  /** Summary: */

  /** - define local variables */
  double k;
  int index_md;

  struct precision * ppr;
  struct background * pba;
  struct thermodynamics * pth;
  struct perturbations * ppt;
  struct perturbations_workspace * ppw;
  double * pvecback;
  double * pvecthermo;
  double * pvecmetric;

  double delta_g,theta_g,shear_g,l4_g,pol0_g,pol1_g,pol2_g,pol4_g;
  double delta_b,theta_b;
  double delta_cdm=0.,theta_cdm=0.;
  double delta_idm=0., theta_idm=0.;
  double delta_dcdm=0.,theta_dcdm=0.;
  double delta_dr=0.,theta_dr=0.,shear_dr=0., f_dr=1.0;
  double delta_ur=0.,theta_ur=0.,shear_ur=0.,l4_ur=0.;
  double delta_idr=0., theta_idr=0., shear_idr=0.;
  double delta_rho_scf=0., rho_plus_p_theta_scf=0.;
  double delta_scf=0., theta_scf=0.;
  /** - ncdm sector begins */
  int n_ncdm;
  double *delta_ncdm=NULL, *theta_ncdm=NULL, *shear_ncdm=NULL, *delta_p_over_delta_rho_ncdm=NULL;
  double rho_ncdm_bg, p_ncdm_bg, pseudo_p_ncdm, w_ncdm;
  double rho_delta_ncdm = 0.0;
  double rho_plus_p_theta_ncdm = 0.0;
  double rho_plus_p_shear_ncdm = 0.0;
  double delta_p_ncdm = 0.0;
  double factor = 0.0;
  double q,q2,epsilon;
  /** - ncdm sector ends */
  double phi=0.,psi=0.,alpha=0.;
  double delta_temp=0., delta_chi=0.;

  double a,a2,H;
  int idx,index_q, storeidx;
  double *dataptr;


  /** - rename structure fields (just to avoid heavy notations) */

  pppaw = (struct perturbations_parameters_and_workspace *)parameters_and_workspace;
  k = pppaw->k;
  index_md = pppaw->index_md;

  ppr = pppaw->ppr;
  pba = pppaw->pba;
  pth = pppaw->pth;
  ppt = pppaw->ppt;
  ppw = pppaw->ppw;
  pvecback = ppw->pvecback;
  pvecthermo = ppw->pvecthermo;
  pvecmetric = ppw->pvecmetric;

  /** - update background/thermo quantities in this point */

  class_call(background_at_tau(pba,
                               tau,
                               normal_info,
                               inter_closeby,
                               &(ppw->last_index_back),
                               pvecback),
             pba->error_message,
             error_message);

  class_call(thermodynamics_at_z(pba,
                                 pth,
                                 1./pvecback[pba->index_bg_a]-1.,
                                 inter_closeby,
                                 &(ppw->last_index_thermo),
                                 pvecback,
                                 pvecthermo),
             pth->error_message,
             error_message);

  /** - update metric perturbations in this point */

  class_call(perturbations_einstein(ppr,
                                    pba,
                                    pth,
                                    ppt,
                                    index_md,
                                    k,
                                    tau,
                                    y,
                                    ppw),
             ppt->error_message,
             error_message);

  a = pvecback[pba->index_bg_a];
  a2 = a*a;
  H = pvecback[pba->index_bg_H];

  if (pba->has_ncdm == _TRUE_){
    class_alloc(delta_ncdm, sizeof(double)*pba->N_ncdm,error_message);
    class_alloc(theta_ncdm, sizeof(double)*pba->N_ncdm,error_message);
    class_alloc(shear_ncdm, sizeof(double)*pba->N_ncdm,error_message);
    class_alloc(delta_p_over_delta_rho_ncdm, sizeof(double)*pba->N_ncdm,error_message);
  }

  /** - calculate perturbed recombination */

  if ((ppt->has_perturbed_recombination == _TRUE_) && (ppw->approx[ppw->index_ap_tca] == (int)tca_off) ){
    delta_temp = y[ppw->pv->index_pt_perturbed_recombination_delta_temp];
    delta_chi =y[ppw->pv->index_pt_perturbed_recombination_delta_chi];
  }
  /** - for scalar modes */
  if (_scalars_) {

    if (ppw->approx[ppw->index_ap_rsa]==(int)rsa_off) {
      delta_g = y[ppw->pv->index_pt_delta_g];
      theta_g = y[ppw->pv->index_pt_theta_g];
    }
    else {
      delta_g = ppw->rsa_delta_g;
      theta_g = ppw->rsa_theta_g;
    }

    if (ppw->approx[ppw->index_ap_rsa]==(int)rsa_off) {
      if (ppw->approx[ppw->index_ap_tca]==(int)tca_on) {
        shear_g = ppw->tca_shear_g;
        //l3_g = 6./7.*k/pvecthermo[pth->index_th_dkappa]*ppw->tca_shear_g;
        pol0_g = 2.5*ppw->tca_shear_g;
        pol1_g = 7./12.*6./7.*k/pvecthermo[pth->index_th_dkappa]*ppw->tca_shear_g;
        pol2_g = 0.5*ppw->tca_shear_g;
        //pol3_g = 0.25*6./7.*k/pvecthermo[pth->index_th_dkappa]*ppw->tca_shear_g;
      }
      else {
        shear_g = y[ppw->pv->index_pt_shear_g];
        //l3_g = y[ppw->pv->index_pt_l3_g];
        pol0_g = y[ppw->pv->index_pt_pol0_g];
        pol1_g = y[ppw->pv->index_pt_pol1_g];
        pol2_g = y[ppw->pv->index_pt_pol2_g];
        //pol3_g = y[ppw->pv->index_pt_pol3_g];
      }
    }
    else {
      shear_g = 0;
      //l3_g = 0;
      pol0_g = 0;
      pol1_g = 0;
      pol2_g = 0;
      //pol3_g = 0.;
    }

    if (pba->has_ur == _TRUE_) {
      if (ppw->approx[ppw->index_ap_rsa]==(int)rsa_off) {
        delta_ur = y[ppw->pv->index_pt_delta_ur];
        theta_ur = y[ppw->pv->index_pt_theta_ur];
        shear_ur = y[ppw->pv->index_pt_shear_ur];
      }
      else {
        delta_ur = ppw->rsa_delta_ur;
        theta_ur = ppw->rsa_theta_ur;
        shear_ur = 0.;
      }
    }

    delta_b = y[ppw->pv->index_pt_delta_b];
    theta_b = y[ppw->pv->index_pt_theta_b];

    /* interacting dark radiation */
    if (pba->has_idr == _TRUE_) {
      if (ppw->approx[ppw->index_ap_rsa_idr] == (int)rsa_idr_off) {
        delta_idr = y[ppw->pv->index_pt_delta_idr];
        theta_idr = y[ppw->pv->index_pt_theta_idr];

        if (ppt->idr_nature == idr_free_streaming){
          if (ppw->approx[ppw->index_ap_tca_idm_dr] == (int)tca_idm_dr_on){
            shear_idr = ppw->tca_shear_idm_dr;
          }
          else{
            shear_idr = y[ppw->pv->index_pt_shear_idr];
          }
        }
      }
      else{
        delta_idr = ppw->rsa_delta_idr;
        theta_idr = ppw->rsa_theta_idr;
        shear_idr = 0.;
      }
    }


    if (pba->has_cdm == _TRUE_) {

      delta_cdm = y[ppw->pv->index_pt_delta_cdm];
      if (ppt->gauge == synchronous) {
        theta_cdm = 0.;
      }
      else {
        theta_cdm = y[ppw->pv->index_pt_theta_cdm];
      }
    }

    if (pba->has_idm == _TRUE_) {
      delta_idm = y[ppw->pv->index_pt_delta_idm];
      theta_idm = y[ppw->pv->index_pt_theta_idm];
    }

    /* gravitational potentials */
    if (ppt->gauge == synchronous) {

      alpha = pvecmetric[ppw->index_mt_alpha];

      psi = pvecback[pba->index_bg_H]*pvecback[pba->index_bg_a] * alpha + pvecmetric[ppw->index_mt_alpha_prime];
      phi = y[ppw->pv->index_pt_eta] - pvecback[pba->index_bg_H]*pvecback[pba->index_bg_a]*alpha;
    }
    else if (ppt->gauge == newtonian){
      psi = pvecmetric[ppw->index_mt_psi];
      phi = y[ppw->pv->index_pt_phi];
    }
    else{
      psi = 0.0;
      phi = 0.0;
    }

    if (pba->has_ncdm == _TRUE_) {
      /** - --> Get delta, deltaP/rho, theta, shear and store in array */
      idx = ppw->pv->index_pt_psi0_ncdm1;
      if (ppw->approx[ppw->index_ap_ncdmfa] == (int)ncdmfa_on){
        // The perturbations are evolved integrated:
        for (n_ncdm=0; n_ncdm < pba->N_ncdm; n_ncdm++){
          rho_ncdm_bg = pvecback[pba->index_bg_rho_ncdm1+n_ncdm];
          p_ncdm_bg = pvecback[pba->index_bg_p_ncdm1+n_ncdm];
          pseudo_p_ncdm = pvecback[pba->index_bg_pseudo_p_ncdm1+n_ncdm];
          w_ncdm = p_ncdm_bg/rho_ncdm_bg;

          delta_ncdm[n_ncdm] = y[idx];
          theta_ncdm[n_ncdm] = y[idx+1];
          shear_ncdm[n_ncdm] = y[idx+2];
          //This is the adiabatic sound speed:
          delta_p_over_delta_rho_ncdm[n_ncdm] = w_ncdm*(1.0-1.0/(3.0+3.0*w_ncdm)*(3.0*w_ncdm-2.0+pseudo_p_ncdm/p_ncdm_bg));
          idx += ppw->pv->l_max_ncdm[n_ncdm]+1;
        }
      }
      else{
        // We must integrate to find perturbations:
        for (n_ncdm=0; n_ncdm < pba->N_ncdm; n_ncdm++){
          rho_delta_ncdm = 0.0;
          rho_plus_p_theta_ncdm = 0.0;
          rho_plus_p_shear_ncdm = 0.0;
          delta_p_ncdm = 0.0;
          factor = pba->factor_ncdm[n_ncdm]/pow(a,4);

          for (index_q=0; index_q < ppw->pv->q_size_ncdm[n_ncdm]; index_q ++) {

            q = pba->q_ncdm[n_ncdm][index_q];
            q2 = q*q;
            epsilon = sqrt(q2+pba->M_ncdm[n_ncdm]*pba->M_ncdm[n_ncdm]*a2);

            rho_delta_ncdm += q2*epsilon*pba->w_ncdm[n_ncdm][index_q]*y[idx];
            rho_plus_p_theta_ncdm += q2*q*pba->w_ncdm[n_ncdm][index_q]*y[idx+1];
            rho_plus_p_shear_ncdm += q2*q2/epsilon*pba->w_ncdm[n_ncdm][index_q]*y[idx+2];
            delta_p_ncdm += q2*q2/epsilon*pba->w_ncdm[n_ncdm][index_q]*y[idx];

            //Jump to next momentum bin:
            idx+=(ppw->pv->l_max_ncdm[n_ncdm]+1);
          }

          rho_delta_ncdm *= factor;
          rho_plus_p_theta_ncdm *= k*factor;
          rho_plus_p_shear_ncdm *= 2.0/3.0*factor;
          delta_p_ncdm *= factor/3.;

          delta_ncdm[n_ncdm] = rho_delta_ncdm/ppw->pvecback[pba->index_bg_rho_ncdm1+n_ncdm];
          theta_ncdm[n_ncdm] = rho_plus_p_theta_ncdm/
            (ppw->pvecback[pba->index_bg_rho_ncdm1+n_ncdm]+ppw->pvecback[pba->index_bg_p_ncdm1+n_ncdm]);
          shear_ncdm[n_ncdm] = rho_plus_p_shear_ncdm/
            (ppw->pvecback[pba->index_bg_rho_ncdm1+n_ncdm]+ppw->pvecback[pba->index_bg_p_ncdm1+n_ncdm]);
          delta_p_over_delta_rho_ncdm[n_ncdm] = delta_p_ncdm/rho_delta_ncdm;

        }
      }
    }

    if (pba->has_dcdm == _TRUE_) {

      delta_dcdm = y[ppw->pv->index_pt_delta_dcdm];
      theta_dcdm = y[ppw->pv->index_pt_theta_dcdm];

    }


    if (pba->has_dr == _TRUE_) {
      f_dr = pow(pvecback[pba->index_bg_a]*pvecback[pba->index_bg_a]/pba->H0,2)*pvecback[pba->index_bg_rho_dr];
      delta_dr = y[ppw->pv->index_pt_F0_dr]/f_dr;
      theta_dr = y[ppw->pv->index_pt_F0_dr+1]*3./4.*k/f_dr;
      shear_dr = y[ppw->pv->index_pt_F0_dr+2]*0.5/f_dr;
    }

    if (pba->has_scf == _TRUE_){
      if (ppt->gauge == synchronous){
        delta_rho_scf =  1./3.*
          (1./a2*ppw->pvecback[pba->index_bg_phi_prime_scf]*y[ppw->pv->index_pt_phi_prime_scf]
           + ppw->pvecback[pba->index_bg_dV_scf]*y[ppw->pv->index_pt_phi_scf]);
      }
      else{
        delta_rho_scf =  1./3.*
          (1./a2*ppw->pvecback[pba->index_bg_phi_prime_scf]*y[ppw->pv->index_pt_phi_prime_scf]
           + ppw->pvecback[pba->index_bg_dV_scf]*y[ppw->pv->index_pt_phi_scf]
           - 1./a2*pow(ppw->pvecback[pba->index_bg_phi_prime_scf],2)*ppw->pvecmetric[ppw->index_mt_psi]);
      }

      rho_plus_p_theta_scf =  1./3.*
        k*k/a2*ppw->pvecback[pba->index_bg_phi_prime_scf]*y[ppw->pv->index_pt_phi_scf];

      delta_scf = delta_rho_scf/pvecback[pba->index_bg_rho_scf];
      theta_scf = rho_plus_p_theta_scf/(pvecback[pba->index_bg_rho_scf]+pvecback[pba->index_bg_p_scf]);

    }

    /* converting synchronous variables to newtonian ones */
    if (ppt->gauge == synchronous) {

      /* density and velocity perturbations (comment out if you wish to keep synchronous variables) */

      delta_g -= 4. * pvecback[pba->index_bg_H]*pvecback[pba->index_bg_a]*alpha;
      theta_g += k*k*alpha;

      delta_b -= 3. * pvecback[pba->index_bg_H]*pvecback[pba->index_bg_a]*alpha;
      theta_b += k*k*alpha;

      if (pba->has_ur == _TRUE_) {
        delta_ur -= 4. * pvecback[pba->index_bg_H]*pvecback[pba->index_bg_a]*alpha;
        theta_ur += k*k*alpha;
      }

      if (pba->has_idr == _TRUE_) {
        delta_idr -= 4. * pvecback[pba->index_bg_H]*pvecback[pba->index_bg_a]*alpha;
        theta_idr += k*k*alpha;
      }

      if (pba->has_dr == _TRUE_) {
        delta_dr += (-4.*a*H+a*pba->Gamma_dcdm*pvecback[pba->index_bg_rho_dcdm]/pvecback[pba->index_bg_rho_dr])*alpha;

        theta_dr += k*k*alpha;
      }

      if (pba->has_cdm == _TRUE_) {
        delta_cdm -= 3. * pvecback[pba->index_bg_H]*pvecback[pba->index_bg_a]*alpha;
        theta_cdm += k*k*alpha;
      }

      if (pba->has_idm == _TRUE_) {
        delta_idm -= 3. * pvecback[pba->index_bg_H]*pvecback[pba->index_bg_a]*alpha;
        theta_idm += k*k*alpha;
      }

      if (pba->has_ncdm == _TRUE_) {
        for (n_ncdm=0; n_ncdm < pba->N_ncdm; n_ncdm++){
          /** - --> TODO: gauge transformation of delta, deltaP/rho (?) and theta using -= 3aH(1+w_ncdm) alpha for delta. */
        }
      }

      if (pba->has_dcdm == _TRUE_) {
        delta_dcdm += alpha*(-a*pba->Gamma_dcdm-3.*a*H);
        theta_dcdm += k*k*alpha;
      }

      if (pba->has_scf == _TRUE_) {
        delta_scf += alpha*(-3.0*H*(1.0+pvecback[pba->index_bg_p_scf]/pvecback[pba->index_bg_rho_scf]));
        theta_scf += k*k*alpha;
      }

    }

    //    fprintf(ppw->perturbations_output_file," ");
    /** - --> Handle (re-)allocation */
    if (ppt->scalar_perturbations_data[ppw->index_ikout] == NULL){
      class_alloc(ppt->scalar_perturbations_data[ppw->index_ikout],
                  sizeof(double)*ppt->number_of_scalar_titles,
                  error_message);
      ppt->size_scalar_perturbation_data[ppw->index_ikout] = 0;
    }
    else{
      class_realloc(ppt->scalar_perturbations_data[ppw->index_ikout],
                    (ppt->size_scalar_perturbation_data[ppw->index_ikout]+ppt->number_of_scalar_titles)*sizeof(double),
                    ppt->error_message);
    }
    storeidx = 0;
    dataptr = ppt->scalar_perturbations_data[ppw->index_ikout]+
      ppt->size_scalar_perturbation_data[ppw->index_ikout];
    ppt->size_scalar_perturbation_data[ppw->index_ikout] += ppt->number_of_scalar_titles;

    class_store_double(dataptr, tau, _TRUE_, storeidx);
    class_store_double(dataptr, pvecback[pba->index_bg_a], _TRUE_, storeidx);
    class_store_double(dataptr, delta_g, _TRUE_, storeidx);
    class_store_double(dataptr, theta_g, _TRUE_, storeidx);
    class_store_double(dataptr, shear_g, _TRUE_, storeidx);
    /* Higher photon temperature multipoles Fr3, Fr4, ..., Fr{l_max_g} */
    if (ppt->l_max_g > 2) {
      int l;
      double fr_l;
      for (l = 3; l <= ppt->l_max_g; l++) {
        fr_l = 0.0;  /* Default to zero */
        /* Only read from vector if TCA is off and l is within the computed range */
        if ((ppw->approx[ppw->index_ap_tca] == (int)tca_off) && (l <= ppw->pv->l_max_g)) {
          /* The multipole F_l is at index (index_pt_l3_g + l - 3) */
          fr_l = y[ppw->pv->index_pt_l3_g + l - 3];
        }
        class_store_double(dataptr, fr_l, _TRUE_, storeidx);
      }
    }
    class_store_double(dataptr, pol0_g, _TRUE_, storeidx);
    class_store_double(dataptr, pol1_g, _TRUE_, storeidx);
    class_store_double(dataptr, pol2_g, _TRUE_, storeidx);
    class_store_double(dataptr, delta_b, _TRUE_, storeidx);
    class_store_double(dataptr, theta_b, _TRUE_, storeidx);
    class_store_double(dataptr, psi, _TRUE_, storeidx);
    class_store_double(dataptr, phi, _TRUE_, storeidx);
    /* perturbed recombination */
    class_store_double(dataptr, delta_temp, ppt->has_perturbed_recombination, storeidx);
    class_store_double(dataptr, delta_chi, ppt->has_perturbed_recombination, storeidx);
    /* Ultra relativistic species */
    class_store_double(dataptr, delta_ur, pba->has_ur, storeidx);
    class_store_double(dataptr, theta_ur, pba->has_ur, storeidx);
    class_store_double(dataptr, shear_ur, pba->has_ur, storeidx);
    /* Interacting dark radiation */
    class_store_double(dataptr, delta_idr, pba->has_idr, storeidx);
    class_store_double(dataptr, theta_idr, pba->has_idr, storeidx);
    if ((pba->has_idr==_TRUE_) && (ppt->idr_nature == idr_free_streaming))
      class_store_double(dataptr, shear_idr, _TRUE_, storeidx);
    /* Cold dark matter */
    class_store_double(dataptr, delta_cdm, pba->has_cdm, storeidx);
    class_store_double(dataptr, theta_cdm, pba->has_cdm, storeidx);
    /* Interacting dark matter */
    class_store_double(dataptr, delta_idm, pba->has_idm, storeidx);
    class_store_double(dataptr, theta_idm, pba->has_idm, storeidx);
    /* Non-cold Dark Matter */
    if ((pba->has_ncdm == _TRUE_) && ((ppt->has_density_transfers == _TRUE_) || (ppt->has_velocity_transfers == _TRUE_) || (ppt->has_source_delta_m == _TRUE_))) {
      for (n_ncdm=0; n_ncdm < pba->N_ncdm; n_ncdm++){
        class_store_double(dataptr, delta_ncdm[n_ncdm], _TRUE_, storeidx);
        class_store_double(dataptr, theta_ncdm[n_ncdm], _TRUE_, storeidx);
        class_store_double(dataptr, shear_ncdm[n_ncdm], _TRUE_, storeidx);
        class_store_double(dataptr, delta_p_over_delta_rho_ncdm[n_ncdm],  _TRUE_, storeidx);
      }
    }
    /* Decaying cold dark matter */
    class_store_double(dataptr, delta_dcdm, pba->has_dcdm, storeidx);
    class_store_double(dataptr, theta_dcdm, pba->has_dcdm, storeidx);
    /* Decay radiation */
    class_store_double(dataptr, delta_dr, pba->has_dr, storeidx);
    class_store_double(dataptr, theta_dr, pba->has_dr, storeidx);
    class_store_double(dataptr, shear_dr, pba->has_dr, storeidx);
    /* Scalar field scf*/
    class_store_double(dataptr, delta_scf, pba->has_scf, storeidx);
    class_store_double(dataptr, theta_scf, pba->has_scf, storeidx);
    /** Fluid */
    class_store_double(dataptr, ppw->delta_rho_fld, pba->has_fld, storeidx);
    class_store_double(dataptr, ppw->rho_plus_p_theta_fld, pba->has_fld, storeidx);
    class_store_double(dataptr, ppw->delta_p_fld, pba->has_fld, storeidx);
    //fprintf(ppw->perturbations_output_file,"\n");

  }
  /** - for tensor modes: */

  if (_tensors_) {

    if (ppw->approx[ppw->index_ap_rsa]==(int)rsa_off) {
      if (ppw->approx[ppw->index_ap_tca]==(int)tca_off) {
        delta_g = y[ppw->pv->index_pt_delta_g];
        shear_g = y[ppw->pv->index_pt_shear_g];
        l4_g = y[ppw->pv->index_pt_delta_g+4];
        pol0_g = y[ppw->pv->index_pt_pol0_g];
        pol2_g = y[ppw->pv->index_pt_pol2_g];
        pol4_g = y[ppw->pv->index_pt_pol0_g+4];
      }
      else {
        delta_g = -4./3.*ppw->pv->y[ppw->pv->index_pt_gwdot]/pvecthermo[pth->index_th_dkappa]; //TBC
        shear_g = 0.;
        l4_g = 0.;
        pol0_g = 1./3.*ppw->pv->y[ppw->pv->index_pt_gwdot]/pvecthermo[pth->index_th_dkappa]; //TBC
        pol2_g = 0.;
        pol4_g = 0.;
      }
    }
    else {
      delta_g = 0.;
      shear_g = 0.;
      l4_g = 0.;
      pol0_g = 0.;
      pol2_g = 0.;
      pol4_g = 0.;
    }

    if (ppt->evolve_tensor_ur == _TRUE_){
      delta_ur = y[ppw->pv->index_pt_delta_ur];
      shear_ur = y[ppw->pv->index_pt_shear_ur];
      l4_ur = y[ppw->pv->index_pt_delta_ur+4];
    }

    /** - --> Handle (re-)allocation */
    if (ppt->tensor_perturbations_data[ppw->index_ikout] == NULL){
      class_alloc(ppt->tensor_perturbations_data[ppw->index_ikout],
                  sizeof(double)*ppt->number_of_tensor_titles,
                  error_message);
      ppt->size_tensor_perturbation_data[ppw->index_ikout] = 0;
    }
    else{
      ppt->tensor_perturbations_data[ppw->index_ikout] =
        (double*)realloc(ppt->tensor_perturbations_data[ppw->index_ikout],
                sizeof(double)*(ppt->size_tensor_perturbation_data[ppw->index_ikout]+ppt->number_of_tensor_titles));
    }
    storeidx = 0;
    dataptr = ppt->tensor_perturbations_data[ppw->index_ikout]+
      ppt->size_tensor_perturbation_data[ppw->index_ikout];
    ppt->size_tensor_perturbation_data[ppw->index_ikout] += ppt->number_of_tensor_titles;

    //fprintf(ppw->perturbations_output_file," ");
    class_store_double(dataptr, tau, _TRUE_, storeidx);
    class_store_double(dataptr, pvecback[pba->index_bg_a], _TRUE_, storeidx);
    class_store_double(dataptr, delta_g, _TRUE_, storeidx);
    class_store_double(dataptr, shear_g, _TRUE_, storeidx);
    class_store_double(dataptr, l4_g, _TRUE_, storeidx);
    class_store_double(dataptr, pol0_g, _TRUE_, storeidx);
    class_store_double(dataptr, pol2_g, _TRUE_, storeidx);
    class_store_double(dataptr, pol4_g, _TRUE_, storeidx);
    class_store_double(dataptr, y[ppw->pv->index_pt_gw], _TRUE_, storeidx);
    class_store_double(dataptr, y[ppw->pv->index_pt_gwdot], _TRUE_, storeidx);

    class_store_double(dataptr, delta_ur, ppt->evolve_tensor_ur, storeidx);
    class_store_double(dataptr, shear_ur, ppt->evolve_tensor_ur, storeidx);
    class_store_double(dataptr, l4_ur, ppt->evolve_tensor_ur, storeidx);
    //printf("index_pt_delta+ur = %d\n",ppw->pv->index_pt_delta_ur);

    /* Non-cold Dark Matter */
    if (ppt->evolve_tensor_ncdm == _TRUE_) {

      idx = ppw->pv->index_pt_psi0_ncdm1;

      for (n_ncdm=0; n_ncdm < pba->N_ncdm; n_ncdm++){

        rho_delta_ncdm = 0.0;
        rho_plus_p_theta_ncdm = 0.0;
        rho_plus_p_shear_ncdm = 0.0;
        delta_p_ncdm = 0.0;
        factor = pba->factor_ncdm[n_ncdm]/pow(a,4);

        for (index_q=0; index_q < ppw->pv->q_size_ncdm[n_ncdm]; index_q ++) {

          q = pba->q_ncdm[n_ncdm][index_q];
          q2 = q*q;
          epsilon = sqrt(q2+pba->M_ncdm[n_ncdm]*pba->M_ncdm[n_ncdm]*a2);

          rho_delta_ncdm += q2*epsilon*pba->w_ncdm[n_ncdm][index_q]*y[idx];
          rho_plus_p_theta_ncdm += q2*q*pba->w_ncdm[n_ncdm][index_q]*y[idx+1];
          rho_plus_p_shear_ncdm += q2*q2/epsilon*pba->w_ncdm[n_ncdm][index_q]*y[idx+2];
          delta_p_ncdm += q2*q2/epsilon*pba->w_ncdm[n_ncdm][index_q]*y[idx];

          //Jump to next momentum bin:
          idx+=(ppw->pv->l_max_ncdm[n_ncdm]+1);
        }

        rho_delta_ncdm *= factor;
        rho_plus_p_theta_ncdm *= k*factor;
        rho_plus_p_shear_ncdm *= 2.0/3.0*factor;
        delta_p_ncdm *= factor/3.;

        delta_ncdm[n_ncdm] = rho_delta_ncdm/ppw->pvecback[pba->index_bg_rho_ncdm1+n_ncdm];
        theta_ncdm[n_ncdm] = rho_plus_p_theta_ncdm/
          (ppw->pvecback[pba->index_bg_rho_ncdm1+n_ncdm]+ppw->pvecback[pba->index_bg_p_ncdm1+n_ncdm]);
        shear_ncdm[n_ncdm] = rho_plus_p_shear_ncdm/
          (ppw->pvecback[pba->index_bg_rho_ncdm1+n_ncdm]+ppw->pvecback[pba->index_bg_p_ncdm1+n_ncdm]);

        class_store_double(dataptr, delta_ncdm[n_ncdm], _TRUE_, storeidx);
        class_store_double(dataptr, theta_ncdm[n_ncdm], _TRUE_, storeidx);
        class_store_double(dataptr, shear_ncdm[n_ncdm], _TRUE_, storeidx);
      }
    }

    //    fprintf(ppw->perturbations_output_file,"\n");

  }

  if (pba->has_ncdm == _TRUE_){
    free(delta_ncdm);
    free(theta_ncdm);
    free(shear_ncdm);
    free(delta_p_over_delta_rho_ncdm);
  }

  return _SUCCESS_;

}

/**
 * Compute derivative of all perturbations to be integrated
 *
 * For each mode (scalar/vector/tensor) and each wavenumber k, this
 * function computes the derivative of all values in the vector of
 * perturbed variables to be integrated.
 *
 * This is one of the few functions in the code which is passed to the generic_integrator() routine.
 * Since generic_integrator() should work with functions passed from various modules, the format of the arguments
 * is a bit special:
 * - fixed parameters and workspaces are passed through a generic pointer.
 *   generic_integrator() doesn't know what the content of this pointer is.
 * - errors are not written as usual in pth->error_message, but in a generic
 *   error_message passed in the list of arguments.
 *
 * @param tau                      Input: conformal time
 * @param y                        Input: vector of perturbations
 * @param dy                       Output: vector of its derivatives (already allocated)
 * @param parameters_and_workspace Input/Output: in input, fixed parameters (e.g. indices); in output, background and thermo quantities evaluated at tau.
 * @param error_message            Output: error message
 */

int perturbations_derivs(double tau,
                         double * y,
                         double * dy,
                         void * parameters_and_workspace,
                         ErrorMsg error_message
                         ) {
  /** Summary: */

  /** - define local variables */

  /* multipole */
  int l;

  /* scale factor and other background quantities */
  double a,a2,a_prime_over_a,R;

  /* short-cut names for the fields of the input structure */
  struct perturbations_parameters_and_workspace * pppaw;
  double k,k2;
  int index_md;
  struct precision * ppr;
  struct background * pba;
  struct thermodynamics * pth;
  struct perturbations * ppt;
  struct perturbations_workspace * ppw;
  double * pvecback;
  double * pvecthermo;
  double * pvecmetric;
  double * s_l;
  struct perturbations_vector * pv;

  /* short-cut notations for the perturbations */
  double delta_g=0.,theta_g=0.,shear_g=0.;
  double delta_b,theta_b;
  double delta_idm = 0., theta_idm = 0.;
  double delta_idr=0., theta_idr=0.;
  double cb2,cs2,ca2,delta_p_b_over_rho_b;
  double metric_continuity=0.,metric_euler=0.,metric_shear=0.,metric_ufa_class=0.;

  /* perturbed recombination (just to simplify the notation) */

  double H0=0.,Nnow=0.,n_H=0.,fHe=0.;
  double delta_temp=0.,delta_chi=0., chi=0.;
  double alpha_rec=0.,delta_alpha_rec=0.;
  double a_rad=0., Compton_CR =0.;
  double Tb_in_K=0.;


  /* Non-metric source terms for photons, i.e. \mathcal{P}^{(m)} from arXiv:1305.3261  */
  double P0,P1,P2;

  /* for use with fluid (fld): */
  double w_fld,dw_over_da_fld,w_prime_fld,integral_fld;

  /*  for use with interacting dark matter  */
  double c2_idm=0., S_idm_g=0.;
  double dmu_idm_g = 0., photon_scattering_rate;
  double S_idm_dr=0., dmu_idm_dr=0., dmu_idr=0., tca_slip_idm_dr=0.;
  double R_idm_b = 0., dR_idm_b = 0., S_idm_b = 0.; /* these are just going to be used as a short hand notation */

  /* for use with non-cold dark matter (ncdm): */
  int index_q,n_ncdm,idx;
  double q,epsilon,dlnf0_dlnq,qk_div_epsilon;
  double rho_ncdm_bg,p_ncdm_bg,pseudo_p_ncdm,w_ncdm,ca2_ncdm,ceff2_ncdm=0.,cvis2_ncdm=0.;

  /* for use with curvature */
  double cotKgen, sqrt_absK;
  double s2_squared, ssqrt3;

  /* for use with dcdm and dr */
  double f_dr, fprime_dr;

  /** - rename the fields of the input structure (just to avoid heavy notations) */

  pppaw = (struct perturbations_parameters_and_workspace *)parameters_and_workspace;

  k = pppaw->k;
  k2=k*k;
  index_md = pppaw->index_md;
  ppr = pppaw->ppr;
  pba = pppaw->pba;
  pth = pppaw->pth;
  ppt = pppaw->ppt;
  ppw = pppaw->ppw;

  s_l = ppw->s_l;
  pvecback = ppw->pvecback;
  pvecthermo = ppw->pvecthermo;
  pvecmetric = ppw->pvecmetric;
  pv = ppw->pv;

  /** - get background/thermo quantities in this point */

  class_call(background_at_tau(pba,
                               tau,
                               normal_info,
                               inter_closeby,
                               &(ppw->last_index_back),
                               pvecback),
             pba->error_message,
             error_message);

  class_call(thermodynamics_at_z(pba,
                                 pth,
                                 1./pvecback[pba->index_bg_a]-1.,  /* redshift z=1/a-1 */
                                 inter_closeby,
                                 &(ppw->last_index_thermo),
                                 pvecback,
                                 pvecthermo),
             pth->error_message,
             error_message);

  /** - get metric perturbations with perturbations_einstein() */
  class_call(perturbations_einstein(ppr,
                                    pba,
                                    pth,
                                    ppt,
                                    index_md,
                                    k,
                                    tau,
                                    y,
                                    ppw),
             ppt->error_message,
             error_message);

  /** - compute related background quantities */

  a = pvecback[pba->index_bg_a];
  a2 = a*a;
  a_prime_over_a = pvecback[pba->index_bg_H] * a;
  R = 4./3. * pvecback[pba->index_bg_rho_g]/pvecback[pba->index_bg_rho_b];

  photon_scattering_rate = pvecthermo[pth->index_th_dkappa];

  if (pba->has_idm == _TRUE_) {

    if (ppt->has_idm_soundspeed == _TRUE_) {
      c2_idm = pvecthermo[pth->index_th_c2_idm];
    }
    else {
      c2_idm = 0.;
    }

    if (pth->has_idm_g == _TRUE_) {
      dmu_idm_g = pvecthermo[pth->index_th_dmu_idm_g];
      photon_scattering_rate += pvecthermo[pth->index_th_dmu_idm_g];
      S_idm_g = 4./3. * pvecback[pba->index_bg_rho_g] / pvecback[pba->index_bg_rho_idm];
    }
    if (pth->has_idm_dr == _TRUE_){
      S_idm_dr = 4./3. * pvecback[pba->index_bg_rho_idr]/ pvecback[pba->index_bg_rho_idm];
      dmu_idm_dr = pvecthermo[pth->index_th_dmu_idm_dr];
      dmu_idr = pth->b_idr/pth->a_idm_dr*pba->Omega0_idr/pba->Omega0_idm*dmu_idm_dr;
    }
    if (pth->has_idm_b == _TRUE_) {
      R_idm_b = pvecthermo[pth->index_th_R_idm_b];
      dR_idm_b = pvecthermo[pth->index_th_dR_idm_b];
      S_idm_b = pvecback[pba->index_bg_rho_idm]/pvecback[pba->index_bg_rho_b];
    }
  }

  /** - Compute 'generalised cotK function of argument \f$ \sqrt{|K|}*\tau \f$, for closing hierarchy.
      (see equation 2.34 in arXiv:1305.3261): */
  if (pba->has_curvature == _FALSE_){
    cotKgen = 1.0/(k*tau);
  }
  else{
    sqrt_absK = sqrt(fabs(pba->K));
    if (pba->K < 0)
      cotKgen = sqrt_absK/k/tanh(sqrt_absK*tau);
    else
      cotKgen = sqrt_absK/k/tan(sqrt_absK*tau);
  }

  s2_squared = 1.-3.*pba->K/k2;

  /** - for scalar modes: */
  if (_scalars_) {

    /** - --> (a) define short-cut notations for the scalar perturbations */
    if (ppw->approx[ppw->index_ap_rsa] == (int)rsa_off) {
      delta_g = y[pv->index_pt_delta_g];
      theta_g = y[pv->index_pt_theta_g];
    }

    if (pba->has_idr == _TRUE_){
      if (ppw->approx[ppw->index_ap_rsa_idr] == (int)rsa_idr_off){
        delta_idr = y[pv->index_pt_delta_idr];
        theta_idr = y[pv->index_pt_theta_idr];
      }
    }

    delta_b = y[pv->index_pt_delta_b];
    theta_b = y[pv->index_pt_theta_b];
    cb2 = pvecthermo[pth->index_th_cb2];
    delta_p_b_over_rho_b = cb2*delta_b; /* for baryons, (delta p)/rho with Ma & Bertschinger approximation: sound speed = adiabatic sound speed */


    if (pba->has_idm == _TRUE_){
      delta_idm = y[pv->index_pt_delta_idm];
      theta_idm = y[pv->index_pt_theta_idm];
      ppw->theta_idm = theta_idm;
    }

    /** - --> (b) perturbed recombination **/

    if ((ppt->has_perturbed_recombination == _TRUE_)&&(ppw->approx[ppw->index_ap_tca]==(int)tca_off)){

      delta_temp= y[ppw->pv->index_pt_perturbed_recombination_delta_temp];
      delta_p_b_over_rho_b = pvecthermo[pth->index_th_wb]*(delta_b+delta_temp); /* for baryons, (delta p)/rho with sound speed from arXiv:0707.2727 */

      delta_chi= y[ppw->pv->index_pt_perturbed_recombination_delta_chi];
      chi=pvecthermo[pth->index_th_xe];

      // Conversion of H0 in inverse seconds (pba->H0 is [H0/c] in inverse Mpcs)
      H0 = pba->H0 * _c_ / _Mpc_over_m_;

      //Computation of Nnow in SI units
      Nnow = 3.*H0*H0*pba->Omega0_b*(1.-pth->YHe)/(8.*_PI_*_G_*_m_H_);

      // total amount of hydrogen today
      n_H = Nnow/pow(a,3);

      // Helium-to-hydrogen ratio
      fHe = pth->YHe / (_not4_*(1-pth->YHe));

      // The constant such that rho_gamma = a_rad * T^4
      a_rad = 8./15.*pow(_PI_,5)*pow(_k_B_,4)/pow(_c_*_h_P_,3);

      // Compton cooling rate in Mpc^(-1)
      Compton_CR = 8./3. *_sigma_ * a_rad /(_m_e_ * _c_ *_c_) *_Mpc_over_m_   ;

      // Temperature is already in Kelvin
      Tb_in_K = pvecthermo[pth->index_th_Tb];

      // Alpha in m^3/s, cf. Recfast paper
      alpha_rec = 1.14 * 4.309e-19*pow((Tb_in_K * 1e-4),-0.6166)/(1+0.6703*pow((Tb_in_K * 1e-4),0.53)) ;

      // delta alpha, dimensionless
      delta_alpha_rec= (-0.6166 + 0.6703 * pow((Tb_in_K * 1e-4),0.53)*(-0.6166-0.53))/(1+0.6703*pow((Tb_in_K * 1e-4),0.53)) * delta_temp;

    } // end of perturbed recombination related quantities

    /** - --> (c) compute metric-related quantities (depending on gauge; additional gauges can be coded below)

        - Each continuity equation contains a term in (theta+metric_continuity) with
        metric_continuity = (h_prime/2) in synchronous gauge, (-3 phi_prime) in newtonian gauge

        - Each Euler equation contains a source term metric_euler with
        metric_euler = 0 in synchronous gauge, (k2 psi) in newtonian gauge

        - Each shear derivative equation contains a source term metric_shear equal to
        metric_shear = (h_prime+6eta_prime)/2 in synchronous gauge, 0 in newtonian gauge

        - metric_shear_prime is the derivative of metric_shear

        - In the ufa_class approximation, the leading-order source term is (h_prime/2) in synchronous gauge,
        (-3 (phi_prime+psi_prime)) in newtonian gauge: we approximate the later by (-6 phi_prime) */

    if (ppt->gauge == synchronous) {

      metric_continuity = pvecmetric[ppw->index_mt_h_prime]/2.;
      metric_euler = 0.;
      metric_shear = k2 * pvecmetric[ppw->index_mt_alpha];
      //metric_shear_prime = k2 * pvecmetric[ppw->index_mt_alpha_prime];
      metric_ufa_class = pvecmetric[ppw->index_mt_h_prime]/2.;
    }

    if (ppt->gauge == newtonian) {

      metric_continuity = -3.*pvecmetric[ppw->index_mt_phi_prime];
      metric_euler = k2*pvecmetric[ppw->index_mt_psi];
      metric_shear = 0.;
      //metric_shear_prime = 0.;
      metric_ufa_class = -6.*pvecmetric[ppw->index_mt_phi_prime];
    }

    /** - --> (d) if some approximation schemes are turned on, enforce a few y[] values computed in perturbations_einstein */

    if (ppw->approx[ppw->index_ap_rsa] == (int)rsa_on) {
      delta_g = ppw->rsa_delta_g;
      theta_g = ppw->rsa_theta_g;
    }

    if (pba->has_idr == _TRUE_){
      if (ppw->approx[ppw->index_ap_rsa_idr] == (int)rsa_idr_on){
        delta_idr = ppw->rsa_delta_idr;
        theta_idr = ppw->rsa_theta_idr;
      }
    }

    /** - --> (e) BEGINNING OF ACTUAL SYSTEM OF EQUATIONS OF EVOLUTION */

    /* start with idm as it might be needed during (normal) tca  */
    if (pba->has_idm == _TRUE_){
      dy[pv->index_pt_delta_idm] = -(theta_idm+metric_continuity); /* idm density */
      dy[pv->index_pt_theta_idm] =
        -a_prime_over_a*theta_idm
        +metric_euler
        + k2*c2_idm*delta_idm; /* idm velocity */

      if (pth->has_idm_g == _TRUE_) {
        dy[pv->index_pt_theta_idm] += -S_idm_g*dmu_idm_g*(theta_idm-theta_g); /* correction to idm velocity due to idm_g */
      }
      if (pth->has_idm_b == _TRUE_){
        dy[pv->index_pt_theta_idm] += -R_idm_b*(theta_idm-theta_b); /* correction to idm velocity due to idm_b */
      }
      if (pth->has_idm_dr == _TRUE_) {
        if (ppw->approx[ppw->index_ap_tca_idm_dr] == (int)tca_idm_dr_off) {
          dy[pv->index_pt_theta_idm] += -S_idm_dr * dmu_idm_dr * (theta_idm - theta_idr); /* correction to idm velocity due to idm_dr when tca_idm_dr is off */

        }
        else {
          tca_slip_idm_dr = (pth->n_index_idm_dr-2./(1.+S_idm_dr))*a_prime_over_a*( theta_idm - theta_idr)
            + 1./(1.+S_idm_dr)/dmu_idm_dr* ( - theta_idm * (pvecback[pba->index_bg_H_prime] * a + 2. * a_prime_over_a * a_prime_over_a)
                                             - a_prime_over_a * (.5*k2*delta_idr + metric_euler) - k2*c2_idm*(theta_idm+metric_continuity) + k2/3.*(theta_idr + metric_continuity)
                                             );

          if (pth->has_idm_g == _TRUE_) {
            tca_slip_idm_dr += 1./(1.+S_idm_dr)/dmu_idm_dr * ( (2+pth->n_index_idm_g) * a_prime_over_a * S_idm_g*dmu_idm_g*(theta_idm - theta_g)
                                                               - S_idm_g*dmu_idm_g*(dy[pv->index_pt_theta_idm] - k2*delta_g/4. - metric_euler
                                                                                    - pvecthermo[pth->index_th_dkappa]*(theta_b-theta_g) - dmu_idm_g * (theta_idm - theta_g)) );
          }
          if (pth->has_idm_b == _TRUE_) {
            tca_slip_idm_dr += 1./(1.+S_idm_dr)/dmu_idm_dr * ( - (a_prime_over_a *R_idm_b + dR_idm_b)*(theta_idm - theta_b)
                                                               - R_idm_b*( dy[pv->index_pt_theta_idm] + a_prime_over_a*theta_b - metric_euler - k2*delta_p_b_over_rho_b
                                                                           - R*pvecthermo[pth->index_th_dkappa]*(theta_g-theta_b) - S_idm_b*R_idm_b*(theta_idm-theta_b)));
          }

          ppw->tca_shear_idm_dr = 0.5*8./15./dmu_idm_dr/ppt->alpha_idm_dr[0]*(y[pv->index_pt_theta_idm]+metric_shear);


          dy[pv->index_pt_theta_idm] = 1./(1.+S_idm_dr)* dy[pv->index_pt_theta_idm] /* This is technically correct as long as idm_dr is the last interaction calculated */
            + S_idm_dr/(1.+S_idm_dr)*(k2*(delta_idr/4. - ppw->tca_shear_idm_dr) + metric_euler) /* the other part of metric_euler is in dtheta_idm  */
            + S_idm_dr/(1.+S_idm_dr)*tca_slip_idm_dr; /* overwrite the idm velocity when tca_idm_dr is on */
        }
      }

      ppw->theta_idm_prime = dy[pv->index_pt_theta_idm];
    }

    /** - ---> photon temperature density */

    if (ppw->approx[ppw->index_ap_rsa] == (int)rsa_off) {

      dy[pv->index_pt_delta_g] = -4./3.*(theta_g+metric_continuity);

    }

    /** - ---> baryon density */

    dy[pv->index_pt_delta_b] = -(theta_b+metric_continuity);

    /** - ---> baryon velocity (depends on tight-coupling approximation=tca) */

    if (ppw->approx[ppw->index_ap_tca] == (int)tca_off) {

      /* without tca */

      /** - ----> perturbed recombination has an impact **/
      dy[pv->index_pt_theta_b] =
        - a_prime_over_a*theta_b
        + metric_euler
        + k2*delta_p_b_over_rho_b
        + R*pvecthermo[pth->index_th_dkappa]*(theta_g-theta_b);

      if (pth->has_idm_b == _TRUE_) {
        dy[pv->index_pt_theta_b] += S_idm_b*R_idm_b*(theta_idm-theta_b);
      }
    }

    else {

      /* with tca */
      class_call(perturbations_tca_slip_and_shear(y,pppaw,error_message),
                 error_message,
                 error_message);

      /* perturbed recombination has an impact **/
      dy[pv->index_pt_theta_b] =
        (-a_prime_over_a*theta_b
         +k2*(delta_p_b_over_rho_b+R*(delta_g/4.-s2_squared*ppw->tca_shear_g))
         +R*ppw->tca_slip)/(1.+R)
        +metric_euler;

      if (pth->has_idm_g == _TRUE_) {
        dy[pv->index_pt_theta_b] +=
          -dmu_idm_g * R/(1.+R) * (theta_g - theta_idm);
      }
      if (pth->has_idm_b == _TRUE_) {
        dy[pv->index_pt_theta_b] += (S_idm_b * R_idm_b * (theta_idm - theta_b))/(1.+R);
      }
    }

    /** - ---> photon temperature higher momenta and photon polarization (depend on tight-coupling approximation) */

    if (ppw->approx[ppw->index_ap_rsa] == (int)rsa_off) {

      /** - ----> if photon tight-coupling is off */
      if (ppw->approx[ppw->index_ap_tca] == (int)tca_off) {

        /** - -----> define \f$ \Pi = G_{\gamma 0} + G_{\gamma 2} + F_{\gamma 2} \f$ */
        P0 = (y[pv->index_pt_pol0_g] + y[pv->index_pt_pol2_g] + 2.*s_l[2]*y[pv->index_pt_shear_g])/8.;

        /** - -----> photon temperature velocity */

        dy[pv->index_pt_theta_g] =
          k2*(delta_g/4.-s2_squared*y[pv->index_pt_shear_g])
          + metric_euler
          + pvecthermo[pth->index_th_dkappa]*(theta_b-theta_g);

        if (pth->has_idm_g == _TRUE_) {
          dy[pv->index_pt_theta_g] += dmu_idm_g * (theta_idm - theta_g);
        }

        /** - -----> photon temperature shear */
        dy[pv->index_pt_shear_g] =
          0.5*(8./15.*(theta_g+metric_shear)
               -3./5.*k*s_l[3]/s_l[2]*y[pv->index_pt_l3_g]
               -photon_scattering_rate*(2.*y[pv->index_pt_shear_g]-4./5./s_l[2]*P0));

        /** - -----> photon temperature l=3 */

        l = 3;
        dy[pv->index_pt_l3_g] = k/(2.0*l+1.0)*
          (l*s_l[l]*2.*s_l[2]*y[pv->index_pt_shear_g]-(l+1.)*s_l[l+1]*y[pv->index_pt_l3_g+1])
          - photon_scattering_rate*y[pv->index_pt_l3_g];

        /** - -----> photon temperature l>3 */
        for (l = 4; l < pv->l_max_g; l++) {

          dy[pv->index_pt_delta_g+l] = k/(2.0*l+1.0)*
            (l*s_l[l]*y[pv->index_pt_delta_g+l-1]-(l+1)*s_l[l+1]*y[pv->index_pt_delta_g+l+1])
            - photon_scattering_rate*y[pv->index_pt_delta_g+l];
        }

        /** - -----> photon temperature lmax */
        l = pv->l_max_g; /* l=lmax */
        dy[pv->index_pt_delta_g+l] =
          k*(s_l[l]*y[pv->index_pt_delta_g+l-1]-(1.+l)*cotKgen*y[pv->index_pt_delta_g+l])
          - photon_scattering_rate*y[pv->index_pt_delta_g+l];

        /** - -----> photon polarization l=0 */

        dy[pv->index_pt_pol0_g] =
          -k*y[pv->index_pt_pol0_g+1]
          -photon_scattering_rate*(y[pv->index_pt_pol0_g]-4.*P0);

        /** - -----> photon polarization l=1 */

        dy[pv->index_pt_pol1_g] =
          k/3.*(y[pv->index_pt_pol1_g-1]-2.*s_l[2]*y[pv->index_pt_pol1_g+1])
          -photon_scattering_rate*y[pv->index_pt_pol1_g];

        /** - -----> photon polarization l=2 */

        dy[pv->index_pt_pol2_g] =
          k/5.*(2.*s_l[2]*y[pv->index_pt_pol2_g-1]-3.*s_l[3]*y[pv->index_pt_pol2_g+1])
          -photon_scattering_rate*(y[pv->index_pt_pol2_g]-4./5.*P0);

        /** - -----> photon polarization l>2 */

        for (l=3; l < pv->l_max_pol_g; l++)
          dy[pv->index_pt_pol0_g+l] = k/(2.*l+1)*
            (l*s_l[l]*y[pv->index_pt_pol0_g+l-1]-(l+1.)*s_l[l+1]*y[pv->index_pt_pol0_g+l+1])
            -photon_scattering_rate*y[pv->index_pt_pol0_g+l];

        /** - -----> photon polarization lmax_pol */

        l = pv->l_max_pol_g;
        dy[pv->index_pt_pol0_g+l] =
          k*(s_l[l]*y[pv->index_pt_pol0_g+l-1]-(l+1)*cotKgen*y[pv->index_pt_pol0_g+l])
          -photon_scattering_rate*y[pv->index_pt_pol0_g+l];


      }
      /** - ----> if photon tight-coupling is on: */

      else {

        /** - -----> in that case, only need photon velocity */

        /* perturbed recombination has an impact **/
        dy[pv->index_pt_theta_g] =
          -(dy[pv->index_pt_theta_b]+a_prime_over_a*theta_b-k2*delta_p_b_over_rho_b)/R
          +k2*(0.25*delta_g-s2_squared*ppw->tca_shear_g)+(1.+R)/R*metric_euler;

        if (pth->has_idm_g == _TRUE_) {
          dy[pv->index_pt_theta_g] +=
            -dmu_idm_g * (theta_g - theta_idm);
        }
        if (pth->has_idm_b == _TRUE_) {
          dy[pv->index_pt_theta_g] += S_idm_b * R_idm_b * (theta_idm - theta_b) / R;
        }
      }

    }

    /** - ---> cdm */

    if (pba->has_cdm == _TRUE_) {

      /** - ----> newtonian gauge: cdm density and velocity */

      if (ppt->gauge == newtonian) {
        dy[pv->index_pt_delta_cdm] = -(y[pv->index_pt_theta_cdm]+metric_continuity); /* cdm density */

        dy[pv->index_pt_theta_cdm] = - a_prime_over_a*y[pv->index_pt_theta_cdm] + metric_euler; /* cdm velocity */
      }

      /** - ----> synchronous gauge: cdm density only (velocity set to zero by definition of the gauge) */

      if (ppt->gauge == synchronous) {
        dy[pv->index_pt_delta_cdm] = -metric_continuity; /* cdm density */
      }
    }

    /** - ---> interacting dark radiation */
    if (pba->has_idr == _TRUE_){

      if (ppw->approx[ppw->index_ap_rsa_idr] == (int)rsa_idr_off) {

        dy[pv->index_pt_delta_idr] = -4./3.*(theta_idr + metric_continuity);

        if (ppw->approx[ppw->index_ap_tca_idm_dr] == (int)tca_idm_dr_off) {

          /** - ----> idr velocity */
          if (ppt->idr_nature == idr_free_streaming)
            dy[pv->index_pt_theta_idr] = k2*(y[pv->index_pt_delta_idr]/4.-s2_squared*y[pv->index_pt_shear_idr]) + metric_euler;
          else
            dy[pv->index_pt_theta_idr] = k2/4. * y[pv->index_pt_delta_idr] + metric_euler;

          if (pth->has_idm_dr == _TRUE_)
            dy[pv->index_pt_theta_idr] += dmu_idm_dr*(y[pv->index_pt_theta_idm]-y[pv->index_pt_theta_idr]);

          if (ppt->idr_nature == idr_free_streaming){

            /** - ----> exact idr shear */
            l = 2;
            dy[pv->index_pt_shear_idr] = 0.5*(8./15.*(y[pv->index_pt_theta_idr]+metric_shear)-3./5.*k*s_l[3]/s_l[2]*y[pv->index_pt_shear_idr+1]);
            if (pth->has_idm_dr == _TRUE_)
              dy[pv->index_pt_shear_idr]-= (ppt->alpha_idm_dr[l-2]*dmu_idm_dr + ppt->beta_idr[l-2]*dmu_idr)*y[pv->index_pt_shear_idr];

            /** - ----> exact idr l=3 */
            l = 3;
            dy[pv->index_pt_l3_idr] = k/(2.*l+1.)*(l*2.*s_l[l]*s_l[2]*y[pv->index_pt_shear_idr]-(l+1.)*s_l[l+1]*y[pv->index_pt_l3_idr+1]);
            if (pth->has_idm_dr == _TRUE_)
              dy[pv->index_pt_l3_idr]-= (ppt->alpha_idm_dr[l-2]*dmu_idm_dr + ppt->beta_idr[l-2]*dmu_idr)*y[pv->index_pt_l3_idr];

            /** - ----> exact idr l>3 */
            for (l = 4; l < pv->l_max_idr; l++) {
              dy[pv->index_pt_delta_idr+l] = k/(2.*l+1)*(l*s_l[l]*y[pv->index_pt_delta_idr+l-1]-(l+1.)*s_l[l+1]*y[pv->index_pt_delta_idr+l+1]);
              if (pth->has_idm_dr == _TRUE_)
                dy[pv->index_pt_delta_idr+l]-= (ppt->alpha_idm_dr[l-2]*dmu_idm_dr + ppt->beta_idr[l-2]*dmu_idr)*y[pv->index_pt_delta_idr+l];
            }

            /** - ----> exact idr lmax_dr */
            l = pv->l_max_idr;
            dy[pv->index_pt_delta_idr+l] = k*(s_l[l]*y[pv->index_pt_delta_idr+l-1]-(1.+l)*cotKgen*y[pv->index_pt_delta_idr+l]);
            if (pth->has_idm_dr == _TRUE_)
              dy[pv->index_pt_delta_idr+l]-= (ppt->alpha_idm_dr[l-2]*dmu_idm_dr + ppt->beta_idr[l-2]*dmu_idr)*y[pv->index_pt_delta_idr+l];
          }
        }
        else{
          dy[pv->index_pt_theta_idr] = ppw->theta_idm_prime - tca_slip_idm_dr;
        }
      }
    }

    /* perturbed recombination */
    /* computes the derivatives of delta x_e and delta T_b */

    if ((ppt->has_perturbed_recombination == _TRUE_)&&(ppw->approx[ppw->index_ap_tca] == (int)tca_off)){

      /* alpha * n_H is in inverse seconds, so we have to multiply it by Mpc_in_sec */
      dy[ppw->pv->index_pt_perturbed_recombination_delta_chi] = - alpha_rec* a * chi*n_H  *(delta_alpha_rec + delta_chi + delta_b) * _Mpc_over_m_ / _c_ ;

      /* see the documentation for this formula */
      dy[ppw->pv->index_pt_perturbed_recombination_delta_temp] =  2./3. * dy[ppw->pv->index_pt_delta_b] - a * Compton_CR
        * pow(pba->T_cmb/a, 4) * chi / (1.+chi+fHe) * ( (1.-pba->T_cmb/a/pvecthermo[pth->index_th_Tb])*(delta_g + delta_chi*(1.+fHe)/(1.+chi+fHe))
                                                        + pba->T_cmb/a/pvecthermo[pth->index_th_Tb] *(delta_temp - 1./4. * delta_g) );

    }

    /** - ---> dcdm and dr */

    if (pba->has_dcdm == _TRUE_) {

      /** - ----> dcdm */

      dy[pv->index_pt_delta_dcdm] = -(y[pv->index_pt_theta_dcdm]+metric_continuity)
        - a * pba->Gamma_dcdm / k2 * metric_euler; /* dcdm density */

      dy[pv->index_pt_theta_dcdm] = - a_prime_over_a*y[pv->index_pt_theta_dcdm] + metric_euler; /* dcdm velocity */
    }

    /** - ---> dr */

    if ((pba->has_dcdm == _TRUE_)&&(pba->has_dr == _TRUE_)) {


      /* f = rho_dr*a^4/rho_crit_today. In CLASS density units
         rho_crit_today = H0^2.
      */

      f_dr = pow(pow(a,2)/pba->H0,2)*pvecback[pba->index_bg_rho_dr];
      fprime_dr = pba->Gamma_dcdm*pvecback[pba->index_bg_rho_dcdm]*pow(a,5)/pow(pba->H0,2);

      /** - ----> dr F0 */
      dy[pv->index_pt_F0_dr] = -k*y[pv->index_pt_F0_dr+1]-4./3.*metric_continuity*f_dr+
        fprime_dr*(y[pv->index_pt_delta_dcdm]+metric_euler/k2);

      /** - ----> dr F1 */
      dy[pv->index_pt_F0_dr+1] = k/3.*y[pv->index_pt_F0_dr]-2./3.*k*y[pv->index_pt_F0_dr+2]*s2_squared +
        4*metric_euler/(3.*k)*f_dr + fprime_dr/k*y[pv->index_pt_theta_dcdm];

      /** - ----> exact dr F2 */
      dy[pv->index_pt_F0_dr+2] = 8./15.*(3./4.*k*y[pv->index_pt_F0_dr+1]+metric_shear*f_dr) -3./5.*k*s_l[3]/s_l[2]*y[pv->index_pt_F0_dr+3];

      /** - ----> exact dr l=3 */
      l = 3;
      dy[pv->index_pt_F0_dr+3] = k/(2.*l+1.)*
        (l*s_l[l]*s_l[2]*y[pv->index_pt_F0_dr+2]-(l+1.)*s_l[l+1]*y[pv->index_pt_F0_dr+4]);

      /** - ----> exact dr l>3 */
      for (l = 4; l < pv->l_max_dr; l++) {
        dy[pv->index_pt_F0_dr+l] = k/(2.*l+1)*
          (l*s_l[l]*y[pv->index_pt_F0_dr+l-1]-(l+1.)*s_l[l+1]*y[pv->index_pt_F0_dr+l+1]);
      }

      /** - ----> exact dr lmax_dr */
      l = pv->l_max_dr;
      dy[pv->index_pt_F0_dr+l] =
        k*(s_l[l]*y[pv->index_pt_F0_dr+l-1]-(1.+l)*cotKgen*y[pv->index_pt_F0_dr+l]);

    }

    /** - ---> fluid (fld) */

    if (pba->has_fld == _TRUE_) {

      if (pba->use_ppf == _FALSE_){

        /** - ----> factors w, w_prime, adiabatic sound speed ca2 (all three background-related),
            plus actual sound speed in the fluid rest frame cs2 */

        class_call(background_w_fld(pba,a,&w_fld,&dw_over_da_fld,&integral_fld), pba->error_message, ppt->error_message);
        w_prime_fld = dw_over_da_fld * a_prime_over_a * a;

        ca2 = w_fld - w_prime_fld / 3. / (1.+w_fld) / a_prime_over_a;
        cs2 = pba->cs2_fld;

        /** - ----> fluid density */

        dy[pv->index_pt_delta_fld] =
          -(1+w_fld)*(y[pv->index_pt_theta_fld]+metric_continuity)
          -3.*(cs2-w_fld)*a_prime_over_a*y[pv->index_pt_delta_fld]
          -9.*(1+w_fld)*(cs2-ca2)*a_prime_over_a*a_prime_over_a*y[pv->index_pt_theta_fld]/k2;

        /** - ----> fluid velocity */

        dy[pv->index_pt_theta_fld] = /* fluid velocity */
          -(1.-3.*cs2)*a_prime_over_a*y[pv->index_pt_theta_fld]
          +cs2*k2/(1.+w_fld)*y[pv->index_pt_delta_fld]
          +metric_euler;
      }
      else {
        dy[pv->index_pt_Gamma_fld] = ppw->Gamma_prime_fld; /* Gamma variable of PPF formalism */
      }

    }

    /** - ---> scalar field (scf) */

    if (pba->has_scf == _TRUE_) {

      /** - ----> field value */

      dy[pv->index_pt_phi_scf] = y[pv->index_pt_phi_prime_scf];

      /** - ----> Klein Gordon equation */

      dy[pv->index_pt_phi_prime_scf] =  - 2.*a_prime_over_a*y[pv->index_pt_phi_prime_scf]
        - metric_continuity*pvecback[pba->index_bg_phi_prime_scf] //  metric_continuity = h'/2
        - (k2 + a2*pvecback[pba->index_bg_ddV_scf])*y[pv->index_pt_phi_scf]; //checked

    }

    /** - ---> ultra-relativistic neutrino/relics (ur) */

    if (pba->has_ur == _TRUE_) {

      /** - ----> if radiation streaming approximation is off */

      if (ppw->approx[ppw->index_ap_rsa] == (int)rsa_off) {

        /** - -----> ur density */
        dy[pv->index_pt_delta_ur] =
          // standard term
          -4./3.*(y[pv->index_pt_theta_ur] + metric_continuity)
          // non-standard term, non-zero if if ceff2_ur not 1/3
          +(1.-ppt->three_ceff2_ur)*a_prime_over_a*(y[pv->index_pt_delta_ur] + 4.*a_prime_over_a*y[pv->index_pt_theta_ur]/k/k);

        /** - -----> ur velocity */
        dy[pv->index_pt_theta_ur] =
          // standard term with extra coefficient (3 ceff2_ur), normally equal to one
          k2*(ppt->three_ceff2_ur*y[pv->index_pt_delta_ur]/4.-s2_squared*y[pv->index_pt_shear_ur]) + metric_euler
          // non-standard term, non-zero if ceff2_ur not 1/3
          -(1.-ppt->three_ceff2_ur)*a_prime_over_a*y[pv->index_pt_theta_ur];

        if (ppw->approx[ppw->index_ap_ufa] == (int)ufa_off) {

          /** - -----> exact ur shear */
          dy[pv->index_pt_shear_ur] =
            0.5*(
                 // standard term
                 8./15.*(y[pv->index_pt_theta_ur]+metric_shear)-3./5.*k*s_l[3]/s_l[2]*y[pv->index_pt_shear_ur+1]
                 // non-standard term, non-zero if cvis2_ur not 1/3
                 -(1.-ppt->three_cvis2_ur)*(8./15.*(y[pv->index_pt_theta_ur]+metric_shear)));

          /** - -----> exact ur l=3 */
          l = 3;
          dy[pv->index_pt_l3_ur] = k/(2.*l+1.)*
            (l*2.*s_l[l]*s_l[2]*y[pv->index_pt_shear_ur]-(l+1.)*s_l[l+1]*y[pv->index_pt_l3_ur+1]);

          /** - -----> exact ur l>3 */
          for (l = 4; l < pv->l_max_ur; l++) {
            dy[pv->index_pt_delta_ur+l] = k/(2.*l+1)*
              (l*s_l[l]*y[pv->index_pt_delta_ur+l-1]-(l+1.)*s_l[l+1]*y[pv->index_pt_delta_ur+l+1]);
          }

          /** - -----> exact ur lmax_ur */
          l = pv->l_max_ur;
          dy[pv->index_pt_delta_ur+l] =
            k*(s_l[l]*y[pv->index_pt_delta_ur+l-1]-(1.+l)*cotKgen*y[pv->index_pt_delta_ur+l]);

        }

        else {

          /** - -----> in fluid approximation (ufa): only ur shear needed */
          //TBC: curvature?
          /* a la Ma & Bertschinger */
          if (ppr->ur_fluid_approximation == ufa_mb) {

            dy[pv->index_pt_shear_ur] =
              -3./tau*y[pv->index_pt_shear_ur]
              +2./3.*(y[pv->index_pt_theta_ur]+metric_shear);

          }

          /* a la Hu */
          if (ppr->ur_fluid_approximation == ufa_hu) {

            dy[pv->index_pt_shear_ur] =
              -3.*a_prime_over_a*y[pv->index_pt_shear_ur]
              +2./3.*(y[pv->index_pt_theta_ur]+metric_shear);

          }

          /* a la CLASS */
          if (ppr->ur_fluid_approximation == ufa_CLASS) {

            dy[pv->index_pt_shear_ur] =
              -3./tau*y[pv->index_pt_shear_ur]
              +2./3.*(y[pv->index_pt_theta_ur]+metric_ufa_class);

          }
        }
      }
    }

    /** - ---> non-cold dark matter (ncdm): massive neutrinos, WDM, etc. */
    //TBC: curvature in all ncdm
    if (pba->has_ncdm == _TRUE_) {

      idx = pv->index_pt_psi0_ncdm1;

      /** - ----> first case: use a fluid approximation (ncdmfa) */
      //TBC: curvature
      if (ppw->approx[ppw->index_ap_ncdmfa] == (int)ncdmfa_on) {

        /** - -----> loop over species */

        for (n_ncdm=0; n_ncdm<pv->N_ncdm; n_ncdm++) {

          /** - -----> define intermediate quantitites */

          rho_ncdm_bg = pvecback[pba->index_bg_rho_ncdm1+n_ncdm]; /* background density */
          p_ncdm_bg = pvecback[pba->index_bg_p_ncdm1+n_ncdm]; /* background pressure */
          pseudo_p_ncdm = pvecback[pba->index_bg_pseudo_p_ncdm1+n_ncdm]; /* pseudo-pressure (see CLASS IV paper) */
          w_ncdm = p_ncdm_bg/rho_ncdm_bg; /* equation of state parameter */
          ca2_ncdm = w_ncdm/3.0/(1.0+w_ncdm)*(5.0-pseudo_p_ncdm/p_ncdm_bg); /* adiabatic sound speed */

          /* c_eff is (delta p / delta rho) in the gauge under
             consideration (not in the gauge comoving with the
             fluid) */

          /* c_vis is introduced in order to close the system */

          /* different ansatz for sound speed c_eff and viscosity speed c_vis */
          if (ppr->ncdm_fluid_approximation == ncdmfa_mb) {
            ceff2_ncdm = ca2_ncdm;
            cvis2_ncdm = 3.*w_ncdm*ca2_ncdm;
          }
          if (ppr->ncdm_fluid_approximation == ncdmfa_hu) {
            ceff2_ncdm = ca2_ncdm;
            cvis2_ncdm = w_ncdm;
          }
          if (ppr->ncdm_fluid_approximation == ncdmfa_CLASS) {
            ceff2_ncdm = ca2_ncdm;
            cvis2_ncdm = 3.*w_ncdm*ca2_ncdm;
          }

          /** - -----> exact continuity equation */

          dy[idx] = -(1.0+w_ncdm)*(y[idx+1]+metric_continuity)-
            3.0*a_prime_over_a*(ceff2_ncdm-w_ncdm)*y[idx];

          /** - -----> exact euler equation */

          dy[idx+1] = -a_prime_over_a*(1.0-3.0*ca2_ncdm)*y[idx+1]+
            ceff2_ncdm/(1.0+w_ncdm)*k2*y[idx]-k2*y[idx+2]
            + metric_euler;

          /** - -----> different ansatz for approximate shear derivative */

          if (ppr->ncdm_fluid_approximation == ncdmfa_mb) {

            dy[idx+2] = -3.0*(a_prime_over_a*(2./3.-ca2_ncdm-pseudo_p_ncdm/p_ncdm_bg/3.)+1./tau)*y[idx+2]
              +8.0/3.0*cvis2_ncdm/(1.0+w_ncdm)*s_l[2]*(y[idx+1]+metric_shear);

          }

          if (ppr->ncdm_fluid_approximation == ncdmfa_hu) {

            dy[idx+2] = -3.0*a_prime_over_a*ca2_ncdm/w_ncdm*y[idx+2]
              +8.0/3.0*cvis2_ncdm/(1.0+w_ncdm)*s_l[2]*(y[idx+1]+metric_shear);

          }

          if (ppr->ncdm_fluid_approximation == ncdmfa_CLASS) {

            dy[idx+2] = -3.0*(a_prime_over_a*(2./3.-ca2_ncdm-pseudo_p_ncdm/p_ncdm_bg/3.)+1./tau)*y[idx+2]
              +8.0/3.0*cvis2_ncdm/(1.0+w_ncdm)*s_l[2]*(y[idx+1]+metric_ufa_class);

          }

          /** - -----> jump to next species */

          idx += pv->l_max_ncdm[n_ncdm]+1;
        }
      }

      /** - ----> second case: use exact equation (Boltzmann hierarchy on momentum grid) */

      else {

        /** - -----> loop over species */

        for (n_ncdm=0; n_ncdm<pv->N_ncdm; n_ncdm++) {

          /** - -----> loop over momentum */

          for (index_q=0; index_q < pv->q_size_ncdm[n_ncdm]; index_q++) {

            /** - -----> define intermediate quantities */

            dlnf0_dlnq = pba->dlnf0_dlnq_ncdm[n_ncdm][index_q];
            q = pba->q_ncdm[n_ncdm][index_q];
            epsilon = sqrt(q*q+a2*pba->M_ncdm[n_ncdm]*pba->M_ncdm[n_ncdm]);
            qk_div_epsilon = k*q/epsilon;

            /** - -----> ncdm density for given momentum bin */

            dy[idx] = -qk_div_epsilon*y[idx+1]+metric_continuity*dlnf0_dlnq/3.;

            /** - -----> ncdm velocity for given momentum bin */

            dy[idx+1] = qk_div_epsilon/3.0*(y[idx] - 2*s_l[2]*y[idx+2])
              -epsilon*metric_euler/(3*q*k)*dlnf0_dlnq;

            /** - -----> ncdm shear for given momentum bin */

            dy[idx+2] = qk_div_epsilon/5.0*(2*s_l[2]*y[idx+1]-3.*s_l[3]*y[idx+3])
              -s_l[2]*metric_shear*2./15.*dlnf0_dlnq;

            /** - -----> ncdm l>3 for given momentum bin */

            for (l=3; l<pv->l_max_ncdm[n_ncdm]; l++){
              dy[idx+l] = qk_div_epsilon/(2.*l+1.0)*(l*s_l[l]*y[idx+(l-1)]-(l+1.)*s_l[l+1]*y[idx+(l+1)]);
            }

            /** - -----> ncdm lmax for given momentum bin (truncation as in Ma and Bertschinger)
                but with curvature taken into account a la arXiv:1305.3261 */

            dy[idx+l] = qk_div_epsilon*y[idx+l-1]-(1.+l)*k*cotKgen*y[idx+l];

            /** - -----> jump to next momentum bin or species */

            idx += (pv->l_max_ncdm[n_ncdm]+1);
          }
        }
      }
    }

    /** - ---> metric */

    /** - ---> eta of synchronous gauge */

    if (ppt->gauge == synchronous) {

      dy[pv->index_pt_eta] = pvecmetric[ppw->index_mt_eta_prime];

    }

    if (ppt->gauge == newtonian) {

      dy[pv->index_pt_phi] = pvecmetric[ppw->index_mt_phi_prime];

    }

  }

  /** - vector mode */
  if (_vectors_) {

    fprintf(stderr,"we are in vectors\n");

    ssqrt3 = sqrt(1.-2.*pba->K/k2);
    cb2 = pvecthermo[pth->index_th_cb2];

    /** - --> baryon velocity */

    if (ppt->gauge == synchronous) {

      dy[pv->index_pt_theta_b] = -(1-3.*cb2)*a_prime_over_a*y[pv->index_pt_theta_b]
        - pvecthermo[pth->index_th_dkappa]*(_SQRT2_/4.*delta_g + y[pv->index_pt_theta_b]);

    }

    else if (ppt->gauge == newtonian) {

      dy[pv->index_pt_theta_b] = -(1-3.*cb2)*a_prime_over_a*y[pv->index_pt_theta_b]
        - _SQRT2_/4.*pvecthermo[pth->index_th_dkappa]*(delta_g+2.*_SQRT2_*y[pv->index_pt_theta_b])
        + pvecmetric[ppw->index_mt_V_prime]+(1.-3.*cb2)*a_prime_over_a*y[pv->index_pt_V];

    }

    /*
      if (ppw->approx[ppw->index_ap_rsa] == (int)rsa_off) {
      if (ppw->approx[ppw->index_ap_tca]==(int)tca_off) {
    */

    /* short-cut notations for the tensor perturbations */
    delta_g = y[pv->index_pt_delta_g];
    theta_g = y[pv->index_pt_theta_g];
    shear_g = y[pv->index_pt_shear_g];


    /* (P^{(1)}) (see Eq. B.23 in 1305.3261)*/
    P1 = -_SQRT6_/40.*(
                       4./(3.*k)*theta_g //F1
                       +y[pv->index_pt_delta_g+3]
                       +2.*y[pv->index_pt_pol0_g]
                       +10./7.*y[pv->index_pt_pol2_g]
                       -4./7.*y[pv->index_pt_pol0_g+4]);

    if (ppt->gauge == synchronous) {

      /* photon density (delta_g = F_0) */
      dy[pv->index_pt_delta_g] =
        -4./3.*theta_g
        -pvecthermo[pth->index_th_dkappa]*(delta_g+2.*_SQRT2_*y[pv->index_pt_theta_b]);

      /* photon velocity (theta_g = (3k/4)*F_1) */
      dy[pv->index_pt_theta_g] =
        k2*(delta_g/4.-s_l[2]*shear_g)
        -pvecthermo[pth->index_th_dkappa]*(theta_g+4.0/_SQRT6_*P1)
        +4.0/(3.0*_SQRT2_)*ssqrt3*y[pv->index_pt_hv_prime];

    }

    else if (ppt->gauge == newtonian) {

      /* photon density (delta_g = F_0) */
      dy[pv->index_pt_delta_g] =
        -4./3.*theta_g
        -pvecthermo[pth->index_th_dkappa]*(delta_g+2.*_SQRT2_*y[pv->index_pt_theta_b])
        -2.*_SQRT2_*pvecmetric[ppw->index_mt_V_prime];

      /* photon velocity (theta_g = (3k/4)*F_1) */
      dy[pv->index_pt_theta_g] =
        k2*(delta_g/4.-s_l[2]*shear_g)
        -pvecthermo[pth->index_th_dkappa]*(theta_g+4.0/_SQRT6_*P1);

    }

    /* photon shear (shear_g = F_2/2) */
    dy[pv->index_pt_shear_g] =
      4./15.*s_l[2]*theta_g-3./10.*k*s_l[3]*y[pv->index_pt_shear_g+1]
      -pvecthermo[pth->index_th_dkappa]*shear_g;

    /* photon l=3 */
    dy[pv->index_pt_l3_g] =
      k/7.*(6.*s_l[3]*shear_g-4.*s_l[4]*y[pv->index_pt_l3_g+1])
      -pvecthermo[pth->index_th_dkappa]*y[pv->index_pt_l3_g];

    /* additional momenta in Boltzmann hierarchy (beyond l=0,1,2,3,4) */
    for (l=4; l < pv->l_max_g; l++)
      dy[pv->index_pt_delta_g+l] =
        k/(2.*l+1.)*(l*s_l[l]*y[pv->index_pt_delta_g+l-1]
                     -(l+1.)*s_l[l+1]*y[pv->index_pt_delta_g+l+1])
        -pvecthermo[pth->index_th_dkappa]*y[pv->index_pt_delta_g+l];

    /* l=lmax */
    l = pv->l_max_g;
    dy[pv->index_pt_delta_g+l] =
      k*(s_l[l]*y[pv->index_pt_delta_g+l-1]
         -(1.+l)*cotKgen*y[pv->index_pt_delta_g+l])
      - pvecthermo[pth->index_th_dkappa]*y[pv->index_pt_delta_g+l];

    /* photon polarization, l=0 (pol0_g = G_0)*/
    dy[pv->index_pt_pol0_g] =
      -k*y[pv->index_pt_pol0_g+1]
      -pvecthermo[pth->index_th_dkappa]*(y[pv->index_pt_pol0_g]-_SQRT6_*P1);

    /* additional momenta in Boltzmann hierarchy (beyond l=0,1,2,3,4) */
    for (l=1; l < pv->l_max_pol_g; l++)
      dy[pv->index_pt_pol0_g+l] =
        k/(2.*l+1.)*(l*s_l[l]*y[pv->index_pt_pol0_g+l-1]
                     -(l+1.)*s_l[l+1]*y[pv->index_pt_pol0_g+l+1])
        -pvecthermo[pth->index_th_dkappa]*y[pv->index_pt_pol0_g+l];

    /* l=lmax */
    l = pv->l_max_pol_g;
    dy[pv->index_pt_pol0_g+l] =
      k*(s_l[l]*y[pv->index_pt_pol0_g+l-1]
         -(l+1.)*cotKgen*y[pv->index_pt_pol0_g+l])
      -pvecthermo[pth->index_th_dkappa]*y[pv->index_pt_pol0_g+l];

    /*
      }
      }
    */

    if (ppt->gauge == synchronous) {

      /* Vector metric perturbation in synchronous gauge: */
      dy[pv->index_pt_hv_prime] = pvecmetric[ppw->index_mt_hv_prime_prime];

    }
    else if (ppt->gauge == newtonian){

      /* Vector metric perturbation in Newtonian gauge: */
      dy[pv->index_pt_V] = pvecmetric[ppw->index_mt_V_prime];

    }

  }


  /** - tensor modes: */
  if (_tensors_) {

    if (ppw->approx[ppw->index_ap_rsa] == (int)rsa_off) {
      if (ppw->approx[ppw->index_ap_tca]==(int)tca_off) {

        /* short-cut notations for the tensor perturbations */
        delta_g = y[pv->index_pt_delta_g];
        theta_g = y[pv->index_pt_theta_g];
        shear_g = y[pv->index_pt_shear_g];


        /* (P^{(2)}) */
        P2 =-1.0/_SQRT6_*(
                          1./10.*delta_g
                          +2./7.*shear_g
                          +3./70.*y[pv->index_pt_delta_g+4]
                          -3./5.*y[pv->index_pt_pol0_g]
                          +6./7.*y[pv->index_pt_pol2_g]
                          -3./70.*y[pv->index_pt_pol0_g+4]);

        /* above expression from paper, expression below matches old class but is not correct
           P2 = -1.0/_SQRT6_*(
           1./10.*delta_g
           +2./35.*shear_g
           +1./210.*y[pv->index_pt_delta_g+4]
           -3./5.*y[pv->index_pt_pol0_g]
           +6./35.*y[pv->index_pt_pol2_g]
           -1./210.*y[pv->index_pt_pol0_g+4]
           );
        */

        /* photon density (delta_g = F_0) */
        dy[pv->index_pt_delta_g] =
          -4./3.*theta_g
          -pvecthermo[pth->index_th_dkappa]*(delta_g+_SQRT6_*P2)
          //+y[pv->index_pt_gwdot];
          +_SQRT6_*y[pv->index_pt_gwdot];  //TBC

        /* photon velocity (theta_g = (3k/4)*F_1) */
        dy[pv->index_pt_theta_g] =
          k2*(delta_g/4.-s_l[2]*shear_g)
          -pvecthermo[pth->index_th_dkappa]*theta_g;

        /* photon shear (shear_g = F_2/2) */
        dy[pv->index_pt_shear_g] =
          4./15.*s_l[2]*theta_g-3./10.*k*s_l[3]*y[pv->index_pt_shear_g+1]
          -pvecthermo[pth->index_th_dkappa]*shear_g;

        /* photon l=3 */
        dy[pv->index_pt_l3_g] =
          k/7.*(6.*s_l[3]*shear_g-4.*s_l[4]*y[pv->index_pt_l3_g+1])
          -pvecthermo[pth->index_th_dkappa]*y[pv->index_pt_l3_g];

        /* additional momenta in Boltzmann hierarchy (beyond l=0,1,2,3,4) */
        for (l=4; l < pv->l_max_g; l++)
          dy[pv->index_pt_delta_g+l] =
            k/(2.*l+1.)*(l*s_l[l]*y[pv->index_pt_delta_g+l-1]
                         -(l+1.)*s_l[l+1]*y[pv->index_pt_delta_g+l+1])
            -pvecthermo[pth->index_th_dkappa]*y[pv->index_pt_delta_g+l];

        /* l=lmax */
        l = pv->l_max_g;
        dy[pv->index_pt_delta_g+l] =
          k*(s_l[l]*y[pv->index_pt_delta_g+l-1]
             -(1.+l)*cotKgen*y[pv->index_pt_delta_g+l])
          - pvecthermo[pth->index_th_dkappa]*y[pv->index_pt_delta_g+l];

        /* photon polarization, l=0 (pol0_g = G_0)*/
        dy[pv->index_pt_pol0_g] =
          -k*y[pv->index_pt_pol0_g+1]
          -pvecthermo[pth->index_th_dkappa]*(y[pv->index_pt_pol0_g]-_SQRT6_*P2);

        /* additional momenta in Boltzmann hierarchy (beyond l=0,1,2,3,4) */
        for (l=1; l < pv->l_max_pol_g; l++)
          dy[pv->index_pt_pol0_g+l] =
            k/(2.*l+1.)*(l*s_l[l]*y[pv->index_pt_pol0_g+l-1]
                         -(l+1.)*s_l[l+1]*y[pv->index_pt_pol0_g+l+1])
            -pvecthermo[pth->index_th_dkappa]*y[pv->index_pt_pol0_g+l];

        /* l=lmax */
        l = pv->l_max_pol_g;
        dy[pv->index_pt_pol0_g+l] =
          k*(s_l[l]*y[pv->index_pt_pol0_g+l-1]
             -(l+1.)*cotKgen*y[pv->index_pt_pol0_g+l])
          -pvecthermo[pth->index_th_dkappa]*y[pv->index_pt_pol0_g+l];

      }
    }

    if (ppt->evolve_tensor_ur == _TRUE_) {

      dy[pv->index_pt_delta_ur] = -4./3.*y[pv->index_pt_theta_ur]+_SQRT6_*y[pv->index_pt_gwdot];

      dy[pv->index_pt_theta_ur] = k2*(y[pv->index_pt_delta_ur]/4.-s2_squared*y[pv->index_pt_shear_ur]);

      dy[pv->index_pt_shear_ur] = (4./15.*y[pv->index_pt_theta_ur]
                                   -3./10.*k*s_l[3]/s_l[2]*y[pv->index_pt_shear_ur+1]);

      l = 3;
      dy[pv->index_pt_l3_ur] = k/(2.*l+1.)*
        (l*2.*s_l[l]*s_l[2]*y[pv->index_pt_shear_ur]-(l+1.)*s_l[l+1]*y[pv->index_pt_l3_ur+1]);

      for (l = 4; l < pv->l_max_ur; l++) {
        dy[pv->index_pt_delta_ur+l] = k/(2.*l+1)*
          (l*s_l[l]*y[pv->index_pt_delta_ur+l-1]-(l+1.)*s_l[l+1]*y[pv->index_pt_delta_ur+l+1]);
      }

      l = pv->l_max_ur;
      dy[pv->index_pt_delta_ur+l] =
        k*(s_l[l]*y[pv->index_pt_delta_ur+l-1]-(1.+l)*cotKgen*y[pv->index_pt_delta_ur+l]);

    }

    /** - --> non-cold dark matter (ncdm): massive neutrinos, WDM, etc. */
    //TBC: curvature in all ncdm
    if (ppt->evolve_tensor_ncdm == _TRUE_) {

      idx = pv->index_pt_psi0_ncdm1;

      /** - ---> loop over species */

      for (n_ncdm=0; n_ncdm<pv->N_ncdm; n_ncdm++) {

        /** - ----> loop over momentum */

        for (index_q=0; index_q < pv->q_size_ncdm[n_ncdm]; index_q++) {

          /** - ----> define intermediate quantities */

          dlnf0_dlnq = pba->dlnf0_dlnq_ncdm[n_ncdm][index_q];
          q = pba->q_ncdm[n_ncdm][index_q];
          epsilon = sqrt(q*q+a2*pba->M_ncdm[n_ncdm]*pba->M_ncdm[n_ncdm]);
          qk_div_epsilon = k*q/epsilon;

          /** - ----> ncdm density for given momentum bin */

          dy[idx] = -qk_div_epsilon*y[idx+1]-0.25*_SQRT6_*y[pv->index_pt_gwdot]*dlnf0_dlnq;

          /** - ----> ncdm l>0 for given momentum bin */

          for (l=1; l<pv->l_max_ncdm[n_ncdm]; l++){
            dy[idx+l] = qk_div_epsilon/(2.*l+1.0)*(l*s_l[l]*y[idx+(l-1)]-(l+1.)*s_l[l+1]*y[idx+(l+1)]);
          }

          /** - ----> ncdm lmax for given momentum bin (truncation as in Ma and Bertschinger)
              but with curvature taken into account a la arXiv:1305.3261 */

          dy[idx+l] = qk_div_epsilon*y[idx+l-1]-(1.+l)*k*cotKgen*y[idx+l];

          /** - ----> jump to next momentum bin or species */

          idx += (pv->l_max_ncdm[n_ncdm]+1);
        }
      }
    }

    /** - --> tensor metric perturbation h (gravitational waves) */
    dy[pv->index_pt_gw] = y[pv->index_pt_gwdot];

    /** - --> its time-derivative */
    dy[pv->index_pt_gwdot] = pvecmetric[ppw->index_mt_gw_prime_prime];

  }

  return _SUCCESS_;
}

/**
 * Compute the baryon-photon slip (theta_g - theta_b)' and the photon
 * shear in the tight-coupling approximation
 *
 * @param y                        Input: vector of perturbations
 * @param parameters_and_workspace Input/Output: in input, fixed parameters (e.g. indices); in output, slip and shear
 * @param error_message            Output: error message
 */

int perturbations_tca_slip_and_shear(double * y,
                                     void * parameters_and_workspace,
                                     ErrorMsg error_message
                                     ) {
  /** Summary: */

  /** - define local variables */

  /* scale factor and other background quantities */
  double a,a_prime_over_a,a_primeprime_over_a,R;

  /* useful terms for tight-coupling approximation */
  double slip=0.;
  double tau_c=0.,dtau_c=0.;
  double theta_prime,shear_g_prime=0.,theta_prime_prime;
  double g0,g0_prime,g0_prime_prime;
  double F=0.,F_prime=0.,F_prime_prime=0.;

  /* short-cut names for the fields of the input structure */
  struct perturbations_parameters_and_workspace * pppaw;
  double k,k2;
  struct precision * ppr;
  struct background * pba;
  struct thermodynamics * pth;
  struct perturbations * ppt;
  struct perturbations_workspace * ppw;
  double * pvecback;
  double * pvecthermo;
  double * pvecmetric;
  struct perturbations_vector * pv;

  /* short-cut notations for the perturbations */
  double delta_g=0.,theta_g=0.,shear_g=0.;
  double delta_b,theta_b;
  double Delta;
  double cb2;
  double metric_continuity=0.,metric_euler=0.,metric_shear=0.,metric_shear_prime=0.;

  /* idm_g effects on tca */
  double theta_idm = 0., theta_idm_prime = 0.;
  double tau_2_idm_g=0., dtau_2_idm_g=0.;
  double dmu_idm_g = 0., ddmu_idm_g = 0.;
  /* in case of idm_b - for notation see 1802.06788 */
  double tau_idm_b=0., dtau_idm_b=0.;
  double R_idm_b = 0., R_idm_b_prime = 0.;
  double S_idm_b = 0.;

  /* for use with curvature */
  double s2_squared;

  /** - rename the fields of the input structure (just to avoid heavy notations) */

  pppaw = (struct perturbations_parameters_and_workspace *)parameters_and_workspace;

  k = pppaw->k;
  k2=k*k;

  ppr = pppaw->ppr;
  pba = pppaw->pba;
  pth = pppaw->pth;
  ppt = pppaw->ppt;
  ppw = pppaw->ppw;

  pvecback = ppw->pvecback;
  pvecthermo = ppw->pvecthermo;
  pvecmetric = ppw->pvecmetric;
  pv = ppw->pv;

  /** - compute related background quantities */

  a = pvecback[pba->index_bg_a];
  a_prime_over_a = pvecback[pba->index_bg_H] * a;
  a_primeprime_over_a = pvecback[pba->index_bg_H_prime] * a + 2. * a_prime_over_a * a_prime_over_a;
  R = 4./3. * pvecback[pba->index_bg_rho_g]/pvecback[pba->index_bg_rho_b];
  s2_squared = 1.-3.*pba->K/k2;

  /** - --> (a) define short-cut notations for the scalar perturbations */
  if (ppw->approx[ppw->index_ap_rsa] == (int)rsa_off) {
    delta_g = y[pv->index_pt_delta_g];
    theta_g = y[pv->index_pt_theta_g];
  }
  delta_b = y[pv->index_pt_delta_b];
  theta_b = y[pv->index_pt_theta_b];
  cb2 = pvecthermo[pth->index_th_cb2];
  /* during TCA one can show that sound speed = adiabatic sound speed,
     so no need to take into account corrections from perturbed
     recombination here */

  if ((pth->has_idm_b == _TRUE_) || (pth->has_idm_g == _TRUE_)) {
    theta_idm = y[pv->index_pt_theta_idm];
    theta_idm_prime = ppw->theta_idm_prime;
  }

  /* terms for idm_b */
  if (pth->has_idm_b == _TRUE_) {
    R_idm_b = pvecthermo[pth->index_th_R_idm_b];
    R_idm_b_prime = pvecthermo[pth->index_th_dR_idm_b];
    S_idm_b = pvecback[pba->index_bg_rho_idm]/pvecback[pba->index_bg_rho_b];
    class_test( (ppr->tight_coupling_approximation != (int)first_order_CLASS) ,
                ppt->error_message,
                "idm_b is only coded with first order CLASS approximation in the tight coupling regime.");
  }

  if (pth->has_idm_g == _TRUE_) {
    dmu_idm_g = pvecthermo[pth->index_th_dmu_idm_g];
    ddmu_idm_g = pvecthermo[pth->index_th_ddmu_idm_g];

    class_test(ppr->tight_coupling_approximation != (int)first_order_CLASS && ppr->tight_coupling_approximation != (int)compromise_CLASS,
               ppt->error_message,
               "idm_g is only coded with the first order and compromise CLASS approximation in the tight coupling regime.");
  }

  /** - --> (b) define short-cut notations used only in tight-coupling approximation */
  tau_c = 1./pvecthermo[pth->index_th_dkappa]; /* inverse of opacity */
  dtau_c = -pvecthermo[pth->index_th_ddkappa]*tau_c*tau_c; /* its first derivative wrt conformal time */
  F = tau_c/(1+R); /* F = tau_c/(1+R) */
  if (ppr->tight_coupling_approximation >= (int)second_order_CLASS) {
    F_prime = dtau_c/(1+R)+tau_c*a_prime_over_a*R/(1+R)/(1+R); /*F' needed by second_order_CLASS and compromise_CLASS */
    if (ppr->tight_coupling_approximation == (int)second_order_CLASS) {
      F_prime_prime =(- pvecthermo[pth->index_th_dddkappa]*tau_c*tau_c /* F'' needed by second_order_CLASS only */
                      + 2.*pvecthermo[pth->index_th_ddkappa]*pvecthermo[pth->index_th_ddkappa]*tau_c*tau_c*tau_c)/(1+R)
        +2.*dtau_c*a_prime_over_a*R/(1+R)/(1+R)
        +tau_c*((a_primeprime_over_a-2.*a_prime_over_a*a_prime_over_a)+2.*a_prime_over_a*a_prime_over_a*R/(1+R))*R/(1+R)/(1+R);
    }
  }
  /* these are only needed for the photon shear */
  if (pth->has_idm_g == _TRUE_) {
    tau_2_idm_g = 1./(pvecthermo[pth->index_th_dkappa] + dmu_idm_g);
    dtau_2_idm_g = - (pvecthermo[pth->index_th_ddkappa] + ddmu_idm_g)*tau_2_idm_g*tau_2_idm_g;
  }

  if (pth->has_idm_b == _TRUE_) {
    tau_idm_b = 1./R_idm_b;
    dtau_idm_b = -R_idm_b_prime/R_idm_b/R_idm_b;
  }

  /** - --> (c) compute metric-related quantities (depending on gauge; additional gauges can be coded below)

      - Each continuity equation contains a term in (theta+metric_continuity) with
      metric_continuity = (h_prime/2) in synchronous gauge, (-3 phi_prime) in newtonian gauge

      - Each Euler equation contains a source term metric_euler with
      metric_euler = 0 in synchronous gauge, (k2 psi) in newtonian gauge

      - Each shear derivative equation contains a source term metric_shear equal to
      metric_shear = (h_prime+6eta_prime)/2 in synchronous gauge, 0 in newtonian gauge

      - metric_shear_prime is the derivative of metric_shear

      - In the ufa_class approximation, the leading-order source term is (h_prime/2) in synchronous gauge,
      (-3 (phi_prime+psi_prime)) in newtonian gauge: we approximate the later by (-6 phi_prime) */

  if (ppt->gauge == synchronous) {

    metric_continuity = pvecmetric[ppw->index_mt_h_prime]/2.;
    metric_euler = 0.;
    metric_shear = k2 * pvecmetric[ppw->index_mt_alpha];
    metric_shear_prime = k2 * pvecmetric[ppw->index_mt_alpha_prime];
  }

  if (ppt->gauge == newtonian) {

    metric_continuity = -3.*pvecmetric[ppw->index_mt_phi_prime];
    metric_euler = k2*pvecmetric[ppw->index_mt_psi];
    metric_shear = 0.;
    metric_shear_prime = 0.;
  }

  /** - --> (d) if some approximation schemes are turned on, enforce a few y[ ] values computed in perturbations_einstein */

  /* free-streaming photon velocity */
  if (ppw->approx[ppw->index_ap_rsa] == (int)rsa_on)
    theta_g = ppw->rsa_theta_g;



  /** - ---> intermediate quantities for 2nd order tca (or 1st with idm_g): zero order for theta_b' = theta_g' */
  theta_prime = (-a_prime_over_a*theta_b+k2*(cb2*delta_b+R/4.*delta_g))/(1.+R) + metric_euler;

  /** - ---> standard photon velocity derivative without tca (neglecting shear) - only needed for idm_g_dr behavior */
  if (pth->has_idm_g == _TRUE_) {
	theta_prime += -R/(1.+R) * dmu_idm_g * (theta_g - theta_idm);
  }

  /** - ---> like Ma & Bertschinger */
  if (ppr->tight_coupling_approximation == (int)first_order_MB) {

    slip=2.*R/(1.+R)*a_prime_over_a*(theta_b-theta_g)
      +F*(-a_primeprime_over_a*theta_b
          +k2*(-a_prime_over_a*delta_g/2.
               +cb2*(-theta_b-metric_continuity)
               -4./3.*(-theta_g-metric_continuity)/4.)
          -a_prime_over_a*metric_euler);

  }

  /** - ---> relax assumption dkappa~a\f$^{-2}\f$ (like in CAMB) */
  if ((ppr->tight_coupling_approximation == (int)first_order_CAMB) || (ppr->tight_coupling_approximation == (int)compromise_CLASS)) {

    slip=(dtau_c/tau_c-2.*a_prime_over_a/(1.+R))*(theta_b-theta_g)
      +F*(-a_primeprime_over_a*theta_b
          +k2*(-a_prime_over_a*delta_g/2.
               +cb2*(-theta_b-metric_continuity)
               -4./3.*(-theta_g-metric_continuity)/4.)
          -a_prime_over_a*metric_euler);
  }

  /** - ---> also relax assumption cb2~a\f$^{-1}\f$ */
  if ((ppr->tight_coupling_approximation == (int)first_order_CLASS) || (ppr->tight_coupling_approximation == (int)second_order_CLASS)){

    slip=(dtau_c/tau_c-2.*a_prime_over_a/(1.+R))*(theta_b-theta_g)
      +F*(-a_primeprime_over_a*theta_b
          +k2*(-a_prime_over_a*delta_g/2.
               +pvecthermo[pth->index_th_dcb2]*delta_b
               +cb2*(-theta_b-metric_continuity)
               -4./3.*(-theta_g-metric_continuity)/4.)
          -a_prime_over_a*metric_euler);
  }


  if (pth->has_idm_g == _TRUE_ && (ppr->tight_coupling_approximation == (int)first_order_CLASS || ppr->tight_coupling_approximation == (int)second_order_CLASS ||  ppr->tight_coupling_approximation == (int)compromise_CLASS )) {
    slip += -F*dmu_idm_g * ( k2*delta_g/4. + metric_euler + pvecthermo[pth->index_th_dkappa]*(theta_b-theta_g) + dmu_idm_g * (theta_idm - theta_g)
                             - theta_idm_prime);
  }

  if (pth->has_idm_b == _TRUE_) {
    slip -= S_idm_b * tau_c/tau_idm_b / (1.+R)
      * ( (a_prime_over_a - dtau_idm_b/tau_idm_b) * (theta_idm - theta_b)
          + theta_idm_prime
          - (-a_prime_over_a*theta_b + metric_euler + cb2*k2*delta_b + R/tau_c*(theta_g - theta_b) + S_idm_b*R_idm_b*(theta_idm - theta_b)) );
  }

  /** - ---> intermediate quantities for 2nd order tca: shear_g at first order in tight-coupling */
  shear_g=16./45.*tau_c*(theta_g+metric_shear);
  /* (Ma & Bertschinger give (1/9)*(4/3) instead of (2/15)*(4/3)
     because they didn't include the contribution of G_gamma0
     and G_gamma2, which are of the same order as sigma_g. This
     was already consistently included in CAMB) */
  /* if there is idm_g we have to use a different photon shear term, see 1802.06589 */
  if (pth->has_idm_g == _TRUE_) {
    shear_g = 16./45. * tau_2_idm_g * (theta_g + metric_shear);
  }
  /** - ---> intermediate quantities for 2nd order tca: shear_g_prime at first order in tight-coupling */
  shear_g_prime=16./45.*(tau_c*(theta_prime+metric_shear_prime)+dtau_c*(theta_g+metric_shear));

  /* change for idm_g, same as above */
  if (pth->has_idm_g == _TRUE_) {
    shear_g_prime = 16./45.*(tau_2_idm_g*(theta_prime + metric_shear_prime) + dtau_2_idm_g*(theta_g+metric_shear));
  }
  /** - ---> 2nd order as in CRS*/
  if (ppr->tight_coupling_approximation == (int)second_order_CRS) {

    if (ppt->gauge == newtonian) {

      class_stop(error_message,
                 "the second_order_CRS approach to tight-coupling is coded in synchronous gauge, not newtonian: change gauge or try another tight-coupling scheme");

    }

    if (ppt->gauge == synchronous) {

      class_test(pba->sgnK != 0,
                 ppt->error_message,
                 "the second_order_CRS approach to tight-coupling is coded in the flat case only: for non-flat try another tight-coupling scheme");

      /* infer Delta from h'' using Einstein equation */

      Delta = 2*k2*y[pv->index_pt_eta]
        -2*a_prime_over_a*pvecmetric[ppw->index_mt_h_prime]
        -pvecmetric[ppw->index_mt_h_prime_prime];

      /* monster expression for slip at second-order in tight-coupling */
      slip=(-2./(1.+R)*a_prime_over_a-pvecthermo[pth->index_th_ddkappa]/pvecthermo[pth->index_th_dkappa])*(theta_b-theta_g)
        +(-a_primeprime_over_a*theta_b
          -k2*a_prime_over_a*(delta_g/2.-2.*shear_g)
          +k2*(cb2*(-theta_b-metric_continuity)
               -4./3.*(-theta_g-metric_continuity)/4.
               +shear_g_prime)
          )/pvecthermo[pth->index_th_dkappa]/(1.+R)
        -2.*R*(3.*a_prime_over_a*a_prime_over_a*cb2+(1.+R)*(a_primeprime_over_a-a_prime_over_a*a_prime_over_a)-3.*a_prime_over_a*a_prime_over_a)
        /(1.+R)/(1.+R)/(1.+R)*(theta_b-theta_g)/pvecthermo[pth->index_th_dkappa]
        +(
          a_primeprime_over_a*a_prime_over_a*((2.-3.*cb2)*R-2.)*theta_b/(1.+R)
          +a_prime_over_a*k2*(1.-3.*cb2)*theta_b/3./(1.+R)
          +a_primeprime_over_a*k2*cb2*delta_b/(1.+R)
          +k2*k2*(3.*cb2-1.)*cb2*delta_b/3./(1.+R)
          +k2*k2*R*(3.*cb2-1.)*delta_g/12./(1.+R)
          +a_primeprime_over_a*k2*(2.+3.*R)*delta_g/4./(1.+R)
          +a_prime_over_a*a_prime_over_a*k2*((2.-3.*cb2)*R-1.)*delta_g/2./(1.+R)
          +a_prime_over_a*k2*cb2*(1.+(3.*cb2-2.)*R)*(-theta_b-metric_continuity)/(1.+R)
          +a_prime_over_a*k2*(2.+(5.-3.*cb2)*R)*4./3.*(-theta_g-metric_continuity)/4./(1.+R)
          +a_prime_over_a*(1.-3.*cb2)*k2*2.*metric_shear/3.
          +k2*k2*(3.*cb2-1.)*y[pv->index_pt_eta]/3.
          +2.*a_prime_over_a*k2*(3.*cb2-1.)*pvecmetric[ppw->index_mt_eta_prime]
          +k2*(1.-3.*cb2)*Delta/6.
          )/pvecthermo[pth->index_th_dkappa]/pvecthermo[pth->index_th_dkappa]/(1.+R)/(1.+R)
        -(4.*a_primeprime_over_a*theta_b-4.*k2*cb2*(-theta_b-metric_continuity)+2.*a_prime_over_a*k2*delta_g+k2*4./3.*(-theta_g-metric_continuity))/2./(1.+R)/(1.+R)*pvecthermo[pth->index_th_ddkappa]/pvecthermo[pth->index_th_dkappa]/pvecthermo[pth->index_th_dkappa]/pvecthermo[pth->index_th_dkappa]
        +4.*a_prime_over_a*R/(1.+R)/(1.+R)*pvecthermo[pth->index_th_ddkappa]/pvecthermo[pth->index_th_dkappa]/pvecthermo[pth->index_th_dkappa]*(theta_b-theta_g);

      /* second-order correction to shear */
      shear_g = (1.-11./6.*dtau_c)*shear_g-11./6.*tau_c*16./45.*tau_c*(theta_prime+k2*pvecmetric[ppw->index_mt_alpha_prime]);

    }
  }

  /** - ---> 2nd order like in CLASS paper */
  if (ppr->tight_coupling_approximation == (int)second_order_CLASS) {

    if (ppt->gauge == newtonian) {

      class_stop(error_message,
                 "the second_order_CLASS approach to tight-coupling is coded in synchronous gauge, not newtonian: change gauge or try another tight-coupling scheme");

    }

    if (ppt->gauge == synchronous) {

      /* zero order for theta_b'' = theta_g'' */
      theta_prime_prime = ((R-1.)*a_prime_over_a*theta_prime-(a_primeprime_over_a-a_prime_over_a*a_prime_over_a)*theta_b
                           +k2*(pvecthermo[pth->index_th_dcb2]*delta_b+cb2*(-theta_b-metric_continuity)-a_prime_over_a*R/4.*delta_g+R/4.*4./3.*(-theta_g-metric_continuity)))/(1.+R);

      /* zero-order quantities g0, g0', go'' */
      g0 = -a_prime_over_a*theta_b + k2*(cb2*delta_b-delta_g/4.);
      g0_prime = -a_prime_over_a*theta_prime-(a_primeprime_over_a-a_prime_over_a*a_prime_over_a)*theta_b+k2*(pvecthermo[pth->index_th_dcb2]*delta_b+(1./3.-cb2)*(theta_b+0.5*pvecmetric[ppw->index_mt_h_prime]));
      g0_prime_prime = -a_prime_over_a*theta_prime_prime-2.*(a_primeprime_over_a-a_prime_over_a*a_prime_over_a)*theta_prime
        -(2.*a_prime_over_a*a_prime_over_a*a_prime_over_a-3.*a_primeprime_over_a*a_prime_over_a)*theta_b
        +k2*(pvecthermo[pth->index_th_ddcb2]*delta_b-2.*pvecthermo[pth->index_th_dcb2]*(theta_b+0.5*pvecmetric[ppw->index_mt_h_prime])+(1./3.-cb2)*(theta_prime+0.5*pvecmetric[ppw->index_mt_h_prime_prime]));

      /* slip at second order */
      slip = (1.-2*a_prime_over_a*F)*slip + F*k2*s2_squared*(2.*a_prime_over_a*shear_g+shear_g_prime)
        -F*(F_prime_prime*g0+2.*F_prime*g0_prime+F*g0_prime_prime);

      /* second-order correction to shear*/
      /* this is modified for idm_g, see 1802.06589 */
      if (pth->has_idm_g == _TRUE_) {
        shear_g = (1.-11./6.*dtau_2_idm_g)*shear_g-11./6.*tau_2_idm_g*16./45.*tau_2_idm_g*(theta_prime+metric_shear_prime);
      }
      else {
        shear_g = (1.-11./6.*dtau_c)*shear_g-11./6.*tau_c*16./45.*tau_c*(theta_prime+metric_shear_prime);
      }
    }
  }

  /** - ---> add only the most important 2nd order terms */
  if (ppr->tight_coupling_approximation == (int)compromise_CLASS) {

    /* slip at second order (only leading second-order terms) */
    slip = (1.-2.*a_prime_over_a*F)*slip + F*k2*(2.*a_prime_over_a*s2_squared*shear_g+s2_squared*shear_g_prime-(1./3.-cb2)*(F*theta_prime+2.*F_prime*theta_b));

    /* second-order correction to shear */
    /* this is modified for idm_g, see 1802.06589 */
    if (pth->has_idm_g == _TRUE_) {
      shear_g = (1.-11./6.*dtau_2_idm_g)*shear_g-11./6.*tau_2_idm_g*16./45.*tau_2_idm_g*(theta_prime+metric_shear_prime);
    }
    else {
      shear_g = (1.-11./6.*dtau_c)*shear_g-11./6.*tau_c*16./45.*tau_c*(theta_prime+metric_shear_prime);
    }
  }

  /** - ---> store tight-coupling values of photon shear and its derivative */

  ppw->tca_shear_g = shear_g;
  ppw->tca_slip = slip;

  return _SUCCESS_;

}

/**
 * Compute the density delta and velocity theta of photons and
 * ultra-relativistic neutrinos in the radiation streaming
 * approximation
 *
 * @param ppr                      Input: pointer to precision structure
 * @param pba                      Input: pointer to background structure
 * @param pth                      Input: pointer to thermodynamics structure
 * @param ppt                      Input: pointer to perturbation structure
 * @param k                        Input: wavenumber
 * @param y                        Input: vector of perturbations
 * @param a_prime_over_a           Input: a'/a
 * @param pvecthermo               Input: vector of thermodynamics quantites
 * @param ppw                      Input/Output: in input, fixed parameters (e.g. indices); in output, delta and theta
 * @param error_message            Output: error message
 */

int perturbations_rsa_delta_and_theta(
                                      struct precision * ppr,
                                      struct background * pba,
                                      struct thermodynamics * pth,
                                      struct perturbations * ppt,
                                      double k,
                                      double * y,
                                      double a_prime_over_a,
                                      double * pvecthermo,
                                      struct perturbations_workspace * ppw,
                                      ErrorMsg error_message
                                      ) {
  /* - define local variables */

  double k2;

  k2 = k*k;

  class_test(ppw->approx[ppw->index_ap_rsa] == (int)rsa_off,
             "this function should not have been called now, bug was introduced",
             ppt->error_message,
             ppt->error_message);

  // formulas below TBC for curvaturema

  /* newtonian gauge */
  if (ppt->gauge == newtonian) {

    if (ppr->radiation_streaming_approximation == rsa_null) {
      ppw->rsa_delta_g = 0.;
      ppw->rsa_theta_g = 0.;
    }
    else {
      ppw->rsa_delta_g = -4.*y[ppw->pv->index_pt_phi];
      ppw->rsa_theta_g = 6.*ppw->pvecmetric[ppw->index_mt_phi_prime];
    }

    if (ppr->radiation_streaming_approximation == rsa_MD_with_reio) {

      ppw->rsa_delta_g +=
        -4./k2*ppw->pvecthermo[pth->index_th_dkappa]*y[ppw->pv->index_pt_theta_b];

      ppw->rsa_theta_g +=
        3./k2*(ppw->pvecthermo[pth->index_th_ddkappa]*y[ppw->pv->index_pt_theta_b]
               +ppw->pvecthermo[pth->index_th_dkappa]*
               (-a_prime_over_a*y[ppw->pv->index_pt_theta_b]
                +ppw->pvecthermo[pth->index_th_cb2]*k2*y[ppw->pv->index_pt_delta_b]
                +k2*y[ppw->pv->index_pt_phi]));
    }

    if (pba->has_ur == _TRUE_) {

      if (ppr->radiation_streaming_approximation == rsa_null) {
        ppw->rsa_delta_ur = 0.;
        ppw->rsa_theta_ur = 0.;
      }
      else {
        ppw->rsa_delta_ur = -4.*y[ppw->pv->index_pt_phi];
        ppw->rsa_theta_ur = 6.*ppw->pvecmetric[ppw->index_mt_phi_prime];
      }
    }
  }

  /* synchronous gauge */
  if (ppt->gauge == synchronous) {

    if (ppr->radiation_streaming_approximation == rsa_null) {
      ppw->rsa_delta_g = 0.;
      ppw->rsa_theta_g = 0.;
    }
    else {

      ppw->rsa_delta_g = 4./k2*(a_prime_over_a*ppw->pvecmetric[ppw->index_mt_h_prime]
                                -k2*y[ppw->pv->index_pt_eta]);
      ppw->rsa_theta_g = -0.5*ppw->pvecmetric[ppw->index_mt_h_prime];
    }

    if (ppr->radiation_streaming_approximation == rsa_MD_with_reio) {

      ppw->rsa_delta_g +=
        -4./k2*ppw->pvecthermo[pth->index_th_dkappa]*(y[ppw->pv->index_pt_theta_b]+0.5*ppw->pvecmetric[ppw->index_mt_h_prime]);

      ppw->rsa_theta_g +=
        3./k2*(ppw->pvecthermo[pth->index_th_ddkappa]*
               (y[ppw->pv->index_pt_theta_b]
                +0.5*ppw->pvecmetric[ppw->index_mt_h_prime])
               +ppw->pvecthermo[pth->index_th_dkappa]*
               (-a_prime_over_a*y[ppw->pv->index_pt_theta_b]
                + ppw->pvecthermo[pth->index_th_cb2]*k2*y[ppw->pv->index_pt_delta_b]
                -a_prime_over_a*ppw->pvecmetric[ppw->index_mt_h_prime]
                +k2*y[ppw->pv->index_pt_eta]));
    }

    if (pba->has_ur == _TRUE_) {

      if (ppr->radiation_streaming_approximation == rsa_null) {
        ppw->rsa_delta_ur = 0.;
        ppw->rsa_theta_ur = 0.;
      }
      else {
        ppw->rsa_delta_ur = 4./k2*(a_prime_over_a*ppw->pvecmetric[ppw->index_mt_h_prime]
                                   -k2*y[ppw->pv->index_pt_eta]);
        ppw->rsa_theta_ur = -0.5*ppw->pvecmetric[ppw->index_mt_h_prime];
      }
    }
  }

  /* update total delta and theta given rsa approximation results */

  ppw->delta_rho += ppw->pvecback[pba->index_bg_rho_g]*ppw->rsa_delta_g;
  ppw->delta_p += 1./3.*ppw->pvecback[pba->index_bg_rho_g]*ppw->rsa_delta_g;
  ppw->rho_plus_p_theta += 4./3.*ppw->pvecback[pba->index_bg_rho_g]*ppw->rsa_theta_g;

  if (pba->has_ur == _TRUE_) {
    ppw->delta_rho += ppw->pvecback[pba->index_bg_rho_ur]*ppw->rsa_delta_ur;
    ppw->delta_p += 1./3.*ppw->pvecback[pba->index_bg_rho_ur]*ppw->rsa_delta_ur;
    ppw->rho_plus_p_theta += 4./3.*ppw->pvecback[pba->index_bg_rho_ur]*ppw->rsa_theta_ur;
  }

  return _SUCCESS_;

}

/**
 * Compute the density delta and velocity theta of interacting dark
 * radiation in its streaming approximation
 *
 * @param ppr                      Input: pointer to precision structure
 * @param pba                      Input: pointer to background structure
 * @param pth                      Input: pointer to thermodynamics structure
 * @param ppt                      Input: pointer to perturbation structure
 * @param k                        Input: wavenumber
 * @param y                        Input: vector of perturbations
 * @param a_prime_over_a           Input: a'/a
 * @param pvecthermo               Input: vector of thermodynamics quantites
 * @param ppw                      Input/Output: in input, fixed parameters (e.g. indices); in output, delta and theta
 * @param error_message            Output: error message
 */

int perturbations_rsa_idr_delta_and_theta(
                                          struct precision * ppr,
                                          struct background * pba,
                                          struct thermodynamics * pth,
                                          struct perturbations * ppt,
                                          double k,
                                          double * y,
                                          double a_prime_over_a,
                                          double * pvecthermo,
                                          struct perturbations_workspace * ppw,
                                          ErrorMsg error_message
                                          ) {
  /* - define local variables */

  double k2;

  k2 = k*k;

  // formulas below TBC for curvaturema

  /* newtonian gauge */
  if (ppt->gauge == newtonian) {

    if (ppw->approx[ppw->index_ap_rsa_idr] == (int)rsa_idr_on) {

      ppw->rsa_delta_idr = -4.*y[ppw->pv->index_pt_phi];
      ppw->rsa_theta_idr = 6.*ppw->pvecmetric[ppw->index_mt_phi_prime];

    }
  }

  if (ppt->gauge == synchronous) {

    if (ppw->approx[ppw->index_ap_rsa_idr] == (int)rsa_idr_on) {

      ppw->rsa_delta_idr = 4./k2*(a_prime_over_a*ppw->pvecmetric[ppw->index_mt_h_prime]
                                  -k2*y[ppw->pv->index_pt_eta]);
      ppw->rsa_theta_idr = -0.5*ppw->pvecmetric[ppw->index_mt_h_prime];

    }
  }

  return _SUCCESS_;

}
```

`source/primordial.c`:

```c
/** @file primordial.c Documented primordial module.
 *
 * Julien Lesgourgues, 24.08.2010
 *
 * This module computes the primordial spectra. It can be used in different modes:
 * simple parametric form, evolving inflaton perturbations, etc. So far only
 * the mode corresponding to a simple analytic form in terms of amplitudes, tilts
 * and runnings has been developed.
 *
 * The following functions can be called from other modules:
 *
 * -# primordial_init() at the beginning (anytime after perturbations_init() and before harmonic_init())
 * -# primordial_spectrum_at_k() at any time for computing P(k) at any k
 * -# primordial_free() at the end
 */

#include "primordial.h"
#include "parallel.h"

/**
 * Primordial spectra for arbitrary argument and for all initial conditions.
 *
 * This routine evaluates the primordial spectrum at a given value of k by
 * interpolating in the pre-computed table.
 *
 * When k is not in the pre-computed range but the spectrum can be found
 * analytically, it finds it. Otherwise returns an error.
 *
 * Can be called in two modes; linear or logarithmic:
 *
 * - linear: takes k, returns P(k)
 *
 * - logarithmic: takes ln(k), return ln(P(k))
 *
 * One little subtlety: in case of several correlated initial conditions,
 * the cross-correlation spectrum can be negative. Then, in logarithmic mode,
 * the non-diagonal elements contain the cross-correlation angle \f$ P_{12}/\sqrt{P_{11} P_{22}}\f$
 * (from -1 to 1) instead of \f$\ln{P_{12}}\f$
 *
 * This function can be
 * called from whatever module at whatever time, provided that
 * primordial_init() has been called before, and primordial_free() has not
 * been called yet.
 *
 * @param ppm        Input: pointer to primordial structure containing tabulated primordial spectrum
 * @param index_md   Input: index of mode (scalar, tensor, ...)
 * @param mode       Input: linear or logarithmic
 * @param input      Input: wavenumber in 1/Mpc (linear mode) or its logarithm (logarithmic mode)
 * @param output     Output: for each pair of initial conditions, primordial spectra P(k) in \f$Mpc^3\f$ (linear mode), or their logarithms and cross-correlation angles (logarithmic mode)
 * @return the error status
 */

int primordial_spectrum_at_k(
                             struct primordial * ppm,
                             int index_md,
                             enum linear_or_logarithmic mode,
                             double input,
                             double * output /* array with argument output[index_ic1_ic2] (must be already allocated) */
                             ) {

  /** Summary: */

  /** - define local variables */

  int index_ic1,index_ic2,index_ic1_ic2;
  double lnk;
  int last_index;

  /** - infer ln(k) from input. In linear mode, reject negative value of input k value. */

  if (mode == linear) {
    class_test(input<=0.,
               ppm->error_message,
               "k = %e",input);
    lnk=log(input);
  }
  else {
    lnk = input;
  }

  /** - if ln(k) is not in the interpolation range, return an error, unless
      we are in the case of a analytic spectrum, for which a direct computation is possible */

  if ((lnk > ppm->lnk[ppm->lnk_size-1]) || (lnk < ppm->lnk[0])) {

    class_test(ppm->primordial_spec_type != analytic_Pk,
               ppm->error_message,
               "k=%e out of range [%e : %e]",exp(lnk),exp(ppm->lnk[0]),exp(ppm->lnk[ppm->lnk_size-1]));

    /* direct computation */

    for (index_ic1 = 0; index_ic1 < ppm->ic_size[index_md]; index_ic1++) {
      for (index_ic2 = index_ic1; index_ic2 < ppm->ic_size[index_md]; index_ic2++) {

        index_ic1_ic2 = index_symmetric_matrix(index_ic1,index_ic2,ppm->ic_size[index_md]);

        if (ppm->is_non_zero[index_md][index_ic1_ic2] == _TRUE_) {

          class_call(primordial_analytic_spectrum(ppm,
                                                  index_md,
                                                  index_ic1_ic2,
                                                  exp(lnk),
                                                  &(output[index_ic1_ic2])),
                     ppm->error_message,
                     ppm->error_message);
        }
        else {
          output[index_ic1_ic2] = 0.;
        }
      }
    }

    /* if mode==linear, output is already in the correct format. Otherwise, apply necessary transformation. */

    if (mode == logarithmic) {

      for (index_ic1 = 0; index_ic1 < ppm->ic_size[index_md]; index_ic1++) {
        index_ic1_ic2 = index_symmetric_matrix(index_ic1,index_ic1,ppm->ic_size[index_md]);
        output[index_ic1_ic2] = log(output[index_ic1_ic2]);
      }
      for (index_ic1 = 0; index_ic1 < ppm->ic_size[index_md]; index_ic1++) {
        for (index_ic2 = index_ic1+1; index_ic2 < ppm->ic_size[index_md]; index_ic2++) {
          index_ic1_ic2 = index_symmetric_matrix(index_ic1,index_ic2,ppm->ic_size[index_md]);
          if (ppm->is_non_zero[index_md][index_ic1_ic2] == _TRUE_) {
            output[index_ic1_ic2] /= sqrt(output[index_symmetric_matrix(index_ic1,index_ic1,ppm->ic_size[index_md])]*
                                          output[index_symmetric_matrix(index_ic2,index_ic2,ppm->ic_size[index_md])]);
          }
        }
      }
    }
  }

  /** - otherwise, interpolate in the pre-computed table */

  else {

    class_call(array_interpolate_spline(
                                        ppm->lnk,
                                        ppm->lnk_size,
                                        ppm->lnpk[index_md],
                                        ppm->ddlnpk[index_md],
                                        ppm->ic_ic_size[index_md],
                                        lnk,
                                        &last_index,
                                        output,
                                        ppm->ic_ic_size[index_md],
                                        ppm->error_message),
               ppm->error_message,
               ppm->error_message);

    /* if mode==logarithmic, output is already in the correct format. Otherwise, apply necessary transformation. */

    if (mode == linear) {

      for (index_ic1 = 0; index_ic1 < ppm->ic_size[index_md]; index_ic1++) {
        index_ic1_ic2 = index_symmetric_matrix(index_ic1,index_ic1,ppm->ic_size[index_md]);
        output[index_ic1_ic2]=exp(output[index_ic1_ic2]);
      }
      for (index_ic1 = 0; index_ic1 < ppm->ic_size[index_md]; index_ic1++) {
        for (index_ic2 = index_ic1+1; index_ic2 < ppm->ic_size[index_md]; index_ic2++) {
          index_ic1_ic2 = index_symmetric_matrix(index_ic1,index_ic2,ppm->ic_size[index_md]);
          if (ppm->is_non_zero[index_md][index_ic1_ic2] == _TRUE_) {
            output[index_ic1_ic2] *= sqrt(output[index_symmetric_matrix(index_ic1,index_ic1,ppm->ic_size[index_md])]*
                                          output[index_symmetric_matrix(index_ic2,index_ic2,ppm->ic_size[index_md])]);
          }
          else {
            output[index_ic1_ic2] = 0.;
          }
        }
      }
    }
  }

  return _SUCCESS_;

}

/**
 * This routine initializes the primordial structure (in particular, it computes table of primordial spectrum values)
 *
 * @param ppr Input: pointer to precision structure (defines method and precision for all computations)
 * @param pba Input: pointer to background structure
 * @param ppt Input: pointer to perturbation structure (useful for knowing k_min, k_max, etc.)
 * @param ppm Output: pointer to initialized primordial structure
 * @return the error status
 */

int primordial_init(
                    struct precision  * ppr,
                    struct background * pba,
                    struct perturbations * ppt,
                    struct primordial * ppm
                    ) {

  /** Summary: */

  /** - define local variables */

  double k,k_min,k_max;
  int index_md,index_ic1,index_ic2,index_ic1_ic2,index_k;
  double pk,pk1,pk2;
  double dlnk,lnpk_pivot,lnpk_minus,lnpk_plus,lnpk_minusminus,lnpk_plusplus;
  /* uncomment if you use optional test below
     (for correlated isocurvature modes) */
  //double cos_delta_k;

  /** - check that we really need to compute the primordial spectra */

  if (ppt->has_perturbations == _FALSE_) {
    ppm->lnk_size=0;
    if (ppm->primordial_verbose > 0)
      printf("No perturbations requested. Primordial module skipped.\n");
    return _SUCCESS_;
  }
  else {
    if (ppm->primordial_verbose > 0)
      printf("Computing primordial spectra");
  }

  /** - get kmin and kmax from perturbation structure. Test that they make sense. */

  k_min = ppt->k_min; /* first value, inferred from perturbations structure */
  if (ppm->has_k_max_for_primordial_pk == _TRUE_){
    k_max = ppm->k_max_for_primordial_pk; /* last value, user-defined (i.e. if specified in .ini file) */
  }
  else{
    k_max = ppt->k_max; /* last value, inferred from perturbations structure */
  }

  class_test(k_min <= 0.,
             ppm->error_message,
             "k_min negative or null: stop to avoid segmentation fault");

  class_test(k_max <= 0.,
             ppm->error_message,
             "k_max negative or null: stop to avoid segmentation fault");

  class_test(ppm->k_pivot <= 0.,
             ppm->error_message,
             "k_pivot negative or null: stop to avoid segmentation fault");

  class_test(ppr->k_per_decade_primordial <= 0.,
             ppm->error_message,
             "k_per_decade_primordial negative or null: stop to avoid segmentation fault");

  class_test(ppr->k_per_decade_primordial <= _K_PER_DECADE_PRIMORDIAL_MIN_,
             ppm->error_message,
             "k_per_decade_primordial = %e: you ask for such a sparse sampling of the primordial spectrum that this is probably a mistake",
             ppr->k_per_decade_primordial);

  /** - allocate and fill values of \f$ \ln{k}\f$'s */

  class_call(primordial_get_lnk_list(ppt,
                                     ppm,
                                     k_min,
                                     k_max,
                                     ppr->k_per_decade_primordial,
                                     pba->nu_spacing,pba->K,pba->sgnK
                                     ),
             ppm->error_message,
             ppm->error_message);

  /** - define indices and allocate tables in primordial structure */

  class_call(primordial_indices(ppt,
                                ppm),
             ppm->error_message,
             ppm->error_message);

  /** - deal with case of analytic primordial spectra (with amplitudes, tilts, runnings, etc.) */

  if (ppm->primordial_spec_type == analytic_Pk) {

    if (ppm->primordial_verbose > 0)
      printf(" (analytic spectrum)\n");

    class_call_except(primordial_analytic_spectrum_init(ppt,
                                                        ppm),
                      ppm->error_message,
                      ppm->error_message,
                      primordial_free(ppm));

    for (index_k = 0; index_k < ppm->lnk_size; index_k++) {

      k=exp(ppm->lnk[index_k]);

      for (index_md = 0; index_md < ppt->md_size; index_md++) {
        for (index_ic1 = 0; index_ic1 < ppm->ic_size[index_md]; index_ic1++) {
          for (index_ic2 = index_ic1; index_ic2 < ppm->ic_size[index_md]; index_ic2++) {

            index_ic1_ic2 = index_symmetric_matrix(index_ic1,index_ic2,ppm->ic_size[index_md]);

            if (ppm->is_non_zero[index_md][index_ic1_ic2] == _TRUE_) {

              class_call(primordial_analytic_spectrum(ppm,
                                                      index_md,
                                                      index_ic1_ic2,
                                                      k,
                                                      &pk),
                         ppm->error_message,
                         ppm->error_message);

              if (index_ic1 == index_ic2) {

                /* diagonal coefficients: ln[P(k)] */

                ppm->lnpk[index_md][index_k*ppm->ic_ic_size[index_md]+index_ic1_ic2] = log(pk);
              }
              else {

                /* non-diagonal coefficients: cosDelta(k) = P(k)_12/sqrt[P(k)_1 P(k)_2] */

                class_call(primordial_analytic_spectrum(ppm,
                                                        index_md,
                                                        index_symmetric_matrix(index_ic1,index_ic1,ppm->ic_size[index_md]),
                                                        k,
                                                        &pk1),
                           ppm->error_message,
                           ppm->error_message);

                class_call(primordial_analytic_spectrum(ppm,
                                                        index_md,
                                                        index_symmetric_matrix(index_ic2,index_ic2,ppm->ic_size[index_md]),
                                                        k,
                                                        &pk2),
                           ppm->error_message,
                           ppm->error_message);

                /* either return an error if correlation is too large... */
                /*
                  cos_delta_k = pk/sqrt(pk1*pk2);
                  class_test_except((cos_delta_k < -1.) || (cos_delta_k > 1.),
                  ppm->error_message,
                  primordial_free(ppm),
                  "correlation angle between IC's takes unphysical values");

                  ppm->lnpk[index_md][index_k*ppm->ic_ic_size[index_md]+index_ic1_ic2] = cos_delta_k;
                */

                /* ... or enforce definite positive correlation matrix */

                if (pk > sqrt(pk1*pk2))
                  ppm->lnpk[index_md][index_k*ppm->ic_ic_size[index_md]+index_ic1_ic2] = 1.;
                else if (pk < -sqrt(pk1*pk2))
                  ppm->lnpk[index_md][index_k*ppm->ic_ic_size[index_md]+index_ic1_ic2] = -1.;
                else
                  ppm->lnpk[index_md][index_k*ppm->ic_ic_size[index_md]+index_ic1_ic2] = pk/sqrt(pk1*pk2);


              }
            }
            else {

              /* non-diagonal coefficients when ic's are uncorrelated */

              ppm->lnpk[index_md][index_k*ppm->ic_ic_size[index_md]+index_ic1_ic2] = 0.;
            }
          }
        }
      }
    }
  }

  /** - deal with case of inflation with given \f$V(\phi)\f$ or \f$H(\phi)\f$ */

  else if ((ppm->primordial_spec_type == inflation_V) || (ppm->primordial_spec_type == inflation_H) || (ppm->primordial_spec_type == inflation_V_end)) {

    class_call(primordial_inflation_indices(ppm),
               ppm->error_message,
               ppm->error_message);

    if (ppm->primordial_verbose > 0)
      printf(" (simulating inflation)\n");

    class_call_except(primordial_inflation_solve_inflation(ppt,ppm,ppr),
                      ppm->error_message,
                      ppm->error_message,
                      primordial_free(ppm));

  }

  /** - deal with the case of external calculation of \f$ P_k \f$*/

  else if (ppm->primordial_spec_type == external_Pk) {

    class_test(ppt->has_scalars == _FALSE_,
               ppm->error_message,
               "external Pk module cannot work if you do not ask for scalar modes");

    class_test(ppt->has_vectors == _TRUE_,
               ppm->error_message,
               "external Pk module cannot work if you ask for vector modes");

    class_test(ppt->has_bi == _TRUE_ || ppt->has_cdi == _TRUE_ || ppt->has_nid == _TRUE_ || ppt->has_niv == _TRUE_,
               ppm->error_message,
               "external Pk module cannot work if you ask for isocurvature modes (but that could be implemented easily in the future!)");

    if (ppm->primordial_verbose > 0)
      printf(" (Pk calculated externally)\n");

    class_call_except(primordial_external_spectrum_init(ppt,ppm),
                      ppm->error_message,
                      ppm->error_message,
                      primordial_free(ppm));
  }

  else {

    class_test(0==0,
               ppm->error_message,
               "primordial spectrum type not recognized");

  }

  /** - compute second derivative of each \f$ \ln{P_k} \f$ versus lnk with spline, in view of interpolation */

  for (index_md = 0; index_md < ppm->md_size; index_md++) {

    class_call(array_spline_table_lines(ppm->lnk,
                                        ppm->lnk_size,
                                        ppm->lnpk[index_md],
                                        ppm->ic_ic_size[index_md],
                                        ppm->ddlnpk[index_md],
                                        _SPLINE_EST_DERIV_,
                                        ppm->error_message),
               ppm->error_message,
               ppm->error_message);

  }

  /** - derive spectral parameters from numerically computed spectra
      (not used by the rest of the code, but useful to keep in memory for several types of investigation) */

  if (ppm->primordial_spec_type != analytic_Pk) {

    dlnk = log(10.)/ppr->k_per_decade_primordial;

    if (ppt->has_scalars == _TRUE_) {

      class_call(primordial_spectrum_at_k(ppm,
                                          ppt->index_md_scalars,
                                          logarithmic,
                                          log(ppm->k_pivot),
                                          &lnpk_pivot),
                 ppm->error_message,
                 ppm->error_message);

      class_call(primordial_spectrum_at_k(ppm,
                                          ppt->index_md_scalars,
                                          logarithmic,
                                          log(ppm->k_pivot)+dlnk,

                                          &lnpk_plus),
                 ppm->error_message,
                 ppm->error_message);

      class_call(primordial_spectrum_at_k(ppm,
                                          ppt->index_md_scalars,
                                          logarithmic,
                                          log(ppm->k_pivot)-dlnk,
                                          &lnpk_minus),
                 ppm->error_message,
                 ppm->error_message);

      ppm->A_s = exp(lnpk_pivot);
      ppm->n_s = (lnpk_plus-lnpk_minus)/(2.*dlnk)+1.;
      ppm->alpha_s = (lnpk_plus-2.*lnpk_pivot+lnpk_minus)/pow(dlnk,2);

      /** - expression for alpha_s comes from:

          `ns_2 = (lnpk_plus-lnpk_pivot)/(dlnk)+1`

          `ns_1 = (lnpk_pivot-lnpk_minus)/(dlnk)+1`

          `alpha_s = dns/dlnk = (ns_2-ns_1)/dlnk = (lnpk_plus-lnpk_pivot-lnpk_pivot+lnpk_minus)/(dlnk)/(dlnk)`

      **/

      class_call(primordial_spectrum_at_k(ppm,
                                          ppt->index_md_scalars,
                                          logarithmic,
                                          log(ppm->k_pivot)+2.*dlnk,

                                          &lnpk_plusplus),
                 ppm->error_message,
                 ppm->error_message);

      class_call(primordial_spectrum_at_k(ppm,
                                          ppt->index_md_scalars,
                                          logarithmic,
                                          log(ppm->k_pivot)-2.*dlnk,
                                          &lnpk_minusminus),
                 ppm->error_message,
                 ppm->error_message);

      /** - expression for beta_s:

          `ppm->beta_s = (alpha_plus-alpha_minus)/dlnk = (lnpk_plusplus-2.*lnpk_plus+lnpk_pivot -
          (lnpk_pivot-2.*lnpk_minus+lnpk_minusminus)/pow(dlnk,3)`
      **/

      /* Simplification of the beta_s expression: */

      ppm->beta_s = (lnpk_plusplus-2.*lnpk_plus+2.*lnpk_minus-lnpk_minusminus)/pow(dlnk,3);

      if (ppm->primordial_verbose > 0)
        printf(" -> A_s=%g  n_s=%g  alpha_s=%g\n",ppm->A_s,ppm->n_s,ppm->alpha_s);

    }

    if (ppt->has_tensors == _TRUE_) {

      class_call(primordial_spectrum_at_k(ppm,
                                          ppt->index_md_tensors,
                                          logarithmic,
                                          log(ppm->k_pivot),
                                          &lnpk_pivot),
                 ppm->error_message,
                 ppm->error_message);

      class_call(primordial_spectrum_at_k(ppm,
                                          ppt->index_md_tensors,
                                          logarithmic,
                                          log(ppm->k_pivot)+dlnk,
                                          &lnpk_plus),
                 ppm->error_message,
                 ppm->error_message);

      class_call(primordial_spectrum_at_k(ppm,
                                          ppt->index_md_tensors,
                                          logarithmic,
                                          log(ppm->k_pivot)-dlnk,
                                          &lnpk_minus),
                 ppm->error_message,
                 ppm->error_message);

      ppm->r = exp(lnpk_pivot)/ppm->A_s;
      ppm->n_t = (lnpk_plus-lnpk_minus)/(2.*dlnk);
      ppm->alpha_t = (lnpk_plus-2.*lnpk_pivot+lnpk_minus)/pow(dlnk,2);

      if (ppm->primordial_verbose > 0)
        printf(" -> r=%g  n_t=%g  alpha_t=%g\n",ppm->r,ppm->n_t,ppm->alpha_t);

    }

  }

  ppm->is_allocated = _TRUE_;

  return _SUCCESS_;

}

/**
 * This routine frees all the memory space allocated by primordial_init().
 *
 * To be called at the end of each run.
 *
 * @param ppm Input: pointer to primordial structure (which fields must be freed)
 * @return the error status
 */

int primordial_free(
                    struct primordial * ppm
                    ) {

  int index_md;

  if (ppm->lnk_size > 0) {

    if (ppm->primordial_spec_type == analytic_Pk) {
      for (index_md = 0; index_md < ppm->md_size; index_md++) {
        free(ppm->amplitude[index_md]);
        free(ppm->tilt[index_md]);
        free(ppm->running[index_md]);
      }
      free(ppm->amplitude);
      free(ppm->tilt);
      free(ppm->running);
    }
    else if (ppm->primordial_spec_type == external_Pk) {
      free(ppm->command);
    }

    for (index_md = 0; index_md < ppm->md_size; index_md++) {
      free(ppm->lnpk[index_md]);
      free(ppm->ddlnpk[index_md]);
      free(ppm->is_non_zero[index_md]);
    }

    free(ppm->lnpk);
    free(ppm->ddlnpk);
    free(ppm->is_non_zero);
    free(ppm->ic_size);
    free(ppm->ic_ic_size);

    free(ppm->lnk);

  }

  ppm->is_allocated = _FALSE_;

  return _SUCCESS_;
}

/**
 * This routine defines indices and allocates tables in the primordial structure
 *
 * @param ppt  Input: pointer to perturbation structure
 * @param ppm  Input/output: pointer to primordial structure
 * @return the error status
 */

int primordial_indices(
                       struct perturbations   * ppt,
                       struct primordial * ppm
                       ) {

  int index_md;

  ppm->md_size = ppt->md_size;

  class_alloc(ppm->lnpk,ppt->md_size*sizeof(double*),ppm->error_message);

  class_alloc(ppm->ddlnpk,ppt->md_size*sizeof(double*),ppm->error_message);

  class_alloc(ppm->ic_size,ppt->md_size*sizeof(int*),ppm->error_message);

  class_alloc(ppm->ic_ic_size,ppt->md_size*sizeof(int*),ppm->error_message);

  class_alloc(ppm->is_non_zero,ppm->md_size*sizeof(short *),ppm->error_message);

  for (index_md = 0; index_md < ppt->md_size; index_md++) {

    ppm->ic_size[index_md] = ppt->ic_size[index_md];

    ppm->ic_ic_size[index_md] = (ppm->ic_size[index_md]*(ppm->ic_size[index_md]+1))/2;

    class_alloc(ppm->lnpk[index_md],
                ppm->lnk_size*ppm->ic_ic_size[index_md]*sizeof(double),
                ppm->error_message);

    class_alloc(ppm->ddlnpk[index_md],
                ppm->lnk_size*ppm->ic_ic_size[index_md]*sizeof(double),
                ppm->error_message);

    class_alloc(ppm->is_non_zero[index_md],
                ppm->ic_ic_size[index_md]*sizeof(short),
                ppm->error_message);


  }

  return _SUCCESS_;

}

/**
 * This routine allocates and fills the list of wavenumbers k
 *
 *
 * @param ppt  Input: pointer to perturbation structure
 * @param ppm  Input/output: pointer to primordial structure
 * @param kmin Input: first value
 * @param kmax Input: last value that we should encompass
 * @param k_per_decade Input: number of k per decade
 * @param nu_spacing Input: specific spacing of nu 
 * @param K        Input: spatial curvature (in absolute value)
 * @param sgnK     Input: spatial curvature sign (open/closed/flat)
 * @return the error status
 */

int primordial_get_lnk_list(
                            struct perturbations  * ppt,
                            struct primordial * ppm,
                            double kmin,
                            double kmax,
                            double k_per_decade,
                            int nu_spacing, // For closed universe, the spacing of nu is not just 1, but can be 2, 3, etc.
                            double K,
                            int sgnK
                            ) {

  if  (sgnK <= 0) {
      /* Original code */

      int i;

      class_test((kmin <= 0.) || (kmax <= kmin),
                ppm->error_message,
                "inconsistent values of kmin=%e, kmax=%e",kmin,kmax);

      ppm->lnk_size = (int)(log(kmax/kmin)/log(10.)*k_per_decade) + 2;

      class_alloc(ppm->lnk,ppm->lnk_size*sizeof(double),ppm->error_message);

      for (i=0; i<ppm->lnk_size; i++)
        ppm->lnk[i]=log(kmin)+i*log(10.)/k_per_decade;

  } else {  // sgnK >0 (closed universe)

      /* Modified code */
      double m=0.;
      double q,q_min=0.,q_max=0.,q_step;
      int nu, nu_min;
      int q_size_max;
      int index_k = 0;
      int k_size_max;
      double k;
      int index_md;

      if (_scalars_) {
        m=0.;
      }
      if (_vectors_) {
        m=1.;
      }
      if (_tensors_) {
        m=2.;
      }

      nu_min = 3;
      q_min = nu_min * sqrt(K);

      q_max = sqrt(kmax*kmax + K*(m+1.));

      class_test((q_max <= q_min),
                ppm->error_message,
                "inconsistent values of kmax=%e",kmax);

      q_step = nu_spacing * sqrt(K);
      q_size_max = (int)((q_max-q_min)/q_step) + 1;
      k_size_max = q_size_max;

      fprintf(stdout,"kmax=%f, q_size_max=%d q_max = %d\n",kmax,q_size_max,q_max);
      
      ppm->lnk_size = k_size_max;
      class_alloc(ppm->lnk,ppm->lnk_size*sizeof(double),ppm->error_message);

      /* assign the first value before starting the loop */
      k = sqrt(q_min*q_min - K*(m+1.));
      ppm->lnk[index_k] = log(k); 
      nu = 3;
      index_k++;

      /* loop over the values */

      while (index_k < k_size_max) {
          q = nu*sqrt(K);
          nu = nu + nu_spacing;
          k = sqrt(q*q - K*(m+1.));
          ppm->lnk[index_k] = log(k);
          index_k++;
      }
    
      /* infer total number of values (also checking if we overshot the last point) */
      
      if (ppm->lnk[index_k-1] > kmax)
          ppm->lnk_size=index_k-1;
      else
          ppm->lnk_size=index_k;
      
      class_test(ppm->lnk_size<2,ppm->error_message,"buggy k-list definition");
        
        
      /* now, readjust array size */
        
      class_realloc(ppm->lnk,
                    ppm->lnk_size*sizeof(double),
                    ppm->error_message);

  } 

  return _SUCCESS_;
}

/**
 * This routine interprets and stores in a condensed form the input parameters
 * in the case of a simple analytic spectra with amplitudes, tilts, runnings,
 * in such way that later on, the spectrum can be obtained by a quick call to
 * the routine primordial_analytic_spectrum(()
 *
 * @param ppt  Input: pointer to perturbation structure
 * @param ppm  Input/output: pointer to primordial structure
 * @return the error status
 */

int primordial_analytic_spectrum_init(
                                      struct perturbations   * ppt,
                                      struct primordial * ppm
                                      ) {

  int index_md,index_ic1,index_ic2;
  int index_ic1_ic2,index_ic1_ic1,index_ic2_ic2;
  double one_amplitude=0.;
  double one_tilt=0.;
  double one_running=0.;
  double one_correlation=0.;

  class_alloc(ppm->amplitude,
              ppm->md_size*sizeof(double *),
              ppm->error_message);

  class_alloc(ppm->tilt,
              ppm->md_size*sizeof(double *),
              ppm->error_message);

  class_alloc(ppm->running,
              ppm->md_size*sizeof(double *),
              ppm->error_message);

  for (index_md = 0; index_md < ppm->md_size; index_md++) {

    class_alloc(ppm->amplitude[index_md],
                ppm->ic_ic_size[index_md]*sizeof(double),
                ppm->error_message);

    class_alloc(ppm->tilt[index_md],
                ppm->ic_ic_size[index_md]*sizeof(double),
                ppm->error_message);

    class_alloc(ppm->running[index_md],
                ppm->ic_ic_size[index_md]*sizeof(double),
                ppm->error_message);

  }

  for (index_md = 0; index_md < ppm->md_size; index_md++) {

    /* diagonal coefficients */

    for (index_ic1 = 0; index_ic1 < ppm->ic_size[index_md]; index_ic1++) {

      if (_scalars_) {

        if ((ppt->has_ad == _TRUE_) && (index_ic1 == ppt->index_ic_ad)) {
          one_amplitude = ppm->A_s;
          one_tilt = ppm->n_s;
          one_running = ppm->alpha_s;
        }

        if ((ppt->has_bi == _TRUE_) && (index_ic1 == ppt->index_ic_bi)) {
          one_amplitude = ppm->A_s*ppm->f_bi*ppm->f_bi;
          one_tilt = ppm->n_bi;
          one_running = ppm->alpha_bi;
        }

        if ((ppt->has_cdi == _TRUE_) && (index_ic1 == ppt->index_ic_cdi)) {
          one_amplitude = ppm->A_s*ppm->f_cdi*ppm->f_cdi;
          one_tilt = ppm->n_cdi;
          one_running = ppm->alpha_cdi;
        }

        if ((ppt->has_nid == _TRUE_) && (index_ic1 == ppt->index_ic_nid)) {
          one_amplitude = ppm->A_s*ppm->f_nid*ppm->f_nid;
          one_tilt = ppm->n_nid;
          one_running = ppm->alpha_nid;
        }

        if ((ppt->has_niv == _TRUE_) && (index_ic1 == ppt->index_ic_niv)) {
          one_amplitude = ppm->A_s*ppm->f_niv*ppm->f_niv;
          one_tilt = ppm->n_niv;
          one_running = ppm->alpha_niv;
        }
      }

      if (_tensors_) {

        if (index_ic1 == ppt->index_ic_ten) {
          one_amplitude = ppm->A_s*ppm->r;
          one_tilt = ppm->n_t+1.; /* +1 to match usual definition of n_t (equivalent to n_s-1) */
          one_running = ppm->alpha_t;
        }
      }

      class_test(one_amplitude <= 0.,
                 ppm->error_message,
                 "inconsistent input for primordial amplitude: %g for index_md=%d, index_ic=%d\n",
                 one_amplitude,index_md,index_ic1);

      index_ic1_ic2 = index_symmetric_matrix(index_ic1,index_ic1,ppm->ic_size[index_md]);

      ppm->is_non_zero[index_md][index_ic1_ic2] = _TRUE_;
      ppm->amplitude[index_md][index_ic1_ic2] = one_amplitude;
      ppm->tilt[index_md][index_ic1_ic2] = one_tilt;
      ppm->running[index_md][index_ic1_ic2] = one_running;
    }

    /* non-diagonal coefficients */

    for (index_ic1 = 0; index_ic1 < ppm->ic_size[index_md]; index_ic1++) {
      for (index_ic2 = index_ic1+1; index_ic2 < ppm->ic_size[index_md]; index_ic2++) {

        if (_scalars_) {

          if ((ppt->has_ad == _TRUE_) && (ppt->has_bi == _TRUE_) &&
              (((index_ic1 == ppt->index_ic_ad) && (index_ic2 == ppt->index_ic_bi)) ||
               ((index_ic1 == ppt->index_ic_ad) && (index_ic1 == ppt->index_ic_bi)))) {
            one_correlation = ppm->c_ad_bi;
            one_tilt = ppm->n_ad_bi;
            one_running = ppm->alpha_ad_bi;
          }

          if ((ppt->has_ad == _TRUE_) && (ppt->has_cdi == _TRUE_) &&
              (((index_ic1 == ppt->index_ic_ad) && (index_ic2 == ppt->index_ic_cdi)) ||
               ((index_ic2 == ppt->index_ic_ad) && (index_ic1 == ppt->index_ic_cdi)))) {
            one_correlation = ppm->c_ad_cdi;
            one_tilt = ppm->n_ad_cdi;
            one_running = ppm->alpha_ad_cdi;
          }

          if ((ppt->has_ad == _TRUE_) && (ppt->has_nid == _TRUE_) &&
              (((index_ic1 == ppt->index_ic_ad) && (index_ic2 == ppt->index_ic_nid)) ||
               ((index_ic2 == ppt->index_ic_ad) && (index_ic1 == ppt->index_ic_nid)))) {
            one_correlation = ppm->c_ad_nid;
            one_tilt = ppm->n_ad_nid;
            one_running = ppm->alpha_ad_nid;
          }

          if ((ppt->has_ad == _TRUE_) && (ppt->has_niv == _TRUE_) &&
              (((index_ic1 == ppt->index_ic_ad) && (index_ic2 == ppt->index_ic_niv)) ||
               ((index_ic2 == ppt->index_ic_ad) && (index_ic1 == ppt->index_ic_niv)))) {
            one_correlation = ppm->c_ad_niv;
            one_tilt = ppm->n_ad_niv;
            one_running = ppm->alpha_ad_niv;
          }

          if ((ppt->has_bi == _TRUE_) && (ppt->has_cdi == _TRUE_) &&
              (((index_ic1 == ppt->index_ic_bi) && (index_ic2 == ppt->index_ic_cdi)) ||
               ((index_ic2 == ppt->index_ic_bi) && (index_ic1 == ppt->index_ic_cdi)))) {
            one_correlation = ppm->c_bi_cdi;
            one_tilt = ppm->n_bi_cdi;
            one_running = ppm->alpha_bi_cdi;
          }

          if ((ppt->has_bi == _TRUE_) && (ppt->has_nid == _TRUE_) &&
              (((index_ic1 == ppt->index_ic_bi) && (index_ic2 == ppt->index_ic_nid)) ||
               ((index_ic2 == ppt->index_ic_bi) && (index_ic1 == ppt->index_ic_nid)))) {
            one_correlation = ppm->c_bi_nid;
            one_tilt = ppm->n_bi_nid;
            one_running = ppm->alpha_bi_nid;
          }

          if ((ppt->has_bi == _TRUE_) && (ppt->has_niv == _TRUE_) &&
              (((index_ic1 == ppt->index_ic_bi) && (index_ic2 == ppt->index_ic_niv)) ||
               ((index_ic2 == ppt->index_ic_bi) && (index_ic1 == ppt->index_ic_niv)))) {
            one_correlation = ppm->c_bi_niv;
            one_tilt = ppm->n_bi_niv;
            one_running = ppm->alpha_bi_niv;
          }

          if ((ppt->has_cdi == _TRUE_) && (ppt->has_nid == _TRUE_) &&
              (((index_ic1 == ppt->index_ic_cdi) && (index_ic2 == ppt->index_ic_nid)) ||
               ((index_ic2 == ppt->index_ic_cdi) && (index_ic1 == ppt->index_ic_nid)))) {
            one_correlation = ppm->c_cdi_nid;
            one_tilt = ppm->n_cdi_nid;
            one_running = ppm->alpha_cdi_nid;
          }

          if ((ppt->has_cdi == _TRUE_) && (ppt->has_niv == _TRUE_) &&
              (((index_ic1 == ppt->index_ic_cdi) && (index_ic2 == ppt->index_ic_niv)) ||
               ((index_ic2 == ppt->index_ic_cdi) && (index_ic1 == ppt->index_ic_niv)))) {
            one_correlation = ppm->c_cdi_niv;
            one_tilt = ppm->n_cdi_niv;
            one_running = ppm->alpha_cdi_niv;
          }

          if ((ppt->has_nid == _TRUE_) && (ppt->has_niv == _TRUE_) &&
              (((index_ic1 == ppt->index_ic_nid) && (index_ic2 == ppt->index_ic_niv)) ||
               ((index_ic2 == ppt->index_ic_nid) && (index_ic1 == ppt->index_ic_niv)))) {
            one_correlation = ppm->c_nid_niv;
            one_tilt = ppm->n_nid_niv;
            one_running = ppm->alpha_nid_niv;
          }

        }

        class_test((one_correlation < -1) || (one_correlation > 1),
                   ppm->error_message,
                   "inconsistent input for isocurvature cross-correlation\n");

        index_ic1_ic2 = index_symmetric_matrix(index_ic1,index_ic2,ppm->ic_size[index_md]);
        index_ic1_ic1 = index_symmetric_matrix(index_ic1,index_ic1,ppm->ic_size[index_md]);
        index_ic2_ic2 = index_symmetric_matrix(index_ic2,index_ic2,ppm->ic_size[index_md]);

        if (one_correlation == 0.) {
          ppm->is_non_zero[index_md][index_ic1_ic2] = _FALSE_;
          ppm->amplitude[index_md][index_ic1_ic2] = 0.;
          ppm->tilt[index_md][index_ic1_ic2] = 0.;
          ppm->running[index_md][index_ic1_ic2] = 0.;
        }
        else {
          ppm->is_non_zero[index_md][index_ic1_ic2] = _TRUE_;
          ppm->amplitude[index_md][index_ic1_ic2] =
            sqrt(ppm->amplitude[index_md][index_ic1_ic1]*
                 ppm->amplitude[index_md][index_ic2_ic2])*
            one_correlation;
          ppm->tilt[index_md][index_ic1_ic2] =
            0.5*(ppm->tilt[index_md][index_ic1_ic1]
                 +ppm->tilt[index_md][index_ic2_ic2])
            + one_tilt;
          ppm->running[index_md][index_ic1_ic2] =
            0.5*(ppm->running[index_md][index_ic1_ic1]
                 +ppm->running[index_md][index_ic2_ic2])
            + one_running;
        }
      }
    }
  }

  return _SUCCESS_;

}

/**
 * This routine returns the primordial spectrum in the simple analytic case with
 * amplitudes, tilts, runnings, for each mode (scalar/tensor...),
 * pair of initial conditions, and wavenumber.
 *
 * @param ppm            Input/output: pointer to primordial structure
 * @param index_md     Input: index of mode (scalar, tensor, ...)
 * @param index_ic1_ic2  Input: pair of initial conditions (ic1, ic2)
 * @param k              Input: wavenumber in same units as pivot scale, i.e. in 1/Mpc
 * @param pk             Output: primordial power spectrum A (k/k_pivot)^(n+...)
 * @return the error status
 */

int primordial_analytic_spectrum(
                                 struct primordial * ppm,
                                 int index_md,
                                 int index_ic1_ic2,
                                 double k,
                                 double * pk
                                 ) {

  if (ppm->is_non_zero[index_md][index_ic1_ic2] == _TRUE_) {
    *pk = ppm->amplitude[index_md][index_ic1_ic2]
      *exp((ppm->tilt[index_md][index_ic1_ic2]-1.)*log(k/ppm->k_pivot)
           + 0.5 * ppm->running[index_md][index_ic1_ic2] * pow(log(k/ppm->k_pivot), 2.));

  }
  else {
    *pk = 0.;
  }

  return _SUCCESS_;

}

/**
 * This routine encodes the inflaton scalar potential
 *
 * @param ppm            Input: pointer to primordial structure
 * @param phi            Input: background inflaton field value in units of Mp
 * @param V              Output: inflaton potential in units of \f$ Mp^4\f$
 * @param dV             Output: first derivative of inflaton potential wrt the field
 * @param ddV            Output: second derivative of inflaton potential wrt the field
 * @return the error status
 */

int primordial_inflation_potential(
                                   struct primordial * ppm,
                                   double phi,
                                   double * V,
                                   double * dV,
                                   double * ddV
                                   ) {

  double e,de,dde,mu,dmu,ddmu,l,dl,ddl,p,dp,ddp;

  switch (ppm->potential) {

    /* V(phi)=polynomial in phi */
  case polynomial:

    *V   = ppm->V0+phi*ppm->V1+pow(phi,2)/2.*ppm->V2+pow(phi,3)/6.*ppm->V3+pow(phi,4)/24.*ppm->V4;
    *dV  = ppm->V1+phi*ppm->V2+pow(phi,2)/2.*ppm->V3+pow(phi,3)/6.*ppm->V4;
    *ddV = ppm->V2+phi*ppm->V3+pow(phi,2)/2.*ppm->V4;
    break;

    /* V(phi) = Lambda^4(1+cos(phi/f)) = V0 (1+cos(phi/V1)) */
  case natural:

    *V   = ppm->V0*(1.+cos(phi/ppm->V1));
    *dV  = -ppm->V0/ppm->V1*sin(phi/ppm->V1);
    *ddV = -ppm->V0/ppm->V1/ppm->V1*cos(phi/ppm->V1);
    break;

    /* Higgs inflation from arXiv:1403.6078 */
  case higgs_inflation:

    // correspondence with 1403.6078:
    // V0 = b
    // V1 = ksi
    // V2 = kappa
    // V3 = delta_lambda
    // mu = bar(mu)/M_P
    // phi = -chi/M_P

    e = exp(2./sqrt(6.)*sqrt(8.*_PI_)*phi);
    de = 2./sqrt(6.)*sqrt(8.*_PI_)*e;
    dde = 2./3. * 8.*_PI_ * e;

    mu = pow(1.-e,0.5);
    dmu = -0.5*de*pow(1.-e,-0.5);
    ddmu = -0.5*dde*pow(1.-e,-0.5)-0.25*de*de*pow(1.-e,-1.5);

    l = log(mu/ppm->V2);
    dl = dmu/mu;
    ddl = ddmu/mu - dl*dl;

    p = 1./16. + ppm->V3/ppm->V0 + l*l;
    dp = 2.*dl*l;
    ddp = 2.*ddl*l+2.*dl*dl;

    *V = ppm->V0/4./pow(8.*_PI_,2)/ppm->V1/ppm->V1*p*pow(mu,4);
    *dV = ppm->V0/4./pow(8.*_PI_,2)/ppm->V1/ppm->V1*(dp*pow(mu,4)+4.*p*dmu*pow(mu,3));
    *ddV = ppm->V0/4./pow(8.*_PI_,2)/ppm->V1/ppm->V1*(ddp*pow(mu,4)+8.*dp*dmu*pow(mu,3)+4.*p*ddmu*pow(mu,3)+12.*p*pow(dmu*mu,2));

    //fprintf(stderr,"%e  %e  %e\n",*V,p,mu);

    break;

    /* code here other shapes */

  default:
    class_stop(ppm->error_message,"ppm->potential=%d different from all known cases",ppm->potential);
    break;
  }

  return _SUCCESS_;
}

/**
 * This routine encodes the function \f$ H(\phi)\f$
 *
 * @param ppm            Input: pointer to primordial structure
 * @param phi            Input: background inflaton field value in units of Mp
 * @param H              Output: Hubble parameters in units of Mp
 * @param dH             Output: \f$ dH / d\phi \f$
 * @param ddH            Output: \f$ d^2H / d\phi^2 \f$
 * @param dddH           Output: \f$ d^3H / d\phi^3 \f$
 * @return the error status
 */

int primordial_inflation_hubble(
                                struct primordial * ppm,
                                double phi,
                                double * H,
                                double * dH,
                                double * ddH,
                                double * dddH
                                ) {

  *H =    ppm->H0 + phi*ppm->H1 + pow(phi,2)/2.*ppm->H2 + pow(phi,3)/6.*ppm->H3 + pow(phi,4)/24.*ppm->H4;
  *dH =   ppm->H1 + phi*ppm->H2 + pow(phi,2)/2.*ppm->H3 + pow(phi,3)/6.*ppm->H4;
  *ddH =  ppm->H2 + phi*ppm->H3 + pow(phi,2)/2.*ppm->H4;
  *dddH = ppm->H3 + phi*ppm->H4;

  return _SUCCESS_;

}

/**
 * This routine defines indices used by the inflation simulator
 *
 * @param ppm  Input/output: pointer to primordial structure
 * @return the error status
 */
int primordial_inflation_indices(
                                 struct primordial * ppm
                                 ) {

  int index_in;

  index_in = 0;

  /* indices for background quantities */
  ppm->index_in_a = index_in;
  index_in ++;
  ppm->index_in_phi = index_in;
  index_in ++;
  if ((ppm->primordial_spec_type == inflation_V) || (ppm->primordial_spec_type == inflation_V_end)) {
    ppm->index_in_dphi = index_in;
    index_in ++;
  }

  /* size of background vector */
  ppm->in_bg_size = index_in;

  /* indices for perturbations */
  ppm->index_in_ksi_re = index_in;
  index_in ++;
  ppm->index_in_ksi_im = index_in;
  index_in ++;
  ppm->index_in_dksi_re = index_in;
  index_in ++;
  ppm->index_in_dksi_im = index_in;
  index_in ++;
  ppm->index_in_ah_re = index_in;
  index_in ++;
  ppm->index_in_ah_im = index_in;
  index_in ++;
  ppm->index_in_dah_re = index_in;
  index_in ++;
  ppm->index_in_dah_im = index_in;
  index_in ++;

  /* size of perturbation vector */
  ppm->in_size = index_in;

  return _SUCCESS_;
}

/**
 * Main routine of inflation simulator. Its goal is to check the
 * background evolution before and after the pivot value
 * phi=phi_pivot, and then, if this evolution is suitable, to call the
 * routine primordial_inflation_spectra().
 *
 * @param ppt  Input: pointer to perturbation structure
 * @param ppm  Input/output: pointer to primordial structure
 * @param ppr  Input: pointer to precision structure
 * @return the error status
 */

int primordial_inflation_solve_inflation(
                                         struct perturbations * ppt,
                                         struct primordial * ppm,
                                         struct precision *ppr
                                         ) {
  /** Summary: */
  /** - define local variables */
  double * y;
  double * y_ini;
  double * dy;
  double a_pivot;
  double a_try;
  double H_pivot;
  double H_try;
  double phi_try;
  double dphidt_pivot;
  double dphidt_try;
  double aH_ini,aH_end;
  double k_max,k_min;
  int counter;
  double dH,ddH,dddH;

  /** - allocate vectors for background/perturbed quantities */
  class_alloc(y,ppm->in_size*sizeof(double),ppm->error_message);
  class_alloc(y_ini,ppm->in_size*sizeof(double),ppm->error_message);
  class_alloc(dy,ppm->in_size*sizeof(double),ppm->error_message);

  /** - eventually, needs first to find phi_pivot */
  if (ppm->primordial_spec_type == inflation_V_end) {

    class_call(primordial_inflation_find_phi_pivot(ppm,ppr,y,dy),
               ppm->error_message,
               ppm->error_message);

  }
  else {
    ppm->phi_pivot = 0.;
  }

  // uncomment these lines if for checking, you want first-order slow-roll predictions
  /*
    if (ppm->primordial_verbose>0) {
    if ((ppm->primordial_spec_type == inflation_V) || (ppm->primordial_spec_type == inflation_V_end)) {
    double V,dV,ddV;
    class_call(primordial_inflation_check_potential(ppm,ppm->phi_pivot,&V,&dV,&ddV),
    ppm->error_message,
    ppm->error_message);
    fprintf(stdout," -> 1st-order slow-roll prediction for A_s: %g\n",128.*_PI_/3.*pow(V,3)/pow(dV,2));
    fprintf(stdout," -> 1st-order slow-roll prediction for T/S: %g\n",pow(dV/V,2)/_PI_);
    fprintf(stdout," -> 1st-order slow-roll prediction for A_T: %g\n",pow(dV/V,2)/_PI_*128.*_PI_/3.*pow(V,3)/pow(dV,2));
    fprintf(stdout," -> 1st-order slow-roll prediction for n_s: %g\n",1.-6./16./_PI_*pow(dV/V,2)+2./8./_PI_*(ddV/V));
    fprintf(stdout," -> 1st-order slow-roll prediction for n_t: %g\n",-2./16./_PI_*pow(dV/V,2));
    }
    }
  */

  /** - compute H_pivot at phi_pivot */
  switch (ppm->primordial_spec_type) {

  case inflation_V:
  case inflation_V_end:

    /** - check positivity and negative slope of potential in field pivot
        value, and find value of phi_dot and H for field's pivot value,
        assuming slow-roll attractor solution has been reached. If no
        solution, code will stop there. */

    if (ppm->primordial_verbose > 1)
      printf(" (search attractor at pivot)\n");

    class_call_except(primordial_inflation_find_attractor(ppm,
                                                          ppr,
                                                          ppm->phi_pivot,
                                                          ppr->primordial_inflation_attractor_precision_pivot,
                                                          y,
                                                          dy,
                                                          &H_pivot,
                                                          &dphidt_pivot),
                      ppm->error_message,
                      ppm->error_message,
                      free(y);free(y_ini);free(dy));
    break;

  case inflation_H:

    /** - check positivity and negative slope of \f$ H(\phi)\f$ in field pivot
        value, and get H_pivot */

    class_call_except(primordial_inflation_check_hubble(ppm,
                                                        ppm->phi_pivot,
                                                        &H_pivot,
                                                        &dH,
                                                        &ddH,
                                                        &dddH),
                      ppm->error_message,
                      ppm->error_message,
                      free(y);free(y_ini);free(dy));
    break;

  default:
    free(y);free(y_ini);free(dy);
    class_stop(ppm->error_message,"ppm->primordial_spec_type=%d different from possible relevant cases",ppm->primordial_spec_type);
    break;
  }

  /** - find a_pivot, value of scale factor when k_pivot crosses horizon while phi=phi_pivot */

  a_pivot = ppm->k_pivot/H_pivot;

  /** - integrate background solution starting from phi_pivot and until
      k_max>>aH. This ensures that the inflationary model considered
      here is valid and that the primordial spectrum can be
      computed. Otherwise, if slow-roll brakes too early, model is not
      suitable and run stops. */

  if (ppm->primordial_verbose > 1)
    printf(" (check inflation duration after phi_pivot=%e)\n",ppm->phi_pivot);

  k_max = exp(ppm->lnk[ppm->lnk_size-1]);
  aH_end = k_max/ppr->primordial_inflation_ratio_max;

  y[ppm->index_in_a] = a_pivot;
  y[ppm->index_in_phi] = ppm->phi_pivot;
  if ((ppm->primordial_spec_type == inflation_V) || (ppm->primordial_spec_type == inflation_V_end))
    y[ppm->index_in_dphi] = a_pivot*dphidt_pivot;

  class_call_except(primordial_inflation_evolve_background(ppm,
                                                           ppr,
                                                           y,
                                                           dy,
                                                           _aH_,
                                                           aH_end,
                                                           _TRUE_,
                                                           forward,
                                                           conformal),
                    ppm->error_message,
                    ppm->error_message,
                    free(y);free(y_ini);free(dy));

  /* we need to do the opposite: to check that there is an initial
     time such that k_min << (aH)_ini. A guess is made by integrating
     backward in time. This can be done exactly for inflation_H, or
     only approximately for inflation_V (using the first-order
     approximation to the attractor inflationary solution). However
     this approximation is irrelevant because nevertheless, later on,
     we compute the attractor solution at the initial time with high
     accuracy, and then we integrate the background equations forward
     in time. Hence the approximation made here introduces zero
     mistake on the final result. It is just a way to find quickly a
     reasonable initial phi value. In the inflation_V case, if the
     exact forward integration reveals that the guess was not good
     (i.e. does not correspond to "early enough"), we iterate over
     sequences of backward/forward integration, until a correct time is
     found. For potential such that no solution exists (no long-enough
     slow-roll period before the pivot scale), the run stops. */

  if (ppm->primordial_verbose > 1)
    printf(" (check inflation duration before pivot)\n");

  k_min = exp(ppm->lnk[0]);
  aH_ini = k_min/ppr->primordial_inflation_ratio_min;

  switch (ppm->primordial_spec_type) {

  case inflation_V:
  case inflation_V_end:

    counter = 0;

    y[ppm->index_in_a] = a_pivot;
    y[ppm->index_in_phi] = ppm->phi_pivot;

    do {

      /* counter to avoid infinite loop */
      counter ++;

      class_test_except(counter >= ppr->primordial_inflation_phi_ini_maxit,
                        ppm->error_message,
                        free(y);free(y_ini);free(dy),
                        "when searching for an initial value of phi just before observable inflation takes place, could not converge after %d iterations. The potential does not allow eough inflationary e-folds before reaching the pivot scale",
                        counter);

      /* try to find a value phi_try such that
         aH=aH_ini*(ppr->primordial_inflation_aH_ini_target) (default:
         aH_ini*0.9). But this is using the approximate backward
         solution. So, anyway, we will check using the exact forward
         solution that at this phi_try, we really have aH < aH_ini; if
         this is not the case, we will iterate until a correct phi_try
         is found. */

      class_call_except(primordial_inflation_evolve_background(ppm,
                                                               ppr,
                                                               y,
                                                               dy,
                                                               _aH_,
                                                               aH_ini*ppr->primordial_inflation_aH_ini_target,
                                                               _TRUE_,
                                                               backward,
                                                               conformal),
                        ppm->error_message,
                        ppm->error_message,
                        free(y);free(y_ini);free(dy));

      phi_try = y[ppm->index_in_phi];

      /* in inflation_V case, find the accurate attractor solution for
         phi_ini', and then the correct value of a_ini, and finally of
         dphi/dtau_ini */

      /* find dphi/dt_ini (unlike dphi/dtau_ini, this does not depend on normalization of a) */
      class_call_except(primordial_inflation_find_attractor(ppm,
                                                            ppr,
                                                            phi_try,
                                                            ppr->primordial_inflation_attractor_precision_initial,
                                                            y,
                                                            dy,
                                                            &H_try,
                                                            &dphidt_try),
                        ppm->error_message,
                        ppm->error_message,
                        free(y);free(y_ini);free(dy));

      /* we need to normalize a properly so that a=a_pivot when
         phi=phi_pivot. To do so, we evolve starting arbitrarily from
         a_ini=1, and then we rescale a_ini appropriately. */

      y[ppm->index_in_a] = 1.;
      y[ppm->index_in_phi] = phi_try;
      y[ppm->index_in_dphi] = y[ppm->index_in_a]*dphidt_try; // dphi/dtau = a dphi/dt

      class_call_except(primordial_inflation_evolve_background(ppm,
                                                               ppr,
                                                               y,
                                                               dy,
                                                               _phi_,
                                                               ppm->phi_pivot,
                                                               _TRUE_,
                                                               forward,
                                                               conformal),
                        ppm->error_message,
                        ppm->error_message,
                        free(y);free(y_ini);free(dy));

      /* now impose the correct a_ini */
      a_try = a_pivot/y[ppm->index_in_a];

      /* in case another iteration will be needed, set a new starting point for the routine primordial_inflation_evolve_background(...,backward) */
      y[ppm->index_in_a] = a_try;
      y[ppm->index_in_phi] = phi_try;

    } while (a_try*H_try > aH_ini);

    y_ini[ppm->index_in_a] = a_try;
    y_ini[ppm->index_in_phi] = phi_try;
    y_ini[ppm->index_in_dphi] = y_ini[ppm->index_in_a]*dphidt_try; // dphi/dtau = a dphi/dt

    break;

  case inflation_H:

    y[ppm->index_in_a] = a_pivot;
    y[ppm->index_in_phi] = ppm->phi_pivot;

    class_call_except(primordial_inflation_evolve_background(ppm,
                                                             ppr,
                                                             y,
                                                             dy,
                                                             _aH_,
                                                             aH_ini,
                                                             _TRUE_,
                                                             backward,
                                                             conformal),
                      ppm->error_message,
                      ppm->error_message,
                      free(y);free(y_ini);free(dy));

    y_ini[ppm->index_in_a] = y[ppm->index_in_a];
    y_ini[ppm->index_in_phi] = y[ppm->index_in_phi];

    break;

  default:
    free(y);free(y_ini);free(dy);
    class_stop(ppm->error_message,"ppm->primordial_spec_type=%d different from possible relevant cases",ppm->primordial_spec_type);
    break;
  }

  /** - starting from this time, i.e. from y_ini[ ], we run the routine
      which takes care of computing the primordial spectrum. */

  if (ppm->primordial_verbose > 1)
    printf(" (compute spectrum)\n");

  if (ppm->behavior == numerical) {

    class_call_except(primordial_inflation_spectra(ppt,
                                                   ppm,
                                                   ppr,
                                                   y_ini),
                      ppm->error_message,
                      ppm->error_message,
                      free(y);free(y_ini);free(dy));
  }
  else if (ppm->behavior == analytical) {

    class_call_except(primordial_inflation_analytic_spectra(ppt,
                                                            ppm,
                                                            ppr,
                                                            y_ini),
                      ppm->error_message,
                      ppm->error_message,
                      free(y);free(y_ini);free(dy));
  }
  else {
    class_stop(ppm->error_message,"Uncomprehensible value of the flag ppm->behavior=%d",ppm->behavior);
  }

  /** - before ending, we want to compute and store the values of \f$ \phi \f$
      corresponding to k=aH for k_min and k_max */

  y[ppm->index_in_a] = y_ini[ppm->index_in_a];
  y[ppm->index_in_phi] = y_ini[ppm->index_in_phi];
  if ((ppm->primordial_spec_type == inflation_V) || (ppm->primordial_spec_type == inflation_V_end))
    y[ppm->index_in_dphi] = y_ini[ppm->index_in_dphi];

  class_call_except(primordial_inflation_evolve_background(ppm,
                                                           ppr,
                                                           y,
                                                           dy,
                                                           _aH_,
                                                           k_min,
                                                           _FALSE_,
                                                           forward,
                                                           conformal),
                    ppm->error_message,
                    ppm->error_message,
                    free(y);free(y_ini);free(dy));

  ppm->phi_min=y[ppm->index_in_phi];

  class_call_except(primordial_inflation_evolve_background(ppm,
                                                           ppr,
                                                           y,
                                                           dy,
                                                           _aH_,
                                                           k_max,
                                                           _FALSE_,
                                                           forward,
                                                           conformal),
                    ppm->error_message,
                    ppm->error_message,
                    free(y);free(y_ini);free(dy));

  ppm->phi_max=y[ppm->index_in_phi];

  if (ppm->primordial_verbose > 1)
    printf(" (observable power spectrum goes from %e to %e)\n",
           ppm->phi_min,
           ppm->phi_max);

  /** - finally, we can de-allocate */

  free(y);
  free(y_ini);
  free(dy);

  return _SUCCESS_;
}

/**
 * Routine for the computation of an analytic apporoximation to the
 * the primordial spectrum. In general, should be used only for
 * comparing with exact numerical computation performed by
 * primordial_inflation_spectra().
 *
 * @param ppt   Input: pointer to perturbation structure
 * @param ppm   Input/output: pointer to primordial structure
 * @param ppr   Input: pointer to precision structure
 * @param y_ini Input: initial conditions for the vector of background/perturbations, already allocated and filled
 * @return the error status
 */

int primordial_inflation_analytic_spectra(
                                          struct perturbations * ppt,
                                          struct primordial * ppm,
                                          struct precision * ppr,
                                          double * y_ini
                                          ) {
  double * y;
  double * dy;
  int index_k;
  double k,phi_k;
  double curvature,tensors;
  double V,dV,ddV;

  /** Summary */
  /** - allocate vectors for background/perturbed quantities */
  class_alloc(y,ppm->in_size*sizeof(double),ppm->error_message);
  class_alloc(dy,ppm->in_size*sizeof(double),ppm->error_message);

  /** - initialize the background part of the running vector */
  y[ppm->index_in_a] = y_ini[ppm->index_in_a];
  y[ppm->index_in_phi] = y_ini[ppm->index_in_phi];
  if ((ppm->primordial_spec_type == inflation_V) || (ppm->primordial_spec_type == inflation_V_end))
    y[ppm->index_in_dphi] = y_ini[ppm->index_in_dphi];

  /** - loop over Fourier wavenumbers */
  for (index_k=0; index_k < ppm->lnk_size; index_k++) {

    k = exp(ppm->lnk[index_k]);

    /* evolve background until k=aH is reached */
    class_call(primordial_inflation_evolve_background(ppm,
                                                      ppr,
                                                      y,
                                                      dy,
                                                      _aH_,
                                                      k,
                                                      _FALSE_,
                                                      forward,
                                                      conformal),
               ppm->error_message,
               ppm->error_message);

    /** - read value of phi at time when k=aH */
    phi_k = y[ppm->index_in_phi];

    /** - get potential (and its derivatives) at this value */
    class_call(primordial_inflation_check_potential(ppm,phi_k,&V,&dV,&ddV),
               ppm->error_message,
               ppm->error_message);

    /** - calculate the analytic slow-roll formula for the spectra */
    curvature = 128.*_PI_/3.*pow(V,3)/pow(dV,2);
    tensors = pow(dV/V,2)/_PI_*128.*_PI_/3.*pow(V,3)/pow(dV,2);

    /** - store the obtained result for curvature and tensor perturbations */
    ppm->lnpk[ppt->index_md_scalars][index_k] = log(curvature);
    ppm->lnpk[ppt->index_md_tensors][index_k] = log(tensors);
  }

  ppm->is_non_zero[ppt->index_md_scalars][ppt->index_ic_ad] = _TRUE_;
  ppm->is_non_zero[ppt->index_md_tensors][ppt->index_ic_ten] = _TRUE_;

  return _SUCCESS_;
}

/**
 * Routine with a loop over wavenumbers for the computation of the primordial
 * spectrum. For each wavenumber it calls primordial_inflation_one_wavenumber()
 *
 * @param ppt   Input: pointer to perturbation structure
 * @param ppm   Input/output: pointer to primordial structure
 * @param ppr   Input: pointer to precision structure
 * @param y_ini Input: initial conditions for the vector of background/perturbations, already allocated and filled
 * @return the error status
 */

int primordial_inflation_spectra(
                                 struct perturbations * ppt,
                                 struct primordial * ppm,
                                 struct precision * ppr,
                                 double * y_ini
                                 ) {
  int index_k;

  class_setup_parallel();
  /* loop over Fourier wavenumbers */
  for (index_k=0; index_k < ppm->lnk_size; index_k++) {

    class_run_parallel(with_arguments(ppt,ppm,ppr,y_ini,index_k),

    class_call(primordial_inflation_one_wavenumber(ppt,ppm,ppr,y_ini,index_k),
               ppm->error_message,
               ppm->error_message);
    return _SUCCESS_;
    );
  }

  class_finish_parallel();

  ppm->is_non_zero[ppt->index_md_scalars][ppt->index_ic_ad] = _TRUE_;
  ppm->is_non_zero[ppt->index_md_tensors][ppt->index_ic_ten] = _TRUE_;

  return _SUCCESS_;

}

/**
 * Routine coordinating the computation of the primordial
 * spectrum for one wavenumber. It calls primordial_inflation_one_k() to
 * integrate the perturbation equations, and then it stores the result
 * for the scalar/tensor spectra.
 *
 * @param ppt     Input: pointer to perturbation structure
 * @param ppm     Input/output: pointer to primordial structure
 * @param ppr     Input: pointer to precision structure
 * @param y_ini   Input: initial conditions for the vector of background/perturbations, already allocated and filled
 * @param index_k Input: index of wavenumber to be considered
 * @return the error status
 */

int primordial_inflation_one_wavenumber(
                                        struct perturbations * ppt,
                                        struct primordial * ppm,
                                        struct precision * ppr,
                                        double * y_ini,
                                        int index_k
                                        ) {
  double k;
  double curvature,tensors;
  double * y;
  double * dy;

  k = exp(ppm->lnk[index_k]);

  /** Summary */
  /** - allocate vectors for background/perturbed quantities */
  class_alloc(y,ppm->in_size*sizeof(double),ppm->error_message);
  class_alloc(dy,ppm->in_size*sizeof(double),ppm->error_message);

  /** - initialize the background part of the running vector */
  y[ppm->index_in_a] = y_ini[ppm->index_in_a];
  y[ppm->index_in_phi] = y_ini[ppm->index_in_phi];
  if ((ppm->primordial_spec_type == inflation_V) || (ppm->primordial_spec_type == inflation_V_end))
    y[ppm->index_in_dphi] = y_ini[ppm->index_in_dphi];

  /** - evolve the background until the relevant initial time for
      integrating perturbations */
  class_call(primordial_inflation_evolve_background(ppm,
                                                    ppr,
                                                    y,
                                                    dy,
                                                    _aH_,
                                                    k/ppr->primordial_inflation_ratio_min,
                                                    _FALSE_,
                                                    forward,
                                                    conformal),
             ppm->error_message,
             ppm->error_message);

  /** - evolve the background/perturbation equations from this time and
      until some time after Horizon crossing */
  class_call(primordial_inflation_one_k(ppm,
                                        ppr,
                                        k,
                                        y,
                                        dy,
                                        &curvature,
                                        &tensors),
             ppm->error_message,
             ppm->error_message);

  free(y);
  free(dy);

  class_test(curvature<=0.,
             ppm->error_message,
             "negative curvature spectrum");

  class_test(tensors<=0.,
             ppm->error_message,
             "negative tensor spectrum");

  /** - store the obtained result for curvature and tensor perturbations */
  ppm->lnpk[ppt->index_md_scalars][index_k] = log(curvature);
  ppm->lnpk[ppt->index_md_tensors][index_k] = log(tensors);

  /* uncomment if you want to print here the spectra for testing */
  /* fprintf(stderr,"%e %e %e\n", */
  /* 	    ppm->lnk[index_k], */
  /* 	    ppm->lnpk[ppt->index_md_scalars][index_k], */
  /* 	    ppm->lnpk[ppt->index_md_tensors][index_k]); */

  return _SUCCESS_;
}

/**
 * Routine integrating the background plus perturbation equations for
 * each wavenumber, and returning the scalar and tensor spectrum.
 *
 * @param ppm   Input: pointer to primordial structure
 * @param ppr   Input: pointer to precision structure
 * @param k     Input: Fourier wavenumber
 * @param y     Input: running vector of background/perturbations, already allocated and initialized
 * @param dy    Input: running vector of background/perturbation derivatives, already allocated
 * @param curvature  Output: curvature perturbation
 * @param tensor     Output: tensor perturbation
 * @return the error status
 */

int primordial_inflation_one_k(
                               struct primordial * ppm,
                               struct precision * ppr,
                               double k,
                               double * y,
                               double * dy,
                               double * curvature,
                               double * tensor
                               ) {

  /** Summary: */

  /** - define local variables */
  double tau_start,tau_end,dtau;
  double z,ksi2,ah2;
  double aH;
  double curvature_old;
  double curvature_new;
  double dlnPdN;

  struct primordial_inflation_parameters_and_workspace pipaw;
  struct generic_integrator_workspace gi;

  /** - initialize the generic integrator (same integrator already used
      in background, thermodynamics and perturbation modules) */

  pipaw.ppm = ppm;
  pipaw.N = ppm->in_size;
  pipaw.integrate = forward;
  pipaw.time = conformal;
  pipaw.k = k;

  class_call(initialize_generic_integrator(pipaw.N,&gi),
             gi.error_message,
             ppm->error_message);

  /* initial conditions for the perturbations, Bunch-Davies vacuum */
  y[ppm->index_in_ksi_re]=1./sqrt(2.*k);
  y[ppm->index_in_ksi_im]=0.;
  y[ppm->index_in_dksi_re]=0.;
  y[ppm->index_in_dksi_im]=-k*y[ppm->index_in_ksi_re];

  y[ppm->index_in_ah_re]=1./sqrt(2.*k);
  y[ppm->index_in_ah_im]=0.;
  y[ppm->index_in_dah_re]=0.;
  y[ppm->index_in_dah_im]=-k*y[ppm->index_in_ah_re];

  /** - initialize variable used for deciding when to stop the calculation (= when the curvature remains stable) */
  curvature_new = _HUGE_;

  /** - initialize conformal time to arbitrary value (here, only variations
      of tau matter: the equations that we integrate do not depend
      explicitly on time) */
  tau_end = 0;

  /** - compute derivative of initial vector and infer first value of adaptive time-step */
  class_call(primordial_inflation_derivs(tau_end,
                                         y,
                                         dy,
                                         &pipaw,
                                         ppm->error_message),
             ppm->error_message,
             ppm->error_message);

  dtau = ppr->primordial_inflation_pt_stepsize*2.*_PI_
    /MAX(sqrt(fabs(dy[ppm->index_in_dksi_re]/y[ppm->index_in_ksi_re])),k);

  /** - loop over time */
  do {

    /*  new time interval [tau_start, tau_end] over which equations will be integrated */
    tau_start = tau_end;

    tau_end = tau_start + dtau;

    class_test(dtau/tau_start < ppr->smallest_allowed_variation,
               ppm->error_message,
               "integration step: relative change in time =%e < machine precision : leads either to numerical error or infinite loop",dtau/tau_start);

    /* evolve the system */
    class_call(generic_integrator(primordial_inflation_derivs,
                                  tau_start,
                                  tau_end,
                                  y,
                                  &pipaw,
                                  ppr->primordial_inflation_tol_integration,
                                  ppr->smallest_allowed_variation,
                                  &gi),
               gi.error_message,
               ppm->error_message);

    /* compute derivatives at tau_end, useful to infer new time step and spectra */
    class_call(primordial_inflation_derivs(tau_end,
                                           y,
                                           dy,
                                           &pipaw,
                                           ppm->error_message),
               ppm->error_message,
               ppm->error_message);

    /* new time step */
    dtau = ppr->primordial_inflation_pt_stepsize*2.*_PI_
      /MAX(sqrt(fabs(dy[ppm->index_in_dksi_re]/y[ppm->index_in_ksi_re])),k);

    /* new aH */
    aH = dy[ppm->index_in_a]/y[ppm->index_in_a];

    /* store previous value of curvature (at tau_start) */
    curvature_old =  curvature_new;

    /* new curvature */
    z = y[ppm->index_in_a]*dy[ppm->index_in_phi]/aH;
    ksi2 = y[ppm->index_in_ksi_re]*y[ppm->index_in_ksi_re]+y[ppm->index_in_ksi_im]*y[ppm->index_in_ksi_im];
    curvature_new = k*k*k/2./_PI_/_PI_*ksi2/z/z;

    /* variation of curvature with time (dimensionless) */
    dlnPdN = (curvature_new-curvature_old)/dtau*y[ppm->index_in_a]/dy[ppm->index_in_a]/curvature_new;

    /* stop when (k >> aH) AND curvature is stable */
  } while ((k/aH >= ppr->primordial_inflation_ratio_max) || (fabs(dlnPdN) > ppr->primordial_inflation_tol_curvature));

  /** - clean the generic integrator */
  class_call(cleanup_generic_integrator(&gi),
             gi.error_message,
             ppm->error_message);

  /** - store final value of curvature for this wavenumber */
  *curvature = curvature_new;

  /** - store final value of tensor perturbation for this wavenumber */
  ah2 = y[ppm->index_in_ah_re]*y[ppm->index_in_ah_re]+y[ppm->index_in_ah_im]*y[ppm->index_in_ah_im];
  *tensor = 32.*k*k*k/_PI_*ah2/y[ppm->index_in_a]/y[ppm->index_in_a];

  //fprintf(stdout,"%g %g %g %g %g\n",k,*curvature,*tensor,*tensor/(*curvature),dlnPdN);

  return _SUCCESS_;
}

/**
 * Routine searching for the inflationary attractor solution at a
 * given phi_0, by iterations, with a given tolerance. If no solution
 * found within tolerance, returns error message. The principle is the
 * following. The code starts integrating the background equations
 * from various values of phi, corresponding to earlier and earlier
 * value before phi_0, and separated by a small arbitrary step size,
 * corresponding roughly to 1 e-fold of inflation. Each time, the
 * integration starts with the initial condition \f$ \phi=-V'/3H\f$ (slow-roll
 * prediction). If the found value of \f$\phi'\f$ in phi_0 is stable (up to
 * the parameter "precision"), the code considers that there is an
 * attractor, and stops iterating. If this process does not converge,
 * it returns an error message.
 *
 * @param ppm       Input: pointer to primordial structure
 * @param ppr       Input: pointer to precision structure
 * @param phi_0     Input: field value at which we wish to find the solution
 * @param precision Input: tolerance on output values (if too large, an attractor will always considered to be found)
 * @param y         Input: running vector of background variables, already allocated and initialized
 * @param dy        Input: running vector of background derivatives, already allocated
 * @param H_0       Output: Hubble value at phi_0 for attractor solution
 * @param dphidt_0  Output: field derivative value at phi_0 for attractor solution
 * @return the error status
 */

int primordial_inflation_find_attractor(
                                        struct primordial * ppm,
                                        struct precision * ppr,
                                        double phi_0,
                                        double precision,
                                        double * y,
                                        double * dy,
                                        double * H_0,
                                        double * dphidt_0
                                        ) {

  double V_0,dV_0,ddV_0;
  double V=0.,dV=0.,ddV=0.;
  double a;
  double dphidt,dphidt_0new,dphidt_0old,phi;
  int counter;

  /* we want a series of value of phi' in phi_0, obtained by
     integrating the system from earlier and earlier time. The first
     value iof the series is the slow-roll prediction phi' =
     -V'/3H. The following lines compute this value and initialize relevant quantities. */

  class_call(primordial_inflation_check_potential(ppm,phi_0,&V_0,&dV_0,&ddV_0),
             ppm->error_message,
             ppm->error_message);

  dphidt_0new = -dV_0/3./sqrt((8.*_PI_/3.)*V_0);
  phi = phi_0;
  counter = 0;

  dphidt_0old = dphidt_0new/(precision+2.); // this silly value just
                                            // ensures that the loop
                                            // below will be executed
                                            // at least once.

  /* loop over different values of phi, from which the background
     equations are integrated until phi_0 */

  while (fabs(dphidt_0new/dphidt_0old-1.) >= precision) {

    counter ++;
    class_test(counter >= ppr->primordial_inflation_attractor_maxit,
               ppm->error_message,
               "could not converge after %d iterations: there exists no attractor solution near phi=%g. Potential probably too steep in this region, or precision parameter primordial_inflation_attractor_precision=%g too small",
               counter,
               phi_0,
               precision);

    dphidt_0old = dphidt_0new;

    /* take one step in phi, corresponding roughly to adding one more
       e-fold of inflation */

    phi=phi+dV_0/V_0/16./_PI_;

    /* fix the initial phi' to the slow-roll prediction in that point,
       and initialize other relevant quantities */

    class_call(primordial_inflation_check_potential(ppm,phi,&V,&dV,&ddV),
               ppm->error_message,
               ppm->error_message);

    a = 1.;
    dphidt = -dV/3./sqrt((8.*_PI_/3.)*V);
    y[ppm->index_in_a]=a;
    y[ppm->index_in_phi]=phi;
    y[ppm->index_in_dphi]=a*dphidt;

    /* evolve the background equations until phi_0 is reached */

    class_call(primordial_inflation_evolve_background(ppm,
                                                      ppr,
                                                      y,
                                                      dy,
                                                      _phi_,
                                                      phi_0,
                                                      _TRUE_,
                                                      forward,
                                                      conformal),
               ppm->error_message,
               ppm->error_message);

    /* compute phi' in phi_0, this is the new point in the series
       which convergence we want to check */

    dphidt_0new = y[ppm->index_in_dphi]/y[ppm->index_in_a];

  }

  /* if we have converged and found the attractor, we take the last
     value of phi' in phi_0 to be the correct one for the attractor
     solution */

  *dphidt_0 = dphidt_0new;
  *H_0 = sqrt((8.*_PI_/3.)*(0.5*dphidt_0new*dphidt_0new+V_0));

  if (ppm->primordial_verbose > 1) {
    printf(" (attractor found in phi=%g with phi'=%g, H=%g)\n",phi_0,*dphidt_0,*H_0);
  }

  return _SUCCESS_;
}

/**
 * Routine integrating background equations only, from initial values
 * stored in y, to a final value (if target = _aH_, until aH =
 * aH_stop; if target = _phi_, till phi = phi_stop; if target =
 * _end_inflation_, until \f$ d^2a/dt^2 = 0\f$ (here t = proper time)). In
 * output, y contains the final background values. In addition, if
 * check_epsilon is true, the routine controls at each step that the
 * expansion is accelerated and that inflation holds (wepsilon>1),
 * otherwise it returns an error. Thanks to the last argument, it is
 * also possible to specify whether the integration should be carried
 * forward or backward in time. For the inflation_H case, only a 1st
 * order differential equation is involved, so the forward and
 * backward case can be done exactly without problems. For the
 * inflation_V case, the equation of motion is 2nd order. What the
 * module will do in the backward case is to search for an approximate
 * solution, corresponding to the (first-order) attractor inflationary
 * solution. This approximate backward solution is used in order to
 * estimate some initial times, but the approximation made here will
 * never impact the final result: the module is written in such a way
 * that after using this approximation, the code always computes (and
 * relies on) the exact forward solution.
 *
 * @param ppm           Input: pointer to primordial structure
 * @param ppr           Input: pointer to precision structure
 * @param y             Input/output: running vector of background variables, already allocated and initialized
 * @param dy            Input: running vector of background derivatives, already allocated
 * @param target        Input: whether the goal is to reach a given aH or \f$ \phi \f$
 * @param stop          Input: the target value of either aH or \f$ \phi \f$
 * @param check_epsilon Input: whether we should impose inflation (epsilon>1) at each step
 * @param direction     Input: whether we should integrate forward or backward in time
 * @param time          Input: definition of time (proper or conformal)
 * @return the error status
 */

int primordial_inflation_evolve_background(
                                           struct primordial * ppm,
                                           struct precision * ppr,
                                           double * y,
                                           double * dy,
                                           enum target_quantity target,
                                           double stop,
                                           short check_epsilon,
                                           enum integration_direction direction,
                                           enum time_definition time
                                           ) {

  struct primordial_inflation_parameters_and_workspace pipaw;
  struct generic_integrator_workspace gi;
  double tau_start,tau_end,dtau=0.;
  double H,dH,ddH,dddH;
  double epsilon,epsilon_old;
  double quantity=0.;
  double V,dV,ddV;
  double sign_dtau=0.;

  pipaw.ppm = ppm;

  pipaw.N = ppm->in_bg_size;

  if ((direction == backward) && ((ppm->primordial_spec_type == inflation_V) || (ppm->primordial_spec_type == inflation_V_end))) {
    // -1 to remove the differential equation for phi', since we stick to the attractor
    pipaw.N -= 1;
  }

  pipaw.integrate = direction;
  pipaw.time = time;

  switch (direction) {
  case forward:
    sign_dtau = 1.;
    break;
  case backward:
    sign_dtau = -1.;
    break;
  }

  class_call(initialize_generic_integrator(pipaw.N,&gi),
             gi.error_message,
             ppm->error_message);

  /* at starting point, compute eventually epsilon */

  if (check_epsilon == _TRUE_) {

    class_call(primordial_inflation_get_epsilon(ppm,
                                                y[ppm->index_in_phi],
                                                &epsilon),
               ppm->error_message,
               ppm->error_message);
  }

  /* at starting point, compute the stepsize dtau */

  tau_end = 0;

  class_call(primordial_inflation_derivs(tau_end,
                                         y,
                                         dy,
                                         &pipaw,
                                         ppm->error_message),
             ppm->error_message,
             ppm->error_message);

  // compute timestep (if time = conformal, dtau is the conformal time step,
  // if time = proper, dtau is in fact dt, the proper time step)
  if ((direction == forward) && ((ppm->primordial_spec_type == inflation_V) || (ppm->primordial_spec_type == inflation_V_end))) {
    dtau = ppr->primordial_inflation_bg_stepsize
      *MIN(y[ppm->index_in_a]/dy[ppm->index_in_a],fabs(y[ppm->index_in_dphi]/dy[ppm->index_in_dphi]));
  }
  else {
    // minus sign for backward in time
    dtau = sign_dtau * ppr->primordial_inflation_bg_stepsize*y[ppm->index_in_a]/dy[ppm->index_in_a];
  }

  /* expected value of target quantity after the next step */
  switch (target) {
  case _aH_:
    // next (approximate) value of aH after next step
    // (a+[da/dx]*dx) H = aH (1 + [da/dx] / a dx)
    // where dtau can be conformal or proper time
    quantity = dy[ppm->index_in_a] * (1.+ dy[ppm->index_in_a]/y[ppm->index_in_a] * dtau);
    if (time == conformal) quantity /= y[ppm->index_in_a];
    break;
  case _phi_:
    // next (approximate) value of phi after next step
    quantity = y[ppm->index_in_phi]+dy[ppm->index_in_phi]*dtau;
    break;
  case _end_inflation_:
    // in this case, the goal is to reach d2a/dt2 = 0 (end of accelerated expansion)
    stop = 0.;
    // current value of quantity = - d2a/dt2 /a = [- (a'/a)^2 + 3/2 8pi/3 phi'^2]/a^2
    quantity = -pow(dy[ppm->index_in_a]/y[ppm->index_in_a],2) + 4*_PI_ *  y[ppm->index_in_dphi] * y[ppm->index_in_dphi];
    if (time == conformal) quantity /= pow(y[ppm->index_in_a],2);

    // check that we are in the right case
    class_test(ppm->primordial_spec_type != inflation_V_end,
               ppm->error_message,
               "the target _end_inflation_ is only coded to work with inflation_V_end (but could be generalized if needed)");
    break;
  case _a_:
    // next (approximate) value of a after next step
    quantity = y[ppm->index_in_a]+dy[ppm->index_in_a]*dtau;
    break;
  }

  /* loop over time steps, checking that there will be no overshooting */

  while (sign_dtau*(quantity - stop) < 0.) {

    /* check that V(phi) or H(phi) do not take forbidden values
       (negative or positive derivative) */

    if ((ppm->primordial_spec_type == inflation_V) || (ppm->primordial_spec_type == inflation_V_end)) {
      class_call(primordial_inflation_check_potential(ppm,
                                                      y[ppm->index_in_phi],
                                                      &V,
                                                      &dV,
                                                      &ddV),
                 ppm->error_message,
                 ppm->error_message);
    }
    else {
      class_call(primordial_inflation_check_hubble(ppm,
                                                   y[ppm->index_in_phi],
                                                   &H,
                                                   &dH,
                                                   &ddH,
                                                   &dddH),
                 ppm->error_message,
                 ppm->error_message);
    }

    /* take one time step */

    tau_start = tau_end;

    tau_end = tau_start + dtau;

    // mind the fabs(...) below (works for both forward and backward integration)
    class_test(fabs(dtau/tau_start) < ppr->smallest_allowed_variation,
               ppm->error_message,
               "integration step: relative change in time =%e < machine precision : leads either to numerical error or infinite loop",dtau/tau_start);

    class_call(generic_integrator(primordial_inflation_derivs,
                                  tau_start,
                                  tau_end,
                                  y,
                                  &pipaw,
                                  ppr->primordial_inflation_tol_integration,
                                  ppr->smallest_allowed_variation,
                                  &gi),
               gi.error_message,
               ppm->error_message);

    /* eventually, check that epsilon is not becoming greater than one */

    if (check_epsilon == _TRUE_) {

      epsilon_old = epsilon;

      class_call_except(primordial_inflation_get_epsilon(ppm,
                                                         y[ppm->index_in_phi],
                                                         &epsilon),
                        ppm->error_message,
                        ppm->error_message,
                        cleanup_generic_integrator(&gi));

      class_test_except((epsilon > 1) && (epsilon_old <= 1),
                        ppm->error_message,
                        cleanup_generic_integrator(&gi),
                        "Inflaton evolution crosses the border from epsilon<1 to epsilon>1 at phi=%g. Inflation disrupted during the observable e-folds",
                        y[ppm->index_in_phi]);
    }

    /* recompute new value of next conformal time step */

    class_call(primordial_inflation_derivs(tau_end,
                                           y,
                                           dy,
                                           &pipaw,
                                           ppm->error_message),
               ppm->error_message,
               ppm->error_message);

    // compute timestep (if time = conformal, dtau is the conformal time step,
    // if time = proper, dtau is in fact dt, the proper time step)
    if ((direction == forward) && ((ppm->primordial_spec_type == inflation_V) || (ppm->primordial_spec_type == inflation_V_end))) {
      dtau = ppr->primordial_inflation_bg_stepsize
        *MIN(y[ppm->index_in_a]/dy[ppm->index_in_a],fabs(y[ppm->index_in_dphi]/dy[ppm->index_in_dphi]));
    }
    else {
      // minus sign for backward in time
      dtau = sign_dtau * ppr->primordial_inflation_bg_stepsize*y[ppm->index_in_a]/dy[ppm->index_in_a];
    }

    /* expected value of target quantity after the next step */

    switch (target) {
    case _aH_:
      // next (approximate) value of aH after next step
      // (a+[da/dx]*dx) H = aH (1 + [da/dx] / a dx)
      // where dtau can be conformal or proper time
      quantity = dy[ppm->index_in_a] * (1.+ dy[ppm->index_in_a]/y[ppm->index_in_a] * dtau);
      if (time == conformal) quantity /= y[ppm->index_in_a];
      break;
    case _phi_:
      // next (approximate) value of phi after next step
      quantity = y[ppm->index_in_phi]+dy[ppm->index_in_phi]*dtau;
      break;
    case _end_inflation_:
      // current value of quantity = - d2a/dt2 /a = [- (a'/a)^2 + 3/2 8pi/3 phi'^2]/a^2
      quantity = -pow(dy[ppm->index_in_a]/y[ppm->index_in_a],2) + 4*_PI_ *  y[ppm->index_in_dphi] * y[ppm->index_in_dphi];
      if (time == conformal) quantity /= pow(y[ppm->index_in_a],2);
      break;
    case _a_:
      // next (approximate) value of a after next step
      quantity = y[ppm->index_in_a]+dy[ppm->index_in_a]*dtau;
      break;
    }

  }

  /* won't use the integrator anymore */

  class_call(cleanup_generic_integrator(&gi),
             gi.error_message,
             ppm->error_message);

  /* Perform one last step with a simple trapezoidal integral. This
     will bring exactly phi or a forward to phi_stop or a_stop, or
     approximately aH forward to aH_stop, or approximately [-d2a/dt2
     /a] backward to zero. */

  switch (target) {
  case _aH_:
    switch (time){
    case proper:
      dtau = (stop/dy[ppm->index_in_a]-1.)/dy[ppm->index_in_a];
      break;
    case conformal:
      dtau = (stop/(dy[ppm->index_in_a]/y[ppm->index_in_a])-1.)/(dy[ppm->index_in_a]/y[ppm->index_in_a]);
      break;
    }
    break;
  case _phi_:
    dtau = (stop-y[ppm->index_in_phi])/dy[ppm->index_in_phi];
    break;
  case _end_inflation_:
    class_call(primordial_inflation_check_potential(ppm,y[ppm->index_in_phi],&V,&dV,&ddV),
               ppm->error_message,
               ppm->error_message);
    // We can easily pull back quantity=-d2a/dt2 /a by noticing that
    // d(quantity)/dtau = 8piG phi' phi'' / a^2 (exact relation!)
    // or
    // d(quantity)/dtau = 8piG phi^dot (a phi^dot)^dot = 8piG phi^dot (a^dot phi^dot+ a phi^dotdot)
    // By taking the step dtau = - quantity / [d(quantity)/dtau] we nearly reach quantity=0 (end of inflation), up to very good approximation
    switch (time){
    case proper:
      dtau = -quantity/(8.*_PI_*dy[ppm->index_in_phi]*(dy[ppm->index_in_a]*dy[ppm->index_in_phi]+y[ppm->index_in_a]*dy[ppm->index_in_dphi]));

      break;
    case conformal:
      dtau = -quantity/(8.*_PI_/y[ppm->index_in_a]/y[ppm->index_in_a]*dy[ppm->index_in_phi]*dy[ppm->index_in_dphi]);
      break;
    }
    break;
  case _a_:
    dtau = (stop-y[ppm->index_in_a])/dy[ppm->index_in_a];
    break;
  }

  y[ppm->index_in_a] += dy[ppm->index_in_a]*dtau;
  y[ppm->index_in_phi] += dy[ppm->index_in_phi]*dtau;
  if ((direction == forward) && ((ppm->primordial_spec_type == inflation_V)||(ppm->primordial_spec_type == inflation_V_end)))
    y[ppm->index_in_dphi] += dy[ppm->index_in_dphi]*dtau;

  // this last step updates also the dy[]
  class_call(primordial_inflation_derivs(tau_end,
                                         y,
                                         dy,
                                         &pipaw,
                                         ppm->error_message),
             ppm->error_message,
             ppm->error_message);

  // uncomment if you want to test that the routine really reached the point at which d2a/dt2=0
  /*
    if (target == _end_inflation_) {
    class_call(primordial_inflation_derivs(tau_end,
    y,
    dy,
    &pipaw,
    ppm->error_message),
    ppm->error_message,
    ppm->error_message);

    aH = dy[ppm->index_in_a]/y[ppm->index_in_a];
    quantity = (-aH*aH + 4*_PI_ *  y[ppm->index_in_dphi] * y[ppm->index_in_dphi])/y[ppm->index_in_a]/y[ppm->index_in_a];
    if (ppm->primordial_verbose>1)
    printf(" (-d2a/dt2 /a = %e)\n",quantity);
    }
  */

  return _SUCCESS_;
}

/**
 * Routine checking positivity and negative slope of potential. The
 * negative slope is an arbitrary choice. Currently the code can only
 * deal with monotonic variations of the inflaton during inflation. So
 * the slope had to be always negative or always positive... we took
 * the first option.
 *
 * @param ppm       Input: pointer to primordial structure
 * @param phi       Input: field value where to perform the check
 * @param V              Output: inflaton potential in units of \f$ Mp^4\f$
 * @param dV             Output: first derivative of inflaton potential wrt the field
 * @param ddV            Output: second derivative of inflaton potential wrt the field
 * @return the error status
 */

int primordial_inflation_check_potential(
                                         struct primordial * ppm,
                                         double phi,
                                         double * V,
                                         double * dV,
                                         double * ddV
                                         ) {

  class_call(primordial_inflation_potential(ppm,phi,V,dV,ddV),
             ppm->error_message,
             ppm->error_message);

  class_test(*V <= 0.,
             ppm->error_message,
             "This potential becomes negative at phi=%g, before the end of observable inflation. It  cannot be treated by this code",
             phi);

  class_test(*dV >= 0.,
             ppm->error_message,
             "All the code is written for the case dV/dphi<0. Here, in phi=%g, we have dV/dphi=%g. This potential cannot be treated by this code",
             phi,*dV);

  return _SUCCESS_;
}

/**
 * Routine checking positivity and negative slope of \f$ H(\phi)\f$. The
 * negative slope is an arbitrary choice. Currently the code can only
 * deal with monotonic variations of the inflaton during
 * inflation. And H can only decrease with time. So the slope \f$ dH/d\phi\f$
 * has to be always negative or always positive... we took the first
 * option: phi increases, H decreases.
 *
 * @param ppm       Input: pointer to primordial structure
 * @param phi       Input: field value where to perform the check
 * @param H         Output: Hubble parameters in units of Mp
 * @param dH        Output: \f$ dH / d\phi \f$
 * @param ddH       Output: \f$ d^2H / d\phi^2 \f$
 * @param dddH      Output: \f$ d^3H / d\phi^3 \f$
 * @return the error status
 */

int primordial_inflation_check_hubble(
                                      struct primordial * ppm,
                                      double phi,
                                      double * H,
                                      double * dH,
                                      double * ddH,
                                      double * dddH
                                      ) {

  class_call(primordial_inflation_hubble(ppm,
                                         phi,
                                         H,dH,ddH,dddH),
             ppm->error_message,
             ppm->error_message);

  class_test(*H < 0.,
             ppm->error_message,
             "this H(phi) is not physical. H = %e",
             *H);

  class_test(*dH > 0.,
             ppm->error_message,
             "this H(phi) is not decreasing with growing phi. dH/dphi = %e",
             *dH);

  return _SUCCESS_;

}

/**
 * Routine computing the first slow-roll parameter epsilon
 *
 * @param ppm       Input: pointer to primordial structure
 * @param phi       Input: field value where to compute epsilon
 * @param epsilon   Output: result
 * @return the error status
 */

int primordial_inflation_get_epsilon(
                                     struct primordial * ppm,
                                     double phi,
                                     double * epsilon
                                     ) {

  double V,dV,ddV;
  double H,dH,ddH,dddH;

  switch (ppm->primordial_spec_type) {

  case inflation_V:
  case inflation_V_end:

    class_call(primordial_inflation_potential(ppm,
                                              phi,
                                              &V,&dV,&ddV),
               ppm->error_message,
               ppm->error_message);

    *epsilon = 1./16./_PI_*pow(dV/V,2);
    //*eta = 1./8./pi*(ddV/V)
    break;

  case inflation_H:

    class_call(primordial_inflation_hubble(ppm,
                                           phi,
                                           &H,&dH,&ddH,&dddH),
               ppm->error_message,
               ppm->error_message);

    *epsilon = 1./4./_PI_*pow(dH/H,2);
    break;

  default:
    class_stop(ppm->error_message,"ppm->primordial_spec_type=%d different from possible relevant cases",ppm->primordial_spec_type);
    break;
  }

  return _SUCCESS_;
}

/**
 * Routine searching phi_pivot when a given amount of inflation is requested.
 *
 * @param ppm       Input/output: pointer to primordial structure
 * @param ppr       Input: pointer to precision structure
 * @param y         Input: running vector of background variables, already allocated and initialized
 * @param dy        Input: running vector of background derivatives, already allocated
 * @return the error status
 */

int primordial_inflation_find_phi_pivot(
                                        struct primordial * ppm,
                                        struct precision * ppr,
                                        double * y,
                                        double * dy
                                        ) {
  /** Summary: */

  /** - define local variables */
  double epsilon,dphi;
  double phi_try,H_try,dphidt_try,ratio_try=0.;
  double phi_left,phi_right,phi_mid;
  double phi_small_epsilon,phi_stop;
  double dphidt_small_epsilon;
  double H_small_epsilon;
  double aH_ratio_after_small_epsilon=0.;
  double a_ratio_after_small_epsilon=0.;
  double target=0.;
  double a_pivot,aH_pivot;

  double rho_end;
  double h;
  double H0;
  double rho_c0;
  double sigma_B;
  double Omega_g0;
  double Omega_r0;

  /** - check whether in vicinity of phi_end, inflation is still ongoing */

  class_call(primordial_inflation_get_epsilon(ppm,ppm->phi_end-ppr->primordial_inflation_end_dphi,&epsilon),
             ppm->error_message,
             ppm->error_message);

  /** - case in which epsilon>1: hence we must find the value phi_stop <
      phi_end where inflation ends up naturally */

  if (epsilon > 1.) {

    // assume that inflation ends up naturally

    /** - --> find latest value of the field such that epsilon = primordial_inflation_small_epsilon (default: 0.1) */

    /** - --> bracketing right-hand value is phi_end (but the potential will not be evaluated exactly there, only closeby */
    phi_right = ppm->phi_end;

    /** - --> bracketing left-hand value is found by iterating with logarithmic step until epsilon < primordial_inflation_small_epsilon */
    dphi = ppr->primordial_inflation_end_dphi;
    do {
      dphi *= ppr->primordial_inflation_end_logstep;
      class_call(primordial_inflation_get_epsilon(ppm,ppm->phi_end-dphi,&epsilon),
                 ppm->error_message,
                 ppm->error_message);
    } while (epsilon > ppr->primordial_inflation_small_epsilon);
    phi_left = ppm->phi_end-dphi;

    /** - --> find value such that epsilon = primordial_inflation_small_epsilon by bisection */
    do {
      phi_mid = 0.5*(phi_left+phi_right);
      class_call(primordial_inflation_get_epsilon(ppm,phi_mid,&epsilon),
                 ppm->error_message,
                 ppm->error_message);
      if (epsilon < ppr->primordial_inflation_small_epsilon) phi_left=phi_mid;
      else phi_right=phi_mid;
    } while (fabs(epsilon-ppr->primordial_inflation_small_epsilon) > ppr->primordial_inflation_small_epsilon_tol);

    /** - --> value found and stored as phi_small_epsilon */
    phi_small_epsilon = phi_mid;

    /** - --> find inflationary attractor in phi_small_epsilon (should exist since epsilon<<1 there) */
    class_call(primordial_inflation_find_attractor(ppm,
                                                   ppr,
                                                   phi_small_epsilon,
                                                   ppr->primordial_inflation_attractor_precision_initial,
                                                   y,
                                                   dy,
                                                   &H_small_epsilon,
                                                   &dphidt_small_epsilon),
               ppm->error_message,
               ppm->error_message);

    /** - --> compute amount of inflation between this phi_small_epsilon and the end of inflation */
    y[ppm->index_in_a]=1.;
    y[ppm->index_in_phi]= phi_small_epsilon;
    y[ppm->index_in_dphi]=y[ppm->index_in_a]*dphidt_small_epsilon;

    class_call(primordial_inflation_evolve_background(ppm,
                                                      ppr,
                                                      y,
                                                      dy,
                                                      _end_inflation_,
                                                      0.,
                                                      _FALSE_,
                                                      forward,
                                                      conformal),
               ppm->error_message,
               ppm->error_message);

    // we have used here conformal time, so aH = dy[a]/y[a]
    aH_ratio_after_small_epsilon = dy[ppm->index_in_a]/y[ppm->index_in_a]/H_small_epsilon;
    a_ratio_after_small_epsilon = y[ppm->index_in_a];

    switch (ppm->phi_pivot_method) {

    case ln_aH_ratio_auto:

      /* get the target value of ln_aH_ratio */

      rho_end = 2./8./_PI_*pow(dy[ppm->index_in_a]/y[ppm->index_in_a],2);
      rho_end = 8*_PI_/3.*rho_end/(_G_*_h_P_/pow(_c_,3))*pow(_Mpc_over_m_,2);
      h = 0.7;
      H0 = h * 1.e5 / _c_;
      rho_c0 = pow(H0,2);

      sigma_B = 2. * pow(_PI_,5) * pow(_k_B_,4) / 15. / pow(_h_P_,3) / pow(_c_,2);
      Omega_g0 = (4.*sigma_B/_c_*pow(2.726,4.)) / (3.*_c_*_c_*1.e10*h*h/_Mpc_over_m_/_Mpc_over_m_/8./_PI_/_G_);
      Omega_r0 = 3.044*7./8.*pow(4./11.,4./3.)*Omega_g0;

      target = log(H0/0.05*pow(Omega_r0,0.5)*pow(2./100.,1./12.)*pow(rho_end/rho_c0,0.25));

      //fprintf(stderr,"auto: log(aH_end/aH_*)=%e\n",target);
      break;

    case ln_aH_ratio:

      target = ppm->phi_pivot_target;
      //fprintf(stderr,"fixed: log(aH_end/aH_*)=%e\n",target);
      break;

    case N_star:

      target = ppm->phi_pivot_target;
      //fprintf(stderr,"fixed: log(a_end/a_*)=%e\n",target);
      break;
    }

    /** - --> by starting from phi_small_epsilon and integrating an approximate
        solution backward in time, try to estimate roughly a value close
        to phi_pivot but a bit smaller. This is done by trying to reach
        an amount of inflation equal to the requested one, minus the
        amount after phi_small_epsilon, and plus
        primordial_inflation_extra_efolds efolds (default: two). Note
        that it is not aggressive to require two extra e-folds of
        inflation before the pivot, since the calculation of the spectrum
        in the observable range will require even more. */

    y[ppm->index_in_a]=1.;
    y[ppm->index_in_phi]= phi_small_epsilon;

    switch (ppm->phi_pivot_method) {

    case ln_aH_ratio_auto:
    case ln_aH_ratio:

      class_call(primordial_inflation_evolve_background(ppm,
                                                        ppr,
                                                        y,
                                                        dy,
                                                        _aH_,
                                                        H_small_epsilon/exp(target+ppr->primordial_inflation_extra_efolds)*aH_ratio_after_small_epsilon,
                                                        _TRUE_,
                                                        backward,
                                                        conformal),
                 ppm->error_message,
                 ppm->error_message);
      break;

    case N_star:

      class_call(primordial_inflation_evolve_background(ppm,
                                                        ppr,
                                                        y,
                                                        dy,
                                                        _a_,
                                                        1./exp(target+ppr->primordial_inflation_extra_efolds)*a_ratio_after_small_epsilon,
                                                        _TRUE_,
                                                        backward,
                                                        conformal),
                 ppm->error_message,
                 ppm->error_message);
      break;
    }

    /* we now have a value phi_try believed to be close to and slightly smaller than phi_pivot */

    phi_try = y[ppm->index_in_phi];

    /** - --> find attractor in phi_try */

    class_call(primordial_inflation_find_attractor(ppm,
                                                   ppr,
                                                   phi_try,
                                                   ppr->primordial_inflation_attractor_precision_initial,
                                                   y,
                                                   dy,
                                                   &H_try,
                                                   &dphidt_try),
               ppm->error_message,
               ppm->error_message);

    /** - --> check the total amount of inflation between phi_try and the end of inflation */

    y[ppm->index_in_a]=1.;
    y[ppm->index_in_phi]= phi_try;
    y[ppm->index_in_dphi]= dphidt_try;

    class_call(primordial_inflation_evolve_background(ppm,
                                                      ppr,
                                                      y,
                                                      dy,
                                                      _end_inflation_,
                                                      0.,
                                                      _FALSE_,
                                                      forward,
                                                      proper),
               ppm->error_message,
               ppm->error_message);

    switch (ppm->phi_pivot_method) {

    case ln_aH_ratio_auto:
    case ln_aH_ratio:

      // aH_ratio (we have used here proper time, so aH = dy[a])
      ratio_try = dy[ppm->index_in_a]/H_try;
      break;

    case N_star:

      // a_ratio
      ratio_try = y[ppm->index_in_a];
      break;
    }

    class_test(log(ratio_try) < target,
               ppm->error_message,
               "phi_try not small enough, log(aH_stop/aH_try) or log(a_stop/a_try) (depending on what you asked) is equal to %e instead of requested %e; must write here a loop to deal automatically with this situation (by decreasing phi_try iteratively), or must increase precision parameter primordial_inflation_extra_efolds",
               log(ratio_try),
               target);

    phi_stop = y[1];

    if (ppm->primordial_verbose > 1)
      printf(" (inflation stops in phi_stop = %e)\n",phi_stop);

    /** - --> go back to phi_try, and now find phi_pivot such that the amount
        of inflation between phi_pivot and the end of inflation is
        exactly the one requested. */
    y[ppm->index_in_a]=1.;
    y[ppm->index_in_phi]= phi_try;
    y[ppm->index_in_dphi]= dphidt_try;

    switch (ppm->phi_pivot_method) {

    case ln_aH_ratio_auto:
    case ln_aH_ratio:

      class_call(primordial_inflation_evolve_background(ppm,
                                                        ppr,
                                                        y,
                                                        dy,
                                                        _aH_,
                                                        H_try*ratio_try/exp(target),
                                                        _FALSE_,
                                                        forward,
                                                        proper),
                 ppm->error_message,
                 ppm->error_message);
      break;

    case N_star:

      class_call(primordial_inflation_evolve_background(ppm,
                                                        ppr,
                                                        y,
                                                        dy,
                                                        _a_,
                                                        ratio_try/exp(target),
                                                        _FALSE_,
                                                        forward,
                                                        proper),
                 ppm->error_message,
                 ppm->error_message);
      break;
    }

    ppm->phi_pivot = y[1];

    if (ppm->primordial_verbose > 1) {

      printf(" (reached phi_pivot=%e)\n",ppm->phi_pivot);

      /* - --> In verbose mode, check that phi_pivot is correct. Done by
         restarting from phi_pivot and going again till the end of
         inflation. */

      aH_pivot = dy[0];
      a_pivot = y[0];
      class_call(primordial_inflation_evolve_background(ppm,
                                                        ppr,
                                                        y,
                                                        dy,
                                                        _end_inflation_,
                                                        0.,
                                                        _FALSE_,
                                                        forward,
                                                        proper),
                 ppm->error_message,
                 ppm->error_message);
      printf(" (from phi_pivot till the end, ln(aH_2/aH_1) = %e, ln(a_2/a_1) = %e)\n",log(dy[0]/aH_pivot),log(y[0]/a_pivot));
    }


  }
  /** - case in which epsilon<1: */
  else {

    /** - --> find inflationary attractor in phi_small_epsilon (should exist since epsilon<1 there) */
    class_call(primordial_inflation_find_attractor(ppm,
                                                   ppr,
                                                   ppm->phi_end,
                                                   ppr->primordial_inflation_attractor_precision_initial,
                                                   y,
                                                   dy,
                                                   &H_small_epsilon,
                                                   &dphidt_small_epsilon),
               ppm->error_message,
               ppm->error_message);

    /** - --> by starting from phi_end and integrating an approximate
        solution backward in time, try to estimate roughly a value close
        to phi_pivot but a bit smaller. This is done by trying to reach
        an amount of inflation equal to the requested one, minus the
        amount after phi_small_epsilon, and plus
        primordial_inflation_extra_efolds efolds (default: two). Note
        that it is not aggressive to require two extra e-folds of
        inflation before the pivot, since the calculation of the spectrum
        in the observable range will require even more. */

    y[ppm->index_in_a]=1.;
    y[ppm->index_in_phi]= ppm->phi_end;

    switch (ppm->phi_pivot_method) {

    case ln_aH_ratio_auto:
    case ln_aH_ratio:

      class_call(primordial_inflation_evolve_background(ppm,
                                                        ppr,
                                                        y,
                                                        dy,
                                                        _aH_,
                                                        H_small_epsilon/exp(target+ppr->primordial_inflation_extra_efolds)*aH_ratio_after_small_epsilon,
                                                        _TRUE_,
                                                        backward,
                                                        conformal),
                 ppm->error_message,
                 ppm->error_message);
      break;

    case N_star:

      class_call(primordial_inflation_evolve_background(ppm,
                                                        ppr,
                                                        y,
                                                        dy,
                                                        _a_,
                                                        1./exp(target+ppr->primordial_inflation_extra_efolds)*a_ratio_after_small_epsilon,
                                                        _TRUE_,
                                                        backward,
                                                        conformal),
                 ppm->error_message,
                 ppm->error_message);
      break;
    }

    /** - --> we now have a value phi_try believed to be close to and slightly smaller than phi_pivot */

    phi_try = y[ppm->index_in_phi];

    /** - --> find attractor in phi_try */

    class_call(primordial_inflation_find_attractor(ppm,
                                                   ppr,
                                                   phi_try,
                                                   ppr->primordial_inflation_attractor_precision_initial,
                                                   y,
                                                   dy,
                                                   &H_try,
                                                   &dphidt_try),
               ppm->error_message,
               ppm->error_message);

    /** - --> check the total amount of inflation between phi_try and the end of inflation */

    y[ppm->index_in_a]=1.;
    y[ppm->index_in_phi]= phi_try;
    y[ppm->index_in_dphi]= dphidt_try;

    class_call(primordial_inflation_evolve_background(ppm,
                                                      ppr,
                                                      y,
                                                      dy,
                                                      _phi_,
                                                      ppm->phi_end,
                                                      _FALSE_,
                                                      forward,
                                                      proper),
               ppm->error_message,
               ppm->error_message);

    switch (ppm->phi_pivot_method) {

    case ln_aH_ratio_auto:
    case ln_aH_ratio:

      // aH_ratio (we have used here proper time, so aH = dy[a])
      ratio_try = dy[ppm->index_in_a]/H_try;
      break;

    case N_star:

      // a_ratio
      ratio_try = y[ppm->index_in_a];
      break;
    }

    class_test(log(ratio_try) < target,
               ppm->error_message,
               "phi_try not small enough, log(aH_stop/aH_try) or log(a_stop/a_try) (depending on what you asked) is equal to %e instead of requested %e; must write here a loop to deal automatically with this situation (by decreasing phi_try iteratively), or must increase precision parameter primordial_inflation_extra_efolds",
               log(ratio_try),
               target);

    phi_stop = y[1];

    if (ppm->primordial_verbose > 1)
      printf(" (inflation stops in phi_stop = %e)\n",phi_stop);

    /** - --> go back to phi_try, and now find phi_pivot such that the amount
        of inflation between phi_pivot and the end of inflation is
        exactly the one requested. */
    y[ppm->index_in_a]=1.;
    y[ppm->index_in_phi]= phi_try;
    y[ppm->index_in_dphi]= dphidt_try;

    switch (ppm->phi_pivot_method) {

    case ln_aH_ratio_auto:
    case ln_aH_ratio:

      class_call(primordial_inflation_evolve_background(ppm,
                                                        ppr,
                                                        y,
                                                        dy,
                                                        _aH_,
                                                        H_try*ratio_try/exp(target),
                                                        _FALSE_,
                                                        forward,
                                                        proper),
                 ppm->error_message,
                 ppm->error_message);
      break;

    case N_star:

      class_call(primordial_inflation_evolve_background(ppm,
                                                        ppr,
                                                        y,
                                                        dy,
                                                        _a_,
                                                        ratio_try/exp(target),
                                                        _FALSE_,
                                                        forward,
                                                        proper),
                 ppm->error_message,
                 ppm->error_message);
      break;
    }

    ppm->phi_pivot = y[1];

    if (ppm->primordial_verbose > 1) {

      printf(" (reached phi_pivot=%e)\n",ppm->phi_pivot);

      /** - --> In verbose mode, check that phi_pivot is correct. Done by
          restarting from phi_pivot and going again till the end of
          inflation. */

      aH_pivot = dy[0];
      a_pivot = y[0];
      class_call(primordial_inflation_evolve_background(ppm,
                                                        ppr,
                                                        y,
                                                        dy,
                                                        _phi_,
                                                        ppm->phi_end,
                                                        _FALSE_,
                                                        forward,
                                                        proper),
                 ppm->error_message,
                 ppm->error_message);
      printf(" (from phi_pivot till the end, ln(aH_2/aH_1) = %e, ln(a_2/a_1) = %e)\n",log(dy[0]/aH_pivot),log(y[0]/a_pivot));
    }

  }

  return _SUCCESS_;
}

/**
 * Routine returning derivative of system of background/perturbation
 * variables. Like other routines used by the generic integrator
 * (background_derivs, thermodynamics_derivs, perturbations_derivs), this
 * routine has a generic list of arguments, and a slightly different
 * error management, with the error message returned directly in an
 * ErrMsg field.
 *
 * @param tau                      Input: time (not used explicitly inside the routine, but requested by the generic integrator)
 * @param y                        Input/output: running vector of background variables, already allocated and initialized
 * @param dy                       Input: running vector of background derivatives, already allocated
 * @param parameters_and_workspace Input: all necessary input variables apart from y
 * @param error_message            Output: error message
 * @return the error status
 */

int primordial_inflation_derivs(
                                double tau,
                                double * y,
                                double * dy,
                                void * parameters_and_workspace,
                                ErrorMsg error_message
                                ) {

  struct primordial_inflation_parameters_and_workspace * ppipaw;
  struct primordial * ppm;

  ppipaw = (struct primordial_inflation_parameters_and_workspace *)parameters_and_workspace;
  ppm = ppipaw->ppm;

  // a2
  ppipaw->a2=y[ppm->index_in_a]*y[ppm->index_in_a];

  // BACKGROUND

  switch (ppm->primordial_spec_type) {

  case inflation_V:
  case inflation_V_end:

    class_call(primordial_inflation_potential(ppm,
                                              y[ppm->index_in_phi],
                                              &(ppipaw->V),
                                              &(ppipaw->dV),
                                              &(ppipaw->ddV)),
               ppm->error_message,
               ppm->error_message);

    switch (ppipaw->integrate) {

    case forward:

      switch (ppipaw->time) {

      case conformal:

        // a H = a'/a
        ppipaw->aH = sqrt((8*_PI_/3.)*(0.5*y[ppm->index_in_dphi]*y[ppm->index_in_dphi]+ppipaw->a2*ppipaw->V));
        // 1: a
        dy[ppm->index_in_a]=y[ppm->index_in_a]*ppipaw->aH;
        // 2: phi
        dy[ppm->index_in_phi]=y[ppm->index_in_dphi];
        // 3: dphi/dtau
        dy[ppm->index_in_dphi]=-2.*ppipaw->aH*y[ppm->index_in_dphi]-ppipaw->a2*ppipaw->dV;
        break;

      case proper:

        // a H = adot
        ppipaw->aH = y[ppm->index_in_a]*sqrt((8*_PI_/3.)*(0.5*y[ppm->index_in_dphi]*y[ppm->index_in_dphi]+ppipaw->V));
        // 1: a
        dy[ppm->index_in_a]=ppipaw->aH;
        // 2: phi
        dy[ppm->index_in_phi]=y[ppm->index_in_dphi];
        // 3: dphi/dt
        dy[ppm->index_in_dphi]=-3.*ppipaw->aH/y[ppm->index_in_a]*y[ppm->index_in_dphi]-ppipaw->dV;
        break;
      }

      // z''/z (assumes that conformal time is requested)
      ppipaw->zpp_over_z=
        2*ppipaw->aH*ppipaw->aH
        - ppipaw->a2*ppipaw->ddV
        - 4.*_PI_*(7.*y[ppm->index_in_dphi]*y[ppm->index_in_dphi]
                   +4.*y[ppm->index_in_dphi]/ppipaw->aH*ppipaw->a2*ppipaw->dV)
        +32.*_PI_*_PI_*pow(y[ppm->index_in_dphi],4)/pow(ppipaw->aH,2);

      // a''/a (assumes that conformal time is requested)
      ppipaw->app_over_a=2.*ppipaw->aH*ppipaw->aH - 4.*_PI_*y[ppm->index_in_dphi]*y[ppm->index_in_dphi];

      break;

      // For backward integration of approximate slow-roll solution:
      // Neglect kinetic energy of the field phi'^2/(2a^2) w.r.t. potential energy V
      // Neglect phi'' w.r.t 2aHphi', reducing 2nd order Klein-Gordon to approximate 1st-order
    case backward:

      switch (ppipaw->time) {

      case conformal:

        // a H = a'/a
        ppipaw->aH = sqrt((8*_PI_/3.)*ppipaw->a2*ppipaw->V);
        // 1: a
        dy[ppm->index_in_a]=y[ppm->index_in_a]*ppipaw->aH;
        // 2: phi
        dy[ppm->index_in_phi]= -ppipaw->a2*ppipaw->dV/3./ppipaw->aH;
        break;

      case proper:

        // a H = da/dt
        ppipaw->aH = y[ppm->index_in_a]*sqrt((8*_PI_/3.)*ppipaw->V);
        // 1: a
        dy[ppm->index_in_a]=ppipaw->aH;
        // 2: phi
        dy[ppm->index_in_phi]= -ppipaw->dV/3./ppipaw->aH*y[ppm->index_in_a];
        break;
      }

      break;
    }

    break;

  case inflation_H:

    class_call(primordial_inflation_hubble(ppm,
                                           y[ppm->index_in_phi],
                                           &(ppipaw->H),
                                           &(ppipaw->dH),
                                           &(ppipaw->ddH),
                                           &(ppipaw->dddH)),
               ppm->error_message,
               ppm->error_message);

    switch (ppipaw->time) {

    case conformal:

      // 1: a
      dy[ppm->index_in_a]=ppipaw->a2*ppipaw->H;
      // 2: phi
      dy[ppm->index_in_phi]=-1./4./_PI_*y[ppm->index_in_a]*ppipaw->dH;
      break;

    case proper:

      // 1: a
      dy[ppm->index_in_a]=y[ppm->index_in_a]*ppipaw->H;
      // 2: phi
      dy[ppm->index_in_phi]=-1./4./_PI_*ppipaw->dH;
      break;
    }

    // z''/z (assumes that conformal time is requested)
    ppipaw->zpp_over_z =
      2.               *ppipaw->a2*ppipaw->H*ppipaw->H
      -3./4./_PI_      *ppipaw->a2*ppipaw->H*ppipaw->ddH
      +1./16./_PI_/_PI_*ppipaw->a2*ppipaw->ddH*ppipaw->ddH
      +1./16./_PI_/_PI_*ppipaw->a2*ppipaw->dH*ppipaw->dddH
      -1./4./_PI_/_PI_ *ppipaw->a2*ppipaw->dH*ppipaw->dH*ppipaw->ddH/ppipaw->H
      +1./2./_PI_      *ppipaw->a2*ppipaw->dH*ppipaw->dH
      +1./8./_PI_/_PI_ *ppipaw->a2*ppipaw->dH*ppipaw->dH*ppipaw->dH*ppipaw->dH/ppipaw->H/ppipaw->H;

    // a''/a (assumes that conformal time is requested)
    ppipaw->app_over_a = 2.*ppipaw->a2*ppipaw->H*ppipaw->H
      -4.*_PI_*dy[ppm->index_in_phi]*dy[ppm->index_in_phi];

    break;

  default:
    class_stop(ppm->error_message,"ppm->primordial_spec_type=%d different from possible relevant cases",ppm->primordial_spec_type);
    break;

  }

  if (ppipaw->N <= ppm->in_bg_size) // mind the <= instead of ==, necessary because for backward integration 1 equation is removed
    return _SUCCESS_;

  // PERTURBATIONS

  class_test(ppipaw->time == proper,
             ppm->error_message,
             "For inflaton perturbations, only conformal time is coded.");

  // SCALARS
  // 4: ksi_re
  dy[ppm->index_in_ksi_re]=y[ppm->index_in_dksi_re];
  // 5: ksi_im
  dy[ppm->index_in_ksi_im]=y[ppm->index_in_dksi_im];
  // 6: d ksi_re / dtau
  dy[ppm->index_in_dksi_re]=-(ppipaw->k*ppipaw->k-ppipaw->zpp_over_z)*y[ppm->index_in_ksi_re];
  // 7: d ksi_im / dtau
  dy[ppm->index_in_dksi_im]=-(ppipaw->k*ppipaw->k-ppipaw->zpp_over_z)*y[ppm->index_in_ksi_im];

  // TENSORS
  // 8: ah_re
  dy[ppm->index_in_ah_re]=y[ppm->index_in_dah_re];
  // 9: ah_im
  dy[ppm->index_in_ah_im]=y[ppm->index_in_dah_im];
  // 10: d ah_re / dtau
  dy[ppm->index_in_dah_re]=-(ppipaw->k*ppipaw->k-ppipaw->app_over_a)*y[ppm->index_in_ah_re];
  // 11: d ah_im / dtau
  dy[ppm->index_in_dah_im]=-(ppipaw->k*ppipaw->k-ppipaw->app_over_a)*y[ppm->index_in_ah_im];

  return _SUCCESS_;
}

/**
 * This routine reads the primordial spectrum from an external command,
 * and stores the tabulated values.
 * The sampling of the k's given by the external command is preserved.
 *
 * Author: Jesus Torrado (torradocacho@lorentz.leidenuniv.nl)
 * Date:   2013-12-20
 *
 * @param ppt  Input/output: pointer to perturbation structure
 * @param ppm  Input/output: pointer to primordial structure
 * @return the error status
 */

int primordial_external_spectrum_init(
                                      struct perturbations * ppt,
                                      struct primordial * ppm
                                      ) {
  /** Summary: */

  char arguments[_ARGUMENT_LENGTH_MAX_];
  char line[_LINE_LENGTH_MAX_];
  char command_with_arguments[2*_ARGUMENT_LENGTH_MAX_];
  FILE *process;
  int n_data_guess, n_data = 0;
  double *k = NULL, *pks = NULL, *pkt = NULL;
  double this_k, this_pks, this_pkt;
  int status;
  int index_k;

  /** - Initialization */
  /* Prepare the data (with some initial size) */
  n_data_guess = 100;
  k   = (double *)malloc(n_data_guess*sizeof(double));
  pks = (double *)malloc(n_data_guess*sizeof(double));
  if (ppt->has_tensors == _TRUE_)
    pkt = (double *)malloc(n_data_guess*sizeof(double));
  /* Prepare the command */
  /* If the command is just a "cat", no arguments need to be passed */
  if (strncmp("cat ", ppm->command, 4) == 0) {
    class_sprintf(arguments, " ");
  }
  /* otherwise pass the list of arguments */
  else {
    class_sprintf(arguments, " %g %g %g %g %g %g %g %g %g %g",
            ppm->custom1, ppm->custom2, ppm->custom3, ppm->custom4, ppm->custom5,
            ppm->custom6, ppm->custom7, ppm->custom8, ppm->custom9, ppm->custom10);
  }
  /* write the actual command in a string */
  class_sprintf(command_with_arguments, "%s %s", ppm->command, arguments);
  if (ppm->primordial_verbose > 0)
    printf(" -> running: %s\n",command_with_arguments);

  /** - Launch the command and retrieve the output */
  /* Launch the process */
  process = popen(command_with_arguments, "r");
  class_test(process == NULL,
             ppm->error_message,
             "The program failed to set the environment for the external command. Maybe you ran out of memory.");
  /* Read output and store it */
  while (fgets(line, sizeof(line)-1, process) != NULL) {
    if (ppt->has_tensors == _TRUE_) {
      sscanf(line, "%lf %lf %lf", &this_k, &this_pks, &this_pkt);
    }
    else {
      sscanf(line, "%lf %lf", &this_k, &this_pks);
    }
    /* Standard technique in C: if too many data, double the size of the vectors */
    /* (it is faster and safer that reallocating every new line) */
    if ((n_data+1) > n_data_guess) {
      n_data_guess *= 2;
      class_realloc(k, n_data_guess*sizeof(double), ppm->error_message);
      class_realloc(pks, n_data_guess*sizeof(double), ppm->error_message);
      if (ppt->has_tensors == _TRUE_) {
        class_realloc(pkt, n_data_guess*sizeof(double), ppm->error_message);
      }
    }
    /* Store */
    k  [n_data]   = this_k;
    pks[n_data]   = this_pks;
    if (ppt->has_tensors == _TRUE_) {
      pkt[n_data] = this_pkt;
    }
    n_data++;
    /* Check ascending order of the k's */
    if (n_data>1) {
      class_test(k[n_data-1] <= k[n_data-2],
                 ppm->error_message,
                 "The k's are not strictly sorted in ascending order, "
                 "as it is required for the calculation of the splines.\n");
    }
  }
  /* Close the process */
  status = pclose(process);
  class_test(status != 0.,
             ppm->error_message,
             "The attempt to launch the external command was unsuccessful. "
             "Try doing it by hand to check for errors.");
  /* Test limits of the k's */
  class_test(k[1] > ppt->k_min,
             ppm->error_message,
             "Your table for the primordial spectrum does not have "
             "at least 2 points before the minimum value of k: %e . "
             "The splines interpolation would not be safe.",ppt->k_min);
  class_test(k[n_data-2] < ppt->k_max,
             ppm->error_message,
             "Your table for the primordial spectrum does not have "
             "at least 2 points after the maximum value of k: %e . "
             "The splines interpolation would not be safe.",ppt->k_max);

  /** - Store the read results into CLASS structures */
  ppm->lnk_size = n_data;
  /** - Make room */
  class_realloc(ppm->lnk,
                ppm->lnk_size*sizeof(double),
                ppm->error_message);
  class_realloc(ppm->lnpk[ppt->index_md_scalars],
                ppm->lnk_size*sizeof(double),
                ppm->error_message);
  class_realloc(ppm->ddlnpk[ppt->index_md_scalars],
                ppm->lnk_size*sizeof(double),
                ppm->error_message);
  if (ppt->has_tensors == _TRUE_) {
    class_realloc(ppm->lnpk[ppt->index_md_tensors],
                  ppm->lnk_size*sizeof(double),
                  ppm->error_message);
    class_realloc(ppm->ddlnpk[ppt->index_md_tensors],
                  ppm->lnk_size*sizeof(double),
                  ppm->error_message);
  };
  /** - Store values */
  for (index_k=0; index_k<ppm->lnk_size; index_k++) {
    ppm->lnk[index_k] = log(k[index_k]);
    ppm->lnpk[ppt->index_md_scalars][index_k] = log(pks[index_k]);
    if (ppt->has_tensors == _TRUE_)
      ppm->lnpk[ppt->index_md_tensors][index_k] = log(pkt[index_k]);
    /* DEBUG (with tensors)
       fprintf(stderr,"Storing[%d(+1) of %d]: \n k = %g == %g\n pks = %g == %g\n pkt = %g == %g\n",
       index_k, n_data,
       ppm->lnk[index_k], log(k[index_k]),
       ppm->lnpk[ppt->index_md_scalars][index_k], log(pks[index_k]),
       ppm->lnpk[ppt->index_md_tensors][index_k], log(pkt[index_k]));
    */
  };
  /** - Release the memory used locally */
  free(k);
  free(pks);
  if (ppt->has_tensors == _TRUE_)
    free(pkt);
  /** - Tell CLASS that there are scalar (and tensor) modes */
  ppm->is_non_zero[ppt->index_md_scalars][ppt->index_ic_ad] = _TRUE_;
  if (ppt->has_tensors == _TRUE_)
    ppm->is_non_zero[ppt->index_md_tensors][ppt->index_ic_ten] = _TRUE_;

  return _SUCCESS_;
}

int primordial_output_titles(struct perturbations * ppt,
                             struct primordial * ppm,
                             char titles[_MAXTITLESTRINGLENGTH_]
                             ){
  class_store_columntitle(titles,"k [1/Mpc]",_TRUE_);
  class_store_columntitle(titles,"P_scalar(k)",_TRUE_);
  class_store_columntitle(titles,"P_tensor(k)",ppt->has_tensors);

  return _SUCCESS_;

}

int primordial_output_data(struct perturbations * ppt,
                           struct primordial * ppm,
                           int number_of_titles,
                           double *data){

  int index_k, storeidx;
  double *dataptr;

  for (index_k=0; index_k<ppm->lnk_size; index_k++) {
    dataptr = data + index_k*number_of_titles;
    storeidx = 0;

    class_store_double(dataptr, exp(ppm->lnk[index_k]), _TRUE_,storeidx);
    class_store_double(dataptr, exp(ppm->lnpk[ppt->index_md_scalars][index_k]), _TRUE_,storeidx);
    class_store_double(dataptr, exp(ppm->lnpk[ppt->index_md_tensors][index_k]), ppt->has_tensors,storeidx);
  }


  return _SUCCESS_;

}

```

`source/thermodynamics.c`:

```c
/** @file thermodynamics.c Documented thermodynamics module
 *
 * * Julien Lesgourgues, 6.09.2010
 * * Restructured by Nils Schoeneberg and Matteo Lucca, 27.02.2019
 * * Evolver implementation by Daniel Meinert, spring 2019
 *
 * Deals with the thermodynamical evolution.
 * This module has two purposes:
 *
 * - at the beginning, to initialize the thermodynamics, i.e. to
 *   integrate the thermodynamical equations, and store all
 *   thermodynamical quantities as a function of redshift inside an
 *   interpolation table.
 *
 * - to provide a routine which allow other modules to evaluate any
 *   thermodynamical quantities at a given redshift value (by
 *   interpolating within the interpolation table).
 *
 * The most important differential equations to compute the free
 * electron fraction x at each step are provided either by the HyRec
 * 2020 or RecFastCLASS code, located in the external/ directory. The
 * thermodynamics module integrates these equations using the generic
 * integrator (which can be set to ndf15, rkck4, etc.) The HyRec and
 * RecFastCLASS algorithms are used and called in the same way by this
 * module.
 *
 * In summary, the following functions can be called from other modules:
 *
 * -# thermodynamics_init at the beginning (but after background_init)
 * -# thermodynamics_at_z at any later time
 * -# thermodynamics_free at the end, when no more calls to thermodynamics_at_z are needed
 */

#include "thermodynamics.h"

#include "history.h"
#include "hyrectools.h"
#include "helium.h"
#include "wrap_hyrec.h"


/**
 * Thermodynamics quantities at given redshift z.
 * Evaluates all thermodynamics quantities at a given value of the redshift by reading the pre-computed table and interpolating.
 *
 * @param pba          Input: pointer to background structure
 * @param pth          Input: pointer to the thermodynamics structure (containing pre-computed table)
 * @param z            Input: redshift
 * @param inter_mode   Input: interpolation mode (normal or growing_closeby)
 * @param last_index   Input/Output: index of the previous/current point in the interpolation array (input only for closeby mode, output for both)
 * @param pvecback     Input: vector of background quantities (used only in case z>z_initial for getting ddkappa and dddkappa; in that case,
 should be already allocated (!) and filled (!), with format short_info or larger; in other cases, will be ignored)
 * @param pvecthermo Output: vector of thermodynamics quantities (assumed to be already allocated)
 * @return the error status
 */

int thermodynamics_at_z(
                        struct background * pba,
                        struct thermodynamics * pth,
                        double z,
                        enum interpolation_method inter_mode,
                        int * last_index,
                        double * pvecback, //should be filled for z>z_initial!
                        double * pvecthermo
                        ) {

  /** Summary: */

  /** - define local variables */
  double x0;
  /* Dark matter baryon scattering */
  double Vrms_idm_b2, T_diff_idm_b, m_b, FHe;
  /* Varying fundamental constants */
  double sigmaTrescale = 1., alpha = 1., me = 1.;

  /* The fact that z is in the pre-computed range 0 <= z <= z_initial will be checked in the interpolation routines below. Before
     trying to interpolate, allow the routine to deal with the case z > z_initial: then, all relevant quantities can be extrapolated
     using simple analytic approximations */

  if (z >= pth->z_table[pth->tt_size-1]) {

    /* ionization fraction assumed to remain constant at large z */
    x0= pth->thermodynamics_table[(pth->tt_size-1)*pth->th_size+pth->index_th_xe];
    pvecthermo[pth->index_th_xe] = x0;

    /* In the case of varying fundamental constants, compute correction factor (according to 1705.03925) */
    if (pth->has_varconst == _TRUE_) {
      class_call(background_varconst_of_z(pba, z, &alpha, &me),
                 pba->error_message,
                 pth->error_message);
      sigmaTrescale = alpha*alpha/me/me;
    }

    /* Calculate dkappa/dtau (dkappa/dtau = a n_e x_e sigma_T = a^{-2} n_e(today) x_e sigma_T in units of 1/Mpc) */
    pvecthermo[pth->index_th_dkappa] = (1.+z) * (1.+z) * pth->n_e * x0 * sigmaTrescale * _sigma_ * _Mpc_over_m_;

    /* tau_d scales like (1+z)**2 */
    pvecthermo[pth->index_th_tau_d] = pth->thermodynamics_table[(pth->tt_size-1)*pth->th_size+pth->index_th_tau_d]*pow((1+z)/(1.+pth->z_table[pth->tt_size-1]),2);

    if (pth->compute_damping_scale == _TRUE_) {

      /* r_d scales like (1+z)**-3/2 */
      pvecthermo[pth->index_th_r_d] = pth->thermodynamics_table[(pth->tt_size-1)*pth->th_size+pth->index_th_r_d]*pow((1+z)/(1.+pth->z_table[pth->tt_size-1]),-1.5);
    }

    /* Calculate d2kappa/dtau2 = dz/dtau d/dz[dkappa/dtau] given that [dkappa/dtau] proportional to (1+z)^2 and dz/dtau = -H */
    pvecthermo[pth->index_th_ddkappa] = -pvecback[pba->index_bg_H] * 2. / (1.+z) * pvecthermo[pth->index_th_dkappa];

    /* Calculate d3kappa/dtau3 given that [dkappa/dtau] proportional to (1+z)^2 */
    pvecthermo[pth->index_th_dddkappa] = (pvecback[pba->index_bg_H]*pvecback[pba->index_bg_H]/ (1.+z) - pvecback[pba->index_bg_H_prime]) * 2. / (1.+z) * pvecthermo[pth->index_th_dkappa];

    /* \f$ exp^{-\kappa}, g, g', g'' \f$ can be set to zero: they are used only for computing the source functions in the
       perturbation module; but source functions only need to be sampled below z_initial (the condition that
       z_start_sources<z_initial is checked in the perturbation module) */
    pvecthermo[pth->index_th_exp_m_kappa] = 0.;
    pvecthermo[pth->index_th_g]=0.;
    pvecthermo[pth->index_th_dg]=0.;
    pvecthermo[pth->index_th_ddg]=0.;

    /* Calculate Tb assuming Tb ~ T_g at early times */
    pvecthermo[pth->index_th_Tb] = pba->T_cmb*(1.+z);

    /* Tb derivative */
    pvecthermo[pth->index_th_dTb] = pba->T_cmb;

    /* Calculate baryon equation of state parameter wb = (k_B/mu) Tb */
    /* note that m_H / mu = 1 + (m_H/m_He-1) Y_p + x_e (1-Y_p) */
    pvecthermo[pth->index_th_wb] = _k_B_ / ( _c_ * _c_ * _m_H_ ) * (1. + (1./_not4_ - 1.) * pth->YHe + x0 * (1.-pth->YHe)) * pba->T_cmb * (1.+z);

    /* Calculate cb2 (cb2 = (k_B/mu) Tb (1-1/3 dlnTb/dlna) = (k_B/mu) Tb (1+1/3 (1+z) dlnTb/dz)) */
    /* note that m_H / mu = 1 + (m_H/m_He-1) Y_p + x_e (1-Y_p) */
    pvecthermo[pth->index_th_cb2] = pvecthermo[pth->index_th_wb] * 4. / 3.;

    /* derivatives of baryon sound speed (only computed if some non-minimal tight-coupling schemes is requested) */
    if (pth->compute_cb2_derivatives == _TRUE_) {

      /* since cb2 proportional to (1+z) or 1/a, its derivative wrt conformal time is given by dcb2 = - a H cb2 */
      pvecthermo[pth->index_th_dcb2] = - pvecback[pba->index_bg_H] * pvecback[pba->index_bg_a] * pvecthermo[pth->index_th_cb2];

      /* then its second derivative is given by ddcb2 = - a H' cb2 */
      pvecthermo[pth->index_th_ddcb2] = - pvecback[pba->index_bg_H_prime] * pvecback[pba->index_bg_a] * pvecthermo[pth->index_th_cb2];
    }

    /* in this regime, variation rate = dkappa/dtau */
    pvecthermo[pth->index_th_rate] = pvecthermo[pth->index_th_dkappa];

    /* Quantities related to idm */
    if (pba->has_idm == _TRUE_) {

      /* Temperature and sound speed of idm (assuming T_idm ~ T_g at early times) */
      pvecthermo[pth->index_th_T_idm] = pba->T_cmb* (1+z);
      pvecthermo[pth->index_th_c2_idm] = _k_B_ * pba->T_cmb*(1+z)/(pth->m_idm*_eV_)  * (1 - (1.+z)/3./pvecback[pba->index_bg_H]);

      /* For DM-g calculate at early times the optical depth parameters */
      if (pth->has_idm_g == _TRUE_) {
        /* calculate dmu_idm_g and its derivatives */
        pvecthermo[pth->index_th_dmu_idm_g] = 3./8./_PI_/_G_*pow(1.+z, 2+pth->n_index_idm_g)*pba->Omega0_idm*pba->H0*pba->H0*pth->u_idm_g*pow(_c_,4)*_sigma_/1.e11/_eV_/_Mpc_over_m_;
        pvecthermo[pth->index_th_ddmu_idm_g] = -(2.+pth->n_index_idm_g) * pvecback[pba->index_bg_H] * pvecback[pba->index_bg_a] * pvecthermo[pth->index_th_dmu_idm_g];
        pvecthermo[pth->index_th_dddmu_idm_g] = (2.+pth->n_index_idm_g)*pvecthermo[pth->index_th_dmu_idm_g]/(1.+z) *
          (pvecback[pba->index_bg_H]*pvecback[pba->index_bg_H]/(1.+z) * (1.+pth->n_index_idm_g) - pvecback[pba->index_bg_H_prime]);
        /* extrapolate optical depth of idm_g */
        if (pth->n_index_idm_g == -1){
          pvecthermo[pth->index_th_exp_mu_idm_g] = pth->thermodynamics_table[(pth->tt_size-1)*pth->th_size+pth->index_th_exp_mu_idm_g] * exp( - pvecthermo[pth->index_th_dmu_idm_g] *pow(1.+z, -2-pth->n_index_idm_g) * log((1.+z)/(1.+pth->z_table[pth->tt_size-1]))*(1.+z)*(1.+z)/pvecback[pba->index_bg_H]);
        }
        else{
          pvecthermo[pth->index_th_exp_mu_idm_g] = pth->thermodynamics_table[(pth->tt_size-1)*pth->th_size+pth->index_th_exp_mu_idm_g] * exp( - pvecthermo[pth->index_th_dmu_idm_g] *pow(1.+z, -2-pth->n_index_idm_g) /(1.+pth->n_index_idm_g) * (pow(1.+z,pth->n_index_idm_g+1)-pow(1.+pth->z_table[pth->tt_size-1],pth->n_index_idm_g+1))*(1.+z)*(1.+z)/pvecback[pba->index_bg_H] );
        }
      }

      /* For idm_b calculate at early times the interaction rate parameters */
      if (pth->has_idm_b == _TRUE_){

        /* some constants used in the scattering rate and temperatures */
        FHe = 1-pth->YHe;
        m_b = _m_p_*_c_*_c_/_eV_;
        Vrms_idm_b2 = 1.e-8; /* approximation for V_rms at early times */
        T_diff_idm_b = (pvecthermo[pth->index_th_Tb]*_k_B_/_eV_/m_b)+(pvecthermo[pth->index_th_T_idm]*_k_B_/_eV_/pth->m_idm)+(Vrms_idm_b2/3.0); /* T and m are all in eV */

        /* Now compute the coupling coefficients */
        pvecthermo[pth->index_th_R_idm_b] = (pvecback[pba->index_bg_a]*pvecback[pba->index_bg_rho_b]*pth->cross_idm_b*pth->n_coeff_idm_b/(m_b+pth->m_idm))
          *pow(T_diff_idm_b,(pth->n_index_idm_b+1.0)/2.0)*FHe
          *(3.e-4*pow(_c_,4.)/(8.*_PI_*_Mpc_over_m_*_G_*_eV_)); /* conversion coefficient for the units */
        pvecthermo[pth->index_th_dR_idm_b] = pvecthermo[pth->index_th_R_idm_b] * pvecback[pba->index_bg_a] * pvecback[pba->index_bg_H]
          * ( -2. - (1.+z) * (pth->n_index_idm_b+1.0)/2.0 * (pba->T_cmb*_k_B_/_eV_/m_b + pba->T_cmb*_k_B_/_eV_/pth->m_idm)/T_diff_idm_b);
      }

      /* For idm_dr calculate at early times the optical depth parameters */
      if (pth->has_idm_dr == _TRUE_){
        /* calculate dmu_idm_dr and its derivatives */
        pvecthermo[pth->index_th_dmu_idm_dr] = pth->a_idm_dr*pow((1.+z)/1.e7,pth->n_index_idm_dr)*pba->Omega0_idm*pow(pba->h,2);
        pvecthermo[pth->index_th_ddmu_idm_dr] =  -pvecback[pba->index_bg_H] * pth->n_index_idm_dr / (1+z) * pvecthermo[pth->index_th_dmu_idm_dr];
        pvecthermo[pth->index_th_dddmu_idm_dr] = (pvecback[pba->index_bg_H]*pvecback[pba->index_bg_H]/ (1.+z) * (pth->n_index_idm_dr - 1.) - pvecback[pba->index_bg_H_prime])
          * pth->n_index_idm_dr / (1.+z) * pvecthermo[pth->index_th_dmu_idm_dr];

        /* extrapolate optical depth of idm_dr and idr */
        if (pth->n_index_idm_dr == 1 ){
          pvecthermo[pth->index_th_tau_idr] = pth->thermodynamics_table[(pth->tt_size-1)*pth->th_size+pth->index_th_tau_idr]+pvecthermo[pth->index_th_dmu_idm_dr] * pow(1.+z, - pth->n_index_idm_dr) * log((1.+z)/(1.+pth->z_table[pth->tt_size-1]))/(pvecback[pba->index_bg_H]/(1.+z)/(1.+z));
        }
        else{
          pvecthermo[pth->index_th_tau_idr] = pth->thermodynamics_table[(pth->tt_size-1)*pth->th_size+pth->index_th_tau_idr]+pvecthermo[pth->index_th_dmu_idm_dr] * pow(1.+z, - pth->n_index_idm_dr)/(1.-pth->n_index_idm_dr) * (pow(1.+pth->z_table[pth->tt_size-1], pth->n_index_idm_dr -1) - pow(1.+z, pth->n_index_idm_dr -1))/(pvecback[pba->index_bg_H]/(1.+z)/(1.+z));
        }

        if (pth->n_index_idm_dr == 0 ){
          pvecthermo[pth->index_th_tau_idm_dr] = pth->thermodynamics_table[(pth->tt_size-1)*pth->th_size+pth->index_th_tau_idm_dr]+pvecthermo[pth->index_th_dmu_idm_dr] * pow(1.+z, - pth->n_index_idm_dr) * 4./3. * pba->Omega0_idr/pba->Omega0_idm * log((1.+z)/(1.+pth->z_table[pth->tt_size-1]))/(pvecback[pba->index_bg_H]/(1.+z)/(1.+z));
        }
        else{
          pvecthermo[pth->index_th_tau_idm_dr] = pth->thermodynamics_table[(pth->tt_size-1)*pth->th_size+pth->index_th_tau_idm_dr]+pvecthermo[pth->index_th_dmu_idm_dr] * pow(1.+z, - pth->n_index_idm_dr) * 4./3. * pba->Omega0_idr/pba->Omega0_idm /(-pth->n_index_idm_dr) * (pow(1.+pth->z_table[pth->tt_size-1], pth->n_index_idm_dr) - pow(1.+z, pth->n_index_idm_dr))/(pvecback[pba->index_bg_H]/(1.+z)/(1.+z));
        }

        /* extrapolate idm_dr visibility function */
        pvecthermo[pth->index_th_g_idm_dr] = pvecthermo[pth->index_th_dmu_idm_dr] * 4./3. * pba->Omega0_idr/pba->Omega0_idm * (1.+z) * exp(-pvecthermo[pth->index_th_tau_idm_dr]);
      }

    }

    /* Quantities related to idr */
    if (pba->has_idr == _TRUE_) {

      /* Use the temperature scaling assumed throughout */
      pvecthermo[pth->index_th_T_idr] = pba->T_idr* (1+z);

      /* calculate dmu_idr (self interaction) */
      pvecthermo[pth->index_th_dmu_idr] = pth->b_idr*pow((1.+z)/1.e7,pth->n_index_idm_dr)*pba->Omega0_idr*pow(pba->h,2);
    }
  }

  /** - interpolate in table with array_interpolate_spline (normal mode) or array_interpolate_spline_growing_closeby (closeby mode) */

  else {

    /* some very specific cases require linear interpolation because of a break in the derivative of the functions */
    if (((pth->reio_parametrization == reio_half_tanh) && (z < 2*pth->z_reio))
        || ((pth->reio_parametrization == reio_inter) && (z < 50.))) {

      class_call(array_interpolate_linear(pth->z_table,
                                          pth->tt_size,
                                          pth->thermodynamics_table,
                                          pth->th_size,
                                          z,
                                          last_index,
                                          pvecthermo,
                                          pth->th_size,
                                          pth->error_message),
                 pth->error_message,
                 pth->error_message);
    }

    /* in the "normal" case, use spline interpolation */
    else {

      if (inter_mode == inter_normal) {

        class_call(array_interpolate_spline(pth->z_table,
                                            pth->tt_size,
                                            pth->thermodynamics_table,
                                            pth->d2thermodynamics_dz2_table,
                                            pth->th_size,
                                            z,
                                            last_index,
                                            pvecthermo,
                                            pth->th_size,
                                            pth->error_message),
                   pth->error_message,
                   pth->error_message);
      }

      if (inter_mode == inter_closeby) {

        class_call(array_interpolate_spline_growing_closeby(pth->z_table,
                                                            pth->tt_size,
                                                            pth->thermodynamics_table,
                                                            pth->d2thermodynamics_dz2_table,
                                                            pth->th_size,
                                                            z,
                                                            last_index,
                                                            pvecthermo,
                                                            pth->th_size,
                                                            pth->error_message),
                   pth->error_message,
                   pth->error_message);

      }
    }
  }
  return _SUCCESS_;
}

/**
 * Initialize the thermodynamics structure, and in particular the
 * thermodynamics interpolation table.
 *
 * @param ppr   Input: pointer to precision structure
 * @param pba   Input: pointer to background structure
 * @param pth   Input/Output: pointer to initialized thermodynamics structure
 * @return the error status
 */

int thermodynamics_init(
                        struct precision * ppr,
                        struct background * pba,
                        struct thermodynamics * pth
                        ) {

  /** Summary: */

  /** - define local variables */

  /* vector of background values for calling background_at_tau */
  double * pvecback;

  /* structures for storing temporarily information on recombination and reionization */
  struct thermo_workspace * ptw;

  pth->has_idm_g = pba->has_idm && (pth->u_idm_g > 0.);
  pth->has_idm_dr = pba->has_idm && (pba->has_idr && pth->a_idm_dr > 0.);
  pth->has_idm_b = pba->has_idm && (pth->cross_idm_b > 0.);

  /** - update the user about which recombination code is being run */
  if (pth->thermodynamics_verbose > 0) {
    switch (pth->recombination) {

    case recfast:
      printf("Computing thermodynamics using RecFastCLASS (based on v1.5)\n");
      break;

    case hyrec:
      printf("Computing thermodynamics using HyRec 2020\n");
      break;

    default:
      class_stop(pth->error_message,"pth->recombination=%d different from all known cases",pth->recombination);
      break;
    }
  }

  /** - set flag for varying constants */
  pth->has_varconst = pba->has_varconst;

  /** - compute and check primordial Helium mass fraction rho_He/(rho_H+rho_He) */

  if (pth->YHe == _YHE_BBN_) {
    class_call(thermodynamics_helium_from_bbn(ppr,pba,pth),
               pth->error_message,
               pth->error_message);
  }
  if (pth->thermodynamics_verbose > 0) {
    printf(" -> with primordial helium mass fraction Y_He = %.4f\n",pth->YHe);
  }

  /** - infer primordial helium-to-hydrogen nucleon ratio n_He/n_H
   * It is calculated via n_He/n_H = rho_He/(m_He/m_H * rho_H) = YHe * rho_b / (m_He/m_H * (1-YHe) rho_b) = YHe / (m_He/m_H * (1-YHe))*/
  pth->fHe = pth->YHe/(_not4_ *(1.-pth->YHe));

  /** - infer number of hydrogen nuclei today in m**-3 */
  pth->n_e = 3.*pow(pba->H0 * _c_ / _Mpc_over_m_,2)*pba->Omega0_b/(8.*_PI_*_G_*_m_H_)*(1.-pth->YHe);

  /** - test whether all parameters are in the correct regime */
  class_call(thermodynamics_checks(ppr,pba,pth),
             pth->error_message,
             pth->error_message);

  /** - allocate and assign all temporary structures and indices */
  class_alloc(ptw, sizeof(struct thermo_workspace), pth->error_message);

  /*  in the case of idm, we need to adapt the start of integration time,
      to be sure we capture the time at which the two species are still coupled.
      This is after thermo_workspace was allocated to set the has_ap_idmtca flag*/
  class_call(thermodynamics_obtain_z_ini(ppr,pba,pth, ptw),
             pth->error_message,
             pth->error_message);

  class_call(thermodynamics_workspace_init(ppr,pba,pth,ptw),
             pth->error_message,
             pth->error_message);

  class_call(thermodynamics_indices(pba,pth,ptw),
             pth->error_message,
             pth->error_message);

  class_alloc(pvecback,pba->bg_size*sizeof(double),pba->error_message);

  class_call(thermodynamics_lists(ppr,pba,pth,ptw),
             pth->error_message,
             pth->error_message);

  /** - initialize injection struct (not temporary) */
  if (pth->has_exotic_injection == _TRUE_) {
    class_call(injection_init(ppr,
                              pba,
                              pth),
               (pth->in).error_message,
               pth->error_message);
  }

  /** - assign reionisation parameters */
  class_call(thermodynamics_set_parameters_reionization(ppr,
                                                        pba,
                                                        pth,
                                                        ptw->ptrp),
             pth->error_message,
             pth->error_message);

  /** - solve recombination and reionization and store values of \f$ z, x_e, d \kappa / d \tau, T_b, c_b^2 \f$  */
  class_call(thermodynamics_solve(ppr,pba,pth,ptw,pvecback),
             pth->error_message,
             pth->error_message);

  /** - the differential equation system is now completely solved  */

  /** - fill missing columns (quantities not computed during the differential evolution but related) */
  class_call(thermodynamics_calculate_remaining_quantities(ppr,pba,pth,pvecback),
             pth->error_message,
             pth->error_message);

  /** - write information on thermal history in standard output */
  if (pth->thermodynamics_verbose > 0) {
    class_call(thermodynamics_output_summary(pba,pth),
               pth->error_message,
               pth->error_message);
  }

  /** - free workspace and local variables */
  class_call(thermodynamics_workspace_free(pth,ptw),
             pth->error_message,
             pth->error_message);

  free(pvecback);

  pth->is_allocated = _TRUE_;

  return _SUCCESS_;
}


/**
 * Free all memory space allocated by thermodynamics_init.
 *
 * @param pth Input/Output: pointer to thermodynamics structure (to be freed)
 * @return the error status
 */
int thermodynamics_free(
                        struct thermodynamics * pth
                        ) {

  if (pth->has_exotic_injection == _TRUE_) {
    /* Free all injection-related functions */
    class_call(injection_free(pth),
               (pth->in).error_message,
               pth->error_message);
  }

  /* Free thermodynamics-related functions */
  free(pth->z_table);
  free(pth->tau_table);
  free(pth->thermodynamics_table);
  free(pth->d2thermodynamics_dz2_table);

  class_call(thermodynamics_free_input(pth),
             pth->error_message,
             pth->error_message);

  pth->is_allocated = _FALSE_;

  return _SUCCESS_;
}
/**
 * Free all memory space allocated by input.c for the thermodynamics module.
 *
 * @param pth Input/Output: pointer to thermodynamics structure (to be freed)
 * @return the error status
 */
int thermodynamics_free_input(
                        struct thermodynamics * pth
                        ) {

  switch(pth->reio_parametrization){

  case reio_none:
  case reio_camb:
  case reio_half_tanh:
  default:
    /* nothing to be read*/
    break;

  case reio_bins_tanh:
    /* Read */
    free(pth->binned_reio_z);
    free(pth->binned_reio_xe);
    break;

  case reio_many_tanh:
    /* Read */
    free(pth->many_tanh_z);
    free(pth->many_tanh_xe);
    break;

    /** 8.d) reionization parameters if reio_parametrization=reio_many_tanh */
  case reio_inter:
    /* Read */
    free(pth->reio_inter_z);
    free(pth->reio_inter_xe);
    break;

  }

  return _SUCCESS_;
}
/**
 * Infer the primordial helium mass fraction from standard BBN
 * calculations, as a function of the baryon density and expansion
 * rate during BBN.
 *
 * This module is simpler then the one used in arXiv:0712.2826 because
 * it neglects the impact of a possible significant chemical
 * potentials for electron neutrinos. The full code with xi_nu_e could
 * be introduced here later.
 *
 * @param ppr   Input: pointer to precision structure
 * @param pba   Input: pointer to background structure
 * @param pth   Input/Output: pointer to initialized thermodynamics structure
 * @return the error status
 */
int thermodynamics_helium_from_bbn(
                                   struct precision * ppr,
                                   struct background * pba,
                                   struct thermodynamics * pth
                                   ) {

  /** Summary: */

  /** Define local variables */
  FILE * fA;
  char line[_LINE_LENGTH_MAX_];
  char * left;

  int num_omegab=0;
  int num_deltaN=0;

  double * omegab=NULL;
  double * deltaN=NULL;
  double * YHe=NULL;
  double * ddYHe=NULL;
  double * YHe_at_deltaN=NULL;
  double * ddYHe_at_deltaN=NULL;

  int array_line=0;
  double DeltaNeff;
  double omega_b;
  int last_index;
  double Neff_bbn, z_bbn, * pvecback;

  /** - Infer effective number of neutrinos at the time of BBN */
  class_alloc(pvecback,pba->bg_size*sizeof(double),pba->error_message);

  /** - We randomly choose 0.1 MeV to be the temperature of BBN */
  z_bbn = 0.1*1e6/(_eV_over_Kelvin_*pba->T_cmb)-1.0;

  class_call(background_at_z(pba,
                             z_bbn,
                             long_info,
                             inter_normal,
                             &last_index,
                             pvecback),
             pba->error_message,
             pth->error_message);

  Neff_bbn = (pvecback[pba->index_bg_Omega_r]
              *pvecback[pba->index_bg_rho_crit]
              -pvecback[pba->index_bg_rho_g])
    /(7./8.*pow(4./11.,4./3.)*pvecback[pba->index_bg_rho_g]);


  //  printf("Neff early = %g, Neff at bbn: %g\n",pba->Neff,Neff_bbn);

  /** - compute Delta N_eff as defined in bbn file, i.e. \f$ \Delta N_{eff}=0\f$ means \f$ N_{eff}=3.046\f$.
   * Note that even if 3.044 is a better default value, we must keep 3.046 here as long as the BBN file we are
   * using has been computed assuming 3.046.
   */
  DeltaNeff = Neff_bbn - 3.046;

  /* the following file is assumed to contain (apart from comments and blank lines):
     - the two numbers (num_omegab, num_deltaN) = number of values of BBN free parameters
     - three columns (omegab, deltaN, YHe) where omegab = Omega0_b h^2 and deltaN = Neff-3.046 by definition
     - omegab and deltaN are assumed to be arranged as:
     omegab1 deltaN1 YHe
     omegab2 deltaN1 YHe
     .....
     omegab1 delatN2 YHe
     omegab2 deltaN2 YHe
     .....
  */

  class_open(fA,ppr->sBBN_file, "r",pth->error_message);

  /* go through each line */
  while (fgets(line,_LINE_LENGTH_MAX_-1,fA) != NULL) {

    /* eliminate blank spaces at beginning of line */
    left=line;
    while (left[0]==' ') {
      left++;
    }

    /* check that the line is neither blank neither a comment. In ASCII, left[0]>39 means that first non-blank character might
       be the beginning of some data (it is not a newline, a #, a %, etc.) */
    if (left[0] > 39) {

      /* if the line contains data, we must interpret it. If (num_omegab, num_deltaN)=(0,0), the current line must contain
         their values. Otherwise, it must contain (omegab, delatN, YHe). */
      if ((num_omegab==0) && (num_deltaN==0)) {

        /* read (num_omegab, num_deltaN), infer size of arrays and allocate them */
        class_test(sscanf(line,"%d %d",&num_omegab,&num_deltaN) != 2,
                   pth->error_message,
                   "could not read value of parameters (num_omegab,num_deltaN) in file %s\n",ppr->sBBN_file);

        class_alloc(omegab,num_omegab*sizeof(double),pth->error_message);
        class_alloc(deltaN,num_deltaN*sizeof(double),pth->error_message);
        class_alloc(YHe,num_omegab*num_deltaN*sizeof(double),pth->error_message);
        class_alloc(ddYHe,num_omegab*num_deltaN*sizeof(double),pth->error_message);
        class_alloc(YHe_at_deltaN,num_omegab*sizeof(double),pth->error_message);
        class_alloc(ddYHe_at_deltaN,num_omegab*sizeof(double),pth->error_message);
        array_line=0;

      }
      else{

        /* read (omegab, deltaN, YHe) */
        class_test(sscanf(line,"%lg %lg %lg",&(omegab[array_line%num_omegab]),
                          &(deltaN[array_line/num_omegab]),
                          &(YHe[array_line])
                          ) != 3,
                   pth->error_message,
                   "could not read value of parameters (omegab,deltaN,YHe) in file %s\n",ppr->sBBN_file);
        array_line ++;
      }
    }
  }

  fclose(fA);

  /** - spline in one dimension (along deltaN) */
  class_call(array_spline_table_lines(deltaN,
                                      num_deltaN,
                                      YHe,
                                      num_omegab,
                                      ddYHe,
                                      _SPLINE_NATURAL_,
                                      pth->error_message),
             pth->error_message,
             pth->error_message);

  omega_b=pba->Omega0_b*pba->h*pba->h;

  class_test(omega_b < omegab[0],
             pth->error_message,
             "You have asked for an unrealistic small value omega_b = %e. The corresponding value of the primordial helium fraction cannot be found in the interpolation table. If you really want this value, you should fix YHe to a given value rather than to BBN",
             omega_b);

  class_test(omega_b > omegab[num_omegab-1],
             pth->error_message,
             "You have asked for an unrealistic high value omega_b = %e. The corresponding value of the primordial helium fraction cannot be found in the interpolation table. If you really want this value, you should fix YHe to a given value rather than to BBN",
             omega_b);

  class_test(DeltaNeff < deltaN[0],
             pth->error_message,
             "You have asked for an unrealistic small value of Delta N_eff = %e. The corresponding value of the primordial helium fraction cannot be found in the interpolation table. If you really want this value, you should fix YHe to a given value rather than to BBN",
             DeltaNeff);

  class_test(DeltaNeff > deltaN[num_deltaN-1],
             pth->error_message,
             "You have asked for an unrealistic high value of Delta N_eff = %e. The corresponding value of the primordial helium fraction cannot be found in the interpolation table. If you really want this value, you should fix YHe to a given value rather than to BBN",
             DeltaNeff);

  /** - interpolate in one dimension (along deltaN) */
  class_call(array_interpolate_spline(deltaN,
                                      num_deltaN,
                                      YHe,
                                      ddYHe,
                                      num_omegab,
                                      DeltaNeff,
                                      &last_index,
                                      YHe_at_deltaN,
                                      num_omegab,
                                      pth->error_message),
             pth->error_message,
             pth->error_message);

  /** - spline in remaining dimension (along omegab) */
  class_call(array_spline_table_lines(omegab,
                                      num_omegab,
                                      YHe_at_deltaN,
                                      1,
                                      ddYHe_at_deltaN,
                                      _SPLINE_NATURAL_,
                                      pth->error_message),
             pth->error_message,
             pth->error_message);

  /** - interpolate in remaining dimension (along omegab) */
  class_call(array_interpolate_spline(omegab,
                                      num_omegab,
                                      YHe_at_deltaN,
                                      ddYHe_at_deltaN,
                                      1,
                                      omega_b,
                                      &last_index,
                                      &(pth->YHe),
                                      1,
                                      pth->error_message),
             pth->error_message,
             pth->error_message);

  /** - Take into account impact of varying alpha on helium fraction */
  if (pth->has_varconst == _TRUE_) {
    pth->YHe *= pth->bbn_alpha_sensitivity * (pvecback[pba->index_bg_varc_alpha]-1.)+1.;
  }

  /** - deallocate arrays */
  free(omegab);
  free(deltaN);
  free(YHe);
  free(ddYHe);
  free(YHe_at_deltaN);
  free(ddYHe_at_deltaN);
  free(pvecback);

  return _SUCCESS_;
}

/**
 * Check the thermodynamics structure parameters for bounds and critical values.
 *
 * @param ppr   Input: pointer to precision structure
 * @param pba   Input: pointer to background structure
 * @param pth   Input: pointer to initialized thermodynamics structure
 * @return the error status
 */

int thermodynamics_checks(
                          struct precision * ppr,
                          struct background* pba,
                          struct thermodynamics * pth
                          ) {

  /** Summary: */

  /** - check BBN Y_He fracion */
  class_test((pth->YHe < _YHE_SMALL_)||(pth->YHe > _YHE_BIG_),
             pth->error_message,
             "Y_He=%g out of bounds (%g<Y_He<%g)",pth->YHe,_YHE_SMALL_,_YHE_BIG_);

  /** - tests in order to prevent divisions by zero */
  class_test(pth->YHe == 1.,
             pth->error_message,
             "stop to avoid division by zero");

  /** - test initial condition for recombination */
  class_test(ppr->thermo_z_initial < ppr->recfast_z_He_3,
             pth->error_message,
             "increase z_initial in order to start before HeliumIII recombination");

  return _SUCCESS_;
}

/**
 * Initialize the thermodynamics workspace.
 *
 * The workspace contains the arrays used for solving differential
 * equations (dubbed thermo_diffeq_workspace), and storing all
 * approximations, reionization parameters, heating parameters.
 *
 * @param ppr        Input: pointer to precision structure
 * @param pba        Input: pointer to background structure
 * @param pth        Input: pointer to the thermodynamics structure
 * @param ptw        Input/Output: pointer to thermodynamics workspace
 * @return the error status
 */

int thermodynamics_workspace_init(
                                  struct precision * ppr,
                                  struct background * pba,
                                  struct thermodynamics * pth,
                                  struct thermo_workspace * ptw
                                  ) {

  /** Summary: */

  /** Define local variables */
  int index_ap;
  /* for varying fundamental constants */
  double alpha = 1., me = 1.;

  /** - number of z values */
  ptw->Nz_reco_lin = ppr->thermo_Nz_lin;
  ptw->Nz_reco_log = ppr->thermo_Nz_log;
  ptw->Nz_reco = ptw->Nz_reco_lin + ptw->Nz_reco_log;
  ptw->Nz_reio = ppr->reionization_z_start_max / ppr->reionization_sampling;
  ptw->Nz_tot = ptw->Nz_reio + ptw->Nz_reco;

  /** - relevant cosmological parameters */

  /* primordial helium mass fraction */
  ptw->YHe = pth->YHe;
  /* primordial helium-to-hydrogen nucleon ratio */
  ptw->fHe = pth->fHe;
  /* Hubble parameter today in SI units */
  ptw->SIunit_H0 = pba->H0 * _c_ / _Mpc_over_m_;
  /* H number density today in SI units*/
  ptw->SIunit_nH0 = 3.*ptw->SIunit_H0*ptw->SIunit_H0*pba->Omega0_b/(8.*_PI_*_G_*_m_H_)*(1.-ptw->YHe);
  /* CMB temperature today in Kelvin */
  ptw->Tcmb = pba->T_cmb;

  /** - relevant constants */

  /* Prefactor in non-relativistic number density for temperature -- (2*pi*m_e) and unit conversion */
  ptw->const_NR_numberdens = 2.*_PI_*(_m_e_/_h_P_)*(_k_B_/_h_P_);
  /* Ionization energy for HI -- temperature equivalent in Kelvin */
  ptw->const_Tion_H = _h_P_*_c_*_L_H_ion_/_k_B_;
  /* Ionization energy for HeI -- temperature equivalent in Kelvin */
  ptw->const_Tion_HeI = _h_P_*_c_*_L_He1_ion_/_k_B_;
  /* Ionization energy for HeII -- temperature equivalent in Kelvin */
  ptw->const_Tion_HeII = _h_P_*_c_*_L_He2_ion_/_k_B_;

  /* the field reionization_optical_depth is computed and filled later */

  /** - Allocate and initialize differential equation workspace */
  class_alloc(ptw->ptdw,
              sizeof(struct thermo_diffeq_workspace),
              pth->error_message);

  // Initialize ionisation fraction.
  ptw->ptdw->x_reio = 1.+2.*ptw->fHe;
  ptw->ptdw->x_noreio = 1.+2.*ptw->fHe;

  /** - define approximations */
  index_ap=0;
  /* Approximations have to appear in chronological order here! */
  class_define_index(ptw->ptdw->index_ap_idmtca,ptw->has_ap_idmtca,index_ap,1); //DM tight coupling (assumed always before any recombination phases)
  class_define_index(ptw->ptdw->index_ap_brec,_TRUE_,index_ap,1); // before H- and He-recombination
  class_define_index(ptw->ptdw->index_ap_He1,_TRUE_,index_ap,1);  // during 1st He-recombination (HeIII)
  class_define_index(ptw->ptdw->index_ap_He1f,_TRUE_,index_ap,1); // in between 1st and 2nd He recombination
  class_define_index(ptw->ptdw->index_ap_He2,_TRUE_,index_ap,1);  // beginning of 2nd He-recombination (HeII)
  class_define_index(ptw->ptdw->index_ap_H,_TRUE_,index_ap,1);    // beginning of H-recombination (HI)
  class_define_index(ptw->ptdw->index_ap_frec,_TRUE_,index_ap,1); // during and after full H- and HeII-recombination
  class_define_index(ptw->ptdw->index_ap_reio,_TRUE_,index_ap,1); // during reionization
  ptw->ptdw->ap_size=index_ap;

  /* Set correct initial approximation scheme */
  ptw->ptdw->ap_current = ptw->ptdw->index_ap_brec;
  if (ptw->has_ap_idmtca == _TRUE_)
    ptw->ptdw->ap_current = ptw->ptdw->index_ap_idmtca;

  /** - store all ending redshifts for each approximation */
  class_alloc(ptw->ptdw->ap_z_limits,ptw->ptdw->ap_size*sizeof(double),pth->error_message);

  if (ptw->has_ap_idmtca == _TRUE_)
    ptw->ptdw->ap_z_limits[ptw->ptdw->index_ap_idmtca] = ptw->z_ap_idmtca;
  ptw->ptdw->ap_z_limits[ptw->ptdw->index_ap_brec] =
    ppr->recfast_z_He_1+ppr->recfast_delta_z_He_1; // beginning 1st He-recombination
  ptw->ptdw->ap_z_limits[ptw->ptdw->index_ap_He1] =
    ppr->recfast_z_He_2+ppr->recfast_delta_z_He_2; // end 1st He-recombination
  ptw->ptdw->ap_z_limits[ptw->ptdw->index_ap_He1f] =
    ppr->recfast_z_He_3+ppr->recfast_delta_z_He_3; // beginning 2nd He-recombination
  ptw->ptdw->ap_z_limits[ptw->ptdw->index_ap_He2] =
    ppr->recfast_z_early_H_recombination;          // beginning early H-recombination
  ptw->ptdw->ap_z_limits[ptw->ptdw->index_ap_H] =
    ppr->recfast_z_full_H_recombination;           // beginning full recombination equations
  ptw->ptdw->ap_z_limits[ptw->ptdw->index_ap_frec] =
    ppr->reionization_z_start_max;                 // beginning reionization
  ptw->ptdw->ap_z_limits[ptw->ptdw->index_ap_reio] = 0.0; // today

  /** - Rescale these redshifts in case of varying fundamental constants */
  if (pth->has_varconst == _TRUE_) {
    for (index_ap=0;index_ap<ptw->ptdw->ap_size;++index_ap){
      class_call(background_varconst_of_z(pba,ptw->ptdw->ap_z_limits[index_ap], &alpha, &me),
                 pba->error_message,
                 pth->error_message);
      ptw->ptdw->ap_z_limits[index_ap]*=me*alpha*alpha;
    }
  }

  /** - store smoothing deltas for transitions at the beginning of each aproximation */
  class_alloc(ptw->ptdw->ap_z_limits_delta,ptw->ptdw->ap_size*sizeof(double),pth->error_message);

  if (ptw->has_ap_idmtca == _TRUE_)
    ptw->ptdw->ap_z_limits_delta[ptw->ptdw->index_ap_idmtca] = 0.;
  ptw->ptdw->ap_z_limits_delta[ptw->ptdw->index_ap_brec] = 0.;
  ptw->ptdw->ap_z_limits_delta[ptw->ptdw->index_ap_He1] = ppr->recfast_delta_z_He_1;
  ptw->ptdw->ap_z_limits_delta[ptw->ptdw->index_ap_He1f] = ppr->recfast_delta_z_He_2;
  ptw->ptdw->ap_z_limits_delta[ptw->ptdw->index_ap_He2] = ppr->recfast_delta_z_He_3;
  ptw->ptdw->ap_z_limits_delta[ptw->ptdw->index_ap_H] = ppr->recfast_delta_z_early_H_recombination;
  ptw->ptdw->ap_z_limits_delta[ptw->ptdw->index_ap_frec] = ppr->recfast_delta_z_full_H_recombination;
  ptw->ptdw->ap_z_limits_delta[ptw->ptdw->index_ap_reio] = ppr->recfast_delta_z_reio;

  /* With recombination computed by HyRec or Recfast, we need to allocate and initialize the wrappers */

  switch (pth->recombination) {

  case hyrec:
    class_alloc(ptw->ptdw->phyrec,
                sizeof(struct thermohyrec),
                pth->error_message);

    ptw->ptdw->phyrec->thermohyrec_verbose = pth->hyrec_verbose;
    class_call(thermodynamics_hyrec_init(ppr,pba,pth,ptw->SIunit_nH0,pba->T_cmb,ptw->fHe, ptw->ptdw->ap_z_limits[ptw->ptdw->index_ap_brec],ptw->ptdw->phyrec),
               ptw->ptdw->phyrec->error_message,
               pth->error_message);
    break;

  case recfast:
    class_alloc(ptw->ptdw->precfast,
                sizeof(struct thermorecfast),
                pth->error_message);

    class_call(recfast_init(ppr,pba,pth,ptw->ptdw->precfast,pth->recfast_photoion_mode,ptw->fHe),
               ptw->ptdw->precfast->error_message,
               pth->error_message);

    break;
  }

  /** - Allocate reionisation parameter workspace */
  class_alloc(ptw->ptrp,
              sizeof(struct thermo_reionization_parameters),
              pth->error_message);

  return _SUCCESS_;

}

/**
 * Assign value to each relevant index in vectors of thermodynamical
 * quantities, and the reionization parameters
 *
 * @param pba   Input: pointer to background structure
 * @param pth   Input/Output: pointer to thermodynamics structure
 * @param ptw   Input/Output: pointer to thermo workspace
 * @return the error status
 */

int thermodynamics_indices(
                           struct background * pba,
                           struct thermodynamics * pth,
                           struct thermo_workspace * ptw
                           ) {

  /** Summary: */

  /** - define local variables */
  struct thermo_reionization_parameters* ptrp = ptw->ptrp;
  /* a running index for the vector of thermodynamics quantities */
  int index_th;
  /* a running index for the vector of reionization parameters */
  int index_re;

  /** - initialization of all indices and flags in thermodynamics structure */
  index_th = 0;

  /* Free electron fraction */
  class_define_index(pth->index_th_xe,_TRUE_,index_th,1);
  /* Optical depth and related quantities */
  class_define_index(pth->index_th_dkappa,_TRUE_,index_th,1);
  class_define_index(pth->index_th_ddkappa,_TRUE_,index_th,1);
  class_define_index(pth->index_th_dddkappa,_TRUE_,index_th,1);
  class_define_index(pth->index_th_exp_m_kappa,_TRUE_,index_th,1);
  /* Visibility function + derivatives */
  class_define_index(pth->index_th_g,_TRUE_,index_th,1);
  class_define_index(pth->index_th_dg,_TRUE_,index_th,1);
  class_define_index(pth->index_th_ddg,_TRUE_,index_th,1);
  /* Baryon quantities, Temperature, Sound Speed, Drag time end */
  class_define_index(pth->index_th_Tb,_TRUE_,index_th,1);
  class_define_index(pth->index_th_dTb,_TRUE_,index_th,1);
  class_define_index(pth->index_th_wb,_TRUE_,index_th,1);
  class_define_index(pth->index_th_cb2,_TRUE_,index_th,1);
  class_define_index(pth->index_th_tau_d,_TRUE_,index_th,1);
  /* Derivatives of baryon sound speed (only computed if some non-minimal tight-coupling schemes is requested) */
  class_define_index(pth->index_th_dcb2,pth->compute_cb2_derivatives,index_th,1);
  class_define_index(pth->index_th_ddcb2,pth->compute_cb2_derivatives,index_th,1);

  /* idm quantities  */
  if (pba->has_idm == _TRUE_) {
    /* global quantities */
    class_define_index(pth->index_th_T_idm, pba->has_idm, index_th, 1);
    class_define_index(pth->index_th_c2_idm, pba->has_idm, index_th, 1);
    /* idm-b quantities */
    class_define_index(pth->index_th_R_idm_b,pth->has_idm_b,index_th,1);
    class_define_index(pth->index_th_dR_idm_b,pth->has_idm_b,index_th,1);
    class_define_index(pth->index_th_ddR_idm_b,pth->has_idm_b,index_th,1);
    /* idm-g quantities */
    class_define_index(pth->index_th_dmu_idm_g,pth->has_idm_g, index_th, 1);
    class_define_index(pth->index_th_ddmu_idm_g,pth->has_idm_g, index_th, 1);
    class_define_index(pth->index_th_dddmu_idm_g,pth->has_idm_g, index_th, 1);
    class_define_index(pth->index_th_exp_mu_idm_g,pth->has_idm_g, index_th, 1);
    /* idm-dr quantities */
    class_define_index(pth->index_th_dmu_idm_dr,pth->has_idm_dr, index_th, 1);
    class_define_index(pth->index_th_ddmu_idm_dr,pth->has_idm_dr, index_th, 1);
    class_define_index(pth->index_th_dddmu_idm_dr,pth->has_idm_dr, index_th, 1);
    class_define_index(pth->index_th_tau_idm_dr,pth->has_idm_dr, index_th, 1);
    class_define_index(pth->index_th_tau_idr,pth->has_idm_dr, index_th, 1);
    class_define_index(pth->index_th_g_idm_dr,pth->has_idm_dr, index_th, 1);
  }
  /* idr quantities */
  if (pba->has_idr == _TRUE_) {
    class_define_index(pth->index_th_T_idr,pba->has_idr, index_th, 1);
    class_define_index(pth->index_th_dmu_idr,pba->has_idr, index_th, 1);
  }

  /* Quantity defining the stepsize in perturbations.c */
  class_define_index(pth->index_th_rate,_TRUE_,index_th,1);
  /* Damping scale */
  class_define_index(pth->index_th_r_d,pth->compute_damping_scale,index_th,1);

  /* end of thermodynamics indices */

  pth->th_size = index_th;

  /** - initialization of all indices of parameters of reionization function */

  index_re=0;

  class_define_index(ptrp->index_re_reio_start,_TRUE_,index_re,1);

  switch (pth->reio_parametrization) {

    /* case with no reionization requested */
  case reio_none:
    class_define_index(ptrp->index_re_xe_before,_TRUE_,index_re,1);
    break;

    /* case where x_e(z) taken like in CAMB (other cases can be added) */
  case reio_camb:
  case reio_half_tanh:
    class_define_index(ptrp->index_re_reio_redshift,_TRUE_,index_re,1);
    class_define_index(ptrp->index_re_reio_exponent,_TRUE_,index_re,1);
    class_define_index(ptrp->index_re_reio_width,_TRUE_,index_re,1);
    class_define_index(ptrp->index_re_xe_before,_TRUE_,index_re,1);
    class_define_index(ptrp->index_re_xe_after,_TRUE_,index_re,1);
    class_define_index(ptrp->index_re_helium_fullreio_fraction,_TRUE_,index_re,1);
    class_define_index(ptrp->index_re_helium_fullreio_redshift,_TRUE_,index_re,1);
    class_define_index(ptrp->index_re_helium_fullreio_width,_TRUE_,index_re,1);
    break;

    /* case where x_e(z) is interpolated by tanh between plateaux */
  case reio_bins_tanh:

    /* the code will not only copy here the "bin centers" passed in input. It will add an initial and final value for (z,xe). So
       this array has a dimension bigger than the bin center array */

    ptrp->re_z_size=pth->binned_reio_num+2; /* add two values: beginning and end of reio */

    class_define_index(ptrp->index_re_first_z,_TRUE_,index_re,ptrp->re_z_size);
    class_define_index(ptrp->index_re_first_xe,_TRUE_,index_re,ptrp->re_z_size);
    class_define_index(ptrp->index_re_step_sharpness,_TRUE_,index_re,1);
    class_define_index(ptrp->index_re_xe_before,_TRUE_,index_re,1);
    break;

    /* case where x_e(z) is interpolated by tanh between knots */
  case reio_many_tanh:

    /* the code will not only copy here the "jump centers" passed in input. It will add an initial and final value for (z,xe). So
       this array has a dimension bigger than the jump center array */

    ptrp->re_z_size=pth->many_tanh_num+2; /* add two values: beginning and end of reio */

    class_define_index(ptrp->index_re_first_z,_TRUE_,index_re,ptrp->re_z_size);
    class_define_index(ptrp->index_re_first_xe,_TRUE_,index_re,ptrp->re_z_size);
    class_define_index(ptrp->index_re_step_sharpness,_TRUE_,index_re,1);
    class_define_index(ptrp->index_re_xe_before,_TRUE_,index_re,1);
    break;

    /* case where x_e(z) is linearly interpolated between knots */
  case reio_inter:

    ptrp->re_z_size=pth->reio_inter_num;

    class_define_index(ptrp->index_re_first_z,_TRUE_,index_re,ptrp->re_z_size);
    class_define_index(ptrp->index_re_first_xe,_TRUE_,index_re,ptrp->re_z_size);
    class_define_index(ptrp->index_re_xe_before,_TRUE_,index_re,1);
    break;

  default:
    class_stop(pth->error_message,
               "value of reio_parametrization=%d unclear",pth->reio_parametrization);
    break;
  }
  ptrp->re_size = index_re;

  return _SUCCESS_;

}

/**
 * Initialize the lists (of redshift, tau, etc.) of the thermodynamics struct
 *
 * @param ppr   Input: pointer to precision structure
 * @param pba   Input: pointer to background structure
 * @param pth   Input/Output: pointer to thermodynamics structure
 * @param ptw   Input: pointer to thermo workspace
 * @return the error status
 */

int thermodynamics_lists(
                         struct precision * ppr,
                         struct background* pba,
                         struct thermodynamics* pth,
                         struct thermo_workspace* ptw
                         ) {

  /** Summary: */

  /** Define local variables */
  int index_tau, index_z;
  double zinitial,zlinear;

  pth->tt_size = ptw->Nz_tot;

  /** - allocate tables*/
  class_alloc(pth->tau_table,pth->tt_size*sizeof(double),pth->error_message);
  class_alloc(pth->z_table,pth->tt_size*sizeof(double),pth->error_message);
  class_alloc(pth->thermodynamics_table,pth->th_size*pth->tt_size*sizeof(double),pth->error_message);
  class_alloc(pth->d2thermodynamics_dz2_table,pth->th_size*pth->tt_size*sizeof(double),pth->error_message);

  /** - define time sampling */

  /* Initial z, and the z at which we switch to linear sampling */
  zinitial = ppr->thermo_z_initial;
  zlinear  = ppr->thermo_z_linear;

  /* -> Between z_initial and z_linear, we use the spacing of recombination sampling */
  for (index_z=0; index_z <ptw->Nz_reco_log; index_z++) {
    pth->z_table[(pth->tt_size-1) - index_z] = -(-exp((log(zinitial)-log(zlinear))*(double)(ptw->Nz_reco_log-1-index_z) / (double)(ptw->Nz_reco_log-1)+log(zlinear)));
  }

  /* -> Between z_linear and reionization_z_start_max, we use the spacing of recombination sampling */
  for (index_z=0; index_z <ptw->Nz_reco_lin; index_z++) {
    pth->z_table[(pth->tt_size-1)-(index_z+ptw->Nz_reco_log)] = -(-(zlinear-ppr->reionization_z_start_max) * (double)(ptw->Nz_reco_lin-1-index_z) / (double)(ptw->Nz_reco_lin) - ppr->reionization_z_start_max);
  }

  /* -> Between reionization_z_start_max and 0, we use the spacing of reionization sampling, leaving out the first point to not double-count it */
  for (index_z=0; index_z <ptw->Nz_reio; index_z++) {
    pth->z_table[(pth->tt_size-1)-(index_z+ptw->Nz_reco)] = -(-ppr->reionization_z_start_max * (double)(ptw->Nz_reio-1-index_z) / (double)(ptw->Nz_reio));
  }

  for (index_tau=0; index_tau < pth->tt_size; index_tau++) {
    class_call(background_tau_of_z(pba,
                                   pth->z_table[index_tau],
                                   pth->tau_table+index_tau),
               pba->error_message,
               pth->error_message);
  }

  /** - store initial value of conformal time in the structure */
  pth->tau_ini = pth->tau_table[pth->tt_size-1];

  return _SUCCESS_;
}

/**
 * This routine initializes reionization_parameters for the chosen scheme of reionization function.
 *
 * @param ppr        Input: pointer to precision structure
 * @param pba        Input: pointer to background structure
 * @param pth        Input: pointer to the thermodynamics structure
 * @param preio      Input/Output: pointer to the reionization parameters structure
 * @return the error status
 */

int thermodynamics_set_parameters_reionization(
                                               struct precision * ppr,
                                               struct background * pba,
                                               struct thermodynamics * pth,
                                               struct thermo_reionization_parameters * preio
                                               ) {

  /** Summary: */

  /** Define local variables */
  int bin;
  int point;
  double xe_input,xe_actual,z_sup;

  /** - allocate the vector of parameters defining the function \f$ X_e(z) \f$ */
  class_alloc(preio->reionization_parameters,preio->re_size*sizeof(double),pth->error_message);

  class_test(ppr->reionization_sampling <= 0.0,
             pth->error_message,
             "stop to avoid division by zero. Reionization stepsize has to be larger than zero");

  switch (pth->reio_parametrization) {

    /** - (a) no reionization */
  case reio_none:
    preio->reionization_parameters[preio->index_re_reio_start] = 0.;
    break;

    /** - (b) if reionization implemented like in CAMB, or half tanh like in  1209.0247 */
  case reio_camb:
  case reio_half_tanh:

    /** - --> set values of these parameters, excepted those depending on the reionization redshift */

    if (pth->reio_parametrization == reio_camb) {
      /* xe_after_reio: H + singly ionized He (checked before that denominator is non-zero) */
      preio->reionization_parameters[preio->index_re_xe_after] = 1. + pth->YHe/(_not4_*(1.-pth->YHe));
    }
    if (pth->reio_parametrization == reio_half_tanh) {
      /* xe_after_reio: neglect He ionization */
      preio->reionization_parameters[preio->index_re_xe_after] = 1.;
      //+ 2*pth->YHe/(_not4_*(1.-pth->YHe));    /* xe_after_reio: H + fully ionized He */
    }

    preio->reionization_parameters[preio->index_re_reio_exponent] = pth->reionization_exponent; /* reio_exponent */
    preio->reionization_parameters[preio->index_re_reio_width] = pth->reionization_width;    /* reio_width */
    preio->reionization_parameters[preio->index_re_helium_fullreio_fraction] = pth->YHe/(_not4_*(1.-pth->YHe)); /* helium_fullreio_fraction (checked before that denominator is non-zero) */
    preio->reionization_parameters[preio->index_re_helium_fullreio_redshift] = pth->helium_fullreio_redshift; /* helium_fullreio_redshift */
    preio->reionization_parameters[preio->index_re_helium_fullreio_width] = pth->helium_fullreio_width;    /* helium_fullreio_width */

    class_test(preio->reionization_parameters[preio->index_re_reio_exponent]==0,
               pth->error_message,
               "stop to avoid division by zero");

    class_test(preio->reionization_parameters[preio->index_re_reio_width]==0,
               pth->error_message,
               "stop to avoid division by zero");

    class_test(preio->reionization_parameters[preio->index_re_helium_fullreio_width]==0,
               pth->error_message,
               "stop to avoid division by zero");

    /** - --> if reionization redshift given as an input, initialize the remaining values*/

    if (pth->reio_z_or_tau == reio_z) {

      /* reionization redshift */
      preio->reionization_parameters[preio->index_re_reio_redshift] = pth->z_reio;

      /* infer starting redshift for hydrogen */

      if (pth->reio_parametrization == reio_camb) {

        preio->reionization_parameters[preio->index_re_reio_start] = preio->reionization_parameters[preio->index_re_reio_redshift]+
          ppr->reionization_start_factor*pth->reionization_width;

        /* if starting redshift for helium is larger, take that one (does not happen in realistic models) */
        if (preio->reionization_parameters[preio->index_re_reio_start] <
            pth->helium_fullreio_redshift+ppr->reionization_start_factor*pth->helium_fullreio_width)

          preio->reionization_parameters[preio->index_re_reio_start] =
            pth->helium_fullreio_redshift+ppr->reionization_start_factor*pth->helium_fullreio_width;

      }
      else {

        preio->reionization_parameters[preio->index_re_reio_start] = pth->z_reio;
      }

      class_test(preio->reionization_parameters[preio->index_re_reio_start] > ppr->reionization_z_start_max,
                 pth->error_message,
                 "starting redshift for reionization > reionization_z_start_max = %e\n",ppr->reionization_z_start_max);

    }

    /** - --> if reionization optical depth given as an input, find reionization redshift by bisection and initialize the remaining values */
    if (pth->reio_z_or_tau == reio_tau) {
      z_sup = ppr->reionization_z_start_max-ppr->reionization_start_factor*pth->reionization_width;
      class_test(z_sup < 0.,
                 pth->error_message,
                 "parameters are such that reionization cannot take place before today while starting after z_start_max; need to increase z_start_max");

      /* maximum possible reionization redshift */
      preio->reionization_parameters[preio->index_re_reio_redshift] = z_sup;
      /* maximum possible starting redshift */
      preio->reionization_parameters[preio->index_re_reio_start] = ppr->reionization_z_start_max;
    }
    break;

    /** - (c) if reionization implemented with reio_bins_tanh scheme */
  case reio_bins_tanh:

    /* this algorithm requires at least two bin centers (i.e. at least 4 values in the (z,xe) array, counting the edges). */
    class_test(pth->binned_reio_num<2,
               pth->error_message,
               "current implementation of binned reio requires at least two bin centers");

    /* check that this input can be interpreted by the code */
    for (bin=1; bin<pth->binned_reio_num; bin++) {
      class_test(pth->binned_reio_z[bin-1]>=pth->binned_reio_z[bin],
                 pth->error_message,
                 "value of reionization bin centers z_i expected to be passed in growing order: %e, %e",
                 pth->binned_reio_z[bin-1],
                 pth->binned_reio_z[bin]);
    }

    /* the code will not only copy here the "bin centers" passed in input. It will add an initial and final value for (z,xe).
       First, fill all entries except the first and the last */
    for (bin=1; bin<preio->re_z_size-1; bin++) {
      preio->reionization_parameters[preio->index_re_first_z+bin] = pth->binned_reio_z[bin-1];
      preio->reionization_parameters[preio->index_re_first_xe+bin] = pth->binned_reio_xe[bin-1];
    }

    /* find largest value of z in the array. We choose to define it as z_(i_max) + 2*(the distance between z_(i_max) and z_(i_max-1)). E.g. if
       the bins are in 10,12,14, the largest z will be 18. */
    preio->reionization_parameters[preio->index_re_first_z+preio->re_z_size-1] =
      preio->reionization_parameters[preio->index_re_first_z+preio->re_z_size-2]
      +2.*(preio->reionization_parameters[preio->index_re_first_z+preio->re_z_size-2]
           -preio->reionization_parameters[preio->index_re_first_z+preio->re_z_size-3]);

    /* copy this value in reio_start */
    preio->reionization_parameters[preio->index_re_reio_start] = preio->reionization_parameters[preio->index_re_first_z+preio->re_z_size-1];

    /* check it's not too big */
    class_test(preio->reionization_parameters[preio->index_re_reio_start] > ppr->reionization_z_start_max,
               pth->error_message,
               "starting redshift for reionization = %e, reionization_z_start_max = %e, you must change the binning or increase reionization_z_start_max",
               preio->reionization_parameters[preio->index_re_reio_start],
               ppr->reionization_z_start_max);

    /* find smallest value of z in the array. We choose to define it as z_0 - (the distance between z_1 and z_0). E.g. if
       the bins are in 10,12,14, the stop redshift will be 8. */
    preio->reionization_parameters[preio->index_re_first_z] =
      2.*preio->reionization_parameters[preio->index_re_first_z+1]
      -preio->reionization_parameters[preio->index_re_first_z+2];

    /* check it's not too small */
    /* 6.06.2015: changed this test to simply imposing that the first z is at least zero */
    /*
      class_test(preio->reionization_parameters[preio->index_re_first_z] < 0,
      pth->error_message,
      "final redshift for reionization = %e, you must change the binning or redefine the way in which the code extrapolates below the first value of z_i",preio->reionization_parameters[preio->index_re_first_z]);
    */
    if (preio->reionization_parameters[preio->index_re_first_z] < 0) {
      preio->reionization_parameters[preio->index_re_first_z] = 0.;
    }

    /* infer xe after reio */
    preio->reionization_parameters[preio->index_re_first_xe] = 1. + pth->YHe/(_not4_*(1.-pth->YHe)); /* xe_after_reio: H + singly ionized He (note: segmentation fault impossible,
                                                                                                        checked before that denominator is non-zero) */

    /* pass step sharpness parameter */
    preio->reionization_parameters[preio->index_re_step_sharpness] = pth->binned_reio_step_sharpness;
    break;

    /** - (d) if reionization implemented with reio_many_tanh scheme */
  case reio_many_tanh:

    /* this algorithm requires at least one jump centers */
    class_test(pth->many_tanh_num<1,
               pth->error_message,
               "current implementation of reio_many_tanh requires at least one jump center");

    /* check that z input can be interpreted by the code */
    for (bin=1; bin<pth->many_tanh_num; bin++) {
      class_test(pth->many_tanh_z[bin-1]>=pth->many_tanh_z[bin],
                 pth->error_message,
                 "value of reionization bin centers z_i expected to be passed in growing order: %e, %e",
                 pth->many_tanh_z[bin-1],
                 pth->many_tanh_z[bin]);

    }

    /* the code will not only copy here the "jump centers" passed in input. It will add an initial and final value for (z,xe).
       First, fill all entries except the first and the last */
    for (bin=1; bin<preio->re_z_size-1; bin++) {

      preio->reionization_parameters[preio->index_re_first_z+bin] = pth->many_tanh_z[bin-1];

      /* check that xe input can be interpreted by the code */
      xe_input = pth->many_tanh_xe[bin-1];
      if (xe_input >= 0.) {
        xe_actual = xe_input;
      }
      //-1 means "after hydrogen + first helium recombination"
      else if ((xe_input<-0.9) && (xe_input>-1.1)) {
        xe_actual = 1. + pth->YHe/(_not4_*(1.-pth->YHe));
      }
      //-2 means "after hydrogen + second helium recombination"
      else if ((xe_input<-1.9) && (xe_input>-2.1)) {
        xe_actual = 1. + 2.*pth->YHe/(_not4_*(1.-pth->YHe));
      }
      //other negative number is nonsense
      else {
        class_stop(pth->error_message,
                   "Your entry for many_tanh_xe[%d] is %e, this makes no sense (either positive or 0,-1,-2)",
                   bin-1,pth->many_tanh_xe[bin-1]);
      }

      preio->reionization_parameters[preio->index_re_first_xe+bin] = xe_actual;
    }

    /* find largest value of z in the array. We choose to define it as z_(i_max) + ppr->reionization_start_factor*step_sharpness. */
    preio->reionization_parameters[preio->index_re_first_z+preio->re_z_size-1] =
      preio->reionization_parameters[preio->index_re_first_z+preio->re_z_size-2]
      +ppr->reionization_start_factor*pth->many_tanh_width;

    /* copy this value in reio_start */
    preio->reionization_parameters[preio->index_re_reio_start] = preio->reionization_parameters[preio->index_re_first_z+preio->re_z_size-1];

    /* check it's not too big */
    class_test(preio->reionization_parameters[preio->index_re_reio_start] > ppr->reionization_z_start_max,
               pth->error_message,
               "starting redshift for reionization = %e, reionization_z_start_max = %e, you must change the binning or increase reionization_z_start_max",
               preio->reionization_parameters[preio->index_re_reio_start],
               ppr->reionization_z_start_max);

    /* find smallest value of z in the array. We choose to define it as z_0 - ppr->reionization_start_factor*step_sharpness, but at least zero. */
    preio->reionization_parameters[preio->index_re_first_z] =
      preio->reionization_parameters[preio->index_re_first_z+1]
      -ppr->reionization_start_factor*pth->many_tanh_width;

    if (preio->reionization_parameters[preio->index_re_first_z] < 0) {
      preio->reionization_parameters[preio->index_re_first_z] = 0.;
    }

    /* infer xe after reio */
    preio->reionization_parameters[preio->index_re_first_xe] = preio->reionization_parameters[preio->index_re_first_xe+1];

    /* if we want to model only hydrogen reionization and neglect both helium reionization */
    //preio->reionization_parameters[preio->index_re_first_xe] = 1.;

    /* if we want to model only hydrogen + first helium reionization and neglect second helium reionization */
    //preio->reionization_parameters[preio->index_re_first_xe] = 1. + pth->YHe/(_not4_*(1.-pth->YHe));

    /* if we want to model hydrogen + two helium reionization */
    //preio->reionization_parameters[preio->index_re_first_xe] = 1. + 2.*pth->YHe/(_not4_*(1.-pth->YHe));

    /* pass step sharpness parameter */
    class_test(pth->many_tanh_width<=0,
               pth->error_message,
               "many_tanh_width must be strictly positive, you passed %e",
               pth->many_tanh_width);

    preio->reionization_parameters[preio->index_re_step_sharpness] = pth->many_tanh_width;
    break;

    /** - (e) if reionization implemented with reio_inter scheme */
  case reio_inter:

    /* this parametrization requires at least one point (z,xe) */
    class_test(pth->reio_inter_num<1,
               pth->error_message,
               "current implementation of reio_inter requires at least one point (z,xe)");

    /* this parametrization requires that the first z value is zero */
    class_test(pth->reio_inter_z[0] != 0.,
               pth->error_message,
               "For reio_inter scheme, the first value of reio_inter_z[...]  should always be zero, you passed %e",
               pth->reio_inter_z[0]);

    /* check that z input can be interpreted by the code */
    for (point=1; point<pth->reio_inter_num; point++) {
      class_test(pth->reio_inter_z[point-1]>=pth->reio_inter_z[point],
                 pth->error_message,
                 "value of reionization bin centers z_i expected to be passed in growing order, unlike: %e, %e",
                 pth->reio_inter_z[point-1],
                 pth->reio_inter_z[point]);
    }

    /* this parametrization requires that the last x_i value is zero (the code will substitute it with the value that one would get in
       absence of reionization, as compute by the recombination code) */
    class_test(pth->reio_inter_xe[pth->reio_inter_num-1] != 0.,
               pth->error_message,
               "For reio_inter scheme, the last value of reio_inter_xe[...]  should always be zero, you passed %e",
               pth->reio_inter_xe[pth->reio_inter_num-1]);

    /* copy here the (z,xe) values passed in input. */
    for (point=0; point<preio->re_z_size; point++) {

      preio->reionization_parameters[preio->index_re_first_z+point] = pth->reio_inter_z[point];

      /* check that xe input can be interpreted by the code */
      xe_input = pth->reio_inter_xe[point];
      if (xe_input >= 0.) {
        xe_actual = xe_input;
      }
      //-1 means "after hydrogen + first helium recombination"
      else if ((xe_input<-0.9) && (xe_input>-1.1)) {
        xe_actual = 1. + pth->YHe/(_not4_*(1.-pth->YHe));
      }
      //-2 means "after hydrogen + second helium recombination"
      else if ((xe_input<-1.9) && (xe_input>-2.1)) {
        xe_actual = 1. + 2.*pth->YHe/(_not4_*(1.-pth->YHe));
      }
      //other negative number is nonsense
      else {
        class_stop(pth->error_message,
                   "Your entry for reio_inter_xe[%d] is %e, this makes no sense (either positive or 0,-1,-2)",
                   point,pth->reio_inter_xe[point]);
      }

      preio->reionization_parameters[preio->index_re_first_xe+point] = xe_actual;
    }

    /* copy highest redshift in reio_start */
    preio->reionization_parameters[preio->index_re_reio_start] = preio->reionization_parameters[preio->index_re_first_z+preio->re_z_size-1];

    /* check it's not too big */
    class_test(preio->reionization_parameters[preio->index_re_reio_start] > ppr->reionization_z_start_max,
               pth->error_message,
               "starting redshift for reionization = %e, reionization_z_start_max = %e, you must change the binning or increase reionization_z_start_max",
               preio->reionization_parameters[preio->index_re_reio_start],
               ppr->reionization_z_start_max);
    break;

  default:
    class_stop(pth->error_message,
               "value of reio_parametrization=%d unclear",pth->reio_parametrization);
    break;
  }

  return _SUCCESS_;

}

/**
 * Integrate thermodynamics with your favorite recombination code. The default options are HyRec and RecFastCLASS.
 *
 * Integrate thermodynamics with HyRec or Recfast, allocate and fill part of the thermodynamics interpolation table (the rest is filled in
 * thermodynamics_calculate_remaining_quantitie).
 *
 * Version modified by Daniel Meinert and Nils Schoeneberg to use the ndf15 evolver or any other evolver inherent to CLASS,
 * modified again by Nils Schoeneberg to use wrappers.
 *
 * @param ppr      Input: pointer to precision structure
 * @param pba      Input: pointer to background structure
 * @param pth      Input/Output: pointer to thermodynamics structure where results are stored
 * @param ptw      Input: pointer to thermo_workspace structure used to communicate with generic evolver
 * @param pvecback Input: pointer to an allocated (but empty) vector of background variables
 * @return the error status
 *
 * Integrate thermodynamics with your favorite recombination code. The default options are HyRec and Recfast.
 */

int thermodynamics_solve(
                         struct precision * ppr,
                         struct background * pba,
                         struct thermodynamics * pth,
                         struct thermo_workspace * ptw,
                         double * pvecback
                         ) {
  /** Summary: */

  /** - define local variables */
  /* Index of current approximation scheme */
  int index_ap;
  /* number of time intervals of one approximation scheme */
  int interval_number;
  /* index running over such time intervals */
  int index_interval;
  /* edge of intervals where approximation scheme is uniform: z_ini, z_switch_1, ..., z_end */
  double * interval_limit;
  /* other z sampling variables */
  int i;
  double * mz_output;

  /* contains all fixed parameters which should be passed to thermodynamics_derivs */
  struct thermodynamics_parameters_and_workspace tpaw;

  /* function pointer to ODE evolver and names of possible evolvers. */
  extern int evolver_rk(EVOLVER_PROTOTYPE);
  extern int evolver_ndf15(EVOLVER_PROTOTYPE);
  int (*generic_evolver)(EVOLVER_PROTOTYPE) = evolver_ndf15;

  /** - choose evolver */
  switch (ppr->thermo_evolver) {
  case rk:
    generic_evolver = evolver_rk;
    break;
  case ndf15:
    generic_evolver = evolver_ndf15;
    break;
  }

  /** - define the fields of the 'thermodynamics parameter and workspace' structure */
  tpaw.pba = pba;
  tpaw.ppr = ppr;
  tpaw.pth = pth;
  tpaw.pvecback = pvecback;
  tpaw.ptw = ptw;

  /** - define time sampling: create a local array of minus z values
      called mz (from mz=-zinitial growing towards mz=0) */

  class_alloc(mz_output,pth->tt_size*sizeof(double), pth->error_message);
  for (i=0; i < pth->tt_size; ++i) {
    mz_output[i] = -pth->z_table[pth->tt_size-1-i];
  }

  /** - define intervals for each approximation scheme */

  /* create the array of interval limits */
  class_alloc(interval_limit,(ptw->ptdw->ap_size+1)*sizeof(double),pth->error_message);
  /* fix interval number to number of approximations */
  interval_number = ptw->ptdw->ap_size;
  /* integration starts at z_ini and ends at z_end */
  interval_limit[0]= mz_output[0];
  interval_limit[ptw->ptdw->ap_size] = mz_output[ptw->Nz_tot-1];
  /* each interval ends with the proper ending redshift of its approximation */
  for (index_ap=0; index_ap < ptw->ptdw->ap_size-1; index_ap++) {
    interval_limit[index_ap+1] = -ptw->ptdw->ap_z_limits[index_ap];
  }

  /** - loop over intervals over which approximation scheme is
      uniform. For each interval: */

  for (index_interval=0; index_interval<interval_number; index_interval++) {

    /** - --> (a) fix current approximation scheme. */

    ptw->ptdw->ap_current = index_interval;

    /** - --> (b) define the vector of quantities to be integrated
        over. If the current interval starts from the
        initial time zinitial, fill the vector with initial
        conditions. If it starts from an approximation
        switching point, redistribute correctly the values
        from the previous to the new vector. For both
        RECFAST and HYREC, the vector consists of Tmat, x_H,
        x_He, + others for exotic models */

    class_call(thermodynamics_vector_init(ppr,
                                          pba,
                                          pth,
                                          interval_limit[index_interval],
                                          ptw),
               pth->error_message,
               pth->error_message);

    /* find the value of last_index_back at z = - interval_limit[index_interval], in order to speed up
       subsequent interpolations in thermodynamics_derivs */
    class_call(background_at_z(pba,
                               -interval_limit[index_interval],
                               normal_info,
                               inter_normal,
                               &(ptw->last_index_back),
                               pvecback),
               pba->error_message,
               pth->error_message);

    /** - --> (c1) If we have the optical depth tau_reio as input the
        last evolver step (reionization approximation) is done
        separately in a loop, to find the approximate redshift of
        reionization given the input of tau_reio, using a bisection
        method. This is similar to the general CLASS shooting method,
        but doing this step here is more advantageous since we only
        need to do repeatedly the last approximation step of the
        integration, instead of the full background and thermodynamics
        module */
    if ((pth->reio_z_or_tau == reio_tau) && (index_interval == ptw->ptdw->index_ap_reio)) {

      class_call(thermodynamics_reionization_evolve_with_tau(&tpaw,
                                                             interval_limit[index_interval],
                                                             interval_limit[index_interval+1],
                                                             mz_output,
                                                             pth->tt_size),
                 pth->error_message,
                 pth->error_message);
    }

    /** --> (c2) otherwise, just integrate quantities over the current interval. */
    else{

      class_call(generic_evolver(thermodynamics_derivs,
                                 interval_limit[index_interval],
                                 interval_limit[index_interval+1],
                                 ptw->ptdw->ptv->y,
                                 ptw->ptdw->ptv->used_in_output,
                                 ptw->ptdw->ptv->ti_size,
                                 &tpaw,
                                 ppr->tol_thermo_integration,
                                 ppr->smallest_allowed_variation,
                                 thermodynamics_timescale,  // timescale
                                 ppr->thermo_integration_stepsize, // stepsize = this number * timescale
                                 mz_output, // values of z for output
                                 pth->tt_size, // size of previous array
                                 thermodynamics_sources, // function for output
                                 NULL, // print variables
                                 pth->error_message),
                 pth->error_message,
                 pth->error_message);
    }

  }

  /** - Compute reionization optical depth, if not supplied as input parameter */
  if (pth->reio_z_or_tau == reio_z) {

    class_call(thermodynamics_reionization_get_tau(ppr,
                                                   pba,
                                                   pth,
                                                   ptw),
               pth->error_message,
               pth->error_message);

    pth->tau_reio=ptw->reionization_optical_depth;

  }

  /** - free quantities allocated at the beginning of the routine */
  if (ptw->ptdw->ap_size != 0) {
    class_call(thermodynamics_vector_free(ptw->ptdw->ptv),
               pth->error_message,
               pth->error_message);
  }

  free(interval_limit);
  free(mz_output);

  return _SUCCESS_;

}

/**
 * Calculate those thermodynamics quantities which are not inside of
 * the thermodynamics table already.
 *
 * @param ppr        Input: pointer to precision structure
 * @param pba        Input: pointer to background structure
 * @param pth        Input/Output: pointer to initialized thermodynamics structure
 * @param pvecback   Input: pointer to some allocated pvecback
 * @return the error status
 */

int thermodynamics_calculate_remaining_quantities(
                                                  struct precision * ppr,
                                                  struct background * pba,
                                                  struct thermodynamics* pth,
                                                  double* pvecback
                                                  ) {

  /** Summary: */

  /* The temporary quantities stored in columns ddkappa and dddkappa will not be used anymore, so they can and WILL be overwritten by other
     intermediate steps of other computations */

  class_call(thermodynamics_calculate_conformal_drag_time(pba,pth,pvecback),
             pth->error_message,
             pth->error_message);

  if (pth->compute_damping_scale == _TRUE_) {
    class_call(thermodynamics_calculate_damping_scale(pba,pth,pvecback),
               pth->error_message,
               pth->error_message);
  }

  class_call(thermodynamics_calculate_opticals(ppr,pth),
             pth->error_message,
             pth->error_message);

  /* Please note, this function has to be before the spline_table_lines to generate the correct d2thdz2_table */
  if (pba->has_idr == _TRUE_ || pth->has_idm_b == _TRUE_) {
    class_call(thermodynamics_calculate_idm_and_idr_quantities(ppr,pba,pth,pvecback),
               pth->error_message,
               pth->error_message);
  }

  /** - fill tables of second derivatives with respect to z (in view of spline interpolation) */
  class_call(array_spline_table_lines(pth->z_table,
                                      pth->tt_size,
                                      pth->thermodynamics_table,
                                      pth->th_size,
                                      pth->d2thermodynamics_dz2_table,
                                      _SPLINE_EST_DERIV_,
                                      pth->error_message),
             pth->error_message,
             pth->error_message);

  class_call(thermodynamics_calculate_recombination_quantities(ppr,pba,pth,pvecback),
             pth->error_message,
             pth->error_message);

  class_call(thermodynamics_calculate_drag_quantities(ppr,pba,pth,pvecback),
             pth->error_message,
             pth->error_message);


  return _SUCCESS_;
}

/**
 * In verbose mode, print basic information on the thermal history
 *
 * @param pba   Input: pointer to background structure
 * @param pth   Input/Output: pointer to initialized thermodynamics structure
 * @return the error status
 */

int thermodynamics_output_summary(
                                  struct background* pba,
                                  struct thermodynamics* pth
                                  ) {

  /** Summary: */

  /** Define local variables */
  double tau_reio;

  printf(" -> recombination (maximum of visibility function) at z = %f\n",pth->z_rec);
  printf("    corresponding to conformal time = %f Mpc\n",pth->tau_rec);
  printf("    with comoving sound horizon = %f Mpc\n",pth->rs_rec);
  printf("    angular diameter distance = %f Mpc\n",pth->da_rec);
  printf("    sound horizon angle 100*theta_s = %f\n",100.*pth->rs_rec/pth->ra_rec);
  if (pth->compute_damping_scale == _TRUE_) {
    printf("    comoving photon damping scale = %f Mpc\n",pth->rd_rec);
    printf("    comoving damping wavenumber k_d = %f 1/Mpc\n",2.*_PI_/pth->rd_rec);
  }
  printf("    Thomson optical depth crosses one at z_* = %f\n",pth->z_star);
  printf("    giving an angle 100*theta_* = %f\n",100.*pth->rs_star/pth->ra_star);
  printf(" -> baryon drag stops at z = %f\n",pth->z_d);
  printf("    corresponding to conformal time = %f Mpc\n",pth->tau_d);
  printf("    with comoving sound horizon rs = %f Mpc\n",pth->rs_d);

  switch (pth->reio_parametrization) {

  case reio_none:
    /* the information returned by this line could be interesting when
       using reio_none + exotic energy ionjection, since there could
       still be a global minimum of x_e(z) */
    printf(" -> no reionization requested, optical depth = %f\n",pth->tau_reio);
    break;

  case reio_camb:
  case reio_half_tanh:
    switch (pth->reio_z_or_tau) {
    case reio_tau:
      printf(" -> reionization at z = %f\n",pth->z_reio);
      break;
    case reio_z:
      printf(" -> reionization with optical depth = %f\n",pth->tau_reio);
      break;
    }
    class_call(background_tau_of_z(pba,pth->z_reio,&tau_reio),
               pba->error_message,
               pth->error_message);
    printf("    corresponding to conformal time = %f Mpc\n",tau_reio);
    break;

  case reio_bins_tanh:
    printf(" -> binned reionization gives optical depth = %f\n",pth->tau_reio);
    break;

  case reio_many_tanh:
    printf(" -> many-step reionization gives optical depth = %f\n",pth->tau_reio);
    break;

  case reio_inter:
    printf(" -> interpolated reionization history gives optical depth = %f\n",pth->tau_reio);
    break;

  default:
    class_stop(pth->error_message,
               "value of reio_parametrization=%d unclear",pth->reio_parametrization);
    break;
  }

  if (pth->thermodynamics_verbose > 1)
    printf(" -> free-streaming approximation can be turned on as soon as tau=%g Mpc\n",pth->tau_free_streaming);
  if ((pba->has_idr == _TRUE_)&&(pth->thermodynamics_verbose > 1))
    printf(" -> dark free-streaming approximation can be turned on as soon as tau=%g Mpc\n",pth->tau_idr_free_streaming);

  return _SUCCESS_;
}

/**
 * Free the thermo_workspace structure (with the exception of the thermo_vector '->ptv' field, which is freed separately in
 * thermo_vector_free).
 *
 * @param pth        Input: pointer to initialized thermodynamics structure
 * @param ptw        Input: pointer to perturbations_workspace structure to be freed
 * @return the error status
 */
int thermodynamics_workspace_free(
                                  struct thermodynamics* pth,
                                  struct thermo_workspace * ptw
                                  ) {

  free(ptw->ptdw->ap_z_limits);
  free(ptw->ptdw->ap_z_limits_delta);

  switch (pth->recombination) {

  case hyrec:
    class_call(thermodynamics_hyrec_free(ptw->ptdw->phyrec),
               ptw->ptdw->phyrec->error_message,
               pth->error_message);
    free(ptw->ptdw->phyrec);
    break;

  case recfast:
    free(ptw->ptdw->precfast);
    break;
  }

  free(ptw->ptrp->reionization_parameters);
  free(ptw->ptdw);
  free(ptw->ptrp);

  free(ptw);

  return _SUCCESS_;
}

/**
 * Initialize the field '->ptv' of a thermo_diffeq_workspace structure, which is a thermo_vector structure. This structure contains indices
 * and values of all quantities which need to be integrated with respect to time (and only them: quantities fixed analytically or obeying
 * constraint equations are NOT included in this vector).
 *
 * The routine sets and allocates the vector y, dy and used_in_output with the right size depending on the current approximation scheme
 * stored in the workspace. Moreover the initial conditions for each approximation scheme are calculated and set correctly.
 *
 *
 * @param ppr        Input: pointer to precision structure
 * @param pba        Input: pointer to background structure
 * @param pth        Input: pointer to the thermodynamics structure
 * @param mz         Input: negative redshift
 * @param ptw        Input/Output: pointer to thermodynamics workspace
 *
 * @return the error status
 */

int thermodynamics_vector_init(
                               struct precision * ppr,
                               struct background * pba,
                               struct thermodynamics * pth,
                               double mz,
                               struct thermo_workspace * ptw
                               ) {

  /** Summary: */

  /** Define local variables */
  int index_ti;
  /* ptdw->ptv unallocated if ap_current == index_ap_brec, allocated and filled otherwise */
  struct thermo_vector * ptv;
  struct thermo_diffeq_workspace * ptdw = ptw->ptdw;
  double z;

  class_alloc(ptv,sizeof(struct thermo_vector),pth->error_message);

  /* mz = Minus z is inverted*/
  z = -mz;

  /* Start from no component */
  index_ti = 0;

  /* Add common indices (Have to be added before) */
  class_define_index(ptv->index_ti_D_Tmat,_TRUE_,index_ti,1);

  /* Add all components that should be evolved */
  if (ptdw->ap_current == ptdw->index_ap_brec) {
    /* Nothing else to add */
  }
  else if (ptdw->ap_current == ptdw->index_ap_He1) {
    /* Nothing else to add */
  }
  else if (ptdw->ap_current == ptdw->index_ap_He1f) {
    /* Nothing else to add */
  }
  else if (ptdw->ap_current == ptdw->index_ap_He2) {
    /* Nothing else to add */
  }
  else if (ptdw->ap_current == ptdw->index_ap_H) {
    class_define_index(ptv->index_ti_x_He,_TRUE_,index_ti,1);
  }
  else if (ptdw->ap_current == ptdw->index_ap_frec) {
    class_define_index(ptv->index_ti_x_He,_TRUE_,index_ti,1);
    class_define_index(ptv->index_ti_x_H,_TRUE_,index_ti,1);
  }
  else if (ptdw->ap_current == ptdw->index_ap_reio) {
    class_define_index(ptv->index_ti_x_He,_TRUE_,index_ti,1);
    class_define_index(ptv->index_ti_x_H,_TRUE_,index_ti,1);
  }

  /* Only in the case where we in idm case but not idm TCA define T_idm */
  if (pba->has_idm == _TRUE_){
    class_define_index(ptv->index_ti_T_idm,(ptw->has_ap_idmtca == _FALSE_ || ptdw->ap_current != ptdw->index_ap_idmtca),index_ti,1);
  }

  /* We have now obtained the full size */
  ptv->ti_size = index_ti;

  /* Allocate all arrays used during the evolution */
  class_calloc(ptv->y,ptv->ti_size,sizeof(double),pth->error_message);
  class_alloc(ptv->dy,ptv->ti_size*sizeof(double),pth->error_message);
  class_alloc(ptv->used_in_output,ptv->ti_size*sizeof(int),pth->error_message);

  for (index_ti=0; index_ti<ptv->ti_size; index_ti++) {
    ptv->used_in_output[index_ti] = _TRUE_;
  }

  if (ptw->has_ap_idmtca == _TRUE_ && ptdw->ap_current == ptdw->index_ap_idmtca) {
    /* Store Tmat in workspace for later use */
    ptdw->Tmat = ptw->Tcmb*(1.+z);

    /* Set the new vector and its indices */
    ptdw->ptv = ptv;

    ptdw->ptv->y[ptdw->ptv->index_ti_D_Tmat] = 0.;

    /* set other initial conditions */
    ptdw->require_H = _FALSE_;
    ptdw->require_He = _FALSE_;
  }
  else if (ptw->has_ap_idmtca == _TRUE_ && ptdw->ap_current == ptdw->index_ap_brec) {
    /* Copy old values */
    ptv->y[ptv->index_ti_D_Tmat] = ptdw->ptv->y[ptdw->ptv->index_ti_D_Tmat];
    ptv->dy[ptv->index_ti_D_Tmat] = ptdw->ptv->dy[ptdw->ptv->index_ti_D_Tmat];

    /* Set initial conditions */
    ptv->y[ptv->index_ti_T_idm] = pba->T_cmb * (1.+z);
    /* If we instead have idr tight coupling, we choose instead */
    if ((pth->has_idm_dr == _TRUE_) && pth->n_index_idm_dr > 0)
      ptv->y[ptv->index_ti_T_idm] = pba->T_idr * (1.+z);

    /* Free the old vector and its indices */
    class_call(thermodynamics_vector_free(ptdw->ptv),
               pth->error_message,
               pth->error_message);

    /* Copy the new vector into the position of the old one */
    ptdw->ptv = ptv;
    ptdw->require_H = _FALSE_;
    ptdw->require_He = _FALSE_;
  }
  else if (ptdw->ap_current == ptdw->index_ap_brec) {

    /* Store Tmat in workspace for later use */
    ptdw->Tmat = ptw->Tcmb*(1.+z);

    /* Set the new vector and its indices */
    ptdw->ptv = ptv;

    ptdw->ptv->y[ptdw->ptv->index_ti_D_Tmat] = 0.;

    ptdw->require_H = _FALSE_;
    ptdw->require_He = _FALSE_;

    /* Set idm initial temperature if not coupled */
    if (pba->has_idm == _TRUE_) {
      class_call(thermodynamics_idm_initial_temperature(pba,
                                                        pth,
                                                        z,
                                                        ptdw),
                 pth->error_message,
                 pth->error_message);
      ptv->y[ptv->index_ti_T_idm] = ptdw->T_idm;
    }
  }
  /* - in this scheme we start to evolve Helium and thus need to set its initial condition via the analytic function */
  else if (ptdw->ap_current == ptdw->index_ap_H) {
    /* Store Tmat in workspace for later use */
    ptdw->Tmat = ptdw->ptv->y[ptdw->ptv->index_ti_D_Tmat] + ptw->Tcmb*(1.+z);

    /* Obtain initial contents of new vector analytically, especially x_He */
    class_call(thermodynamics_ionization_fractions(z,ptdw->ptv->y,pba,pth,ptw,ptdw->ap_current-1),
               pth->error_message,
               pth->error_message);

    /* Set the new vector and its indices */
    ptv->y[ptv->index_ti_D_Tmat] = ptdw->ptv->y[ptdw->ptv->index_ti_D_Tmat];
    ptv->y[ptv->index_ti_x_He] = ptdw->x_He;
    if (pba->has_idm == _TRUE_)
      ptv->y[ptv->index_ti_T_idm] = ptdw->ptv->y[ptdw->ptv->index_ti_T_idm];

    /* Free the old vector and its indices */
    class_call(thermodynamics_vector_free(ptdw->ptv),
               pth->error_message,
               pth->error_message);

    /* Copy the new vector into the position of the old one*/
    ptdw->ptv = ptv;

    ptdw->require_H = _FALSE_;
    ptdw->require_He = _TRUE_;
  }
  /* - in the scheme of full recombination (=frec) we evolve all quantities and thus need to set their initial conditions.
     Tmat and x_He are solely taken from the previous scheme, x_H is set via the analytic function */
  else if (ptdw->ap_current == ptdw->index_ap_frec) {
    /* Store Tmat in workspace for later use */
    ptdw->Tmat = ptdw->ptv->y[ptdw->ptv->index_ti_D_Tmat] + ptw->Tcmb*(1.+z);

    /* Obtain initial contents of new vector analytically, especially x_H */
    class_call(thermodynamics_ionization_fractions(z,ptdw->ptv->y,pba,pth,ptw,ptdw->ap_current-1),
               pth->error_message,
               pth->error_message);

    /* Set the new vector and its indices */
    ptv->y[ptv->index_ti_D_Tmat] = ptdw->ptv->y[ptdw->ptv->index_ti_D_Tmat];
    ptv->y[ptv->index_ti_x_H] = ptdw->x_H;
    ptv->y[ptv->index_ti_x_He] = ptdw->ptv->y[ptdw->ptv->index_ti_x_He];
    if (pba->has_idm == _TRUE_)
      ptv->y[ptv->index_ti_T_idm] = ptdw->ptv->y[ptdw->ptv->index_ti_T_idm];

    /* Free the old vector and its indices */
    class_call(thermodynamics_vector_free(ptdw->ptv),
               pth->error_message,
               pth->error_message);

    /* Copy the new vector into the position of the old one*/

    ptdw->ptv = ptv;

    ptdw->require_H = _TRUE_;
    ptdw->require_He = _TRUE_;
  }
  /* - during reionization we continue to evolve all quantities. Now all three intial conditions are just taken from the previous scheme */
  else if (ptdw->ap_current == ptdw->index_ap_reio) {

    /* Set the new vector and its indices */
    ptv->y[ptv->index_ti_D_Tmat] = ptdw->ptv->y[ptdw->ptv->index_ti_D_Tmat];
    ptv->y[ptv->index_ti_x_H] = ptdw->ptv->y[ptdw->ptv->index_ti_x_H];
    ptv->y[ptv->index_ti_x_He] = ptdw->ptv->y[ptdw->ptv->index_ti_x_He];
    if (pba->has_idm == _TRUE_)
      ptv->y[ptv->index_ti_T_idm] = ptdw->ptv->y[ptdw->ptv->index_ti_T_idm];

    /* Free the old vector and its indices */
    class_call(thermodynamics_vector_free(ptdw->ptv),
               pth->error_message,
               pth->error_message);

    /* Copy the new vector into the position of the old one*/

    ptdw->ptv = ptv;

    ptdw->require_H = _TRUE_;
    ptdw->require_He = _TRUE_;
  }
  /* - in all other approximations we only evolve Tmat and set its initial conditions from the previous scheme */
  else{
    /* Store Tmat in workspace for later use */
    ptdw->Tmat = ptdw->ptv->y[ptdw->ptv->index_ti_D_Tmat] + ptw->Tcmb*(1.+z);

    /* Set the new vector and its indices */
    ptv->y[ptv->index_ti_D_Tmat] = ptdw->ptv->y[ptdw->ptv->index_ti_D_Tmat];
    if (pba->has_idm == _TRUE_)
      ptv->y[ptv->index_ti_T_idm] = ptdw->ptv->y[ptdw->ptv->index_ti_T_idm];

    /* Free the old vector and its indices */
    class_call(thermodynamics_vector_free(ptdw->ptv),
               pth->error_message,
               pth->error_message);

    /* Copy the new vector into the position of the old one*/
    ptdw->ptv = ptv;

    ptdw->require_H = _FALSE_;
    ptdw->require_He = _FALSE_;
  }

  return _SUCCESS_;
}

/**
 * If the input for reionization is tau_reio, thermodynamics_solve()
 * calls this function instead of the evolver for dealing with the
 * last era (the reionization era).
 *
 * Instead of computing the evolution of quantities during
 * reionization for a fixed z_reio, as the evolver would do, this
 * function finds z_reio by bisection. First we make an initial guess
 * for z_reio with reionization_z_start_max and then find a z_reio
 * which leads to the given tau_reio (in the range of tolerance
 * reionization_optical_depth_tol).
 *
 * @param ptpaw      Input: pointer to parameters and workspace
 * @param mz_ini     Input: initial redshift
 * @param mz_end     Input: ending redshift
 * @param mz_output  Input: pointer to redshift array at which output should be written
 * @param mz_size    Input: number of redshift values in this array
 * @return the error status
 */

int thermodynamics_reionization_evolve_with_tau(
                                                struct thermodynamics_parameters_and_workspace * ptpaw,
                                                double mz_ini,
                                                double mz_end,
                                                double * mz_output,
                                                int mz_size
                                                ) {

  /** Summary: */

  /** Define local variables */
  int counter;
  double z_sup,z_mid,z_inf;
  double tau_sup,tau_mid,tau_inf;

  int index_ti;
  int last_index_back_mz_ini;

  struct precision * ppr;
  struct background * pba;
  struct thermodynamics * pth;
  struct thermo_workspace * ptw;

  /* function pointer to ODE evolver and names of possible evolvers */
  extern int evolver_rk(EVOLVER_PROTOTYPE);
  extern int evolver_ndf15(EVOLVER_PROTOTYPE);
  int (*generic_evolver)(EVOLVER_PROTOTYPE) = evolver_ndf15;

  /* pointers towards two thermo vector stuctures (see below) */

  struct thermo_vector * ptvs; // Vector for storing the initial conditions
  struct thermo_vector * ptv; // Temporary vector as workspace

  /** - Remame fields to avoid heavy notations */

  ppr = ptpaw->ppr;
  pba = ptpaw->pba;
  pth = ptpaw->pth;
  ptw = ptpaw->ptw;

  /** - Choose evolver */

  switch (ppr->thermo_evolver) {
  case rk:
    generic_evolver = evolver_rk;
    break;
  case ndf15:
    generic_evolver = evolver_ndf15;
    break;
  }

  /** - ptvs will be a pointer towards the same thermo vector that was
      used in the previous approximation schemes; it contains values
      that will serve here to set initial conditions. */

  ptvs = ptw->ptdw->ptv;

  /** - ptv is a pointer towards a whole new thermo vector used for
      the calculations in the bisection, that we must allocate and
      initialize */

  class_alloc(ptv,sizeof(struct thermo_vector),pth->error_message);

  /* allocate vector indices dynamically */
  index_ti = 0;
  class_define_index(ptv->index_ti_D_Tmat,_TRUE_,index_ti,1);
  class_define_index(ptv->index_ti_x_He,_TRUE_,index_ti,1);
  class_define_index(ptv->index_ti_x_H,_TRUE_,index_ti,1);
  class_define_index(ptv->index_ti_T_idm,pba->has_idm,index_ti,1);
  ptv->ti_size = index_ti;

  /* Allocate all arrays used during the evolution */
  class_calloc(ptv->y,ptv->ti_size,sizeof(double),pth->error_message);
  class_alloc(ptv->dy,ptv->ti_size*sizeof(double),pth->error_message);
  class_alloc(ptv->used_in_output,ptv->ti_size*sizeof(int),pth->error_message);

  for (index_ti=0; index_ti<ptv->ti_size; index_ti++) {
    ptv->used_in_output[index_ti] = _TRUE_;
  }

  /** - Initialize the values of the temporary vector */
  ptv->y[ptv->index_ti_D_Tmat] = ptvs->y[ptvs->index_ti_D_Tmat];
  ptv->y[ptv->index_ti_x_H] = ptvs->y[ptvs->index_ti_x_H];
  ptv->y[ptv->index_ti_x_He] = ptvs->y[ptvs->index_ti_x_He];
  if (pba->has_idm == _TRUE_)
    ptv->y[ptv->index_ti_T_idm] = ptvs->y[ptvs->index_ti_T_idm];

  ptw->ptdw->ptv = ptv;

  /** - Evolve quantities through reionization assuming upper value of z_reio */

  z_sup = ppr->reionization_z_start_max-ppr->reionization_start_factor*pth->reionization_width;
  class_test(z_sup < 0.,
             pth->error_message,
             "parameters are such that reionization cannot take place before today while starting after z_start_max; need to increase z_start_max");

  /* maximum possible reionization redshift */
  ptw->ptrp->reionization_parameters[ptw->ptrp->index_re_reio_redshift] = z_sup;
  /* maximum possible starting redshift */
  switch (pth->reio_parametrization) {
  case reio_camb:
    ptw->ptrp->reionization_parameters[ptw->ptrp->index_re_reio_start] = ppr->reionization_z_start_max;
    break;
  case reio_half_tanh:
    ptw->ptrp->reionization_parameters[ptw->ptrp->index_re_reio_start] = z_sup;
    break;
  default:
    class_stop(pth->error_message,"Should not be there: tau_reio acan be an input only for reio_camb and reio_half_tanh");
    break;
  }

  /* ptaw->ptw->last_index_back has been properly set according to the
     redshift z = -mz_inbi, we should keep memory of it */
  last_index_back_mz_ini = ptpaw->ptw->last_index_back;

  /* Calculate a first ionization history at upper limit */
  class_call(generic_evolver(thermodynamics_derivs,
                             mz_ini,
                             mz_end,
                             ptv->y,
                             ptv->used_in_output,
                             ptv->ti_size,
                             ptpaw,
                             ppr->tol_thermo_integration,
                             ppr->smallest_allowed_variation,
                             thermodynamics_timescale,  // timescale
                             ppr->thermo_integration_stepsize, // stepsize
                             mz_output, // values of z for output
                             mz_size, // size of previous array
                             thermodynamics_sources, // function for output
                             NULL, // print variables
                             pth->error_message),
             pth->error_message,
             pth->error_message);

  /* infer corresponding tau_reio */
  class_call(thermodynamics_reionization_get_tau(ppr,
                                                 pba,
                                                 pth,
                                                 ptw),
             pth->error_message,
             pth->error_message);

  tau_sup=ptw->reionization_optical_depth;

  class_test(tau_sup < pth->tau_reio,
             pth->error_message,
             "parameters are such that reionization cannot start after z_start_max");

  /** - Restore initial conditions */
  ptv->y[ptv->index_ti_D_Tmat] = ptvs->y[ptvs->index_ti_D_Tmat];
  ptv->y[ptv->index_ti_x_H] = ptvs->y[ptvs->index_ti_x_H];
  ptv->y[ptv->index_ti_x_He] = ptvs->y[ptvs->index_ti_x_He];
  if (pba->has_idm == _TRUE_)
    ptv->y[ptv->index_ti_T_idm] = ptvs->y[ptvs->index_ti_T_idm];

  /** - Evolve quantities through reionization assuming lower value of z_reio */

  z_inf = 0.;

  /* minimum possible reionization redshift */
  ptw->ptrp->reionization_parameters[ptw->ptrp->index_re_reio_redshift] = z_inf;
  /* minimum possible starting redshift */
  switch (pth->reio_parametrization) {
  case reio_camb:
    ptw->ptrp->reionization_parameters[ptw->ptrp->index_re_reio_start] = ppr->reionization_start_factor*pth->reionization_width;
    if (ptw->ptrp->reionization_parameters[ptw->ptrp->index_re_reio_start] < pth->helium_fullreio_redshift+ppr->reionization_start_factor*pth->helium_fullreio_width) {
      ptw->ptrp->reionization_parameters[ptw->ptrp->index_re_reio_start] = pth->helium_fullreio_redshift+ppr->reionization_start_factor*pth->helium_fullreio_width;
    }
  case reio_half_tanh:
    ptw->ptrp->reionization_parameters[ptw->ptrp->index_re_reio_start] = z_inf;
    break;
  default:
    class_stop(pth->error_message,"Should not be there: tau_reio acan be an input only for reio_camb and reio_half_tanh");
    break;
  }

  /* reset ptaw->ptw->last_index_back to match the redshift z = -mz_inbi */
  ptpaw->ptw->last_index_back = last_index_back_mz_ini;

  /* Calculate a second ionization history at lower limit */
  class_call(generic_evolver(thermodynamics_derivs,
                             mz_ini,
                             mz_end,
                             ptv->y,
                             ptv->used_in_output,
                             ptv->ti_size,
                             ptpaw,
                             ppr->tol_thermo_integration,
                             ppr->smallest_allowed_variation,
                             thermodynamics_timescale,  // timescale
                             ppr->thermo_integration_stepsize, // stepsize
                             mz_output, // values of z for output
                             mz_size, // size of previous array
                             thermodynamics_sources, // function for output
                             NULL, // print variables
                             pth->error_message),
             pth->error_message,
             pth->error_message);

  /* infer corresponding tau_reio */
  class_call(thermodynamics_reionization_get_tau(ppr,
                                                 pba,
                                                 pth,
                                                 ptw),
             pth->error_message,
             pth->error_message);

  tau_inf=ptw->reionization_optical_depth;

  class_test(tau_inf > pth->tau_reio,
             pth->error_message,
             "CLASS cannot reach the low value of tau_reio that was selected, even when setting z_reio as low as 0.\nThis means that some additional physical component is requiring some minimal tau_reio_min = %.10e.\nThis is usually caused by strong energy injections or other modifications of the x_e(z) behaviour.",tau_inf);

  /** - Restore initial conditions */
  ptv->y[ptv->index_ti_D_Tmat] = ptvs->y[ptvs->index_ti_D_Tmat];
  ptv->y[ptv->index_ti_x_H] = ptvs->y[ptvs->index_ti_x_H];
  ptv->y[ptv->index_ti_x_He] = ptvs->y[ptvs->index_ti_x_He];
  if (pba->has_idm == _TRUE_)
    ptv->y[ptv->index_ti_T_idm] = ptvs->y[ptvs->index_ti_T_idm];

  /** - Evolve quantities through reionization, trying intermediate values of z_reio by bisection */
  counter=0;
  while ((tau_sup-tau_inf) > pth->tau_reio * ppr->reionization_optical_depth_tol) {
    z_mid=0.5*(z_sup+z_inf);

    /* reionization redshift */
    ptw->ptrp->reionization_parameters[ptw->ptrp->index_re_reio_redshift] = z_mid;

    /* infer starting redshift for hydrogen (Note, that this is only the start of the ADDITIONAL tanh re-ionization function)*/
    switch (pth->reio_parametrization) {
    case reio_camb:
      ptw->ptrp->reionization_parameters[ptw->ptrp->index_re_reio_start] = ptw->ptrp->reionization_parameters[ptw->ptrp->index_re_reio_redshift]+ppr->reionization_start_factor*pth->reionization_width;
      /* if starting redshift for helium is larger, take that one
       *    (does not happen in realistic models) */
      if (ptw->ptrp->reionization_parameters[ptw->ptrp->index_re_reio_start] < pth->helium_fullreio_redshift+ppr->reionization_start_factor*pth->helium_fullreio_width) {
        ptw->ptrp->reionization_parameters[ptw->ptrp->index_re_reio_start] = pth->helium_fullreio_redshift+ppr->reionization_start_factor*pth->helium_fullreio_width;
      }
      break;
    case reio_half_tanh:
      ptw->ptrp->reionization_parameters[ptw->ptrp->index_re_reio_start] = z_mid;
      break;
    default:
      class_stop(pth->error_message,"Should not be there: tau_reio acan be an input only for reio_camb and reio_half_tanh");
      break;
    }

    class_test(ptw->ptrp->reionization_parameters[ptw->ptrp->index_re_reio_start] > ppr->reionization_z_start_max,
               pth->error_message,
               "starting redshift for reionization > reionization_z_start_max = %e",ppr->reionization_z_start_max);

    /* reset ptaw->ptw->last_index_back to match the redshift z = -mz_inbi */
    ptpaw->ptw->last_index_back = last_index_back_mz_ini;

    /* Compute a new ionization history */
    class_call(generic_evolver(thermodynamics_derivs,
                               mz_ini,
                               mz_end,
                               ptv->y,
                               ptv->used_in_output,
                               ptv->ti_size,
                               ptpaw,
                               ppr->tol_thermo_integration,
                               ppr->smallest_allowed_variation,
                               thermodynamics_timescale,  // timescale
                               ppr->thermo_integration_stepsize, // stepsize
                               mz_output, // values of z for output
                               mz_size, // size of previous array
                               thermodynamics_sources, // function for output
                               NULL, // print variables
                               pth->error_message),
               pth->error_message,
               pth->error_message);

    /* infer corresponding tau_reio */
    class_call(thermodynamics_reionization_get_tau(ppr,
                                                   pba,
                                                   pth,
                                                   ptw),
               pth->error_message,
               pth->error_message);

    tau_mid=ptw->reionization_optical_depth;

    /* trial */
    if (tau_mid > pth->tau_reio) {
      z_sup=z_mid;
      tau_sup=tau_mid;
    }
    else {
      z_inf=z_mid;
      tau_inf=tau_mid;
    }

    /* Restore initial conditions */
    ptv->y[ptv->index_ti_D_Tmat] = ptvs->y[ptvs->index_ti_D_Tmat];
    ptv->y[ptv->index_ti_x_H] = ptvs->y[ptvs->index_ti_x_H];
    ptv->y[ptv->index_ti_x_He] = ptvs->y[ptvs->index_ti_x_He];
    if (pba->has_idm == _TRUE_)
      ptv->y[ptv->index_ti_T_idm] = ptvs->y[ptvs->index_ti_T_idm];

    /* counter to avoid infinite loop */
    counter++;
    class_test(counter > _MAX_IT_,
               pth->error_message,
               "while searching for reionization_optical_depth, maximum number of iterations exceeded");
  }

  /** - Store the ionization redshift in the thermodynamics structure */
  pth->z_reio = ptw->ptrp->reionization_parameters[ptw->ptrp->index_re_reio_redshift];

  /** - Free tempeoraty thermo vector */
  class_call(thermodynamics_vector_free(ptv),
             pth->error_message,
             pth->error_message);

  /* point ptw->ptdw->ptv to same location as when entering the function */
  ptw->ptdw->ptv = ptvs;

  return _SUCCESS_;
}

/**
 * Subroutine evaluating the derivative of thermodynamical quantities
 * with respect to negative redshift mz=-z.
 *
 * Automatically recognizes the current approximation interval and
 * computes the derivatives for this interval of the vector y, which
 * contains (Tmat, x_H, x_He) + others for exotic models.
 *
 * Derivatives are obtained either by calling either HyRec 2020 (Lee and Ali-Haimoud 2020, 2007.14114)
 * or RecFastCLASS (that is, RecFast version 1.5, modified by Daniel Meinert and Nils Schoeneberg for
 * better precision and smoothness at early times). See credits and licences in the wrappers (in external/...)
 *
 * This is one of the few functions in the code which are passed to the generic_evolver routine.  Since generic_evolver
 * should work with functions passed from various modules, the format of the arguments is a bit special:
 *
 * - fixed parameters and workspaces are passed through a generic pointer. Here, this pointer contains the precision, background
 *   and thermodynamics structures, plus a background vector, but generic_evolver doesn't know its precise structure.
 *
 * - the error management is a bit special: errors are not written as usual to pth->error_message, but to a generic error_message
 *   passed in the list of arguments.
 *
 * @param mz                       Input: negative redshift mz = -z
 * @param y                        Input: vector of variable to integrate
 * @param dy                       Output: its derivative (already allocated)
 * @param parameters_and_workspace Input: pointer to fixed parameters (e.g. indices) and workspace (already allocated)
 * @param error_message            Output: error message
 */

int thermodynamics_derivs(
                          double mz,
                          double * y,
                          double * dy,
                          void * parameters_and_workspace,
                          ErrorMsg error_message
                          ) {
  /** Summary: */

  /** Define local variables */
  /* Index for iterating over derivatives */
  int index_ti;

  /* Shorthand notations */
  double z,x,nH,Trad,Tmat,x_H,x_He,Hz,eps,depsdlna,dHdlna,heat_capacity,rate_gamma_b;

  /* Baryon molecular weight */
  double mu_bar;

  /* Shorthand notations for all of the structs */
  struct thermodynamics_parameters_and_workspace * ptpaw;
  struct precision * ppr;
  struct background * pba;
  struct thermodynamics * pth;
  double * pvecback;
  struct thermo_workspace * ptw;
  struct thermo_diffeq_workspace * ptdw;
  struct thermo_vector * ptv;
  struct thermorecfast * precfast;
  struct injection * pin;
  int ap_current;

  /* varying fundamental constants */
  double alpha = 1., me = 1., rescale_rate = 1.;

  /* Redshift */
  z = -mz;

  /** - Rename structure fields (just to avoid heavy notations) */

  /* structures */
  ptpaw = parameters_and_workspace;
  ppr = ptpaw->ppr;
  pba = ptpaw->pba;
  pth = ptpaw->pth;
  pin = &(pth->in);
  /* vector of background quantities */
  pvecback = ptpaw->pvecback;
  /* thermodynamics workspace & vector */
  ptw = ptpaw->ptw;
  ptdw = ptw->ptdw;
  ptv = ptdw->ptv;
  /* pointer to Recfast/HyRec wrappers */
  precfast = ptdw->precfast;
  /* Approximation flag */
  ap_current = ptdw->ap_current;

  /** - Get background/thermo quantities in this point */

  class_call(background_at_z(pba,
                             z,
                             long_info,
                             inter_closeby,
                             &(ptw->last_index_back),
                             pvecback),
             pba->error_message,
             error_message);

  /* Hz is H in inverse seconds (while pvecback returns [H0/c] in inverse Mpcs) */
  Hz = pvecback[pba->index_bg_H] * _c_ / _Mpc_over_m_;

  /* Total number density of Hydrogen nuclei in SI units */
  nH = ptw->SIunit_nH0 * (1.+z) * (1.+z) * (1.+z);

  /* Photon temperature in Kelvins. Modify this for some non-trivial photon temperature changes */
  Trad = ptw->Tcmb * (1.+z);

  /** Set Tmat from the evolver (it is always evolved) and store it in the workspace. */
  Tmat = y[ptv->index_ti_D_Tmat] + ptw->Tcmb*(1.+z);

  /* For varying fundamental constants (according to 1705.03925) */
  if (pth->has_varconst == _TRUE_) {
    alpha = pvecback[pba->index_bg_varc_alpha];
    me = pvecback[pba->index_bg_varc_me];
    rescale_rate = alpha*alpha/me/me/me;
  }

  /** - The input vector y contains thermodynamic variables like
      (Tmat, x_H,x_He).  The goal of this function is: 1) Depending on
      the chosen code and current approximation, to use either
      analytical approximations or the vector y to calculate x_e; 2) To
      compute re-ionization effects on x_e; The output of this function
      is stored in the workspace ptdw */

  class_call(thermodynamics_ionization_fractions(z,y,pba,pth,ptw,ap_current),
             pth->error_message,
             error_message);

  /* Save the output in local variables */
  x = ptdw->x_reio;

  /** - If needed, calculate heating effects (i.e. any possible energy deposition rates
      affecting the evolution equations for x and Tmat) */

  if (pth->has_exotic_injection == _TRUE_) {
    /* In case of energy injection, we currently neglect the contribution to helium ionization for RecFast ! */
    /* Note that we calculate here the energy injection INCLUDING reionization ! */
    class_call(injection_calculate_at_z(pba,pth,x,z,Tmat,pvecback),
               pin->error_message,
               error_message);
  }

  /** - Derivative of the ionization fractions */
  x_H = ptdw->x_H;
  x_He = ptdw->x_He;
  x = ptdw->x_noreio;
  switch (pth->recombination) {

    /** --> use Recfast or HyRec to get the derivatives d(x_H)/dz and
        d(x_He)/dz, and store the result directly in the vector
        dy. This gives the derivative of the ionization fractions from
        recombination only (not from reionization). Of course, the
        full treatment would involve the actual evolution equations
        for x_H and x_He during reionization, but these are not yet
        fully implemented. */
  case recfast:
    precfast->fsR = alpha; /**< Pass value of fsR = relative alpha (fine-structure) */
    precfast->meR = me;    /**< Pass value of meR = relative m_e (effective eletron mass) */
    /* Hydrogen equations */
    if (ptdw->require_H == _TRUE_) {
      class_call(recfast_dx_H_dz(pth,precfast,x_H,x,nH,z,Hz,Tmat,Trad,&(dy[ptv->index_ti_x_H])),
                 precfast->error_message,
                 error_message);
    }

    /* Helium equations */
    if (ptdw->require_He == _TRUE_) {
      class_call(recfast_dx_He_dz(pth,precfast,x_He,x,x_H,nH,z,Hz,Tmat,Trad,&(dy[ptv->index_ti_x_He])),
                 precfast->error_message,
                 error_message);
    }

    break;
  case hyrec:
    /* Hydrogen equations */
    if (ptdw->require_H == _TRUE_) {
      class_call(hyrec_dx_H_dz(pth,ptw->ptdw->phyrec,x_H,x_He,x,nH,z,Hz,Tmat,Trad,alpha,me,&(dy[ptv->index_ti_x_H])),
                 ptw->ptdw->phyrec->error_message,
                 error_message);
    }

    /* Helium equations */
    if (ptdw->require_He == _TRUE_) {
      class_call(hyrec_dx_He_dz(pth,ptw->ptdw->phyrec,x_H,x_He,x,nH,z,Hz,Tmat,Trad,alpha,me,&(dy[ptv->index_ti_x_He])),
                 ptw->ptdw->phyrec->error_message,
                 error_message);
    }
    break;
  }

  /** - Derivative of the matter temperature (relevant for both Recfast and HyRec cases) */

  /* Restore the real x for the temperature equations. */
  x = ptdw->x_reio;

  /** - Calculate quantities for interacting dark matter */
  if (pba->has_idm == _TRUE_ || pba->has_idr == _TRUE_) {
    class_call(thermodynamics_idm_quantities(pba, z, y, dy, pth, ptw, pvecback),
               pth->error_message,
               pth->error_message);
  }

  /* Using the following definitions and equations, we derive a few important quantities
     Using n_e = x * n_H, n_He = f * n_H, rho_He ~ YHe * rho_b, rho_H ~ (1-YHe)*rho_b)
     - Heat capacity of the IGM
     heat_capacity = (3/2)*k_B*(n_H+n_He+n_e) = (3/2)*k_B*(1+f+x)*n_H
     - Mean baryonic molecular mass
     mu_bar = (rho_H + rho_He + rho_e)/(n_H + n_He + n_e) ~ ( (1. + YHe/(1+YHe) + 0.) * rho_H )/( (1. + f + x) * n_H) = m_H / (1+x+f) /(1-YHe)
     - Photon-baryon momentum transfer rate
     R_g = (4/3 * rho_g/rho_b) * (sigma_T * n_e) = (4/3 * rho_g * sigma_T ) * x * (1-YHe)/m_H
     - Photon-Baryon interaction rate:
     rate_gamma_b = 2 * mu_bar / m_e * R_g =  2 * (sigma_T/m_e) * (4/3 * rho_g) * x / (1. + f + x)
  */
  /* Photon-Baryon temperature change rate  */
  rate_gamma_b = ( 2. * _sigma_/_m_e_/_c_ ) * ( 4./3. * pvecback[pba->index_bg_rho_g] * _Jm3_over_Mpc2_ ) * x / (1.+x+ptw->fHe);
  if (pth->has_varconst == _TRUE_) {
    rate_gamma_b *= rescale_rate;
  }

  /* Heat capacity of the IGM */
  heat_capacity = (3./2.)*_k_B_*nH*(1.+ptw->fHe+x);

  /*
   * A note on the temperature definition:
   *
   * All equations work with D_Tmat = Tmat - Trad
   *
   * Thus all derivatives are calculated as dD_Tmat/dz = dTmat/dz - Tcmb
   **/

  /*
   * A note on the 'early' time steady state expansion (activated here before HeIII recombination):
   *
   * Note: dTr/dz = Tr/(1+z) = Tcmb
   *
   * The early system of CMB and matter is very tightly coupled anyway, so we can expand in the following way:
   * The full equation is dTm/dz = (Tm-Tr)/e /(1+z) + 2 Tm/(1+z). Here e = H*(1+x+f)/(cT*Tr^4*x) << 1 at early times
   *
   * Find the first order solution in e, by multiplying in (1+z)*e, and approximate
   *  e*(dTm/dz)*(1+z) ~ e*(dTr/dz)*(1+z) + O(e^2) ~ e * Tr
   *
   * You find e*Tr = (Tm-Tr) + 2 Tm * e
   * Thus Tm = (1+e)/(1+2*e) * Tr = Tr * (1-e) + O(e^2)
   *
   * This is the steady state solution, which is the SAME as e.g. in HyRec
   * In our notation, eps = e*Tr, so we get Tm = Tr - eps
   *
   * So, taking the derivative of the right hand side, we obtain dTm/dz = Tcmb - eps*(dln(eps)/dz)
   *
   * Now use the form of eps = Tr*e = H*(1+x+f)/(cT*Tr^3*x) to derive the remaining terms in the below formula
   * => dln(eps)/dlna = dln(H)/dlna  - (1+f)/(1+x+f)*dln(x)/dlna + 3*dln(Tr)/dlna
   *
   * We also approximate dln(x)/dlna << 1, since we are before HeIII recombination, thus finding
   * => dln(eps)/dlna ~ dln(H)/dlna + 3
   *
   * dD_Tmat/dz = d(-eps)/dz = - eps * dln(eps)/dz = eps *dln(eps)/dlna /(1.+z)
   **/

  if ( ap_current == ptdw->index_ap_brec || (ptw->has_ap_idmtca == _TRUE_ && ap_current == ptdw->index_ap_idmtca)) {
    /* Early time steady state equation */
    dHdlna = (1.+z)*pvecback[pba->index_bg_H_prime]/pvecback[pba->index_bg_H] * _c_ / _Mpc_over_m_;
    eps =  Trad * Hz / rate_gamma_b;
    depsdlna = dHdlna/Hz + 3.;
    /* Recfast v 1.5: add here a smoothing term as suggested by Adam Moss */
    dy[ptdw->ptv->index_ti_D_Tmat] = eps * depsdlna / (1.+z);
  }

  else {
    /* Full equations at later times */
    dy[ptv->index_ti_D_Tmat] =
      + 2.*Tmat/(1.+z)                                                          /* Adiabatic expansion */
      + rate_gamma_b * (Tmat-Trad) / (Hz*(1.+z))                                /* Coupling to photons*/
      - ptw->Tcmb;                                                              /* dTrad/dz */

    /* Add heating from energy injection */
    if (pth->has_exotic_injection == _TRUE_) {
      dy[ptv->index_ti_D_Tmat] -= pin->pvecdeposition[pin->index_dep_heat] / heat_capacity / (Hz*(1.+z));
    }
    /* Add term coming from idm_b */
    if (pth->has_idm_b == _TRUE_){
      mu_bar = _m_H_ / (1. + x + ptw->fHe) / (1. - pth->YHe); //In units of kg
      dy[ptv->index_ti_D_Tmat] += 2.* pvecback[pba->index_bg_rho_idm]/pvecback[pba->index_bg_rho_b]
        * mu_bar/(pth->m_idm*_eV_/_c_/_c_ + _m_p_)
        * ptdw->R_idm_b*(Tmat-ptdw->T_idm) / (pvecback[pba->index_bg_a]*pvecback[pba->index_bg_H]*(1.+z));
    }
  }

  /** - Derivative of the Dark Matter temperature */
  if (pba->has_idm == _TRUE_ && !(ptw->has_ap_idmtca == _TRUE_ && ap_current == ptdw->index_ap_idmtca)) {
    dy[ptv->index_ti_T_idm] = - ptdw->T_idm_prime; // the negative sign will be negated at the end
  }

  /** - If we have extreme heatings, recombination does not fully happen
   * and/or re-ionization happens before a redshift of
   * reionization_z_start_max (default = 50).  We want to catch this
   * unphysical regime, because it would lead to further errors
   * (and/or unphysical calculations) within our recombination codes
   */

  class_test((x>1.0) && (z < ppr->z_end_reco_test) && (z > ppr->reionization_z_start_max),
             error_message,
             "At redshift %.5g : Recombination did not complete by redshift %.5g, or re-ionization happened before %.5g.\nIf this is a desired behavior, please adjust z_end_reco_test and/or reionization_z_start_max.",
             z,ppr->z_end_reco_test,ppr->reionization_z_start_max);

  /** - invert all derivatives (because the evolver evolves with -z, not with +z) */

  for (index_ti=0;index_ti<ptdw->ptv->ti_size;index_ti++) {
    dy[index_ti]=-dy[index_ti];
  }

  return _SUCCESS_;
}

/**
 * This function is relevant for the rk evolver, not ndf15. It
 * estimates a timescale 'delta z' over which quantitites vary. The rk
 * evolver divides large intervals in steps given by this timescale
 * multiplied by ppr->thermo_integration_stepsize.
 *
 * This is one of the few functions in the code which is passed to the generic_evolver routine. Since generic_evolver
 * should work with functions passed from various modules, the format of the arguments is a bit special:
 *
 * - fixed parameters and workspaces are passed through a generic pointer. generic_evolver doesn't know the content of this
 *   pointer.
 *
 * - the error management is a bit special: errors are not written as usual to pth->error_message, but to a generic error_message passed
 *   in the list of arguments.
 *
 * @param mz                              Input: minus the redshift
 * @param thermo_parameters_and_workspace Input: pointer to parameters and workspace
 * @param timescale                       Output: pointer to the timescale
 * @param error_message                   Output: possible errors are written here
 * @return the error status
 */

int thermodynamics_timescale(
                             double mz,
                             void * thermo_parameters_and_workspace,
                             double * timescale,
                             ErrorMsg error_message
                             ) {

  int index_z;
  struct thermodynamics_parameters_and_workspace * ptpaw;

  ptpaw = thermo_parameters_and_workspace;

  /* We could evaluate the timescale automatically, e.g, as [x / (dx/dz)]. */

  /* But for simplicity, we assume that the array of values of z to
     sample (pth->z_table) has been chosen in such way that the
     quantities vary only by a small amount over each step. Thus we
     define our step as delta(-z) = ((-z_i+1) - (-z_i)) = (z_i -
     z_i+1) */

  /* find index_z such that pth->z_table[index_z] > z > pth->z_table[index_z+1] */
  class_call(array_hunt_ascending(ptpaw->pth->z_table,
                                  ptpaw->pth->tt_size,
                                  -mz,
                                  &index_z,
                                  error_message),
             error_message,
             error_message);

  *timescale = ptpaw->pth->z_table[index_z+1] - ptpaw->pth->z_table[index_z];

  return _SUCCESS_;
}

/**
 * This function is passed to the generic evolver and is called whenever we want to store values for a given mz.
 *
 * The ionization fraction is either computed within a call to
 * thermodynamics_derivs(). Moreover there is an automatic smoothing
 * enabled which smoothes out the the ionization_fraction after each
 * approximation switch. This is also the place where HyRec is asked
 * to evolve x(z) using its internal system of differential equations
 * over the next range [z_i, z_i+1], and to store the result in a
 * temporary table.
 *
 * This is one of the few functions in the code which is passed to the generic_evolver routine. Since generic_evolver
 * should work with functions passed from various modules, the format of the arguments is a bit special:
 *
 * - fixed parameters and workspaces are passed through a generic pointer. generic_evolver doesn't know the content of this
 *   pointer.
 *
 * - the error management is a bit special: errors are not written as usual to pth->error_message, but to a generic error_message passed
 *   in the list of arguments.
 *
 * All quantities are computed by a simple call to thermodynamics_derivs, which computes all necessary quantities
 * and stores them in the ptdw thermo_diffeq_workspace structure
 *
 * @param mz                              Input: negative redshift, belonging to array mz_output
 * @param y                               Input: vector of evolved thermodynamical quantities
 * @param dy                              Input: derivatives of this vector w.r.t redshift
 * @param index_z                         Input: index in the array mz_output
 * @param thermo_parameters_and_workspace Input/Output: in input, all parameters needed by thermodynamics_derivs; in output, recombination table
 * @param error_message            Output: error message
 * @return the error status
 */

int thermodynamics_sources(
                           double mz,
                           double * y,
                           double * dy,
                           int index_z,
                           void * thermo_parameters_and_workspace,
                           ErrorMsg error_message
                           ) {

  /** Summary: */

  /** Define local variables */
  /* Shorthand notations */
  double z,x=0.,Tmat,Trad,dTmat;
  /* Varying fundamental constants */
  double sigmaTrescale = 1.,alpha = 1.,me = 1.;
  /* Recfast smoothing */
  double x_previous, weight,s;
  /* Structures as shorthand_notation */
  struct thermodynamics_parameters_and_workspace * ptpaw;
  struct background * pba;
  struct thermodynamics * pth;
  struct thermo_workspace * ptw;
  struct thermo_diffeq_workspace * ptdw;
  struct thermo_vector * ptv;
  int ap_current;

  /* Redshift */
  z = -mz;

  /** - Rename structure fields (just to avoid heavy notations) */

  /* Structs */
  ptpaw = thermo_parameters_and_workspace;
  pba = ptpaw->pba;
  pth = ptpaw->pth;
  /* Thermo workspace & vector */
  ptw = ptpaw->ptw;
  ptdw = ptw->ptdw;
  ptv = ptdw->ptv;
  /* Approximation flag */
  ap_current = ptdw->ap_current;

  if (pth->has_exotic_injection == _TRUE_) {
    /* Tell heating module that it should store the heating at this z in its internal table */
    (pth->in).to_store = _TRUE_;
  }

  /** - Recalculate all quantities at this current redshift: we need
      at least pvecback, ptdw->x_reio, dy[ptv->index_ti_D_Tmat] */

  class_call(thermodynamics_derivs(mz,y,dy,thermo_parameters_and_workspace,error_message),
             error_message,
             error_message);

  /* Assign local variables (note that pvecback is filled through derivs) */
  Trad = ptw->Tcmb*(1.+z);
  Tmat = y[ptv->index_ti_D_Tmat] + Trad;
  /* Note that dy[index_ti_Q] represents dQ/d(-z), thus we need -dy here */
  dTmat = -dy[ptv->index_ti_D_Tmat] + Trad/(1.+z);

  /* Get sigmaT rescale factor from fundamental constants */
  if (pth->has_varconst == _TRUE_) {
    class_call(background_varconst_of_z(pba, z, &alpha, &me),
               pba->error_message,
               pth->error_message);
    sigmaTrescale = alpha*alpha/me/me;
  }

  /* get x */
  x = ptdw->x_reio;

  /** - In the recfast case, we manually smooth the results a bit */

  /* Smoothing if we are shortly after an approximation switch, i.e. if z is within 2 delta after the switch*/
  if ((ap_current != 0) && (z > ptdw->ap_z_limits[ap_current-1]-2*ptdw->ap_z_limits_delta[ap_current])) {

    class_call(thermodynamics_ionization_fractions(z,y,pba,pth,ptw,ap_current-1),
               pth->error_message,
               error_message);

    x_previous = ptdw->x_reio;
    // get s from 0 to 1
    s = (ptdw->ap_z_limits[ap_current-1]-z)/(2*ptdw->ap_z_limits_delta[ap_current]);
    // infer f2(x) = smooth function interpolating from 0 to 1
    weight = f2(s);

    /* get smoothed x */
    x = weight*x+(1.-weight)*x_previous;
  }

  /** - Store the results in the table. Results are obtained in order of decreasing z, and stored in order of growing z */

  /* ionization fraction */
  pth->thermodynamics_table[(pth->tt_size-index_z-1)*pth->th_size+pth->index_th_xe] = x;

  /* Tb */
  pth->thermodynamics_table[(pth->tt_size-index_z-1)*pth->th_size+pth->index_th_Tb] = Tmat;

  /* Baryon temperature derivative */
  pth->thermodynamics_table[(pth->tt_size-index_z-1)*pth->th_size+pth->index_th_dTb] = dTmat;

  /* wb = (k_B/mu) Tb */
  pth->thermodynamics_table[(pth->tt_size-index_z-1)*pth->th_size+pth->index_th_wb]
    = _k_B_ / ( _c_ * _c_ * _m_H_ ) * (1. + (1./_not4_ - 1.) * ptw->YHe + x * (1.-ptw->YHe)) * Tmat;

  /* cb2 = (k_B/mu) Tb (1-1/3 dlnTb/dlna) = (k_B/mu) Tb (1 + 1/3 (1+z) dlnTb/dz) */
  pth->thermodynamics_table[(pth->tt_size-index_z-1)*pth->th_size+pth->index_th_cb2]
    = _k_B_ / ( _c_ * _c_ * _m_H_ ) * (1. + (1./_not4_ - 1.) * ptw->YHe + x * (1.-ptw->YHe)) * Tmat * (1. + (1.+z) * dTmat / Tmat / 3.);

  /* dkappa/dtau = a n_e x_e sigma_T = a^{-2} n_e(today) x_e sigma_T (in units of 1/Mpc) */
  pth->thermodynamics_table[(pth->tt_size-index_z-1)*pth->th_size+pth->index_th_dkappa]
    = (1.+z) * (1.+z) * ptw->SIunit_nH0 * x * sigmaTrescale * _sigma_ * _Mpc_over_m_;

  if (pba->has_idm == _TRUE_) {
    pth->thermodynamics_table[(pth->tt_size-index_z-1)*pth->th_size + pth->index_th_T_idm] = ptdw->T_idm;
    pth->thermodynamics_table[(pth->tt_size-index_z-1)*pth->th_size + pth->index_th_c2_idm] = ptdw->c2_idm;
    if (pth->has_idm_g == _TRUE_) {
      pth->thermodynamics_table[(pth->tt_size-index_z-1)*pth->th_size + pth->index_th_dmu_idm_g] = ptdw->dmu_idm_g;
    }
    if (pth->has_idm_dr == _TRUE_) {
      pth->thermodynamics_table[(pth->tt_size-index_z-1)*pth->th_size + pth->index_th_dmu_idm_dr]  = ptdw->dmu_idm_dr;
      pth->thermodynamics_table[(pth->tt_size-index_z-1)*pth->th_size + pth->index_th_ddmu_idm_dr] = ptdw->Sinv_idm_dr * ptdw->dmu_idm_dr; /* store temporarily in 'wrong' column */
    }
    if (pth->has_idm_b == _TRUE_){
      pth->thermodynamics_table[(pth->tt_size-index_z-1)*pth->th_size+pth->index_th_R_idm_b] = ptdw->R_idm_b;
    }
  }
  if (pba->has_idr == _TRUE_) {
    pth->thermodynamics_table[(pth->tt_size-index_z-1)*pth->th_size + pth->index_th_T_idr] = pba->T_idr*(1.+z);
    pth->thermodynamics_table[(pth->tt_size-index_z-1)*pth->th_size + pth->index_th_dmu_idr] = ptdw->dmu_idr;
  }

  return _SUCCESS_;
}

/**
 * Get the optical depth of reionization tau_reio for a given thermodynamical history.
 *
 * @param ppr        Input: pointer to precision structure
 * @param pba        Input: pointer to background structure
 * @param pth        Input: pointer to the thermodynamics structure
 * @param ptw        Input: pointer to thermodynamics workspace
 * @return the error status
 */

int thermodynamics_reionization_get_tau(
                                        struct precision * ppr,
                                        struct background * pba,
                                        struct thermodynamics * pth,
                                        struct thermo_workspace * ptw
                                        ) {

  /** Summary: */

  /** Define local variables */
  /* running index inside thermodynamics table */
  int index_z,index_reio_start=0;
  double x_e_min;

  x_e_min = _HUGE_;

  /**
   * We are searching now for the start of reionization. This will be
   * the time at which the optical depth tau_reio will be computed.
   *
   * Note that the value reionization_parameters[index_reio_start] is
   * only the start of the reionization function added manually, but
   * not necessarily the total start of reionization. Reionization
   * could be longer/shifted by energy injection.
   *
   * The actual the definition of tau_reio is not unique and
   * unambiguous. We defined it here to be the optical depth up to the
   * time at which there is a global minimum in the free electron
   * fraction. We search for this time by iterating over the
   * thermodynamics table, in order to find the corresponding
   * index_reio_start.
   */

  for (index_z=0; index_z<pth->tt_size-1; index_z++) {
    if (pth->thermodynamics_table[index_z*pth->th_size+pth->index_th_xe] < x_e_min) {
      x_e_min = pth->thermodynamics_table[index_z*pth->th_size+pth->index_th_xe];
      index_reio_start = index_z;
    }
  }

  class_test(index_reio_start == pth->tt_size,
             pth->error_message,
             "reionization start = %e > largest redshift in thermodynamics table",pth->z_table[index_reio_start]);

  if (index_reio_start == 0) {
    /* the global minimum of xe(z) is at z=0. This is possible in
       models no reionization and no exotic energy
       injection. According to our definition of the reionization
       optical depth, tau_reio should then be zero. */
    ptw->reionization_optical_depth = 0;
    return _SUCCESS_;
  }
  if (index_reio_start < 3) {
    /* we need a minimum of three values to do a spline integration in the next step */
    index_reio_start =3;
  }

  /** - --> spline \f$ d \tau / dz \f$ with respect to z in view of
   *         integrating for optical depth between 0 and the just found
   *         starting index
   */
  class_call(array_spline_table_line_to_line(pth->tau_table,
                                             index_reio_start,
                                             pth->thermodynamics_table,
                                             pth->th_size,
                                             pth->index_th_dkappa,
                                             pth->index_th_dddkappa,
                                             _SPLINE_EST_DERIV_,
                                             pth->error_message),
             pth->error_message,
             pth->error_message);

  /** - --> integrate for optical depth */
  class_call(array_integrate_all_spline_table_line_to_line(pth->tau_table,
                                                           index_reio_start,
                                                           pth->thermodynamics_table,
                                                           pth->th_size,
                                                           pth->index_th_dkappa,
                                                           pth->index_th_dddkappa,
                                                           &(ptw->reionization_optical_depth),
                                                           pth->error_message),
             pth->error_message,
             pth->error_message);

  ptw->reionization_optical_depth *= -1; // tau and z go in reverse order, so we must flip the sign

  return _SUCCESS_;
}

/**
 * Free the thermo_vector structure, which is the '->ptv' field of the thermodynamics_differential_workspace ptdw structure
 *
 * @param tv        Input: pointer to thermo_vector structure to be freed
 * @return the error status
 */

int thermodynamics_vector_free(
                               struct thermo_vector * tv
                               ) {

  free(tv->y);
  free(tv->dy);
  free(tv->used_in_output);
  free(tv);

  return _SUCCESS_;
}

/**
 * Compute the baryon drag conformal time tau_d = [int_{tau_today}^{tau} dtau -dkappa_d/dtau]
 *
 * @param pba                Input: pointer to background structure
 * @param pth                Input/Output: pointer to initialized thermodynamics structure
 * @param pvecback           Input: Initialized vector of background quantities
 * @return the error status
 */

int thermodynamics_calculate_conformal_drag_time(
                                                 struct background* pba,
                                                 struct thermodynamics* pth,
                                                 double* pvecback
                                                 ) {

  /** Summary: */

  /** Define local variables */
  double R;
  int index_tau;
  int last_index_back;

  /** - compute minus the baryon drag interaction rate time, -dkappa_d/dtau = -[1/R * kappa'], with R = 3 rho_b / 4 rho_gamma,
      stored temporarily in column ddkappa */

  /* find the value of last_index_back for tau_table[0] in order to speed up subsequent interpolations in the loop */
  class_call(background_at_tau(pba,
                               pth->tau_table[0],
                               normal_info,
                               inter_normal,
                               &last_index_back,
                               pvecback),
             pba->error_message,
             pth->error_message);

  for (index_tau=0; index_tau < pth->tt_size; index_tau++) {

    class_call(background_at_tau(pba,
                                 pth->tau_table[index_tau],
                                 normal_info,
                                 inter_closeby,
                                 &last_index_back,
                                 pvecback),
               pba->error_message,
               pth->error_message);

    R = 3./4.*pvecback[pba->index_bg_rho_b]/pvecback[pba->index_bg_rho_g];

    pth->thermodynamics_table[index_tau*pth->th_size+pth->index_th_ddkappa] =
      -1./R*pth->thermodynamics_table[index_tau*pth->th_size+pth->index_th_dkappa];

  }

  /** - compute second derivative of this rate, -[1/R * kappa']'', stored temporarily in column dddkappa */
  class_call(array_spline_table_line_to_line(pth->tau_table,
                                             pth->tt_size,
                                             pth->thermodynamics_table,
                                             pth->th_size,
                                             pth->index_th_ddkappa,
                                             pth->index_th_dddkappa,
                                             _SPLINE_EST_DERIV_,
                                             pth->error_message),
             pth->error_message,
             pth->error_message);

  /** - compute tau_d = [int_{tau_today}^{tau} dtau -dkappa_d/dtau] */
  class_call(array_integrate_spline_table_line_to_line(pth->tau_table,
                                                       pth->tt_size,
                                                       pth->thermodynamics_table,
                                                       pth->th_size,
                                                       pth->index_th_ddkappa,
                                                       pth->index_th_dddkappa,
                                                       pth->index_th_tau_d,
                                                       pth->error_message),
             pth->error_message,
             pth->error_message);

  return _SUCCESS_;
}

/**
 * Compute the damping scale
 *   r_d = 2pi/k_d = 2pi * [int_{tau_ini}^{tau} dtau (1/kappa') 1/6 (R^2+16/15(1+R))/(1+R)^2]^1/2
 *                 =  2pi * [int_{tau_ini}^{tau} dtau (1/kappa') 1/6 (R^2/(1+R)+16/15)/(1+R)]^1/2
 *
 * which is like in CosmoTherm (CT), but slightly different from Wayne Hu (WH)'s thesis eq. (5.59):
 * The factor 16/15 in CT is 4/5 in WH, but 16/15 is taking more effects into account
 *
 * @param pba                Input: pointer to background structure
 * @param pth                Input/Output: pointer to initialized thermodynamics structure
 * @param pvecback           Input: Initialized vector of background quantities
 * @return the error status
 */

int thermodynamics_calculate_damping_scale(
                                           struct background* pba,
                                           struct thermodynamics* pth,
                                           double* pvecback
                                           ) {

  /** Summary: */

  /** Define local variables */
  double R;
  /* Initial time and dkappa/dtau */
  double tau_ini,dkappa_ini;
  double* tau_table_growing;
  int index_tau;
  int last_index_back;

  class_alloc(tau_table_growing,pth->tt_size*sizeof(double),pth->error_message);

  /* find the value of last_index_back for
     tau_table[pth->tt_size-1] = tau_table_growing[0] in order to
     speed up subsequent interpolations in the loop */
  class_call(background_at_tau(pba,
                               pth->tau_table[pth->tt_size-1],
                               normal_info,
                               inter_normal,
                               &last_index_back,
                               pvecback),
             pba->error_message,
             pth->error_message);

  /* compute integrand and store temporarily in column "ddkappa" */
  for (index_tau=0; index_tau < pth->tt_size; index_tau++) {

    tau_table_growing[index_tau] = pth->tau_table[pth->tt_size-1-index_tau];

    class_call(background_at_tau(pba,
                                 tau_table_growing[index_tau],
                                 normal_info,
                                 inter_closeby,
                                 &last_index_back,
                                 pvecback),
               pba->error_message,
               pth->error_message);

    R = 3./4.*pvecback[pba->index_bg_rho_b]/pvecback[pba->index_bg_rho_g];

    pth->thermodynamics_table[index_tau*pth->th_size+pth->index_th_ddkappa] =
      1./6./pth->thermodynamics_table[(pth->tt_size-1-index_tau)*pth->th_size+pth->index_th_dkappa]
      *(R*R/(1+R)+16./15.)/(1.+R);

  }

  /* compute second derivative of integrand, and store temporarily in column "dddkappa" */
  class_call(array_spline_table_line_to_line(tau_table_growing,
                                             pth->tt_size,
                                             pth->thermodynamics_table,
                                             pth->th_size,
                                             pth->index_th_ddkappa,
                                             pth->index_th_dddkappa,
                                             _SPLINE_EST_DERIV_,
                                             pth->error_message),
             pth->error_message,
             pth->error_message);

  /* compute integratal and store temporarily in column "g" */
  class_call(array_integrate_spline_table_line_to_line(tau_table_growing,
                                                       pth->tt_size,
                                                       pth->thermodynamics_table,
                                                       pth->th_size,
                                                       pth->index_th_ddkappa,
                                                       pth->index_th_dddkappa,
                                                       pth->index_th_g,
                                                       pth->error_message),
             pth->error_message,
             pth->error_message);

  free(tau_table_growing);

  /* we could now write the result as r_d = 2pi * sqrt(integral),
   *  but we will first better acount for the contribution frokm the tau_ini boundary.
   *  Close to this boundary, R=0 and the integrand is just 16/(15*6)/kappa'
   *  Using kappa' propto 1/a^2 and tau propro a during RD, we get the analytic result:
   *  int_0^{tau_ini} dtau / kappa' = tau_ini / 3 / kappa'_ini
   *  Thus r_d = 2pi * sqrt( 16/(15*6*3) * (tau_ini/ kappa'_ini) * integral)
   */

  tau_ini = pth->tau_table[pth->tt_size-1];
  dkappa_ini = pth->thermodynamics_table[(pth->tt_size-1)*pth->th_size+pth->index_th_dkappa];

  for (index_tau=0; index_tau < pth->tt_size; index_tau++) {

    pth->thermodynamics_table[index_tau*pth->th_size+pth->index_th_r_d] =
      2.*_PI_*sqrt(16./(15.*6.*3.)*tau_ini/dkappa_ini
                   +pth->thermodynamics_table[(pth->tt_size-1-index_tau)*pth->th_size+pth->index_th_g]);

  }

  return _SUCCESS_;
}


/**
 * Calculate quantities relating to optical phenomena like kappa' and exp(-kappa) and the visibility function,
 * optical depth (including dark matter photon interactions if necessary)
 *
 * @param ppr   Input: pointer to precision structure
 * @param pth   Input/Output: pointer to thermodynamics structure
 * @return the error status
 */

int thermodynamics_calculate_opticals(
                                      struct precision* ppr,
                                      struct thermodynamics* pth
                                      ) {

  /** Summary: */

  /** Define local quantities */
  /* Visibility function value */
  double g;
  /* kappa derivative values*/
  double dkappa,ddkappa,dddkappa,expmkappa;
  int index_tau;

  /** - --> second derivative with respect to tau of dkappa (in view of of spline interpolation) */
  class_call(array_spline_table_line_to_line(pth->tau_table,
                                             pth->tt_size,
                                             pth->thermodynamics_table,
                                             pth->th_size,
                                             pth->index_th_dkappa,
                                             pth->index_th_dddkappa,
                                             _SPLINE_EST_DERIV_,
                                             pth->error_message),
             pth->error_message,
             pth->error_message);

  /** - --> first derivative with respect to tau of dkappa (using spline interpolation) */
  class_call(array_derive_spline_table_line_to_line(pth->tau_table,
                                                    pth->tt_size,
                                                    pth->thermodynamics_table,
                                                    pth->th_size,
                                                    pth->index_th_dkappa,
                                                    pth->index_th_dddkappa,
                                                    pth->index_th_ddkappa,
                                                    pth->error_message),
             pth->error_message,
             pth->error_message);

  /** - --> compute -kappa = [int_{tau_today}^{tau} dtau dkappa/dtau], store temporarily in column "g" */
  class_call(array_integrate_spline_table_line_to_line(pth->tau_table,
                                                       pth->tt_size,
                                                       pth->thermodynamics_table,
                                                       pth->th_size,
                                                       pth->index_th_dkappa,
                                                       pth->index_th_dddkappa,
                                                       pth->index_th_g,
                                                       pth->error_message),
             pth->error_message,
             pth->error_message);


  /** if there is idm_g, calculate its optical contributions */
  if (pth->has_idm_g == _TRUE_) {
    /** - --> second derivative with respect to tau of dmu (in view of of spline interpolation) */
    class_call(array_spline_table_line_to_line(pth->tau_table,
                                               pth->tt_size,
                                               pth->thermodynamics_table,
                                               pth->th_size,
                                               pth->index_th_dmu_idm_g,
                                               pth->index_th_dddmu_idm_g,
                                               _SPLINE_EST_DERIV_,
                                               pth->error_message),
               pth->error_message,
               pth->error_message);

    /** - --> first derivative with respect to tau of dmu (using spline interpolation) */
    class_call(array_derive_spline_table_line_to_line(pth->tau_table,
                                                      pth->tt_size,
                                                      pth->thermodynamics_table,
                                                      pth->th_size,
                                                      pth->index_th_dmu_idm_g,
                                                      pth->index_th_dddmu_idm_g,
                                                      pth->index_th_ddmu_idm_g,
                                                      pth->error_message),
               pth->error_message,
               pth->error_message);

    /** - --> compute -mu = [int_{tau_today}^{tau} dtau dmu/dtau], store temporarily in column "exp_mu_idm_g" */
    class_call(array_integrate_spline_table_line_to_line(pth->tau_table,
                                                         pth->tt_size,
                                                         pth->thermodynamics_table,
                                                         pth->th_size,
                                                         pth->index_th_dmu_idm_g,
                                                         pth->index_th_dddmu_idm_g,
                                                         pth->index_th_exp_mu_idm_g,
                                                         pth->error_message),
               pth->error_message,
               pth->error_message);

  }
  /** - --> compute visibility: \f$ g= (d \kappa/d \tau) e^{- \kappa} \f$ */

  /* loop on z (decreasing z, increasing time) */
  for (index_tau=pth->tt_size-1; index_tau>=0; index_tau--) {

    dkappa = pth->thermodynamics_table[index_tau*pth->th_size+pth->index_th_dkappa];
    ddkappa = pth->thermodynamics_table[index_tau*pth->th_size+pth->index_th_ddkappa];
    dddkappa = pth->thermodynamics_table[index_tau*pth->th_size+pth->index_th_dddkappa];
    expmkappa = exp(pth->thermodynamics_table[index_tau*pth->th_size+pth->index_th_g]);

    /* This would be the rate without accounting for idm_g : */
    /* pth->thermodynamics_table[index_tau*pth->th_size+pth->index_th_rate] = */
    /*   sqrt(pow(dkappa,2)+pow(ddkappa/dkappa,2)+fabs(dddkappa/dkappa)); */

    pth->thermodynamics_table[index_tau*pth->th_size+pth->index_th_exp_m_kappa] = expmkappa;

    /* presence of idm_g modifies visibility function */
    if (pth->has_idm_g == _TRUE_) {
      dkappa += pth->thermodynamics_table[index_tau*pth->th_size + pth->index_th_dmu_idm_g];
      ddkappa += pth->thermodynamics_table[index_tau*pth->th_size+pth->index_th_ddmu_idm_g];
      dddkappa += pth->thermodynamics_table[index_tau*pth->th_size+pth->index_th_dddmu_idm_g];
      pth->thermodynamics_table[index_tau*pth->th_size+pth->index_th_exp_mu_idm_g] =
        exp(pth->thermodynamics_table[index_tau*pth->th_size+pth->index_th_exp_mu_idm_g]); /* we previously calculated -mu_idm_g and stored it here */
      expmkappa *= pth->thermodynamics_table[index_tau*pth->th_size+pth->index_th_exp_mu_idm_g];
    }

    /** - ---> compute g */
    g = dkappa * expmkappa;

    /* for some very extreme models, in the last line, the exponential of a large negative number could go beyond
     * the range covered by the "double" representation numbers, and be set to zero. To avoid a division by zero in
     * the next steps, it is then better to set it to the minimum non-zero double (this has no impact on observables). */
    if (g==0.) g=DBL_MIN;

    /** - ---> compute g' (the plus sign of the second term is correct, see def of -kappa in thermodynamics module!) */
    pth->thermodynamics_table[index_tau*pth->th_size+pth->index_th_dg] =
      (ddkappa + dkappa * dkappa) * expmkappa;

    /** - ---> compute g''  */
    pth->thermodynamics_table[index_tau*pth->th_size+pth->index_th_ddg] =
      (dddkappa + dkappa * ddkappa * 3. + dkappa * dkappa * dkappa ) * expmkappa;

    /** - ---> store g */
    pth->thermodynamics_table[index_tau*pth->th_size+pth->index_th_g] = g;

    /** - ---> compute variation rate */
    class_test(pth->thermodynamics_table[index_tau*pth->th_size+pth->index_th_dkappa] == 0.,
               pth->error_message,
               "variation rate diverges");

    pth->thermodynamics_table[index_tau*pth->th_size+pth->index_th_rate] =
      sqrt(pow(dkappa,2)+pow(ddkappa/dkappa,2)+fabs(dddkappa/dkappa));

  }

  /** - smooth the rate (details of smoothing unimportant: only the
      order of magnitude of the rate matters) */
  class_call(array_smooth(pth->thermodynamics_table,
                          pth->th_size,
                          pth->tt_size,
                          pth->index_th_rate,
                          ppr->thermo_rate_smoothing_radius,
                          pth->error_message),
             pth->error_message,
             pth->error_message);

  /** - --> derivatives of baryon sound speed (only computed if some non-minimal tight-coupling schemes is requested) */
  if (pth->compute_cb2_derivatives == _TRUE_) {

    /** - ---> second derivative with respect to tau of cb2 */
    class_call(array_spline_table_line_to_line(pth->tau_table,
                                               pth->tt_size,
                                               pth->thermodynamics_table,
                                               pth->th_size,
                                               pth->index_th_cb2,
                                               pth->index_th_ddcb2,
                                               _SPLINE_EST_DERIV_,
                                               pth->error_message),
               pth->error_message,
               pth->error_message);

    /** - ---> first derivative with respect to tau of cb2 (using spline interpolation) */
    class_call(array_derive_spline_table_line_to_line(pth->tau_table,
                                                      pth->tt_size,
                                                      pth->thermodynamics_table,
                                                      pth->th_size,
                                                      pth->index_th_cb2,
                                                      pth->index_th_ddcb2,
                                                      pth->index_th_dcb2,
                                                      pth->error_message),
               pth->error_message,
               pth->error_message);
  }

  return _SUCCESS_;
}

/**
 * Calculate dark optical depths, idm_b interation rate, and other quantities relevant
 * for idm and idr.
 *
 * @param ppr                Input: pointer to precision structure
 * @param pba                Input: pointer to background structure
 * @param pth                Input/Output: pointer to initialized thermo structure
 * @param pvecback           Input: Initialized vector of background quantities
 *
 * @return the error status
 **/
int thermodynamics_calculate_idm_and_idr_quantities(struct precision* ppr,
                                                    struct background * pba,
                                                    struct thermodynamics * pth,
                                                    double* pvecback){

  /** Summary: **/

  /** - Define local variables **/
  int index_tau_fs;
  int index_tau;

  /** - Calculate optical functions tau_idm_dr, tau_idr, g_idm_dr */
  if (pth->has_idm_dr == _TRUE_) {
    /* - second derivative of idm_dr interaction rate (with idr), [Sinv*dmu_idm_dr]'', stored temporarily in column dddmu */
    class_call(array_spline_table_line_to_line(pth->tau_table,
                                               pth->tt_size,
                                               pth->thermodynamics_table,
                                               pth->th_size,
                                               pth->index_th_ddmu_idm_dr,
                                               pth->index_th_dddmu_idm_dr,
                                               _SPLINE_EST_DERIV_,
                                               pth->error_message),
               pth->error_message,
               pth->error_message);

    /* - compute optical depth of idm, tau_idm_dr = [int_{tau_today}^{tau} dtau [Sinv*dmu_idm_dr] ].*/
    /*    This step gives -tau_idm_dr. The resulty is mutiplied by -1 later on. */
    class_call(array_integrate_spline_table_line_to_line(pth->tau_table,
                                                         pth->tt_size,
                                                         pth->thermodynamics_table,
                                                         pth->th_size,
                                                         pth->index_th_ddmu_idm_dr,
                                                         pth->index_th_dddmu_idm_dr,
                                                         pth->index_th_tau_idm_dr,
                                                         pth->error_message),
               pth->error_message,
               pth->error_message);

    /* - second derivative of idr interaction rate (with idm_dr), [dmu_idm_idr]'', stored temporarily in column dddmu */
    class_call(array_spline_table_line_to_line(pth->tau_table,
                                               pth->tt_size,
                                               pth->thermodynamics_table,
                                               pth->th_size,
                                               pth->index_th_dmu_idm_dr,
                                               pth->index_th_dddmu_idm_dr,
                                               _SPLINE_EST_DERIV_,
                                               pth->error_message),
               pth->error_message,
               pth->error_message);

    /* - compute optical depth of idr, tau_idr = [int_{tau_today}^{tau} dtau [dmu_idm_idr] ]. */
    /*   This step gives -tau_idr. The resulty is mutiplied by -1 later on. */
    class_call(array_integrate_spline_table_line_to_line(pth->tau_table,
                                                         pth->tt_size,
                                                         pth->thermodynamics_table,
                                                         pth->th_size,
                                                         pth->index_th_dmu_idm_dr,
                                                         pth->index_th_dddmu_idm_dr,
                                                         pth->index_th_tau_idr,
                                                         pth->error_message),
               pth->error_message,
               pth->error_message);


    /* - restore correct sign for idm_dr and idr optical depth, and calculate idm_dr visibility function */
    /* loop on z (decreasing z, increasing time) */

    for (index_tau=pth->tt_size-1; index_tau>=0; index_tau--) {
      /* - --> restore the correct sign for tau_idm_dr */
      pth->thermodynamics_table[index_tau*pth->th_size+pth->index_th_tau_idm_dr] *= -1.;

      /* - --> restore the correct sign for tau_idr */
      pth->thermodynamics_table[index_tau*pth->th_size+pth->index_th_tau_idr] *= -1.;

      /* - --> visibility function for idm_dr : g_idm_dr = [Sinv*dmu_idm_dr] * exp(-tau_idm_dr) */
      pth->thermodynamics_table[index_tau*pth->th_size+pth->index_th_g_idm_dr] =
        pth->thermodynamics_table[index_tau*pth->th_size+pth->index_th_ddmu_idm_dr]
        * exp(-pth->thermodynamics_table[index_tau*pth->th_size+pth->index_th_tau_idm_dr]);
    }

    /* - fill columns for ddmu_idm_dr and dddmu_idm_dr with true values, and compute idm_dr temperature and sound speed */
    /* - --> second derivative with respect to tau of dmu_idm_dr (in view of spline interpolation) */
    class_call(array_spline_table_line_to_line(pth->tau_table,
                                               pth->tt_size,
                                               pth->thermodynamics_table,
                                               pth->th_size,
                                               pth->index_th_dmu_idm_dr,
                                               pth->index_th_dddmu_idm_dr,
                                               _SPLINE_EST_DERIV_,
                                               pth->error_message),
               pth->error_message,
               pth->error_message);

    /* - --> first derivative with respect to tau of dmu_idm_dr (using spline interpolation) */
    class_call(array_spline_table_line_to_line(pth->tau_table,
                                               pth->tt_size,
                                               pth->thermodynamics_table,
                                               pth->th_size,
                                               pth->index_th_dmu_idm_dr,
                                               pth->index_th_dddmu_idm_dr,
                                               _SPLINE_EST_DERIV_,
                                               pth->error_message),
               pth->error_message,
               pth->error_message);

    /* - --> first derivative with respect to tau of dmu_idm_dr (using spline interpolation) */
    class_call(array_derive_spline_table_line_to_line(pth->tau_table,
                                                      pth->tt_size,
                                                      pth->thermodynamics_table,
                                                      pth->th_size,
                                                      pth->index_th_dmu_idm_dr,
                                                      pth->index_th_dddmu_idm_dr,
                                                      pth->index_th_ddmu_idm_dr,
                                                      pth->error_message),
               pth->error_message,
               pth->error_message);

  }

  /** - Find interacting dark radiation free-streaming time */
  /* First, find index of recombination, or free streaming for ordinary radiation */
  index_tau = pth->tt_size - 1;
  while(1./pth->thermodynamics_table[(index_tau)*pth->th_size+pth->index_th_dkappa]/pth->tau_table[index_tau] < ppr->radiation_streaming_trigger_tau_c_over_tau && index_tau > 0)
    index_tau--;
  index_tau_fs = index_tau;

  /** - Search after the above free-streaming time for idr free-streaming as well */
  if (pth->has_idm_dr == _TRUE_) {

    if (pth->n_index_idm_dr>=2) {
      index_tau=index_tau_fs-1;
      while ((1./pth->thermodynamics_table[(index_tau)*pth->th_size+pth->index_th_dmu_idm_dr]/pth->tau_table[index_tau]
              < ppr->idr_streaming_trigger_tau_c_over_tau) && index_tau > 0)
        index_tau--;
    }
    else {
      index_tau=0;
      while ((1./pth->thermodynamics_table[(index_tau)*pth->th_size+pth->index_th_dmu_idm_dr]/pth->tau_table[index_tau]
              < ppr->idr_streaming_trigger_tau_c_over_tau) && index_tau < pth->tt_size-1)
        index_tau++;
    }

    /* tau_idm_dr_fs = tau; */
    pth->tau_idr_free_streaming = pth->tau_table[index_tau];
  }
  /* case of idr alone without idm_dr: Set idr free streaming simply to normal free-streaming */
  else {
    index_tau= (index_tau_fs > 0 ? index_tau_fs - 1: 0);
    pth->tau_idr_free_streaming = pth->tau_table[index_tau];
  }

  if (pth->has_idm_b == _TRUE_) {
    /** - --> second derivative with respect to tau of R_idm_b (in view of spline interpolation) */
    class_call(array_spline_table_line_to_line(pth->tau_table,
                                               pth->tt_size,
                                               pth->thermodynamics_table,
                                               pth->th_size,
                                               pth->index_th_R_idm_b,
                                               pth->index_th_ddR_idm_b,
                                               _SPLINE_EST_DERIV_,
                                               pth->error_message),
               pth->error_message,
               pth->error_message);

    /** - --> first derivative with respect to tau of R_idm_b (using spline interpolation) */
    class_call(array_derive_spline_table_line_to_line(pth->tau_table,
                                                      pth->tt_size,
                                                      pth->thermodynamics_table,
                                                      pth->th_size,
                                                      pth->index_th_R_idm_b,
                                                      pth->index_th_ddR_idm_b,
                                                      pth->index_th_dR_idm_b,
                                                      pth->error_message),
               pth->error_message,
               pth->error_message);
  }

  return _SUCCESS_;

}


/**
 * Calculate various quantities at the time of recombination, as well
 * as the time tau_cut at which visibility gets negligible and one can
 * assume pure free-streaming.
 *
 * @param ppr                Input: pointer to precision structure
 * @param pba                Input: pointer to background structure
 * @param pth                Input/Output: pointer to initialized thermodynamics structure
 * @param pvecback           Input: pointer to some allocated pvecback
 * @return the error status
 */

int thermodynamics_calculate_recombination_quantities(
                                                      struct precision* ppr,
                                                      struct background * pba,
                                                      struct thermodynamics* pth,
                                                      double* pvecback
                                                      ) {

  /** Summary: */

  /** Define local variables */
  double g_max;

  int index_tau;
  int index_tau_max;
  int last_index_back=0;

  /** - find maximum of g */
  index_tau=pth->tt_size-1;
  while (pth->z_table[index_tau]>_Z_REC_MAX_) {
    index_tau--;
  }

  class_test(pth->thermodynamics_table[(index_tau+1)*pth->th_size+pth->index_th_g] >
             pth->thermodynamics_table[index_tau*pth->th_size+pth->index_th_g],
             pth->error_message,
             "The visibility function is not increasing at redshift _Z_REC_MAX_=%g, which is the value imposed in thermodynamics.h\n This implies that recombination must have already happened at a too early time.",_Z_REC_MAX_);

  while (pth->thermodynamics_table[(index_tau+1)*pth->th_size+pth->index_th_g] <=
         pth->thermodynamics_table[index_tau*pth->th_size+pth->index_th_g]) {
    index_tau--;
  }

  g_max = pth->thermodynamics_table[index_tau*pth->th_size+pth->index_th_g];
  index_tau_max = index_tau;

  /* approximation for maximum of g, using cubic interpolation, assuming equally spaced z's */
  pth->z_rec=pth->z_table[index_tau+1]+0.5*(pth->z_table[index_tau+1]-pth->z_table[index_tau])
    *(pth->thermodynamics_table[(index_tau)*pth->th_size+pth->index_th_g]
      -pth->thermodynamics_table[(index_tau+2)*pth->th_size+pth->index_th_g])
    /(pth->thermodynamics_table[(index_tau)*pth->th_size+pth->index_th_g]
      -2.*pth->thermodynamics_table[(index_tau+1)*pth->th_size+pth->index_th_g]
      +pth->thermodynamics_table[(index_tau+2)*pth->th_size+pth->index_th_g]
      );

  class_test(pth->z_rec+ppr->smallest_allowed_variation >= _Z_REC_MAX_,
             pth->error_message,
             "recombination (at z=%g) happens before _Z_REC_MAX_=%g, which is the maximum value imposed in thermodynamics.h",pth->z_rec+ppr->smallest_allowed_variation,_Z_REC_MAX_);

  class_test(pth->z_rec-ppr->smallest_allowed_variation <= _Z_REC_MIN_,
             pth->error_message,
             "recombination (at z=%g) happens after _Z_REC_MIN_=%g, which is the minimum value imposed in thermodynamics.h",pth->z_rec-ppr->smallest_allowed_variation,_Z_REC_MIN_);

  /** - find conformal recombination time using background_tau_of_z **/

  class_call(background_tau_of_z(pba,pth->z_rec,&(pth->tau_rec)),
             pba->error_message,
             pth->error_message);

  class_call(background_at_z(pba,pth->z_rec, long_info, inter_normal, &last_index_back, pvecback),
             pba->error_message,
             pth->error_message);

  pth->rs_rec=pvecback[pba->index_bg_rs];
  pth->ds_rec=pth->rs_rec/(1.+pth->z_rec);
  pth->da_rec=pvecback[pba->index_bg_ang_distance];
  pth->ra_rec=pth->da_rec*(1.+pth->z_rec);
  pth->angular_rescaling=pth->ra_rec/(pba->conformal_age-pth->tau_rec);

  /** - find damping scale at recombination (using linear interpolation) */
  if (pth->compute_damping_scale == _TRUE_) {

    pth->rd_rec = (pth->z_table[index_tau+1]-pth->z_rec)/(pth->z_table[index_tau+1]-pth->z_table[index_tau])*pth->thermodynamics_table[(index_tau)*pth->th_size+pth->index_th_r_d]
      +(pth->z_rec-pth->z_table[index_tau])/(pth->z_table[index_tau+1]-pth->z_table[index_tau])*pth->thermodynamics_table[(index_tau+1)*pth->th_size+pth->index_th_r_d];

  }

  /** - find time (always after recombination) at which tau_c/tau falls below some threshold, defining tau_free_streaming */
  while (1./pth->thermodynamics_table[(index_tau)*pth->th_size+pth->index_th_dkappa]/pth->tau_table[index_tau]
         < ppr->radiation_streaming_trigger_tau_c_over_tau) {

    index_tau--;
    class_test(index_tau<0, pth->error_message,"Could not find a time at which photons free-stream. This is very suspicious. Aborting.\n");

  }

  pth->tau_free_streaming = pth->tau_table[index_tau];

  /** - find time above which visibility falls below a given fraction of its maximum */
  index_tau=index_tau_max;
  while ((pth->thermodynamics_table[(index_tau)*pth->th_size+pth->index_th_g] >
          g_max * ppr->neglect_CMB_sources_below_visibility)
         && (index_tau > 0))
    index_tau--;

  class_call(background_tau_of_z(pba,pth->z_table[index_tau],&(pth->tau_cut)),
             pba->error_message,
             pth->error_message);

  /** - find z_star (when optical depth kappa crosses one, using linear
      interpolation) and sound horizon at that time */

  index_tau=0;
  while ((pth->thermodynamics_table[(index_tau)*pth->th_size+pth->index_th_exp_m_kappa] > 1./_E_) && (index_tau < pth->tt_size))
    index_tau++;

  pth->z_star = pth->z_table[index_tau-1]+
    (1./_E_-pth->thermodynamics_table[(index_tau-1)*pth->th_size+pth->index_th_exp_m_kappa])
    /(pth->thermodynamics_table[(index_tau)*pth->th_size+pth->index_th_exp_m_kappa]-pth->thermodynamics_table[(index_tau-1)*pth->th_size+pth->index_th_exp_m_kappa])
    *(pth->z_table[index_tau]-pth->z_table[index_tau-1]);

  class_call(background_tau_of_z(pba,pth->z_star,&(pth->tau_star)),
             pba->error_message,
             pth->error_message);

  class_call(background_at_tau(pba,pth->tau_star, long_info, inter_normal, &last_index_back, pvecback),
             pba->error_message,
             pth->error_message);

  pth->rs_star=pvecback[pba->index_bg_rs];
  pth->ds_star=pth->rs_star/(1.+pth->z_star);
  pth->da_star=pvecback[pba->index_bg_ang_distance];
  pth->ra_star=pth->da_star*(1.+pth->z_star);

  if (pth->compute_damping_scale == _TRUE_) {

    pth->rd_star = (pth->z_table[index_tau+1]-pth->z_star)/(pth->z_table[index_tau+1]-pth->z_table[index_tau])*pth->thermodynamics_table[(index_tau)*pth->th_size+pth->index_th_r_d]
      +(pth->z_star-pth->z_table[index_tau])/(pth->z_table[index_tau+1]-pth->z_table[index_tau])*pth->thermodynamics_table[(index_tau+1)*pth->th_size+pth->index_th_r_d];

  }

  return _SUCCESS_;
}

/**
 * Calculate various quantities at the time of ending of baryon drag (It is precisely where tau_d crosses one)
 *
 * @param ppr                Input: pointer to precision structure
 * @param pba                Input: pointer to background structure
 * @param pth                Input/Output: pointer to initialized thermodynamics structure
 * @param pvecback           Input: pointer to some allocated pvecback
 * @return the error status
 */

int thermodynamics_calculate_drag_quantities(
                                             struct precision* ppr,
                                             struct background * pba,
                                             struct thermodynamics* pth,
                                             double* pvecback
                                             ) {

  /** Summary: */

  /** Define local variables */
  int index_tau;
  int last_index_back;

  /** - find baryon drag time (when tau_d crosses one, using linear interpolation) and sound horizon at that time */
  index_tau=0;
  while ((pth->thermodynamics_table[(index_tau)*pth->th_size+pth->index_th_tau_d] < 1.) && (index_tau < pth->tt_size)) {
    index_tau++;
  }

  pth->z_d = pth->z_table[index_tau-1]+
    (1.-pth->thermodynamics_table[(index_tau-1)*pth->th_size+pth->index_th_tau_d])
    /(pth->thermodynamics_table[(index_tau)*pth->th_size+pth->index_th_tau_d]-pth->thermodynamics_table[(index_tau-1)*pth->th_size+pth->index_th_tau_d])
    *(pth->z_table[index_tau]-pth->z_table[index_tau-1]);

  class_call(background_tau_of_z(pba,pth->z_d,&(pth->tau_d)),
             pba->error_message,
             pth->error_message);

  class_call(background_at_z(pba,pth->z_d, long_info, inter_normal, &last_index_back, pvecback),
             pba->error_message,
             pth->error_message);

  pth->rs_d=pvecback[pba->index_bg_rs];
  pth->ds_d=pth->rs_d/(1.+pth->z_d);

  return _SUCCESS_;
}

/**
 * Compute ionization fractions with the RecFast of HyRec algorithm.
 *
 * Compute ionization fractions using either the vector y or, in some
 * approximation schemes, some analytic approximations. The output of
 * this function is located in the ptw->ptdw workspace. We need to
 * assign:
 *
 * - in the RecFast scheme only:
 *   -- ptdw->x_H, ptdw-> x_He (all neglecting reionisation, which is accounted for later on);
 *
 * - in both schemes:
 *   -- ptdw->x_noreio (neglecting reionisation);
 *   -- ptdw->x_reio (if reionisation is going on; obtained by calling
 *                    thermodynamics_reionization_function() and adding something to ptdw->x_noreio)
 *
 * @param z            Input: redshift
 * @param y            Input: vector of quantities to integrate with evolver
 * @param pth          Input: pointer to thermodynamics structure
 * @param pba          Input: pointer to background structure
 * @param ptw          Input/Output: pointer to thermo workspace. Contains output for x, ...
 * @param current_ap   Input: index of current approximation scheme
 * @return the error status
 */

int thermodynamics_ionization_fractions(
                                        double z,
                                        double * y,
                                        struct background * pba,
                                        struct thermodynamics * pth,
                                        struct thermo_workspace * ptw,
                                        int current_ap
                                        ) {

  /** Summary: */

  /** Define local variables */
  struct thermo_diffeq_workspace * ptdw = ptw->ptdw;
  struct thermo_vector * ptv = ptdw->ptv;

  /* Thermo quantities */
  double x_H, x_He, xHeII, x=0., Tmat;
  /* Analytical quantities */
  double rhs, sqrt_val;

  /* Varying fundamental constants (according to 1705.03925) */
  double rescale_rhs = 1., rescale_T = 1.;
  double alpha = 1., me = 1.;

  if (pth->has_varconst == _TRUE_) {
    class_call(background_varconst_of_z(pba, z, &alpha, &me),
               pba->error_message,
               pth->error_message);
    rescale_rhs = alpha*alpha*alpha*me*me*me;
    rescale_T = 1./alpha/alpha/me;
  }

  /** - Calculate x_noreio from Recfast/Hyrec in each approximation
      regime. Store the results in the workspace. */
  /** - --> For credits, see external/wrap_recfast.c */

  /* Set Tmat from the y vector (it is always evolved). */
  Tmat = y[ptv->index_ti_D_Tmat] + ptw->Tcmb*(1.+z);
  if (pth->has_varconst == _TRUE_) {
    Tmat *= rescale_T;
  }

  /** - --> first regime: H and Helium fully ionized */
  if (current_ap == ptdw->index_ap_brec || (ptw->has_ap_idmtca && current_ap == ptdw->index_ap_idmtca)) {

    /* This is equivalent to the formula for HeIII --> HeII in Saha, just using rhs' = 1/rhs */
    rhs = ptw->SIunit_nH0/exp( 1.5*log(ptw->const_NR_numberdens*Tmat/(1.+z)/(1.+z)) - ptw->const_Tion_HeII/Tmat );
    if (pth->has_varconst == _TRUE_) {
      rhs /= rescale_rhs;
    }

    sqrt_val = sqrt(pow(1.-rhs*(1.+ptw->fHe),2) + 4.*rhs*(1.+2*ptw->fHe));

    x = 2.*(1+2.*ptw->fHe)/(1.-rhs*(1.+ptw->fHe) + sqrt_val);

    ptdw->x_H = 1.;
    ptdw->x_He = 1.;

  }
  /** - --> second regime: first Helium recombination (analytic approximation) */
  else if (current_ap == ptdw->index_ap_He1) {

    /* Assuming Saha equilibrium for HeIII --> HeII */
    rhs = exp( 1.5*log(ptw->const_NR_numberdens*Tmat/(1.+z)/(1.+z)) - ptw->const_Tion_HeII/Tmat ) / ptw->SIunit_nH0;
    if (pth->has_varconst == _TRUE_) {
      rhs *= rescale_rhs;
    }

    sqrt_val = sqrt(pow((rhs-1.-ptw->fHe),2) + 4.*(1.+2.*ptw->fHe)*rhs);

    x = 0.5*(sqrt_val - (rhs-1.-ptw->fHe));

    ptdw->x_H = 1.;
    ptdw->x_He = 1.;

  }
  /** - --> third regime: first Helium recombination finished, H and Helium fully ionized */
  else if (current_ap == ptdw->index_ap_He1f) {

    /* Assuming Saha equilibrium for HeII --> HeI with HII fully ionized, again expanding in rhs' = 1/rhs compared to below */
    rhs = 0.25*ptw->SIunit_nH0/exp( 1.5*log(ptw->const_NR_numberdens*Tmat/(1.+z)/(1.+z)) - ptw->const_Tion_HeI/Tmat );
    if (pth->has_varconst == _TRUE_) {
      rhs /= rescale_rhs;
    }

    sqrt_val = sqrt(pow(1.-rhs,2) + 4.*rhs*(1.+ptw->fHe));

    x = 2.*(1+ptw->fHe)/(1.-rhs + sqrt_val);

    ptdw->x_H = 1.;
    ptdw->x_He = 1.;

  }
  /** - --> fourth regime: second Helium recombination starts (analytic approximation) */
  else if (current_ap == ptdw->index_ap_He2) {

    /* Assuming Saha equilibrium for HeII --> HeI with HII fully ionized */
    rhs = 4.*exp(1.5*log(ptw->const_NR_numberdens*Tmat/(1.+z)/(1.+z)) - ptw->const_Tion_HeI/Tmat ) / ptw->SIunit_nH0;
    if (pth->has_varconst == _TRUE_) {
      rhs *= rescale_rhs;
    }

    sqrt_val = sqrt(pow((rhs-1.),2) + 4.*(1.+ptw->fHe)*rhs );

    x = 0.5*(sqrt_val - (rhs-1.));

    ptdw->x_H = 1.;
    ptdw->x_He = (x-1.)/ptw->fHe;

  }
  /** - --> fifth regime: Hydrogen recombination starts (analytic approximation)
      while Helium recombination continues (full equation) */
  else if (current_ap == ptdw->index_ap_H) {

    rhs = exp(1.5*log(ptw->const_NR_numberdens*Tmat/(1.+z)/(1.+z)) - ptw->const_Tion_H/Tmat)/ptw->SIunit_nH0;
    if (pth->has_varconst == _TRUE_) {
      rhs *= rescale_rhs;
    }

    /* Assuming Saha equilibrium for HII->HI. Includes xHeII corrections from incomplete recombination of HeII --> HeI (non-zero x_HeII) */
    xHeII = y[ptv->index_ti_x_He]*ptw->fHe;
    x_H = 2./(1.+xHeII/rhs + sqrt((1.+xHeII/rhs)*(1.+xHeII/rhs)+4./rhs));

    x_He = y[ptv->index_ti_x_He];
    x = x_H + ptw->fHe * x_He;

    ptdw->x_H = x_H;
    ptdw->x_He = x_He;

  }
  /** - --> sixth regime: full Hydrogen and Helium equations */
  else if (current_ap == ptdw->index_ap_frec) {
    x_H = y[ptv->index_ti_x_H];
    x_He = y[ptv->index_ti_x_He];
    x = x_H + ptw->fHe * x_He;

    ptdw->x_H = x_H;
    ptdw->x_He = x_He;

  }
  /** - --> seventh regime: calculate x_noreio during reionization
      (i.e. x before taking reionisation into account) */
  else if (current_ap == ptdw->index_ap_reio) {

    x_H = y[ptv->index_ti_x_H];
    x_He = y[ptv->index_ti_x_He];
    x = x_H + ptw->fHe * x_He;

    ptdw->x_H = x_H;
    ptdw->x_He = x_He;

  }

  ptdw->x_noreio = x;

  /** - If z is during reionization, also calculate the reionized x */
  if (current_ap == ptdw->index_ap_reio) {

    /* set x from the evolver (which is very low ~10^-4) as 'xe_before' */
    ptw->ptrp->reionization_parameters[ptw->ptrp->index_re_xe_before] = x;

    /* compute x */
    class_call(thermodynamics_reionization_function(z,pth,ptw->ptrp,&x),
               pth->error_message,
               pth->error_message);
  }

  ptdw->x_reio = x;

  return _SUCCESS_;
}

/**
 * This subroutine contains the reionization function \f$ X_e(z) \f$ (one for each scheme) and gives x for a given z.
 *
 * @param z     Input: redshift
 * @param pth   Input: pointer to thermodynamics structure, to know which scheme is used
 * @param preio Input: pointer to reionization parameters of the function \f$ X_e(z) \f$
 * @param x     Output: \f$ X_e(z) \f$
 */

int thermodynamics_reionization_function(
                                         double z,
                                         struct thermodynamics * pth,
                                         struct thermo_reionization_parameters * preio,
                                         double * x
                                         ) {

  /** Summary: */

  /** - define local variables */
  double argument;
  int i;
  double z_jump;

  int jump;
  double center,before, after,width,one_jump;
  double z_min, z_max;

  switch (pth->reio_parametrization) {

    /** - no reionization means nothing to be added to xe_before */
  case reio_none:
    *x = preio->reionization_parameters[preio->index_re_xe_before];
    break;

    /** - implementation of ionization function similar to the one in CAMB */
  case reio_camb:

    /** - --> case z > z_reio_start */
    if (z > preio->reionization_parameters[preio->index_re_reio_start]) {
      *x = preio->reionization_parameters[preio->index_re_xe_before];
    }
    else {
      /** - --> case z < z_reio_start: hydrogen contribution (tanh of complicated argument) */
      argument = (pow((1.+preio->reionization_parameters[preio->index_re_reio_redshift]),
                      preio->reionization_parameters[preio->index_re_reio_exponent])
                  -pow((1.+z),preio->reionization_parameters[preio->index_re_reio_exponent]))
        /(preio->reionization_parameters[preio->index_re_reio_exponent]
          *pow((1.+preio->reionization_parameters[preio->index_re_reio_redshift]),
               (preio->reionization_parameters[preio->index_re_reio_exponent]-1.)))
        /preio->reionization_parameters[preio->index_re_reio_width];

      *x = (preio->reionization_parameters[preio->index_re_xe_after]
            -preio->reionization_parameters[preio->index_re_xe_before])
        *(tanh(argument)+1.)/2.
        +preio->reionization_parameters[preio->index_re_xe_before];

      /** - --> case z < z_reio_start: helium contribution (tanh of simpler argument) */
      argument = (preio->reionization_parameters[preio->index_re_helium_fullreio_redshift] - z)
        /preio->reionization_parameters[preio->index_re_helium_fullreio_width];

      *x += preio->reionization_parameters[preio->index_re_helium_fullreio_fraction]
        *(tanh(argument)+1.)/2.;
    }
    break;

    /** - implementation of half-tangent like in 1209.0247 */
  case reio_half_tanh:

    /** - --> case z > z_reio_start */
    if (z > preio->reionization_parameters[preio->index_re_reio_start]) {
      *x = preio->reionization_parameters[preio->index_re_xe_before];
    }
    else {
      /** - --> case z < z_reio_start: hydrogen contribution (tanh of complicated argument) */
      argument = (pow((1.+preio->reionization_parameters[preio->index_re_reio_redshift]),
                      preio->reionization_parameters[preio->index_re_reio_exponent])
                  -pow((1.+z),preio->reionization_parameters[preio->index_re_reio_exponent]))
        /(preio->reionization_parameters[preio->index_re_reio_exponent]
          *pow((1.+preio->reionization_parameters[preio->index_re_reio_redshift]),
               (preio->reionization_parameters[preio->index_re_reio_exponent]-1.)))
        /preio->reionization_parameters[preio->index_re_reio_width];

      /* argument goes from 0 to infty, not from -infty to infty like
         in reio_camb case. Thus tanh(argument) goes from 0 to 1, not
         from -1 to 1.  */

      *x = (preio->reionization_parameters[preio->index_re_xe_after]
            -preio->reionization_parameters[preio->index_re_xe_before])
        *tanh(argument)
        +preio->reionization_parameters[preio->index_re_xe_before];
    }
    break;

    /** - implementation of binned ionization function similar to astro-ph/0606552 */
  case reio_bins_tanh:

    /** - --> case z > z_reio_start */
    if (z > preio->reionization_parameters[preio->index_re_first_z+preio->re_z_size-1]) {
      *x = preio->reionization_parameters[preio->index_re_xe_before];
    }
    else if (z < preio->reionization_parameters[preio->index_re_first_z]) {
      *x = preio->reionization_parameters[preio->index_re_first_xe];
    }
    else {
      i = 0;
      while (preio->reionization_parameters[preio->index_re_first_z+i+1]<z) i++;

      /* fix the final xe to xe_before*/
      preio->reionization_parameters[preio->index_re_first_xe+preio->re_z_size-1] = preio->reionization_parameters[preio->index_re_xe_before];

      /* This is the expression of the tanh-like jumps of the reio_bins_tanh scheme until the 10.06.2015. It appeared to be
         not robust enough. It could lead to a kink in xe(z) near the maximum value of z at which reionisation is sampled. It has
         been replaced by the simpler and more robust expression below.

         *xe = preio->reionization_parameters[preio->index_re_first_xe+i]
         +0.5*(tanh((2.*(z-preio->reionization_parameters[preio->index_re_first_z+i])
         /(preio->reionization_parameters[preio->index_re_first_z+i+1]
         -preio->reionization_parameters[preio->index_re_first_z+i])-1.)
         /preio->reionization_parameters[preio->index_re_step_sharpness])
         /tanh(1./preio->reionization_parameters[preio->index_re_step_sharpness])+1.)
         *(preio->reionization_parameters[preio->index_re_first_xe+i+1]
         -preio->reionization_parameters[preio->index_re_first_xe+i]);
      */

      /* compute the central redshift value of the tanh jump */
      if (i == preio->re_z_size-2) {
        z_jump = preio->reionization_parameters[preio->index_re_first_z+i]
          + 0.5*(preio->reionization_parameters[preio->index_re_first_z+i]
                 -preio->reionization_parameters[preio->index_re_first_z+i-1]);
      }
      else{
        z_jump =  0.5*(preio->reionization_parameters[preio->index_re_first_z+i+1]
                       + preio->reionization_parameters[preio->index_re_first_z+i]);
      }

      /* implementation of the tanh jump */
      *x = preio->reionization_parameters[preio->index_re_first_xe+i]
        +0.5*(tanh((z-z_jump)
                   /preio->reionization_parameters[preio->index_re_step_sharpness])+1.)
        *(preio->reionization_parameters[preio->index_re_first_xe+i+1]
          -preio->reionization_parameters[preio->index_re_first_xe+i]);
    }
    break;

    /** - implementation of many tanh jumps */
  case reio_many_tanh:

    /** - --> case z > z_reio_start */
    if (z > preio->reionization_parameters[preio->index_re_first_z+preio->re_z_size-1]) {
      *x = preio->reionization_parameters[preio->index_re_xe_before];
    }
    else if (z > preio->reionization_parameters[preio->index_re_first_z]) {

      *x = preio->reionization_parameters[preio->index_re_xe_before];

      /* fix the final xe to xe_before*/
      preio->reionization_parameters[preio->index_re_first_xe+preio->re_z_size-1] = preio->reionization_parameters[preio->index_re_xe_before];

      for (jump=1; jump<preio->re_z_size-1; jump++) {

        center = preio->reionization_parameters[preio->index_re_first_z+preio->re_z_size-1-jump];

        /* before and after are meant with respect to growing z, not growing time */
        before = preio->reionization_parameters[preio->index_re_first_xe+preio->re_z_size-1-jump]
          -preio->reionization_parameters[preio->index_re_first_xe+preio->re_z_size-jump];
        after = 0.;
        width = preio->reionization_parameters[preio->index_re_step_sharpness];

        one_jump = before + (after-before)*(tanh((z-center)/width)+1.)/2.;

        *x += one_jump;
      }

    }
    else{
      *x = preio->reionization_parameters[preio->index_re_first_xe];
    }
    break;

    /** - implementation of reio_inter */
  case reio_inter:

    /** - --> case z > z_reio_start */
    if (z > preio->reionization_parameters[preio->index_re_first_z+preio->re_z_size-1]) {
      *x = preio->reionization_parameters[preio->index_re_xe_before];
    }
    else{
      i=0;
      while (preio->reionization_parameters[preio->index_re_first_z+i+1] < z) i++;

      z_min = preio->reionization_parameters[preio->index_re_first_z+i];
      z_max = preio->reionization_parameters[preio->index_re_first_z+i+1];

      /* fix the final xe to xe_before*/
      preio->reionization_parameters[preio->index_re_first_xe+preio->re_z_size-1] = preio->reionization_parameters[preio->index_re_xe_before];

      class_test(z<z_min,
                 pth->error_message,
                 "z out of range for reionization interpolation");

      class_test(z>z_max,
                 pth->error_message,
                 "z out of range for reionization interpolation");

      argument =(z-preio->reionization_parameters[preio->index_re_first_z+i])
        /(preio->reionization_parameters[preio->index_re_first_z+i+1]
          -preio->reionization_parameters[preio->index_re_first_z+i]);

      *x = preio->reionization_parameters[preio->index_re_first_xe+i]
        + argument*(preio->reionization_parameters[preio->index_re_first_xe+i+1]
                    -preio->reionization_parameters[preio->index_re_first_xe+i]);

      class_test(*x<0.,
                 pth->error_message,
                 "Interpolation gives negative ionization fraction\n",
                 argument,
                 preio->reionization_parameters[preio->index_re_first_xe+i],
                 preio->reionization_parameters[preio->index_re_first_xe+i+1]);
    }
    break;

  default:
    class_stop(pth->error_message,
               "value of reio_parametrization=%d unclear",pth->reio_parametrization);
    break;
  }
  return _SUCCESS_;
}

/**
 * Function for formatting the titles to be output
 *
 * @param pba        Input: pointer to background structure
 * @param pth        Input: pointer to the thermodynamics structure
 * @param titles     Input: titles string containing all titles
 * @return the error status
 */

int thermodynamics_output_titles(
                                 struct background * pba,
                                 struct thermodynamics *pth,
                                 char titles[_MAXTITLESTRINGLENGTH_]
                                 ) {

  class_store_columntitle(titles,"scale factor a",_TRUE_); //NS TODO :: Added a, tell Julien
  class_store_columntitle(titles,"z",_TRUE_);
  class_store_columntitle(titles,"conf. time [Mpc]",_TRUE_);
  class_store_columntitle(titles,"x_e",_TRUE_);
  class_store_columntitle(titles,"kappa' [Mpc^-1]",_TRUE_);
  //class_store_columntitle(titles,"kappa''",_TRUE_);
  //class_store_columntitle(titles,"kappa'''",_TRUE_);
  class_store_columntitle(titles,"exp(-kappa)",_TRUE_);
  class_store_columntitle(titles,"g [Mpc^-1]",_TRUE_);
  //class_store_columntitle(titles,"g'",_TRUE_);
  //class_store_columntitle(titles,"g''",_TRUE_);
  class_store_columntitle(titles,"Tb [K]",_TRUE_);
  class_store_columntitle(titles,"dTb [K]",_TRUE_);
  class_store_columntitle(titles,"w_b",_TRUE_);
  class_store_columntitle(titles,"c_b^2",_TRUE_);
  if (pba->has_idm == _TRUE_) {
    class_store_columntitle(titles,"T_idm [K]",_TRUE_);
    class_store_columntitle(titles,"c_idm^2",_TRUE_);
    if (pth->has_idm_g == _TRUE_) {
      class_store_columntitle(titles,"dmu_idm_g",_TRUE_);
      class_store_columntitle(titles,"ddmu_idm_g",_TRUE_);
    }
    if (pth->has_idm_b==_TRUE_){
      class_store_columntitle(titles,"R_idm_b",_TRUE_);
    }
    if (pth->has_idm_dr == _TRUE_){
      class_store_columntitle(titles,"dmu_idm_dr",_TRUE_);
      class_store_columntitle(titles,"tau_idm_dr",_TRUE_);
      class_store_columntitle(titles,"tau_idr",_TRUE_);
      class_store_columntitle(titles,"g_idm_dr [Mpc^-1]",_TRUE_);
    }
  }
  if (pba->has_idr == _TRUE_) {
    class_store_columntitle(titles, "T_idr [K]", _TRUE_);
    class_store_columntitle(titles,"dmu_idr",_TRUE_);
  }
  class_store_columntitle(titles,"tau_d",_TRUE_);
  //class_store_columntitle(titles,"max. rate",_TRUE_);
  class_store_columntitle(titles,"r_d",pth->compute_damping_scale);

  return _SUCCESS_;
}

/**
 * Output the data for the output into files
 *
 * @param pba                 Input: pointer to background structure
 * @param pth                 Input: pointer to the thermodynamics structure
 * @param number_of_titles    Input: number of titles
 * @param data                Input: pointer to data file
 * @return the error status
 */

int thermodynamics_output_data(
                               struct background * pba,
                               struct thermodynamics *pth,
                               int number_of_titles,
                               double *data
                               ) {

  int index_z, storeidx;
  double *dataptr, *pvecthermo;
  double z,tau;

  // pth->number_of_thermodynamics_titles = get_number_of_titles(pth->thermodynamics_titles);
  // pth->size_thermodynamics_data = pth->number_of_thermodynamics_titles*pth->tt_size;

  /* Store quantities: */
  for (index_z=0; index_z<pth->tt_size; index_z++) {
    dataptr = data + index_z*number_of_titles;
    pvecthermo = pth->thermodynamics_table+index_z*pth->th_size;
    z = pth->z_table[index_z];
    storeidx=0;

    class_call(background_tau_of_z(pba, z, &tau),
               pba->error_message,
               pth->error_message);

    class_store_double(dataptr,1./(1.+z),_TRUE_,storeidx);
    class_store_double(dataptr,z,_TRUE_,storeidx);
    class_store_double(dataptr,tau,_TRUE_,storeidx);
    class_store_double(dataptr,pvecthermo[pth->index_th_xe],_TRUE_,storeidx);
    class_store_double(dataptr,pvecthermo[pth->index_th_dkappa],_TRUE_,storeidx);
    //class_store_double(dataptr,pvecthermo[pth->index_th_ddkappa],_TRUE_,storeidx);
    //class_store_double(dataptr,pvecthermo[pth->index_th_dddkappa],_TRUE_,storeidx);
    class_store_double(dataptr,pvecthermo[pth->index_th_exp_m_kappa],_TRUE_,storeidx);
    class_store_double(dataptr,pvecthermo[pth->index_th_g],_TRUE_,storeidx);
    //class_store_double(dataptr,pvecthermo[pth->index_th_dg],_TRUE_,storeidx);
    //class_store_double(dataptr,pvecthermo[pth->index_th_ddg],_TRUE_,storeidx);
    class_store_double(dataptr,pvecthermo[pth->index_th_Tb],_TRUE_,storeidx);
    class_store_double(dataptr,pvecthermo[pth->index_th_dTb],_TRUE_,storeidx);
    class_store_double(dataptr,pvecthermo[pth->index_th_wb],_TRUE_,storeidx);
    class_store_double(dataptr,pvecthermo[pth->index_th_cb2],_TRUE_,storeidx);
    if (pba->has_idm == _TRUE_) {
      class_store_double(dataptr,pvecthermo[pth->index_th_T_idm],_TRUE_,storeidx);
      class_store_double(dataptr,pvecthermo[pth->index_th_c2_idm],_TRUE_,storeidx);
      if (pth->has_idm_g == _TRUE_) {
        class_store_double(dataptr,pvecthermo[pth->index_th_dmu_idm_g],_TRUE_,storeidx);
        class_store_double(dataptr,pvecthermo[pth->index_th_ddmu_idm_g],_TRUE_,storeidx);
      }
      if (pth->has_idm_b == _TRUE_){
        class_store_double(dataptr,pvecthermo[pth->index_th_R_idm_b],_TRUE_,storeidx);
      }
      if (pth->has_idm_dr == _TRUE_){
        class_store_double(dataptr,pvecthermo[pth->index_th_dmu_idm_dr],_TRUE_,storeidx);
        class_store_double(dataptr,pvecthermo[pth->index_th_tau_idm_dr],_TRUE_,storeidx);
        class_store_double(dataptr,pvecthermo[pth->index_th_tau_idr],_TRUE_,storeidx);
        class_store_double(dataptr,pvecthermo[pth->index_th_g_idm_dr],_TRUE_,storeidx);
      }
    }
    if (pba->has_idr == _TRUE_) {
      class_store_double(dataptr, pvecthermo[pth->index_th_T_idr],_TRUE_,storeidx);
      class_store_double(dataptr,pvecthermo[pth->index_th_dmu_idr],_TRUE_,storeidx);
    }
    class_store_double(dataptr,pvecthermo[pth->index_th_tau_d],_TRUE_,storeidx);
    //class_store_double(dataptr,pvecthermo[pth->index_th_rate],_TRUE_,storeidx);
    class_store_double(dataptr,pvecthermo[pth->index_th_r_d],pth->compute_damping_scale,storeidx);

  }

  return _SUCCESS_;
}



/**
 * This routine computes the quantities connected to interacting dark
 * matter with photons, baryons & dark radiation (idm), and interacting dark radiation (idr)
 *
 * @param pba          Input: pointer to background structure
 * @param z            Input: redshift
 * @param y            Input: vector of evolver quantities
 * @param dy           Input: derivative of this vector
 * @param pth          Input: pointer to thermodynamics structure
 * @param ptw          Input/Output: pointer to thermo workspace
 * @param pvecback     Input: vector of background quantities
 *
 * @return the error status
 *
 */
int thermodynamics_idm_quantities(struct background * pba,
                                  double z,
                                  double * y,
                                  double * dy,
                                  struct thermodynamics * pth,
                                  struct thermo_workspace * ptw,
                                  double * pvecback){
  /** Summary: */

  /** Define local variables */
  struct thermo_diffeq_workspace * ptdw = ptw->ptdw;
  struct thermo_vector * ptv = ptdw->ptv;

  /* Thermo quantities */
  double T_g, Tmat, T_idr = 0.;
  double Vrms_idm_b2, m_b, T_diff_idm_b, FHe;

  T_g = ptw->Tcmb * (1.+z);
  Tmat = y[ptv->index_ti_D_Tmat] + T_g;

  /** - First deal with any required dark radiation */
  if (pba->has_idr == _TRUE_) {
    T_idr = pba->T_idr*(1.+z);
    ptdw->dmu_idr = pth->b_idr*pow((1.+z)/1.e7,pth->n_index_idm_dr)*pba->Omega0_idr*pow(pba->h,2);
  }

  /** - Now deal with any required dark matter (and its interactions) */
  if (pba->has_idm == _TRUE_) {
    /* First, set the IDM temperature in tight coupling */
    if (ptw->has_ap_idmtca == _TRUE_ && ptdw->ap_current == ptdw->index_ap_idmtca) {
      ptdw->T_idm = T_g;
      /* If we are coupling strongly to dark radiation instead */
      if ((pth->has_idm_dr == _TRUE_) && pth->n_index_idm_dr > 0)
        ptdw->T_idm = T_idr;
    }

    /* Also set idm temperature without tight coupling */
    else {
      ptdw->T_idm = y[ptv->index_ti_T_idm];
    }

    /* Compute idm temperature derivatives, starting with homogeneous expansion */
    ptdw->T_idm_prime = - 2. * ptdw->T_idm / (1.+z);

    /* Now add also coupling to photons*/
    if (pth->has_idm_g == _TRUE_) {
      /* - photon interaction rate with idm_g */
      ptdw->dmu_idm_g = 3./8./_PI_/_G_*pow(1.+z, 2+pth->n_index_idm_g)*pba->Omega0_idm*pba->H0*pba->H0*pth->u_idm_g*pow(_c_,4)*_sigma_/1.e11/_eV_/_Mpc_over_m_;
      ptdw->T_idm_prime += - 2.*4./3. * pvecback[pba->index_bg_rho_g]/pvecback[pba->index_bg_rho_idm] * ptdw->dmu_idm_g * (ptdw->T_idm  - T_g) / pvecback[pba->index_bg_H];
    }
    /* Now add also coupling to dark radiation */
    if (pth->has_idm_dr == _TRUE_) {
      /* - idr interaction rate with idm_dr */
      ptdw->dmu_idm_dr = pth->a_idm_dr*pow((1.+ z)/1.e7,pth->n_index_idm_dr)*pba->Omega0_idm*pow(pba->h,2);
      ptdw->Sinv_idm_dr  = 4./3.*pvecback[pba->index_bg_rho_idr]/pvecback[pba->index_bg_rho_idm];
      ptdw->T_idm_prime += - 2* ptdw->dmu_idm_dr * ptdw->Sinv_idm_dr * (ptdw->T_idm - T_idr) / pvecback[pba->index_bg_H];
    }
    /* Now add also coupling to baryons */
    /* Note that here we do a simplified calculation of the velocity, as described in 2010.04074. This will be adapted in future versions. */
    if (pth->has_idm_b == _TRUE_) {
      if (z > 1.e3)
        Vrms_idm_b2 = 1.e-8;
      else
        Vrms_idm_b2 = 1.e-8*pow(((1.+z)/1.e3),2);

      FHe = 1- ptw->YHe;
      m_b = _m_p_*_c_*_c_/_eV_; /* Note that for now we always assume scattering with protons. This will be adapted in future versions. */

      T_diff_idm_b = (Tmat*_k_B_/_eV_/m_b)+(ptdw->T_idm*_k_B_/_eV_/pth->m_idm)+(Vrms_idm_b2/3.0);

      ptdw->R_idm_b = (pvecback[pba->index_bg_a]*pvecback[pba->index_bg_rho_b]*pth->cross_idm_b*pth->n_coeff_idm_b/(m_b+pth->m_idm))
        *pow(T_diff_idm_b,(pth->n_index_idm_b+1.0)/2.0)*FHe
        *(3.e-4*pow(_c_,4.)/(8.*_PI_*_Mpc_over_m_*_G_*_eV_));

      ptdw->T_idm_prime += -2.*pth->m_idm/(pth->m_idm + m_b)*ptdw->R_idm_b*(ptdw->T_idm-Tmat) / pvecback[pba->index_bg_H];
    }

    /* Now conclude by computing the sound speed */
    ptdw->c2_idm = _k_B_ /(pth->m_idm*_eV_)  * (ptdw->T_idm - (1.+z)/3. * ptdw->T_idm_prime);
  }

  return _SUCCESS_;
}

/**
 * Check if the initial integration time and spacing needs adjusting, for example for interacting dark matter
 *
 * @param ppr   Input: pointer to precision structure
 * @param pba   Input: pointer to background structure
 * @param pth   Input: pointer to thermo structure
 * @param ptw   Input/Output: pointer to thermo workspace
 * @return the error status
 */
int thermodynamics_obtain_z_ini(
                                struct precision * ppr,
                                struct background *pba,
                                struct thermodynamics *pth,
                                struct thermo_workspace * ptw
                                ) {

  /* These wil affect when and how the temperature integration starts*/
  double z_initial;
  int Nz_log;
  /* This describes until when (if at all) any idm might be coupled to either photon or IDR temp*/
  double z_idm_dec, z_idm_dec_min=_HUGE_;

  double R_dm;
  double f1nu = 7./8.*pow((4./11.),(4./3.));

  z_initial = ppr->thermo_z_initial;
  Nz_log = ppr->thermo_Nz_log;

  /* Set this initially to False and check if it's needed */
  ptw->has_ap_idmtca = _FALSE_;

  /* If there is idm, we want the thermodynamics table to
   * start at a much larger z, in order to capture the possible
   * non-trivial behavior of the dark matter interaction rate at early times */

  /* First, calculate the approximate decoupling time iff there is coupling, based on formulae from 2010.04074 */
  if (pba->has_idm == _TRUE_) {
    if ((pth->has_idm_g == _TRUE_) && (pth->n_index_idm_g > -2)) {
      z_idm_dec = pow(3.01e9, 1./(2+pth->n_index_idm_g)) * pow((1.+pba->Neff*f1nu)/(1.+3.044*f1nu), 1./(4.+2.*pth->n_index_idm_g)) * pow(pth->u_idm_g*1e4, -1./(2.+pth->n_index_idm_g));
      if (pth->thermodynamics_verbose > 3)
        printf("The decoupling redshift for idm_g is z_idm_dec = %.5e\n", z_idm_dec);
      z_idm_dec_min = MIN(z_idm_dec, z_idm_dec_min);
    }
    if ((pth->has_idm_b == _TRUE_) && (pth->n_index_idm_b > -3)) {
      R_dm = pth->m_idm / (_m_p_*_c_*_c_/_eV_);
      z_idm_dec = 4e4 * pow(  9.15/pth->n_coeff_idm_b
                              *pow((1.+pba->Neff*f1nu)/(1.+3.044*f1nu), 1./2.) * (0.0224/pba->Omega0_b/pba->h/pba->h)
                              *pow(R_dm, (pth->n_index_idm_b+1.)/2.)/pow(1.+R_dm, (pth->n_index_idm_b-1.)/2.)
                              *pow(10.,4*pth->n_index_idm_b - 25)/pth->cross_idm_b        ,  2./(pth->n_index_idm_b+3));

      if (pth->n_index_idm_b == -2)
        z_idm_dec *= 10;
      if (pth->thermodynamics_verbose > 3)
        printf("The decoupling redshift for idm_b is z_idm_dec = %.5e\n", z_idm_dec);
      z_idm_dec_min = MIN(z_idm_dec, z_idm_dec_min);
    }
    if ((pth->has_idm_dr == _TRUE_) && (pth->n_index_idm_dr > 0)) {
      z_idm_dec = pow(10., 7.-6./ pth->n_index_idm_dr)
        * pow( 1.6 * (1e-6/pba->Omega0_idr/pba->h/pba->h)
               * pow((1.+pba->Neff*f1nu)/(1.+3.044*f1nu), 1./2.)
               * (1e6 / pth->a_idm_dr)  ,  1./pth->n_index_idm_dr);
      if (pth->thermodynamics_verbose > 3)
        printf("The decoupling redshift for idm_dr is z_idm_dec = %.5e\n", z_idm_dec);
      /* we need to be careful if idm is coupled to photons and idr at the same time */
      class_test(z_idm_dec_min != _HUGE_ && fabs(pba->T_idr - pba->T_cmb) > 1e-2,
                 pth->error_message,
                 "It seems that at early times idm is thermally coupled to both idr and photons (possibly through baryons).\nPlease set the initial temperatures equal or disable this error.");

      z_idm_dec_min = MIN(z_idm_dec, z_idm_dec_min);
    }

    /* if there is initial coupling then we need the approximation scheme ap_idmtca */
    if (z_idm_dec_min != _HUGE_) {
      ptw->has_ap_idmtca = _TRUE_;
      /* assert that ap_idmtca ends before ap_brec ends */
      ptw->z_ap_idmtca = MAX( 1e2 * z_idm_dec_min, (ppr->recfast_z_He_1+ppr->recfast_delta_z_He_1)*1.5);
      if (pth->thermodynamics_verbose > 3)
        printf("Starting the idm TCA at z_ap_idmtca = %.5e\n", ptw->z_ap_idmtca);
    }

    /* From this, decide the initial time of integration */
    /* start the integration before the decoupling */
    if (ptw->has_ap_idmtca == _TRUE_) {
      class_test(ptw->z_ap_idmtca * ppr->a_ini_over_a_today_default > 1,
                 pth->error_message,
                 "The decoupling time of the idm species is set earlier than the background integration. Start the background integration earlier.");

      z_initial = MAX(z_initial, MIN(100 * ptw->z_ap_idmtca, 1/ppr->a_ini_over_a_today_default-2.));
    }

    /* if there is no coupling at early time, we need to set an another starting point */
    else {
      z_initial = MAX(ppr->thermo_z_initial_if_idm, z_initial);
    }

    if (pth->thermodynamics_verbose > 2)
      printf(" -> Increasing the initial redshift of thermodynamics from %e to %e \n",ppr->thermo_z_initial,z_initial);

    /* Rescale Nz_log (if necessary) in order to cover with equal spacing the enlarged range */
    Nz_log = MAX((int)(Nz_log/log(ppr->thermo_z_initial)*log(z_initial)),Nz_log);
  }

  ppr->thermo_z_initial = z_initial;
  ppr->thermo_Nz_log = Nz_log;
  class_test(z_initial * ppr->a_ini_over_a_today_default > 1.,
             pth->error_message,
             "The initial starting time for the temperature integration is set earlier than the background integration. Adjust obtain_z_ini to mitigate this");
  class_test(z_initial <  ppr->recfast_z_He_3,
             pth->error_message,
             "The initial starting time for the temperature integration is set after HeliumIII recombination starts. Adjust obtain_z_ini to mitigate this");

  return _SUCCESS_;

}

/**
 * Set the correct initial temperature for the idm species
 *
 * @param pba   Input: pointer to background structure
 * @param pth   Input: pointer to thermo structure
 * @param z_ini Input: z_ini
 * @param ptdw  Input/Output: pointer to thermo differential equation workspace
 * @return the error status
 */
int thermodynamics_idm_initial_temperature(
                                           struct background* pba,
                                           struct thermodynamics* pth,
                                           double z_ini,
                                           struct thermo_diffeq_workspace * ptdw
                                           ) {

  /** - define local parameters */
  double* pvecback;
  int last_index;
  /* idm-b special parameters */
  double m_b, FHe, T_diff_idm_b;
  /* steady state factors ( = prefactors in temperature evolution equation) */
  double alpha=0.,beta=0.,epsilon=0.;

  /** - obtain necessary background information */
  class_alloc(pvecback,pba->bg_size*sizeof(double),pba->error_message);
  class_call(background_at_z(pba,
                             z_ini,
                             long_info,
                             inter_normal,
                             &last_index,
                             pvecback),
             pba->error_message,
             pth->error_message);

  /* idm-idr steady state */
  if ((pth->has_idm_dr == _TRUE_) && (pth->n_index_idm_dr == 0)) {
    epsilon = 2*4./3.*pvecback[pba->index_bg_rho_idr]/pvecback[pba->index_bg_rho_idm]*
      pth->a_idm_dr*pow((1.+ z_ini)/1.e7,pth->n_index_idm_dr)*pba->Omega0_idm*pow(pba->h,2) / pvecback[pba->index_bg_H]*(1.+z_ini);
  }
  /* idm_g steady state */
  else if (pth->has_idm_g == _TRUE_ && pth->n_index_idm_g == -2) {
    ptdw->dmu_idm_dr = pth->a_idm_dr*pow((1.+ z_ini)/1.e7,pth->n_index_idm_dr)*pba->Omega0_idm*pow(pba->h,2);
    ptdw->Sinv_idm_dr  = 4./3.*pvecback[pba->index_bg_rho_idr]/pvecback[pba->index_bg_rho_idm];
    alpha = 2.* ptdw->dmu_idm_dr * ptdw->Sinv_idm_dr;
  }
  /* idm_b steady state */
  else if (pth->has_idm_b == _TRUE_ && pth->n_index_idm_b == -3) {
    FHe = 1-pth->YHe;
    m_b = _m_p_*_c_*_c_/_eV_;
    /* This is super-highly approximated, and will not usually be correct. However, the small error we incur should be corrected by the evolution equation */
    T_diff_idm_b = (pba->T_cmb*(1.+z_ini)*_k_B_/_eV_/m_b)+(pba->T_cmb*(1.+z_ini)*_k_B_/_eV_/pth->m_idm)+(1.e-8/3.0);
    ptdw->R_idm_b = (pvecback[pba->index_bg_a]*pvecback[pba->index_bg_rho_b]*pth->cross_idm_b*pth->n_coeff_idm_b/(m_b+pth->m_idm))
      *pow(T_diff_idm_b,(pth->n_index_idm_b+1.0)/2.0)*FHe
      *(3.e-4*pow(_c_,4.)/(8.*_PI_*_Mpc_over_m_*_G_*_eV_));
    alpha = 2.*pth->m_idm/(pth->m_idm + m_b)*ptdw->R_idm_b;
  }

  /* This formula (assuming alpha,beta,epsilon=const) approximates the steady-state solution of the IDM temperature evolution equation */
  ptdw->T_idm = (alpha + beta + epsilon * pba->T_idr/pba->T_cmb)/(1.+epsilon+alpha+beta) * pba->T_cmb * (1.+z_ini);

  free(pvecback);

  return _SUCCESS_;
}

```

`source/transfer.c`:

```c
/** @file transfer.c Documented transfer module.
 *
 * Julien Lesgourgues, 28.07.2013
 *
 * This module has two purposes:
 *
 * - at the beginning, to compute the transfer functions \f$
 *   \Delta_l^{X} (q) \f$, and store them in tables used for
 *   interpolation in other modules.
 *
 * - at any time in the code, to evaluate the transfer functions (for
 *   a given mode, initial condition, type and multipole l) at any
 *   wavenumber q (by interpolating within the interpolation table).
 *
 * Hence the following functions can be called from other modules:
 *
 * -# transfer_init() at the beginning (but after perturbations_init()
 *    and bessel_init())
 *
 * -# transfer_functions_at_q() at any later time
 *
 * -# transfer_free() at the end, when no more calls to
 *    transfer_functions_at_q() are needed
 *
 * Note that in the standard implementation of CLASS, only the pre-computed
 * values of the transfer functions are used, no interpolation is necessary;
 * hence the routine transfer_functions_at_q() is actually never called.
 */

#include "transfer.h"
#include "parallel.h"

/**
 * Transfer function \f$ \Delta_l^{X} (q) \f$ at a given wavenumber q.
 *
 * For a given mode (scalar, vector, tensor), initial condition, type
 * (temperature, polarization, lensing, etc) and multipole, computes
 * the transfer function for an arbitrary value of q by interpolating
 * between pre-computed values of q. This
 * function can be called from whatever module at whatever time,
 * provided that transfer_init() has been called before, and
 * transfer_free() has not been called yet.
 *
 * Wavenumbers are called q in this module and k in the perturbation
 * module. In flat universes k=q. In non-flat universes q and k differ
 * through \f$ q2 = k2 + K(1+m)\f$, where m=0,1,2 for scalar, vector,
 * tensor. q should be used throughout the transfer module, excepted
 * when interpolating or manipulating the source functions S(k,tau)
 * calculated in the perturbation module: for a given value of q, this
 * should be done at the corresponding k(q).
 *
 * @param ptr        Input: pointer to transfer structure
 * @param index_md   Input: index of requested mode
 * @param index_ic   Input: index of requested initial condition
 * @param index_tt   Input: index of requested type
 * @param index_l    Input: index of requested multipole
 * @param q          Input: any wavenumber
 * @param transfer_function Output: transfer function
 * @return the error status
 */

int transfer_functions_at_q(
                            struct transfer * ptr,
                            int index_md,
                            int index_ic,
                            int index_tt,
                            int index_l,
                            double q,
                            double * transfer_function
                            ) {
  /** Summary: */

  /** - interpolate in pre-computed table using array_interpolate_two() */
  class_call(array_interpolate_two(
                                   ptr->q,
                                   1,
                                   0,
                                   ptr->transfer[index_md]
                                   +((index_ic * ptr->tt_size[index_md] + index_tt) * ptr->l_size[index_md] + index_l)
                                   * ptr->q_size,
                                   1,
                                   ptr->q_size,
                                   q,
                                   transfer_function,
                                   1,
                                   ptr->error_message),
             ptr->error_message,
             ptr->error_message);

  return _SUCCESS_;
}

/**
 * This routine initializes the transfer structure, (in particular,
 * computes table of transfer functions \f$ \Delta_l^{X} (q) \f$)
 *
 * Main steps:
 *
 * - initialize all indices in the transfer structure
 *   and allocate all its arrays using transfer_indices().
 *
 * - for each thread (in case of parallel run), initialize the fields of a memory zone called the transfer_workspace with transfer_workspace_init()
 *
 * - loop over q values. For each q, compute the Bessel functions if needed with transfer_update_HIS(), and defer the calculation of all transfer functions to transfer_compute_for_each_q()
 * - for each thread, free the the workspace with transfer_workspace_free()
 *
 * @param ppr Input: pointer to precision structure
 * @param pba Input: pointer to background structure
 * @param pth Input: pointer to thermodynamics structure
 * @param ppt Input: pointer to perturbation structure
 * @param pfo Input: pointer to fourier structure
 * @param ptr Output: pointer to initialized transfer structure
 * @return the error status
 */

int transfer_init(
                  struct precision * ppr,
                  struct background * pba,
                  struct thermodynamics * pth,
                  struct perturbations * ppt,
                  struct fourier * pfo,
                  struct transfer * ptr
                  ) {

  /** Summary: */

  /** - define local variables */

  /* running index for wavenumbers */
  int index_q;

  /* conformal time today */
  double tau0;
  /* conformal time at recombination */
  double tau_rec;
  /* order of magnitude of the oscillation period of transfer functions */
  double q_period;

  /* maximum number of sampling times for transfer sources */
  int tau_size_max;

  /* array of sources S(k,tau), just taken from perturbation module,
     or transformed if non-linear corrections are needed
     sources[index_md][index_ic * ppt->tp_size[index_md] + index_tp][index_tau * ppt->k_size[index_md] + index_k]
  */
  double *** sources;

  /* array of source derivatives S''(k,tau)
     (second derivative with respect to k, not tau!),
     used to interpolate sources at the right values of k,
     sources_spline[index_md][index_ic * ppt->tp_size[index_md] + index_tp][index_tau * ppt->k_size[index_md] + index_k]
  */
  double *** sources_spline;


  /** - array with the correspondence between the index of sources in
      the perturbation module and in the transfer module,
      tp_of_tt[index_md][index_tt]
  */
  int ** tp_of_tt;

  /* structure containing the flat spherical bessel functions */

  HyperInterpStruct BIS;
  double xmax;


  /** - check whether any spectrum in harmonic space (i.e., any \f$C_l\f$'s) is actually requested */

  if (ppt->has_cls == _FALSE_) {
    ptr->has_cls = _FALSE_;
    if (ptr->transfer_verbose > 0)
      printf("No harmonic space transfer functions to compute. Transfer module skipped.\n");
    return _SUCCESS_;
  }
  else
    ptr->has_cls = _TRUE_;

  if (ptr->transfer_verbose > 0)
    fprintf(stdout,"Computing transfers\n");

  /** - check whether we will need the full Limber scheme */

  if ((ppt->has_cl_cmb_lensing_potential == _TRUE_) && (ppt->want_lcmb_full_limber == _TRUE_)) {
    ptr->do_lcmb_full_limber = _TRUE_;
  }
  else {
    ptr->do_lcmb_full_limber = _FALSE_;
  }

  /** - get number of modes (scalars, tensors...) */

  ptr->md_size = ppt->md_size;

  /** - get conformal age / recombination time
      from background / thermodynamics structures
      (only place where these structures are used in this module) */

  tau0 = pba->conformal_age;
  tau_rec = pth->tau_rec;

  /** - correspondence between k and l depend on angular diameter
      distance, i.e. on curvature. */

  ptr->angular_rescaling = pth->angular_rescaling;

  /** - order of magnitude of the oscillation period of transfer functions */

  q_period = 2.*_PI_/(tau0-tau_rec)*ptr->angular_rescaling;

  /** - initialize all indices in the transfer structure and
      allocate all its arrays using transfer_indices() */

  class_call(transfer_indices(ppr,ppt,ptr,q_period,pba->nu_spacing,pba->K,pba->sgnK),
             ptr->error_message,
             ptr->error_message);

  /** - copy sources to a local array sources (in fact, only the pointers are copied, not the data), and eventually apply non-linear corrections to the sources */

  class_alloc(sources,
              ptr->md_size*sizeof(double**),
              ptr->error_message);

  class_call(transfer_perturbation_copy_sources_and_nl_corrections(ppt,pfo,ptr,sources),
             ptr->error_message,
             ptr->error_message);

  /** - spline all the sources passed by the perturbation module with respect to k (in order to interpolate later at a given value of k) */

  class_alloc(sources_spline,
              ptr->md_size*sizeof(double**),
              ptr->error_message);

  class_call(transfer_perturbation_source_spline(ppt,ptr,sources,sources_spline),
             ptr->error_message,
             ptr->error_message);

  /** - allocate and fill array describing the correspondence between perturbation types and transfer types */

  class_alloc(tp_of_tt,
              ptr->md_size*sizeof(int*),
              ptr->error_message);

  class_call(transfer_get_source_correspondence(ppt,ptr,tp_of_tt),
             ptr->error_message,
             ptr->error_message);

  /** - evaluate maximum number of sampled times in the transfer
      sources: needs to be known here, in order to allocate a large
      enough workspace */

  class_call(transfer_source_tau_size_max(ppr,pba,ppt,ptr,tau_rec,tau0,&tau_size_max),
             ptr->error_message,
             ptr->error_message);

  /** - compute flat spherical bessel functions */

  xmax = ptr->q[ptr->q_size-1]*tau0;
  if (pba->sgnK == -1)
    xmax *= (ptr->l[ptr->l_size_max-1]/ppr->hyper_flat_approximation_nu)/asinh(ptr->l[ptr->l_size_max-1]/ppr->hyper_flat_approximation_nu)*1.01;

  class_call(hyperspherical_HIS_create(0,
                                       1.,
                                       ptr->l_size_max,
                                       ptr->l,
                                       ppr->hyper_x_min,
                                       xmax,
                                       ppr->hyper_sampling_flat,
                                       ptr->l[ptr->l_size_max-1]+1,
                                       ppr->hyper_phi_min_abs,
                                       &BIS,
                                       ptr->error_message),
             ptr->error_message,
             ptr->error_message);

  /** - eventually read the selection and evolution functions */

  class_call(transfer_global_selection_read(ptr),
             ptr->error_message,
             ptr->error_message);

  /** - precompute window function for integrated nCl/sCl quantities*/
  double* window = NULL;
  if ((ppt->has_cl_lensing_potential == _TRUE_) || (ppt->has_cl_number_count == _TRUE_)) {
    class_call(transfer_precompute_selection(ppr,
                                             pba,
                                             ppt,
                                             ptr,
                                             tau_rec,
                                             tau_size_max,
                                             &(window)),
               ptr->error_message,
               ptr->error_message);
  }

  class_setup_parallel();

  /** - loop over all wavenumbers (parallelized).*/
  /* For each wavenumber: */
  for (index_q = 0; index_q < MAX(ptr->q_size,ptr->q_size_limber); index_q++) {
 class_run_parallel(with_arguments(pba,pth,ppt,ptr,ppr,index_q,tau_rec,tp_of_tt,sources,sources_spline,tau_size_max,window,tau0,&BIS),

      /* compute the transfer functions in the normal case (not the
         full Limber one) */

      struct transfer_workspace tw;
      struct transfer_workspace * ptw = &tw;

      class_call(transfer_workspace_init(ptr,
                                         ppr,
                                         ptw,
                                         ppt->tau_size,
                                         tau_size_max,
                                         pba->K,
                                         pba->sgnK,
                                         tau0-pth->tau_cut,
                                         &BIS),
                 ptr->error_message,
                 ptr->error_message);

      if (index_q < ptr->q_size) {

        if (ptr->transfer_verbose > 2)
        printf("Compute transfer for wavenumber [%d/%zu]\n",index_q,ptr->q_size-1);

        /* Update interpolation structure: */
        class_call(transfer_update_HIS(ppr,
                                       ptr,
                                       ptw,
                                       index_q,
                                       tau0),
                   ptr->error_message,
                   ptr->error_message);

        class_call(transfer_compute_for_each_q(ppr,
                                               pba,
                                               ppt,
                                               ptr,
                                               tp_of_tt,
                                               index_q,
                                               tau_size_max,
                                               tau_rec,
                                               sources,
                                               sources_spline,
                                               window,
                                               ptw,
                                               _FALSE_),
                   ptr->error_message,
                   ptr->error_message);
      }

      /* compute the transfer functions in the full Limber case (if
       this case is not needed, ptr->q_size_limber=0 and the
       condition is never met) */

      if (index_q < ptr->q_size_limber) {

        class_call(transfer_compute_for_each_q(ppr,
                                               pba,
                                               ppt,
                                               ptr,
                                               tp_of_tt,
                                               index_q,
                                               tau_size_max,
                                               tau_rec,
                                               sources,
                                               sources_spline,
                                               window,
                                               ptw,
                                               _TRUE_),
                            ptr->error_message,
                            ptr->error_message);
      }

      class_call(transfer_workspace_free(ptr,ptw),
                 ptr->error_message,
                 ptr->error_message);
      return _SUCCESS_;
    );
  } /* end of loop over wavenumber */

  class_finish_parallel();

  /** - finally, free arrays allocated outside parallel zone */
  free(window);

  class_call(transfer_perturbation_sources_spline_free(ppt,ptr,sources_spline),
             ptr->error_message,
             ptr->error_message);

  class_call(transfer_perturbation_sources_free(ppt,pfo,ptr,sources),
             ptr->error_message,
             ptr->error_message);

  class_call(transfer_free_source_correspondence(ptr,tp_of_tt),
             ptr->error_message,
             ptr->error_message);

  class_call(hyperspherical_HIS_free(&BIS,ptr->error_message),
             ptr->error_message,
             ptr->error_message);

  ptr->is_allocated = _TRUE_;
  return _SUCCESS_;
}

/**
 * This routine frees all the memory space allocated by transfer_init().
 *
 * To be called at the end of each run, only when no further calls to
 * transfer_functions_at_k() are needed.
 *
 * @param ptr Input: pointer to transfer structure (which fields must be freed)
 * @return the error status
 */

int transfer_free(
                  struct transfer * ptr
                  ) {

  int index_md;

  if (ptr->has_cls == _TRUE_) {

    for (index_md = 0; index_md < ptr->md_size; index_md++) {
      free(ptr->l_size_tt[index_md]);
      free(ptr->transfer[index_md]);
      free(ptr->k[index_md]);
      if (ptr->do_lcmb_full_limber == _TRUE_) {
        free(ptr->transfer_limber[index_md]);
        free(ptr->k_limber[index_md]);
      }
    }

    free(ptr->tt_size);
    free(ptr->l_size_tt);
    free(ptr->l_size);
    free(ptr->l);
    free(ptr->q);
    free(ptr->k);
    free(ptr->transfer);
    if (ptr->do_lcmb_full_limber == _TRUE_) {
      free(ptr->q_limber);
      free(ptr->k_limber);
      free(ptr->transfer_limber);
    }

    if (ptr->nz_size > 0) {
      free(ptr->nz_z);
      free(ptr->nz_nz);
      free(ptr->nz_ddnz);
    }

    if (ptr->nz_evo_size > 0) {
      free(ptr->nz_evo_z);
      free(ptr->nz_evo_nz);
      free(ptr->nz_evo_dlog_nz);
      free(ptr->nz_evo_dd_dlog_nz);
    }
  }

  ptr->is_allocated = _FALSE_;

  return _SUCCESS_;

}

/**
 * This routine defines all indices and allocates all tables
 * in the transfer structure
 *
 * Compute list of (k, l) values, allocate and fill corresponding
 * arrays in the transfer structure. Allocate the array of transfer
 * function tables.
 *
 * @param ppr      Input: pointer to precision structure
 * @param ppt      Input: pointer to perturbation structure
 * @param ptr      Input/Output: pointer to transfer structure
 * @param q_period Input: order of magnitude of the oscillation period of transfer functions
 * @param nu_spacing Input: specific spacing of nu 
 * @param K        Input: spatial curvature (in absolute value)
 * @param sgnK     Input: spatial curvature sign (open/closed/flat)
 * @return the error status
 */

int transfer_indices(
                     struct precision * ppr,
                     struct perturbations * ppt,
                     struct transfer * ptr,
                     double q_period,
                     int nu_spacing,
                     double K,
                     int sgnK
                     ) {

  /** Summary: */

  /** - define local variables */

  int index_md,index_tt,index_tt_common;

  /** - define indices for transfer types */

  class_alloc(ptr->tt_size,ptr->md_size * sizeof(int),ptr->error_message);

  /** - type indices common to scalars and tensors */

  index_tt = 0;

  class_define_index(ptr->index_tt_t2,ppt->has_cl_cmb_temperature, index_tt,1);
  class_define_index(ptr->index_tt_e, ppt->has_cl_cmb_polarization,index_tt,1);

  index_tt_common=index_tt;

  /** - type indices for scalars */

  if (ppt->has_scalars == _TRUE_) {

    index_tt = index_tt_common;

    class_define_index(ptr->index_tt_t0,     ppt->has_cl_cmb_temperature,      index_tt,1);
    class_define_index(ptr->index_tt_t1,     ppt->has_cl_cmb_temperature,      index_tt,1);
    class_define_index(ptr->index_tt_lcmb,   ppt->has_cl_cmb_lensing_potential,index_tt,1);
    class_define_index(ptr->index_tt_density,ppt->has_nc_density,              index_tt,ppt->selection_num);
    class_define_index(ptr->index_tt_rsd,    ppt->has_nc_rsd,                  index_tt,ppt->selection_num);
    class_define_index(ptr->index_tt_d0,     ppt->has_nc_rsd,                  index_tt,ppt->selection_num);
    class_define_index(ptr->index_tt_d1,     ppt->has_nc_rsd,                  index_tt,ppt->selection_num);
    class_define_index(ptr->index_tt_nc_lens,ppt->has_nc_lens,                 index_tt,ppt->selection_num);
    class_define_index(ptr->index_tt_nc_g1,  ppt->has_nc_gr,                   index_tt,ppt->selection_num);
    class_define_index(ptr->index_tt_nc_g2,  ppt->has_nc_gr,                   index_tt,ppt->selection_num);
    class_define_index(ptr->index_tt_nc_g3,  ppt->has_nc_gr,                   index_tt,ppt->selection_num);
    class_define_index(ptr->index_tt_nc_g4,  ppt->has_nc_gr,                   index_tt,ppt->selection_num);
    class_define_index(ptr->index_tt_nc_g5,  ppt->has_nc_gr,                   index_tt,ppt->selection_num);
    class_define_index(ptr->index_tt_lensing,ppt->has_cl_lensing_potential,    index_tt,ppt->selection_num);

    ptr->tt_size[ppt->index_md_scalars]=index_tt;

  }

  /** - type indices for vectors */

  if (ppt->has_vectors == _TRUE_) {

    index_tt = index_tt_common;

    class_define_index(ptr->index_tt_t1,ppt->has_cl_cmb_temperature, index_tt,1);
    class_define_index(ptr->index_tt_b, ppt->has_cl_cmb_polarization,index_tt,1);

    ptr->tt_size[ppt->index_md_vectors]=index_tt;

  }

  /** - type indices for tensors */

  if (ppt->has_tensors == _TRUE_) {

    index_tt = index_tt_common;

    class_define_index(ptr->index_tt_b, ppt->has_cl_cmb_polarization,index_tt,1);

    ptr->tt_size[ppt->index_md_tensors]=index_tt;

  }

  /** - allocate arrays of (k, l) values and transfer functions */

  /* number of l values for each mode and type,
     l_size_tt[index_md][index_tt], and maximized for each mode,
     l_size[index_md] */

  class_alloc(ptr->l_size,ptr->md_size * sizeof(int),ptr->error_message);

  class_alloc(ptr->l_size_tt,ptr->md_size * sizeof(int *),ptr->error_message);

  for (index_md = 0; index_md < ptr->md_size; index_md++) {
    class_alloc(ptr->l_size_tt[index_md],ptr->tt_size[index_md] * sizeof(int),ptr->error_message);
  }

  /* array (of array) of transfer functions for each mode, transfer[index_md] */

  class_alloc(ptr->transfer,ptr->md_size * sizeof(double *),ptr->error_message);
  if (ptr->do_lcmb_full_limber == _TRUE_) {
    class_alloc(ptr->transfer_limber,ptr->md_size * sizeof(double *),ptr->error_message);
  }

  /** - get q values using transfer_get_q_list() */

  class_call(transfer_get_q_list(ppr,ppt,ptr,q_period,nu_spacing,K,sgnK),
             ptr->error_message,
             ptr->error_message);

  /** - get q values in full Limber case using transfer_get_q_limber_list() */

  if (ptr->do_lcmb_full_limber == _TRUE_) {
    class_call(transfer_get_q_limber_list(ppr,ppt,ptr,K,sgnK),
               ptr->error_message,
               ptr->error_message);
  }
  else {
    ptr->q_size_limber=0;
  }

  /** - get k values using transfer_get_k_list() */

  class_call(transfer_get_k_list(ppt,ptr,K),
             ptr->error_message,
             ptr->error_message);

  /* for testing, it can be useful to print the q list in a file: */

  /*
    FILE * out=fopen("output/q","w");
    int index_q;

    for (index_q=0; index_q < ptr->q_size; index_q++) {

    fprintf(out,"%d %e %e %e %e\n",
    index_q,
    ptr->q[index_q],
    ptr->k[0][index_q],
    ptr->q[index_q]/sqrt(sgnK*K),
    ptr->q[index_q+1]-ptr->q[index_q]);

    }

    fclose(out);
  */

  /** - get l values using transfer_get_l_list() */
  class_call(transfer_get_l_list(ppr,ppt,ptr),
             ptr->error_message,
             ptr->error_message);

  /** - loop over modes (scalar, etc). For each mode: */

  for (index_md = 0; index_md < ptr->md_size; index_md++) {

    /** - allocate arrays of transfer functions, (ptr->transfer[index_md])[index_ic][index_tt][index_l][index_k] */
    class_alloc(ptr->transfer[index_md],
                ppt->ic_size[index_md] * ptr->tt_size[index_md] * ptr->l_size[index_md] * ptr->q_size * sizeof(double),
                ptr->error_message);

    if (ptr->do_lcmb_full_limber == _TRUE_) {
      class_alloc(ptr->transfer_limber[index_md],
                  ppt->ic_size[index_md] * ptr->tt_size[index_md] * ptr->l_size[index_md] * ptr->q_size_limber * sizeof(double),
                  ptr->error_message);
    }

  }

  return _SUCCESS_;

}

int transfer_perturbation_copy_sources_and_nl_corrections(
                                                          struct perturbations * ppt,
                                                          struct fourier * pfo,
                                                          struct transfer * ptr,
                                                          double *** sources
                                                          ) {
  int index_md;
  int index_ic;
  int index_tp;
  int index_k;
  int index_tau;

  for (index_md = 0; index_md < ptr->md_size; index_md++) {

    class_alloc(sources[index_md],
                ppt->ic_size[index_md]*ppt->tp_size[index_md]*sizeof(double*),
                ptr->error_message);

    for (index_ic = 0; index_ic < ppt->ic_size[index_md]; index_ic++) {

      for (index_tp = 0; index_tp < ppt->tp_size[index_md]; index_tp++) {

        if ((pfo->method != nl_none) && (_scalars_) &&
            (((ppt->has_source_delta_m == _TRUE_) && (index_tp == ppt->index_tp_delta_m)) ||
             ((ppt->has_source_delta_cb == _TRUE_) && (index_tp == ppt->index_tp_delta_cb)) ||
             ((ppt->has_source_theta_m == _TRUE_) && (index_tp == ppt->index_tp_theta_m)) ||
             ((ppt->has_source_theta_cb == _TRUE_) && (index_tp == ppt->index_tp_theta_cb)) ||
             ((ppt->has_source_phi == _TRUE_) && (index_tp == ppt->index_tp_phi)) ||
             ((ppt->has_source_phi_prime == _TRUE_) && (index_tp == ppt->index_tp_phi_prime)) ||
             ((ppt->has_source_phi_plus_psi == _TRUE_) && (index_tp == ppt->index_tp_phi_plus_psi)) ||
             ((ppt->has_source_psi == _TRUE_) && (index_tp == ppt->index_tp_psi)))) {

          class_alloc(sources[index_md][index_ic * ppt->tp_size[index_md] + index_tp],
                      ppt->k_size[index_md]*ppt->tau_size*sizeof(double),
                      ptr->error_message);

          for (index_tau=0; index_tau<ppt->tau_size; index_tau++) {
            for (index_k=0; index_k<ppt->k_size[index_md]; index_k++) {
              if (((ppt->has_source_delta_cb == _TRUE_) && (index_tp == ppt->index_tp_delta_cb)) ||
                  ((ppt->has_source_theta_cb == _TRUE_) && (index_tp == ppt->index_tp_theta_cb))){
                sources[index_md]
                  [index_ic * ppt->tp_size[index_md] + index_tp]
                  [index_tau * ppt->k_size[index_md] + index_k] =
                  ppt->sources[index_md]
                  [index_ic * ppt->tp_size[index_md] + index_tp]
                  [index_tau * ppt->k_size[index_md] + index_k]
                  * pfo->nl_corr_density[pfo->index_pk_cb][index_tau * ppt->k_size[index_md] + index_k];
              }
              else{
                sources[index_md]
                  [index_ic * ppt->tp_size[index_md] + index_tp]
                  [index_tau * ppt->k_size[index_md] + index_k] =
                  ppt->sources[index_md]
                  [index_ic * ppt->tp_size[index_md] + index_tp]
                  [index_tau * ppt->k_size[index_md] + index_k]
                  * pfo->nl_corr_density[pfo->index_pk_m][index_tau * ppt->k_size[index_md] + index_k];
              }
            }
          }
        }
        else {
          sources[index_md][index_ic * ppt->tp_size[index_md] + index_tp] =
            ppt->sources[index_md][index_ic * ppt->tp_size[index_md] + index_tp];
        }
      }
    }
  }

  return _SUCCESS_;

}


int transfer_perturbation_source_spline(
                                        struct perturbations * ppt,
                                        struct transfer * ptr,
                                        double *** sources,
                                        double *** sources_spline
                                        ) {
  int index_md;
  int index_ic;
  int index_tp;

  for (index_md = 0; index_md < ptr->md_size; index_md++) {

    class_alloc(sources_spline[index_md],
                ppt->ic_size[index_md]*ppt->tp_size[index_md]*sizeof(double*),
                ptr->error_message);

    for (index_ic = 0; index_ic < ppt->ic_size[index_md]; index_ic++) {

      for (index_tp = 0; index_tp < ppt->tp_size[index_md]; index_tp++) {

        class_alloc(sources_spline[index_md][index_ic * ppt->tp_size[index_md] + index_tp],
                    ppt->k_size[index_md]*ppt->tau_size*sizeof(double),
                    ptr->error_message);

        class_call(array_spline_table_columns2(ppt->k[index_md],
                                               ppt->k_size[index_md],
                                               sources[index_md][index_ic * ppt->tp_size[index_md] + index_tp],
                                               ppt->tau_size,
                                               sources_spline[index_md][index_ic * ppt->tp_size[index_md] + index_tp],
                                               _SPLINE_EST_DERIV_,
                                               ptr->error_message),
                   ptr->error_message,
                   ptr->error_message);

      }
    }
  }

  return _SUCCESS_;

}

int transfer_perturbation_sources_free(
                                       struct perturbations * ppt,
                                       struct fourier * pfo,
                                       struct transfer * ptr,
                                       double *** sources
                                       ) {
  int index_md;
  int index_ic;
  int index_tp;

  for (index_md = 0; index_md < ptr->md_size; index_md++) {
    for (index_ic = 0; index_ic < ppt->ic_size[index_md]; index_ic++) {
      for (index_tp = 0; index_tp < ppt->tp_size[index_md]; index_tp++) {
        if ((pfo->method != nl_none) && (_scalars_) &&
            (((ppt->has_source_delta_m == _TRUE_) && (index_tp == ppt->index_tp_delta_m)) ||
             ((ppt->has_source_theta_m == _TRUE_) && (index_tp == ppt->index_tp_theta_m)) ||
             ((ppt->has_source_delta_cb == _TRUE_) && (index_tp == ppt->index_tp_delta_cb)) ||
             ((ppt->has_source_theta_cb == _TRUE_) && (index_tp == ppt->index_tp_theta_cb)) ||
             ((ppt->has_source_phi == _TRUE_) && (index_tp == ppt->index_tp_phi)) ||
             ((ppt->has_source_phi_prime == _TRUE_) && (index_tp == ppt->index_tp_phi_prime)) ||
             ((ppt->has_source_phi_plus_psi == _TRUE_) && (index_tp == ppt->index_tp_phi_plus_psi)) ||
             ((ppt->has_source_psi == _TRUE_) && (index_tp == ppt->index_tp_psi)))) {

          free(sources[index_md][index_ic * ppt->tp_size[index_md] + index_tp]);
        }
      }
    }
    free(sources[index_md]);
  }
  free(sources);

  return _SUCCESS_;
}

int transfer_perturbation_sources_spline_free(
                                              struct perturbations * ppt,
                                              struct transfer * ptr,
                                              double *** sources_spline
                                              ) {
  int index_md;
  int index_ic;
  int index_tp;

  for (index_md = 0; index_md < ptr->md_size; index_md++) {
    for (index_ic = 0; index_ic < ppt->ic_size[index_md]; index_ic++) {
      for (index_tp = 0; index_tp < ppt->tp_size[index_md]; index_tp++) {
        free(sources_spline[index_md][index_ic * ppt->tp_size[index_md] + index_tp]);
      }
    }
    free(sources_spline[index_md]);
  }
  free(sources_spline);

  return _SUCCESS_;
}

/**
 * This routine defines the number and values of multipoles l for all modes.
 *
 * @param ppr  Input: pointer to precision structure
 * @param ppt  Input: pointer to perturbation structure
 * @param ptr  Input/Output: pointer to transfer structure containing l's
 * @return the error status
 */

int transfer_get_l_list(
                        struct precision * ppr,
                        struct perturbations * ppt,
                        struct transfer * ptr
                        ) {

  int index_l;
  int l_max=0;
  int index_md;
  int index_tt;
  int increment,current_l;
  /** Summary: */
  /*
    fprintf(stderr,"rescaling %e logstep %e linstep %e\n",
    ptr->angular_rescaling,
    pow(ppr->l_logstep,ptr->angular_rescaling),
    ppr->l_linstep*ptr->angular_rescaling);
  */

  /* check that largests need value of l_max */

  if (ppt->has_cls == _TRUE_) {

    if (ppt->has_scalars == _TRUE_) {

      if ((ppt->has_cl_cmb_temperature == _TRUE_) ||
          (ppt->has_cl_cmb_polarization == _TRUE_) ||
          (ppt->has_cl_cmb_lensing_potential == _TRUE_))
        l_max=MAX(ppt->l_scalar_max,l_max);

      if ((ppt->has_cl_lensing_potential == _TRUE_) ||
          (ppt->has_cl_number_count == _TRUE_))
        l_max=MAX(ppt->l_lss_max,l_max);
    }

    if (ppt->has_tensors == _TRUE_)
      l_max=MAX(ppt->l_tensor_max,l_max);

  }

  /** - allocate and fill l array */

  /** - start from l = 2 and increase with logarithmic step */

  index_l = 0;
  current_l = 2;
  increment = MAX((int)(current_l * (pow(ppr->l_logstep,ptr->angular_rescaling)-1.)),1);

  while (((current_l+increment) < l_max) &&
         (increment < ppr->l_linstep*ptr->angular_rescaling)) {

    index_l ++;
    current_l += increment;
    increment = MAX((int)(current_l * (pow(ppr->l_logstep,ptr->angular_rescaling)-1.)),1);

  }

  /** - when the logarithmic step becomes larger than some linear step,
      stick to this linear step till l_max */

  increment = ppr->l_linstep*ptr->angular_rescaling;

  while ((current_l+increment) <= l_max) {

    index_l ++;
    current_l += increment;

  }

  /** - last value set to exactly l_max */

  if (current_l != l_max) {

    index_l ++;
    current_l = l_max;

  }

  ptr->l_size_max = index_l+1;

  /** - so far we just counted the number of values. Now repeat the
      whole thing but fill array with values. */

  class_alloc(ptr->l,ptr->l_size_max*sizeof(int),ptr->error_message);

  index_l = 0;
  ptr->l[0] = 2;
  increment = MAX((int)(ptr->l[0] * (pow(ppr->l_logstep,ptr->angular_rescaling)-1.)),1);

  while (((ptr->l[index_l]+increment) < l_max) &&
         (increment < ppr->l_linstep*ptr->angular_rescaling)) {

    index_l ++;
    ptr->l[index_l]=ptr->l[index_l-1]+increment;
    increment = MAX((int)(ptr->l[index_l] * (pow(ppr->l_logstep,ptr->angular_rescaling)-1.)),1);

  }

  increment = ppr->l_linstep*ptr->angular_rescaling;

  while ((ptr->l[index_l]+increment) <= l_max) {

    index_l ++;
    ptr->l[index_l]=ptr->l[index_l-1]+increment;

  }

  if (ptr->l[index_l] != l_max) {

    index_l ++;
    ptr->l[index_l]= l_max;

  }

  /* for each mode and type, find relevant size of l array,
     l_size_tt[index_md][index_tt] (since for some modes and types
     l_max can be smaller). Also, maximize this size for each mode to
     find l_size[index_md]. */

  for (index_md=0; index_md < ppt->md_size; index_md++) {

    ptr->l_size[index_md] = 0;

    for (index_tt=0;index_tt<ptr->tt_size[index_md];index_tt++) {

      if (_scalars_) {

        if ((ppt->has_cl_cmb_temperature == _TRUE_) &&
            ((index_tt == ptr->index_tt_t0) || (index_tt == ptr->index_tt_t1) || (index_tt == ptr->index_tt_t2)))
          l_max=ppt->l_scalar_max;

        if ((ppt->has_cl_cmb_polarization == _TRUE_) && (index_tt == ptr->index_tt_e))
          l_max=ppt->l_scalar_max;

        if ((ppt->has_cl_cmb_lensing_potential == _TRUE_) && (index_tt == ptr->index_tt_lcmb))
          l_max=ppt->l_scalar_max;

        if ((_index_tt_in_range_(ptr->index_tt_density, ppt->selection_num, ppt->has_nc_density)) ||
            (_index_tt_in_range_(ptr->index_tt_rsd,     ppt->selection_num, ppt->has_nc_rsd)) ||
            (_index_tt_in_range_(ptr->index_tt_d0,      ppt->selection_num, ppt->has_nc_rsd)) ||
            (_index_tt_in_range_(ptr->index_tt_d1,      ppt->selection_num, ppt->has_nc_rsd)) ||
            (_index_tt_in_range_(ptr->index_tt_nc_lens, ppt->selection_num, ppt->has_nc_lens))||
            (_index_tt_in_range_(ptr->index_tt_nc_g1,   ppt->selection_num, ppt->has_nc_gr))  ||
            (_index_tt_in_range_(ptr->index_tt_nc_g2,   ppt->selection_num, ppt->has_nc_gr))  ||
            (_index_tt_in_range_(ptr->index_tt_nc_g3,   ppt->selection_num, ppt->has_nc_gr))  ||
            (_index_tt_in_range_(ptr->index_tt_nc_g4,   ppt->selection_num, ppt->has_nc_gr))  ||
            (_index_tt_in_range_(ptr->index_tt_nc_g5,   ppt->selection_num, ppt->has_nc_gr))
            )
          l_max=ppt->l_lss_max;

        if ((ppt->has_cl_lensing_potential == _TRUE_) && (index_tt >= ptr->index_tt_lensing) && (index_tt < ptr->index_tt_lensing+ppt->selection_num))
          l_max=ppt->l_lss_max;

      }

      if (_tensors_) {
        l_max = ppt->l_tensor_max;
      }

      class_test(l_max > ptr->l[ptr->l_size_max-1],
                 ptr->error_message,
                 "For mode %d, type %d, asked for l_max=%d greater than in Bessel table where l_max=%d",
                 index_md,
                 index_tt,
                 l_max,
                 ptr->l[ptr->l_size_max-1]);

      index_l=0;
      while (ptr->l[index_l] < l_max) index_l++;
      ptr->l_size_tt[index_md][index_tt]=index_l+1;

      if (ptr->l_size_tt[index_md][index_tt] < ptr->l_size_max)
        ptr->l_size_tt[index_md][index_tt]++;
      if (ptr->l_size_tt[index_md][index_tt] < ptr->l_size_max)
        ptr->l_size_tt[index_md][index_tt]++;

      ptr->l_size[index_md] = MAX(ptr->l_size[index_md],ptr->l_size_tt[index_md][index_tt]);

    }
  }

  return _SUCCESS_;

}

/**
 * This routine defines the number and values of wavenumbers q for
 * each mode (goes smoothly from logarithmic step for small q's to
 * linear step for large q's).
 *
 * @param ppr     Input: pointer to precision structure
 * @param ppt     Input: pointer to perturbation structure
 * @param ptr     Input/Output: pointer to transfer structure containing q's
 * @param q_period Input: order of magnitude of the oscillation period of transfer functions
 * @param nu_spacing Input: specific spacing of nu 
 * @param K        Input: spatial curvature (in absolute value)
 * @param sgnK     Input: spatial curvature sign (open/closed/flat)
 * @return the error status
 */

int transfer_get_q_list(
                        struct precision * ppr,
                        struct perturbations * ppt,
                        struct transfer * ptr,
                        double q_period,
                        int nu_spacing, // For closed universe, the spacing of nu is not just 1, but can be 2, 3, etc.
                        double K,
                        int sgnK
                        ) {

  int index_q;
  double q,q_min=0.,q_max=0.,q_step,k_max;
  int nu, nu_min, nu_proposed;
  int q_size_max;
  double q_approximation;
  double last_step=0.;
  int last_index=0;
  double q_logstep_spline;
  double q_logstep_trapzd;
  int index_md;

  /* first and last value in flat case*/

  if (sgnK == 0) {
    q_min = ppt->k_min;

    q_max = 0.;
    for (index_md=0; index_md<ppt->md_size; index_md++) {
      q_max = MAX(q_max,ppt->k[index_md][ppt->k_size_cl[index_md]-1]);
    }

    K=0;
  }

  /* first and last value in open case*/

  else if (sgnK == -1) {
    q_min = sqrt(ppt->k_min*ppt->k_min+K);

    k_max = 0.;
    for (index_md=0; index_md<ppt->md_size; index_md++) {
      k_max = MAX(k_max,ppt->k[index_md][ppt->k_size_cl[index_md]-1]);
    }

    q_max = sqrt(k_max*k_max+K);
    if (ppt->has_vectors == _TRUE_)
      q_max = MIN(q_max,sqrt(k_max*k_max+2.*K));
    if (ppt->has_tensors == _TRUE_)
      q_max = MIN(q_max,sqrt(k_max*k_max+3.*K));
  }

  /* first and last value in closed case*/

    else if (sgnK == 1) {
    nu_min = 3;
    q_min = nu_min * sqrt(K);

    /* For closed universe, properly convert k_max from perturbations to q_max */
    double k_max_from_pert = 0.;
    for (index_md=0; index_md<ppt->md_size; index_md++) {
      k_max_from_pert = MAX(k_max_from_pert,ppt->k[index_md][ppt->k_size_cl[index_md]-1]);
    }
    
    /* Convert k_max to q_max using q = sqrt(k^2 + K) for scalars */
    q_max = sqrt(k_max_from_pert*k_max_from_pert + K);
    
    /* Round down to the nearest nu_spacing boundary to ensure discrete nu values */
    double nu_max_exact = q_max / sqrt(K);
    int nu_max_allowed = nu_min + ((int)((nu_max_exact - nu_min) / nu_spacing)) * nu_spacing;
    q_max = nu_max_allowed * sqrt(K);
  }

  /* adjust the parameter governing the log step size to curvature */

  q_logstep_spline = ppr->q_logstep_spline/pow(ptr->angular_rescaling,ppr->q_logstep_open);
  q_logstep_trapzd = ppr->q_logstep_trapzd;

  /* very conservative estimate of number of values */

  if (sgnK == 1) {
    
    /* Modified code */
    q_step = nu_spacing * sqrt(K);
    q_size_max = (int)((q_max-q_min)/q_step) + 1;
    // fprintf(stderr,"q_size_max=%d q_max=%f q_min=%f q_step=%f\n",q_size_max,q_max,q_min,q_step);

    /* Original code */
    // q_approximation = MIN(ppr->hyper_flat_approximation_nu,(q_max/sqrt(K)));

    // /* max contribution from integer nu values */
    // q_step = 1.+q_period*ppr->q_logstep_trapzd;
    // q_size_max = 2*(int)(log(q_approximation/q_min)/log(q_step));

    // q_step = q_period*ppr->q_linstep;
    // q_size_max += 2*(int)((q_approximation-q_min)/q_step);

    // /* max contribution from non-integer nu values */
    // q_step = 1.+q_period*ppr->q_logstep_spline;
    // q_size_max += 2*(int)(log(q_max/q_approximation)/log(q_step));

    // q_step = q_period*ppr->q_linstep;
    // q_size_max += 2*(int)((q_max-q_approximation)/q_step);
    

  }
  else {

    /* max contribution from non-integer nu values */
    q_step = 1.+q_period*ppr->q_logstep_spline;
    q_size_max = 5*(int)(log(q_max/q_min)/log(q_step));

    q_step = q_period*ppr->q_linstep;
    q_size_max += 5*(int)((q_max-q_min)/q_step);

  }

  /* create array with this conservative size estimate. The exact size
     will be readjusted below, after filling the array. */

  class_alloc(ptr->q,
              q_size_max*sizeof(double),
              ptr->error_message);

  /* assign the first value before starting the loop */

  index_q = 0;
  ptr->q[index_q] = q_min;
  nu = 3;
  index_q++;

  /* loop over the values */

  while ((index_q < q_size_max) && (ptr->q[index_q-1] < q_max)) {

    class_test(index_q >= q_size_max,ptr->error_message,"buggy q-list definition");

    /* step size formula in flat/open case. Step goes gradually from
       logarithmic to linear:

       - in the small q limit, it is logarithmic with: (delta q / q) =
       q_period * q_logstep_spline

       - in the large q limit, it is linear with: (delta q) = q_period
       * ppr->q_linstep
       */

    if (sgnK<=0) {

      q = ptr->q[index_q-1]
        + q_period * ppr->q_linstep * ptr->q[index_q-1]
        / (ptr->q[index_q-1] + ppr->q_linstep/q_logstep_spline);

    }

    /* step size formula in closed case. Same thing excepted that:

       - in the small q limit, the logarithmic step is reduced, being
       given by q_logstep_trapzd, and values are rounded to integer
       values of nu=q/sqrt(K). This happens as long as
       nu<nu_flat_approximation

       - for nu>nu_flat_approximation, the step gradually catches up
       the same expression as in the flat/open case, and there is no
       need to round up to integer nu's.
    */

    else {

      /* modification, set q to be integers with a specific spacing
      */
      q = nu*sqrt(K);
      nu = nu + nu_spacing;

      /*
      // original code
      
      if (nu < (int)ppr->hyper_flat_approximation_nu) {

        q = ptr->q[index_q-1]
          + q_period * ppr->q_linstep * ptr->q[index_q-1]
          / (ptr->q[index_q-1] + ppr->q_linstep/q_logstep_trapzd);

        nu_proposed = (int)(q/sqrt(K));
        if (nu_proposed <= nu + nu_spacing)
          nu = nu + nu_spacing;
        else
          nu = nu_proposed;

        q = nu*sqrt(K);
        last_step = q - ptr->q[index_q-1];
        last_index = index_q+1;
      }
      else {

        q_step = q_period * ppr->q_linstep * ptr->q[index_q-1] / (ptr->q[index_q-1] + ppr->q_linstep/q_logstep_spline);

        if (index_q-last_index < (int)ppr->q_numstep_transition)
          q = ptr->q[index_q-1] + (1-(double)(index_q-last_index)/ppr->q_numstep_transition) * last_step + (double)(index_q-last_index)/ppr->q_numstep_transition * q_step;
        else
          q = ptr->q[index_q-1] + q_step;
      }
      */
    }

    ptr->q[index_q] = q;
    index_q++;
  }

  /* infer total number of values (also checking if we overshot the last point) */

  if (ptr->q[index_q-1] > q_max)
    ptr->q_size=index_q-1;
  else
    ptr->q_size=index_q;

  class_test(ptr->q_size<2,ptr->error_message,"buggy q-list definition");

  /* now, readjust array size */

  class_realloc(ptr->q,
                ptr->q_size*sizeof(double),
                ptr->error_message);

  /* in curved universe, check at which index the flat rescaling
     approximation will start being used */

  if (sgnK != 0) {

    q_approximation = ppr->hyper_flat_approximation_nu * sqrt(sgnK*K);
    for (ptr->index_q_flat_approximation=0;
         ptr->index_q_flat_approximation < ptr->q_size-1;
         ptr->index_q_flat_approximation++) {
      if (ptr->q[ptr->index_q_flat_approximation] > q_approximation) break;
    }
    if (ptr->transfer_verbose > 1)
      printf("Flat bessel approximation spares hyperspherical bessel computations for %zu wavenumebrs over a total of %zu\n",
             ptr->q_size-ptr->index_q_flat_approximation,ptr->q_size);
  }

  return _SUCCESS_;

}

/**
 * This routine defines the number and values of wavenumbers q_limber for
 * each mode (logarithmic step only).
 *
 * @param ppr     Input: pointer to precision structure
 * @param ppt     Input: pointer to perturbation structure
 * @param ptr     Input/Output: pointer to transfer structure containing q's
 * @param K        Input: spatial curvature (in absolute value)
 * @param sgnK     Input: spatial curvature sign (open/closed/flat)
 * @return the error status
 */

int transfer_get_q_limber_list(
                               struct precision * ppr,
                               struct perturbations * ppt,
                               struct transfer * ptr,
                               double K,
                               int sgnK
                               ) {

  int index_q;
  double q_min=0.,q_max=0.,k_max;
  int nu_min;
  int index_md;

  /* first and last value in flat case*/

  if (sgnK == 0) {
    q_min = ppt->k_min;

    q_max = 0.;
    for (index_md=0; index_md<ppt->md_size; index_md++) {
      q_max = MAX(q_max,ppt->k[index_md][ppt->k_size[index_md]-1]);
    }

    K=0;
  }

  /* first and last value in open case*/

  else if (sgnK == -1) {
    q_min = sqrt(ppt->k_min*ppt->k_min+K);

    k_max = 0.;
    for (index_md=0; index_md<ppt->md_size; index_md++) {
      k_max = MAX(k_max,ppt->k[index_md][ppt->k_size[index_md]-1]);
    }

    q_max = sqrt(k_max*k_max+K);
    if (ppt->has_vectors == _TRUE_)
      q_max = MIN(q_max,sqrt(k_max*k_max+2.*K));
    if (ppt->has_tensors == _TRUE_)
      q_max = MIN(q_max,sqrt(k_max*k_max+3.*K));
  }

  /* first and last value in closed case*/

  else if (sgnK == 1) {
    nu_min = 3;
    q_min = nu_min * sqrt(K);

    q_max = 0.;
    for (index_md=0; index_md<ppt->md_size; index_md++) {
      q_max = MAX(q_max,ppt->k[index_md][ppt->k_size[index_md]-1]);
    }
  }

  /* number of values */
  ptr->q_size_limber = (int)(log(q_max/q_min)/log(ppr->q_logstep_limber))+1;

  class_alloc(ptr->q_limber,
              ptr->q_size_limber*sizeof(double),
              ptr->error_message);

  /* assign the first value before starting the loop */

  ptr->q_limber[0] = q_min;
  for (index_q = 1; index_q < ptr->q_size_limber; index_q++) {
    ptr->q_limber[index_q] = ppr->q_logstep_limber *  ptr->q_limber[index_q-1];
  }

  return _SUCCESS_;

}

/**
 * This routine infers from the q values a list of corresponding k
 * values for each mode.
 *
 * @param ppt     Input: pointer to perturbation structure
 * @param ptr     Input/Output: pointer to transfer structure containing q's
 * @param K       Input: spatial curvature
 * @return the error status
 */

int transfer_get_k_list(
                        struct perturbations * ppt,
                        struct transfer * ptr,
                        double K
                        ) {

  int index_md;
  int index_q;
  double m=0.;

  class_alloc(ptr->k,ptr->md_size*sizeof(double*),ptr->error_message);
  if (ptr->do_lcmb_full_limber == _TRUE_) {
    class_alloc(ptr->k_limber,ptr->md_size*sizeof(double*),ptr->error_message);
  }

  for (index_md = 0; index_md <  ptr->md_size; index_md++) {

    class_alloc(ptr->k[index_md],ptr->q_size*sizeof(double),ptr->error_message);
    if (ptr->do_lcmb_full_limber == _TRUE_) {
      class_alloc(ptr->k_limber[index_md],ptr->q_size_limber*sizeof(double),ptr->error_message);
    }

    if (_scalars_) {
      m=0.;
    }
    if (_vectors_) {
      m=1.;
    }
    if (_tensors_) {
      m=2.;
    }

    for (index_q=0; index_q < ptr->q_size; index_q++) {
      ptr->k[index_md][index_q] = sqrt(ptr->q[index_q]*ptr->q[index_q]-K*(m+1.));
    }
    if (ptr->do_lcmb_full_limber == _TRUE_) {
      for (index_q=0; index_q < ptr->q_size_limber; index_q++) {
        ptr->k_limber[index_md][index_q] = sqrt(ptr->q_limber[index_q]*ptr->q_limber[index_q]-K*(m+1.));
      }
    }

    /* check consistency of the first value of ptr->k */
    if (ptr->k[index_md][0] < ppt->k[index_md][0]){
      /* If ptr->k[index_md][0] < ppt->k[index_md][0] at the level of rounding,
         adjust first value of k_list to avoid interpolation errors: */
      if ((ppt->k[index_md][0]-ptr->k[index_md][0]) < 10.*DBL_EPSILON){
        ptr->k[index_md][0] = ppt->k[index_md][0];
      }
      else{
        class_stop(ptr->error_message,
                   "bug in k_list calculation: in perturbation module k_min=%e, in transfer module k_min[mode=%d]=%e, interpolation impossible",
                   ppt->k[0][0],
                   index_md,
                   ptr->k[index_md][0]);
      }
    }

    /* check consistency of the first value of ptr->k_limber */
    if (ptr->do_lcmb_full_limber == _TRUE_) {
      if (ptr->k_limber[index_md][0] < ppt->k[index_md][0]){
        /* If ptr->k_limber[index_md][0] < ppt->k[index_md][0] at the level of rounding,
           adjust first value of k_list to avoid interpolation errors: */
        if ((ppt->k[index_md][0]-ptr->k_limber[index_md][0]) < 10.*DBL_EPSILON){
          ptr->k_limber[index_md][0] = ppt->k[index_md][0];
        }
        else{
          class_stop(ptr->error_message,
                     "bug in k_list calculation: in perturbation module k_min=%e, in transfer module k_min[mode=%d]=%e, interpolation impossible",
                     ppt->k[0][0],
                     index_md,
                     ptr->k_limber[index_md][0]);
        }
      }
    }

    /* check consistency of the last value of ptr->k compared to the one of ppt->k across all modes (hence the 0 index) */
    class_test(ptr->k[index_md][ptr->q_size-1] > ppt->k[0][ppt->k_size_cl[0]-1],
               ptr->error_message,
               "bug in k_list calculation: in perturbation module k_max=%e, in transfer module k_max[mode=%d]=%e, interpolation impossible",
               ppt->k[0][ppt->k_size_cl[0]-1],
               index_md,
               ptr->k[index_md][ptr->q_size-1]);

    /* check consistency of the last value of ptr->k_limber compared to the one of ppt->k across all modes (hence the 0 index) */
    if (ptr->do_lcmb_full_limber == _TRUE_) {
      class_test(ptr->k_limber[index_md][ptr->q_size_limber-1] > ppt->k[0][ppt->k_size[0]-1],
                 ptr->error_message,
                 "bug in k_list calculation: in perturbation module k_max=%e, in transfer module k_max[mode=%d]=%e, interpolation impossible",
                 ppt->k[0][ppt->k_size[0]-1],
                 index_md,
                 ptr->k_limber[index_md][ptr->q_size_limber-1]);
    }

  }

  return _SUCCESS_;

}

/**
 * This routine defines the correspondence between the sources in the
 * perturbation and transfer module.
 *
 * @param ppt  Input: pointer to perturbation structure
 * @param ptr  Input: pointer to transfer structure containing l's
 * @param tp_of_tt Input/Output: array with the correspondence (allocated before, filled here)
 * @return the error status
 */

int transfer_get_source_correspondence(
                                       struct perturbations * ppt,
                                       struct transfer * ptr,
                                       int ** tp_of_tt
                                       ) {
  /** Summary: */
  /** - running index on modes */
  int index_md;

  /** - running index on transfer types */
  int index_tt;

  /** - which source are we considering? Define correspondence
      between transfer types and source types */

  for (index_md = 0; index_md < ptr->md_size; index_md++) {

    class_alloc(tp_of_tt[index_md],ptr->tt_size[index_md]*sizeof(int),ptr->error_message);

    for (index_tt=0; index_tt<ptr->tt_size[index_md]; index_tt++) {

      if (_scalars_) {

        if ((ppt->has_cl_cmb_temperature == _TRUE_) && (index_tt == ptr->index_tt_t0))
          tp_of_tt[index_md][index_tt]=ppt->index_tp_t0;

        if ((ppt->has_cl_cmb_temperature == _TRUE_) && (index_tt == ptr->index_tt_t1))
          tp_of_tt[index_md][index_tt]=ppt->index_tp_t1;

        if ((ppt->has_cl_cmb_temperature == _TRUE_) && (index_tt == ptr->index_tt_t2))
          tp_of_tt[index_md][index_tt]=ppt->index_tp_t2;

        if ((ppt->has_cl_cmb_polarization == _TRUE_) && (index_tt == ptr->index_tt_e))
          tp_of_tt[index_md][index_tt]=ppt->index_tp_p;

        if ((ppt->has_cl_cmb_lensing_potential == _TRUE_) && (index_tt == ptr->index_tt_lcmb))
          tp_of_tt[index_md][index_tt]=ppt->index_tp_phi_plus_psi;

        if (_index_tt_in_range_(ptr->index_tt_density, ppt->selection_num, ppt->has_nc_density))
          /* use here delta_cb rather than delta_m if density number counts calculated only for cold dark matter + baryon */
          /* (this important comment is referenced in a WARNING message in perturbations.c) */
          tp_of_tt[index_md][index_tt]=ppt->index_tp_delta_m;

        if (_index_tt_in_range_(ptr->index_tt_rsd,     ppt->selection_num, ppt->has_nc_rsd))
          tp_of_tt[index_md][index_tt]=ppt->index_tp_theta_m;

        if (_index_tt_in_range_(ptr->index_tt_d0,      ppt->selection_num, ppt->has_nc_rsd))
          tp_of_tt[index_md][index_tt]=ppt->index_tp_theta_m;

        if (_index_tt_in_range_(ptr->index_tt_d1,      ppt->selection_num, ppt->has_nc_rsd))
          tp_of_tt[index_md][index_tt]=ppt->index_tp_theta_m;

        if (_index_tt_in_range_(ptr->index_tt_nc_lens, ppt->selection_num, ppt->has_nc_lens))
          tp_of_tt[index_md][index_tt]=ppt->index_tp_phi_plus_psi;

        if (_index_tt_in_range_(ptr->index_tt_nc_g1,   ppt->selection_num, ppt->has_nc_gr))
          tp_of_tt[index_md][index_tt]=ppt->index_tp_psi;

        if (_index_tt_in_range_(ptr->index_tt_nc_g2,   ppt->selection_num, ppt->has_nc_gr))
          tp_of_tt[index_md][index_tt]=ppt->index_tp_phi;

        if (_index_tt_in_range_(ptr->index_tt_nc_g3,   ppt->selection_num, ppt->has_nc_gr))
          tp_of_tt[index_md][index_tt]=ppt->index_tp_phi_prime;

        if (_index_tt_in_range_(ptr->index_tt_nc_g4,   ppt->selection_num, ppt->has_nc_gr))
          tp_of_tt[index_md][index_tt]=ppt->index_tp_phi_plus_psi;

        if (_index_tt_in_range_(ptr->index_tt_nc_g5,   ppt->selection_num, ppt->has_nc_gr))
          tp_of_tt[index_md][index_tt]=ppt->index_tp_phi_plus_psi;

        if ((ppt->has_cl_lensing_potential == _TRUE_) && (index_tt >= ptr->index_tt_lensing) && (index_tt < ptr->index_tt_lensing+ppt->selection_num))
          tp_of_tt[index_md][index_tt]=ppt->index_tp_phi_plus_psi;

      }

      if (_vectors_) {

        if ((ppt->has_cl_cmb_temperature == _TRUE_) && (index_tt == ptr->index_tt_t1))
          tp_of_tt[index_md][index_tt]=ppt->index_tp_t1;

        if ((ppt->has_cl_cmb_temperature == _TRUE_) && (index_tt == ptr->index_tt_t2))
          tp_of_tt[index_md][index_tt]=ppt->index_tp_t2;

        if ((ppt->has_cl_cmb_polarization == _TRUE_) && (index_tt == ptr->index_tt_e))
          tp_of_tt[index_md][index_tt]=ppt->index_tp_p;

        if ((ppt->has_cl_cmb_polarization == _TRUE_) && (index_tt == ptr->index_tt_b))
          tp_of_tt[index_md][index_tt]=ppt->index_tp_p;
      }

      if (_tensors_) {

        if ((ppt->has_cl_cmb_temperature == _TRUE_) && (index_tt == ptr->index_tt_t2))
          tp_of_tt[index_md][index_tt]=ppt->index_tp_t2;

        if ((ppt->has_cl_cmb_polarization == _TRUE_) && (index_tt == ptr->index_tt_e))
          tp_of_tt[index_md][index_tt]=ppt->index_tp_p;

        if ((ppt->has_cl_cmb_polarization == _TRUE_) && (index_tt == ptr->index_tt_b))
          tp_of_tt[index_md][index_tt]=ppt->index_tp_p;
      }
    }
  }

  return _SUCCESS_;

}

int transfer_free_source_correspondence(
                                        struct transfer * ptr,
                                        int ** tp_of_tt
                                        ) {

  int index_md;

  for (index_md = 0; index_md < ptr->md_size; index_md++) {
    free(tp_of_tt[index_md]);
  }
  free(tp_of_tt);

  return _SUCCESS_;

}

int transfer_source_tau_size_max(
                                 struct precision * ppr,
                                 struct background * pba,
                                 struct perturbations * ppt,
                                 struct transfer * ptr,
                                 double tau_rec,
                                 double tau0,
                                 int * tau_size_max
                                 ) {

  int index_md;
  int index_tt;
  int tau_size_tt=0;

  *tau_size_max = 0;

  for (index_md = 0; index_md < ptr->md_size; index_md++) {

    for (index_tt = 0; index_tt < ptr->tt_size[index_md]; index_tt++) {

      class_call(transfer_source_tau_size(ppr,
                                          pba,
                                          ppt,
                                          ptr,
                                          tau_rec,
                                          tau0,
                                          index_md,
                                          index_tt,
                                          &tau_size_tt),
                 ptr->error_message,
                 ptr->error_message);

      *tau_size_max = MAX(*tau_size_max,tau_size_tt);
    }
  }

  return _SUCCESS_;
}

/**
 * the code makes a distinction between "perturbation sources"
 * (e.g. gravitational potential) and "transfer sources" (e.g. total
 * density fluctuations, obtained through the Poisson equation, and
 * observed with a given selection function).
 *
 * This routine computes the number of sampled time values for each type
 * of transfer sources.
 *
 * @param ppr                   Input: pointer to precision structure
 * @param pba                   Input: pointer to background structure
 * @param ppt                   Input: pointer to perturbation structure
 * @param ptr                   Input: pointer to transfer structure
 * @param tau_rec               Input: recombination time
 * @param tau0                  Input: time today
 * @param index_md              Input: index of the mode (scalar, tensor)
 * @param index_tt              Input: index of transfer type
 * @param tau_size              Output: pointer to number of sampled times
 * @return the error status
 */

int transfer_source_tau_size(
                             struct precision * ppr,
                             struct background * pba,
                             struct perturbations * ppt,
                             struct transfer * ptr,
                             double tau_rec,
                             double tau0,
                             int index_md,
                             int index_tt,
                             int * tau_size) {

  /* values of conformal time */
  double tau_min,tau_mean,tau_max;

  /* minimum value of index_tt */
  int index_tau_min;

  /* value of l at which limber approximation is switched on */
  int l_limber;

  /* current redshift bin number */
  int bin=0;

  /* scalar mode */
  if (_scalars_) {

    /* scalar temperature */
    if ((ppt->has_cl_cmb_temperature == _TRUE_) &&
        ((index_tt == ptr->index_tt_t0) || (index_tt == ptr->index_tt_t1) || (index_tt == ptr->index_tt_t2)))
      *tau_size = ppt->tau_size;

    /* scalar polarization */
    if ((ppt->has_cl_cmb_polarization == _TRUE_) && (index_tt == ptr->index_tt_e))
      *tau_size = ppt->tau_size;

    /* cmb lensing potential */
    if ((ppt->has_cl_cmb_lensing_potential == _TRUE_) && (index_tt == ptr->index_tt_lcmb)) {

      /* find times before recombination, that will be thrown away */
      index_tau_min=0;
      while (ppt->tau_sampling[index_tau_min]<=tau_rec) index_tau_min++;

      /* infer number of time steps after removing early times */
      *tau_size = ppt->tau_size-index_tau_min;
    }

    /* density Cl's */
    if (_nonintegrated_ncl_) {

      /* bin number associated to particular redshift bin and selection function */
      if (_index_tt_in_range_(ptr->index_tt_density, ppt->selection_num, ppt->has_nc_density))
        bin = index_tt - ptr->index_tt_density;

      if (_index_tt_in_range_(ptr->index_tt_rsd,     ppt->selection_num, ppt->has_nc_rsd))
        bin = index_tt - ptr->index_tt_rsd;

      if (_index_tt_in_range_(ptr->index_tt_d0,      ppt->selection_num, ppt->has_nc_rsd))
        bin = index_tt - ptr->index_tt_d0;

      if (_index_tt_in_range_(ptr->index_tt_d1,      ppt->selection_num, ppt->has_nc_rsd))
        bin = index_tt - ptr->index_tt_d1;

      if (_index_tt_in_range_(ptr->index_tt_nc_g1,   ppt->selection_num, ppt->has_nc_gr))
        bin = index_tt - ptr->index_tt_nc_g1;

      if (_index_tt_in_range_(ptr->index_tt_nc_g2,   ppt->selection_num, ppt->has_nc_gr))
        bin = index_tt - ptr->index_tt_nc_g2;

      if (_index_tt_in_range_(ptr->index_tt_nc_g3,   ppt->selection_num, ppt->has_nc_gr))
        bin = index_tt - ptr->index_tt_nc_g3;

      /* time interval for this bin */
      class_call(transfer_selection_times(ppr,
                                          pba,
                                          ppt,
                                          ptr,
                                          bin,
                                          &tau_min,
                                          &tau_mean,
                                          &tau_max),
                 ptr->error_message,
                 ptr->error_message);

      /* case selection=dirac */
      if (tau_min == tau_max) {
        *tau_size = 1;
      }
      /* other cases (gaussian, top-hat...) */
      else {

        /* check that selection function well sampled */
        *tau_size = (int)ppr->selection_sampling;

        /* value of l at which the code switches to Limber approximation
           (necessary for next step) */
        l_limber=ppr->l_switch_limber_for_nc_local_over_z*ppt->selection_mean[bin];
        /* check that bessel well sampled, if not define finer sampling
           overwriting the previous one.
           One Bessel oscillations corresponds to [Delta tau]=2pi/k.
           This is minimal for largest relevant k_max,
           namely k_max=l_limber/(tau0-tau_mean).
           We need to cut the interval (tau_max-tau_min) in pieces of size
           [Delta tau]=2pi/k_max. This gives the number below.
        */
        *tau_size=MAX(*tau_size,(int)((tau_max-tau_min)/((tau0-tau_mean)/MIN(l_limber,ppt->l_lss_max)))*ppr->selection_sampling_bessel);
      }
    }

    /* galaxy lensing Cl's, differs from density Cl's since the source
       function will spread from the selection function region up to
       tau0 */
    if (_integrated_ncl_) {

      /* bin number associated to particular redshift bin and selection function */
      if (_index_tt_in_range_(ptr->index_tt_lensing, ppt->selection_num, ppt->has_cl_lensing_potential))
        bin = index_tt - ptr->index_tt_lensing;

      if (_index_tt_in_range_(ptr->index_tt_nc_lens, ppt->selection_num, ppt->has_nc_lens))
        bin = index_tt - ptr->index_tt_nc_lens;

      if (_index_tt_in_range_(ptr->index_tt_nc_g4,   ppt->selection_num, ppt->has_nc_gr))
        bin = index_tt - ptr->index_tt_nc_g4;

      if (_index_tt_in_range_(ptr->index_tt_nc_g5,   ppt->selection_num, ppt->has_nc_gr))
        bin = index_tt - ptr->index_tt_nc_g5;

      /* time interval for this bin */
      class_call(transfer_selection_times(ppr,
                                          pba,
                                          ppt,
                                          ptr,
                                          bin,
                                          &tau_min,
                                          &tau_mean,
                                          &tau_max),
                 ptr->error_message,
                 ptr->error_message);

      /* check that selection function well sampled */
      *tau_size = (int)ppr->selection_sampling;

      /* value of l at which the code switches to Limber approximation
         (necessary for next step) */
      if (_index_tt_in_range_(ptr->index_tt_nc_g5,   ppt->selection_num, ppt->has_nc_gr)) {
        /* Even if G5 is integrated along the line-of-sight, we do not apply the same Limber criteria as for the other integrated terms, because here we have the derivative of the Bessel.  */
        l_limber=ppr->l_switch_limber_for_nc_local_over_z*ppt->selection_mean[bin];
        *tau_size=MAX(*tau_size,(int)((tau0-tau_min)/((tau0-tau_mean)/2./MIN(l_limber,ppt->l_lss_max)))*ppr->selection_sampling_bessel);
      }
      else {
        l_limber=ppr->l_switch_limber_for_nc_los_over_z*ppt->selection_mean[bin];
        /* check that bessel well sampled, if not define finer sampling
           overwriting the previous one.
           One Bessel oscillations corresponds to [Delta tau]=2pi/k.
           This is minimal for largest relevant k_max,
           namely k_max=l_limber/((tau0-tau_mean)/2).
           We need to cut the interval (tau_0-tau_min) in pieces of size
           [Delta tau]=2pi/k_max. This gives the number below.
        */
        *tau_size=MAX(*tau_size,(int)((tau0-tau_min)/((tau0-tau_mean)/2./MIN(l_limber,ppt->l_lss_max)))*ppr->selection_sampling_bessel_los);
      }
    }
  }

  /* tensor mode */
  if (_tensors_) {

    /* for all tensor types */
    *tau_size = ppt->tau_size;
  }

  return _SUCCESS_;
}

int transfer_compute_for_each_q(
                                struct precision * ppr,
                                struct background * pba,
                                struct perturbations * ppt,
                                struct transfer * ptr,
                                int ** tp_of_tt,
                                int index_q,
                                int tau_size_max,
                                double tau_rec,
                                double *** pert_sources,
                                double *** pert_sources_spline,
                                double * window,
                                struct transfer_workspace * ptw,
                                short use_full_limber
                                ) {

  /** Summary: */

  /** - define local variables */

  /* running index for modes */
  int index_md;
  /* running index for initial conditions */
  int index_ic;
  /* running index for transfer types */
  int index_tt;
  /* running index for multipoles */
  int index_l;

  /** - we deal with workspaces, i.e. with contiguous memory zones (one
      per thread) containing various fields used by the integration
      routine */

  /* - first workspace field: perturbation source interpolated from perturbation structure */
  double * interpolated_sources;

  /* - second workspace field: list of tau0-tau values, tau0_minus_tau[index_tau] */
  double * tau0_minus_tau;

  /* - third workspace field: list of trapezoidal weights for integration over tau */
  double * w_trapz;

  /* - fourth workspace field, containing just a double: number of time values */
  int * tau_size;

  /* - fifth workspace field, identical to above interpolated sources:
     sources[index_tau] */
  double * sources;

  /** - for a given l, maximum value of k such that we can convolve
      the source with Bessel functions j_l(x) without reaching x_max */
  double q_max_bessel=0.;

  /* a value of index_type */
  int previous_type;

  double l;

  short neglect;

  radial_function_type radial_type;

  double q,k,k_max;

  /** - store the sources in the workspace and define all
      fields in this workspace */
  interpolated_sources = ptw->interpolated_sources;
  tau0_minus_tau = ptw->tau0_minus_tau;
  w_trapz  = ptw->w_trapz;
  tau_size = &(ptw->tau_size);
  sources = ptw->sources;

  /** - loop over all modes. For each mode */

  for (index_md = 0; index_md < ptr->md_size; index_md++) {

    if (use_full_limber == _FALSE_) {
      q = ptr->q[index_q];
      k = ptr->k[index_md][index_q];
      k_max = ppt->k[index_md][ppt->k_size_cl[index_md]-1];
    }
    else {
      q = ptr->q_limber[index_q];
      k = ptr->k_limber[index_md][index_q];
      k_max = ppt->k[index_md][ppt->k_size[index_md]-1];
    }


    /* if we reached q_max for this mode, there is nothing to be done */

    if (k <= k_max) {

      /** - loop over initial conditions. */
      /* For each of them: */

      for (index_ic = 0; index_ic < ppt->ic_size[index_md]; index_ic++) {

        /* initialize the previous type index */
        previous_type=-1;

        /* - loop over types. For each of them: */

        for (index_tt = 0; index_tt < ptr->tt_size[index_md]; index_tt++) {


          /** - define here wich transfer fucntion should be computed
                in the standard way and full limber way. Currently:
                compute all transfer functions in the standard way and
                only the lensing CMB potential in the full limber
                way. */

          if ((use_full_limber == _FALSE_) || (index_tt == ptr->index_tt_lcmb)) {

            /** - check if we must now deal with a new source with a
                new index ppt->index_type. If yes, interpolate it at the
                right values of k. */

            if (tp_of_tt[index_md][index_tt] != previous_type) {

              class_call(transfer_interpolate_sources(ppt,
                                                      ptr,
                                                      k,
                                                      index_md,
                                                      index_ic,
                                                      tp_of_tt[index_md][index_tt],
                                                      pert_sources[index_md][index_ic * ppt->tp_size[index_md] + tp_of_tt[index_md][index_tt]],
                                                      pert_sources_spline[index_md][index_ic * ppt->tp_size[index_md] + tp_of_tt[index_md][index_tt]],
                                                      interpolated_sources),
                         ptr->error_message,
                         ptr->error_message);
            }

            previous_type = tp_of_tt[index_md][index_tt];

            /* the code makes a distinction between "perturbation
               sources" (e.g. gravitational potential) and "transfer
               sources" (e.g. total density fluctuations, obtained
               through the Poisson equation, and observed with a given
               selection function).

               The next routine computes the transfer source given the
               interpolated perturbation source, and copies it in the
               workspace. */

            class_call(transfer_sources(ppr,
                                        pba,
                                        ppt,
                                        ptr,
                                        interpolated_sources,
                                        tau_rec,
                                        k,
                                        index_md,
                                        index_tt,
                                        sources,
                                        window,
                                        tau_size_max,
                                        tau0_minus_tau,
                                        w_trapz,
                                        tau_size),
                       ptr->error_message,
                       ptr->error_message);

            /* now that the array of times tau0_minus_tau is known, we can
               infer the array of radial coordinates r(tau0_minus_tau) as well as a
               few other quantities related by trigonometric functions */

            class_call(transfer_radial_coordinates(ptr,ptw,index_md,index_q),
                       ptr->error_message,
                       ptr->error_message);

            /** - Select radial function type */
            class_call(transfer_select_radial_function(
                                                       ppt,
                                                       ptr,
                                                       index_md,
                                                       index_tt,
                                                       &radial_type),
                       ptr->error_message,
                       ptr->error_message);

            for (index_l = 0; index_l < ptr->l_size[index_md]; index_l++) {

              l = (double)ptr->l[index_l];

              /* neglect transfer function when l is much smaller than k*tau0 */
              class_call(transfer_can_be_neglected(ppr,
                                                   ppt,
                                                   ptr,
                                                   index_md,
                                                   index_ic,
                                                   index_tt,
                                                   (pba->conformal_age-tau_rec)*ptr->angular_rescaling,
                                                   ptr->q[index_q],
                                                   l,
                                                   &neglect),
                         ptr->error_message,
                         ptr->error_message);

              /* for K>0 (closed), transfer functions only defined for l<nu */
              if ((ptw->sgnK == 1) && (ptr->l[index_l] >= (int)(q/sqrt(ptw->K)+0.2))) {
                neglect = _TRUE_;
              }
              /* This would maybe go into transfer_can_be_neglected later: */
              if ((ptw->sgnK != 0) && (index_l>=ptw->HIS.l_size) && (index_q < ptr->index_q_flat_approximation) && (use_full_limber == _FALSE_)) {
                neglect = _TRUE_;
              }
              if (neglect == _TRUE_) {

                if (use_full_limber == _FALSE_) {
                  ptr->transfer[index_md][((index_ic * ptr->tt_size[index_md] + index_tt)
                                           * ptr->l_size[index_md] + index_l)
                                          * ptr->q_size + index_q] = 0.;
                }
                else {
                  ptr->transfer_limber[index_md][((index_ic * ptr->tt_size[index_md] + index_tt)
                                                  * ptr->l_size[index_md] + index_l)
                                                 * ptr->q_size_limber + index_q] = 0.;
                }
              }
              else {

                if (use_full_limber == _FALSE_) {

                  /* for a given l, maximum value of k such that we can
                     convolve the source with Bessel functions j_l(x)
                     without reaching x_max (this is relevant in the flat
                     case when the bessels are computed with the old bessel
                     module. otherwise this condition is guaranteed by the
                     choice of proper xmax when computing bessels) */
                  if (ptw->sgnK == 0) {
                    q_max_bessel = ptw->pBIS->x[ptw->pBIS->x_size-1]/tau0_minus_tau[0];
                  }
                  else {
                    q_max_bessel = ptr->q[ptr->q_size-1];
                  }

                  /* neglect late time CMB sources when l is above threshold */
                  class_call(transfer_late_source_can_be_neglected(ppr,
                                                                   ppt,
                                                                   ptr,
                                                                   index_md,
                                                                   index_tt,
                                                                   l,
                                                                   &(ptw->neglect_late_source)),
                             ptr->error_message,
                             ptr->error_message);
                }

                /* note: if use_full_limber == _TRUE_, q_max_bessel is
                   still equal to zero at this stage, but this is OK
                   because in this case it will never be used, not
                   even inside transfer_compute_for_each_l() */

                /* compute the transfer function for this l */
                class_call(transfer_compute_for_each_l(
                                                       ptw,
                                                       ppr,
                                                       ppt,
                                                       ptr,
                                                       index_q,
                                                       index_md,
                                                       index_ic,
                                                       index_tt,
                                                       index_l,
                                                       l,
                                                       q_max_bessel,
                                                       radial_type,
                                                       use_full_limber
                                                       ),
                           ptr->error_message,
                           ptr->error_message);
              }

            } /* end of loop over l */

          }
          else {
            for (index_l = 0; index_l < ptr->l_size[index_md]; index_l++) {
              if (use_full_limber == _FALSE_) {
                ptr->transfer[index_md][((index_ic * ptr->tt_size[index_md] + index_tt)
                                         * ptr->l_size[index_md] + index_l)
                                        * ptr->q_size + index_q] = 0.;
              }
              else {
                ptr->transfer_limber[index_md][((index_ic * ptr->tt_size[index_md] + index_tt)
                                                * ptr->l_size[index_md] + index_l)
                                               * ptr->q_size_limber + index_q] = 0.;
              }
            }
          }

        } /* end of loop over type */

      } /* end of loop over initial condition */

    }

    else {

      for (index_ic = 0; index_ic < ppt->ic_size[index_md]; index_ic++) {
        for (index_tt = 0; index_tt < ptr->tt_size[index_md]; index_tt++) {
          for (index_l = 0; index_l < ptr->l_size[index_md]; index_l++) {

            if (use_full_limber == _FALSE_) {
              ptr->transfer[index_md][((index_ic * ptr->tt_size[index_md] + index_tt)
                                       * ptr->l_size[index_md] + index_l)
                                      * ptr->q_size + index_q] = 0.;
            }
            else {
              ptr->transfer_limber[index_md][((index_ic * ptr->tt_size[index_md] + index_tt)
                                              * ptr->l_size[index_md] + index_l)
                                             * ptr->q_size_limber + index_q] = 0.;
            }
          }
        }
      }
    }

  } /* end of loop over mode */

  return _SUCCESS_;

}

int transfer_radial_coordinates(
                                struct transfer * ptr,
                                struct transfer_workspace * ptw,
                                int index_md,
                                int index_q
                                ) {

  int index_tau;
  double sqrt_absK=0.;

  switch (ptw->sgnK){
  case 1:
    sqrt_absK = sqrt(ptw->K);
    for (index_tau=0; index_tau < ptw->tau_size; index_tau++) {
      ptw->chi[index_tau] = sqrt_absK*ptw->tau0_minus_tau[index_tau];
      ptw->cscKgen[index_tau] = sqrt_absK/ptr->k[index_md][index_q]/sin(ptw->chi[index_tau]);
      ptw->cotKgen[index_tau] = ptw->cscKgen[index_tau]*cos(ptw->chi[index_tau]);
    }
    break;
  case 0:
    for (index_tau=0; index_tau < ptw->tau_size; index_tau++) {
      ptw->chi[index_tau] = ptr->k[index_md][index_q] * ptw->tau0_minus_tau[index_tau];
      ptw->cscKgen[index_tau] = 1.0/ptw->chi[index_tau];
      ptw->cotKgen[index_tau] = 1.0/ptw->chi[index_tau];
    }
    break;
  case -1:
    sqrt_absK = sqrt(-ptw->K);
    for (index_tau=0; index_tau < ptw->tau_size; index_tau++) {
      ptw->chi[index_tau] = sqrt_absK*ptw->tau0_minus_tau[index_tau];
      ptw->cscKgen[index_tau] = sqrt_absK/ptr->k[index_md][index_q]/sinh(ptw->chi[index_tau]);
      ptw->cotKgen[index_tau] = ptw->cscKgen[index_tau]*cosh(ptw->chi[index_tau]);
    }
    break;
  }

  return _SUCCESS_;
}


/**
 * This routine interpolates sources \f$ S(k, \tau) \f$ for each mode,
 * initial condition and type (of perturbation module), to get them at
 * the right values of k, using the spline interpolation method.
 *
 * @param ppt                   Input: pointer to perturbation structure
 * @param ptr                   Input: pointer to transfer structure
 * @param k                     Input: wavenumber at which to interpolate
 * @param index_md              Input: index of mode
 * @param index_ic              Input: index of initial condition
 * @param index_type            Input: index of type of source (in perturbation module)
 * @param pert_source           Input: array of sources
 * @param pert_source_spline    Input: array of second derivative of sources
 * @param interpolated_sources  Output: array of interpolated sources (filled here but allocated in transfer_init() to avoid numerous reallocation)
 * @return the error status
 */

int transfer_interpolate_sources(
                                 struct perturbations * ppt,
                                 struct transfer * ptr,
                                 double k,
                                 int index_md,
                                 int index_ic,
                                 int index_type,
                                 double * pert_source,       /* array with argument pert_source[index_tau*ppt->k_size[index_md]+index_k] (must be allocated) */
                                 double * pert_source_spline, /* array with argument pert_source_spline[index_tau*ppt->k_size[index_md]+index_k] (must be allocated) */
                                 double * interpolated_sources /* array with argument interpolated_sources[index_tau] (must be allocated) */
                                 ) {

  /** Summary: */

  /** - define local variables */

  /* index running on k values in the original source array */
  int index_k;

  /* index running on time */
  int index_tau;

  /* variables used for spline interpolation algorithm */
  double h, a, b;

  /** - interpolate at each k value using the usual
      spline interpolation algorithm. */

  index_k = 0;
  h = ppt->k[index_md][index_k+1] - ppt->k[index_md][index_k];

  while (((index_k+1) < ppt->k_size[index_md]) &&
         (ppt->k[index_md][index_k+1] < k)) {
    index_k++;
    h = ppt->k[index_md][index_k+1] - ppt->k[index_md][index_k];
  }

  class_test(h==0.,
             ptr->error_message,
             "stop to avoid division by zero");

  b = (k - ppt->k[index_md][index_k])/h;
  a = 1.-b;

  for (index_tau = 0; index_tau < ppt->tau_size; index_tau++) {

    interpolated_sources[index_tau] =
      a * pert_source[index_tau*ppt->k_size[index_md]+index_k]
      + b * pert_source[index_tau*ppt->k_size[index_md]+index_k+1]
      + ((a*a*a-a) * pert_source_spline[index_tau*ppt->k_size[index_md]+index_k]
         +(b*b*b-b) * pert_source_spline[index_tau*ppt->k_size[index_md]+index_k+1])*h*h/6.0;

  }

  return _SUCCESS_;

}

/**
 * The code makes a distinction between "perturbation sources"
 * (e.g. gravitational potential) and "transfer sources" (e.g. total
 * density fluctuations, obtained through the Poisson equation, and
 * observed with a given selection function).
 *
 * This routine computes the transfer source given the interpolated
 * perturbation source, and copies it in the workspace.
 *
 * @param ppr                   Input: pointer to precision structure
 * @param pba                   Input: pointer to background structure
 * @param ppt                   Input: pointer to perturbation structure
 * @param ptr                   Input: pointer to transfer structure
 * @param interpolated_sources  Input: interpolated perturbation source
 * @param tau_rec               Input: recombination time
 * @param k                     Input: wavenumber
 * @param index_md              Input: index of mode
 * @param index_tt              Input: index of type of (transfer) source
 * @param sources               Output: transfer source
 * @param window                Input: window functions for each type and time
 * @param tau_size_max          Input: number of times at wich window fucntions are sampled
 * @param tau0_minus_tau        Output: values of (tau0-tau) at which source are sample
 * @param w_trapz               Output: trapezoidal weights for integration over tau
 * @param tau_size_out          Output: pointer to size of previous two arrays, converted to double
 * @return the error status
 */

int transfer_sources(
                     struct precision * ppr,
                     struct background * pba,
                     struct perturbations * ppt,
                     struct transfer * ptr,
                     double * interpolated_sources,
                     double tau_rec,
                     double k,
                     int index_md,
                     int index_tt,
                     double * sources,
                     double * window,
                     int tau_size_max,
                     double * tau0_minus_tau,
                     double * w_trapz,
                     int * tau_size_out
                     )  {

  /** Summary: */

  /** - define local variables */

  /* index running on time */
  int index_tau;

  /* bin for computation of cl_density */
  int bin=0;

  /* number of tau values */
  int tau_size;

  /* minimum tau index kept in transfer sources */
  int index_tau_min;

  /* conformal time */
  double tau, tau0;

  /* rescaling factor depending on the background at a given time */
  double rescaling=0.;

  /* flag: is there any difference between the perturbation and transfer source? */
  short redefine_source;

  /** - in which cases are perturbation and transfer sources are different?
      I.e., in which case do we need to multiply the sources by some
      background and/or window function, and eventually to resample it,
      or redefine its time limits? */

  redefine_source = _FALSE_;

  if (_scalars_) {

    /* cmb lensing potential */
    if ((ppt->has_cl_cmb_lensing_potential == _TRUE_) && (index_tt == ptr->index_tt_lcmb))
      redefine_source = _TRUE_;

    /* number count Cl's */
    if (_nonintegrated_ncl_ || _integrated_ncl_)
      redefine_source = _TRUE_;

  }

  /* conformal time today */
  tau0 = pba->conformal_age;

  /** - case where we need to redefine by a window function (or any
      function of the background and of k) */
  if (redefine_source == _TRUE_) {

    class_call(transfer_source_tau_size(ppr,
                                        pba,
                                        ppt,
                                        ptr,
                                        tau_rec,
                                        tau0,
                                        index_md,
                                        index_tt,
                                        &tau_size),
               ptr->error_message,
               ptr->error_message);

    if (_scalars_) {

      /* lensing source: throw away times before recombination, and multiply psi by window function */

      if ((ppt->has_cl_cmb_lensing_potential == _TRUE_) && (index_tt == ptr->index_tt_lcmb)) {

        /* first time step after removing early times */
        index_tau_min =  ppt->tau_size - tau_size;

        /* loop over time and rescale */
        for (index_tau = index_tau_min; index_tau < ppt->tau_size; index_tau++) {

          /* conformal time */
          tau = ppt->tau_sampling[index_tau];

          /* lensing source =  - W(tau) (phi(k,tau) + psi(k,tau)) Heaviside(tau-tau_rec)
             with
             psi,phi = metric perturbation in newtonian gauge (phi+psi = Phi_A-Phi_H of Bardeen)
             W = (tau-tau_rec)/(tau_0-tau)/(tau_0-tau_rec)
             H(x) = Heaviside
             (in tau = tau_0, set source = 0 to avoid division by zero;
             regulated anyway by Bessel).
          */

          if (index_tau == ppt->tau_size-1) {
            rescaling=0.;
          }
          else {
            switch (pba->sgnK){
            case 1:
              rescaling = sqrt(pba->K)
                *sin((tau_rec-tau)*sqrt(pba->K))
                /sin((tau0-tau)*sqrt(pba->K))
                /sin((tau0-tau_rec)*sqrt(pba->K));
              break;
            case 0:
              rescaling = (tau_rec-tau)/(tau0-tau)/(tau0-tau_rec);
              break;
            case -1:
              rescaling = sqrt(-pba->K)
                *sinh((tau_rec-tau)*sqrt(-pba->K))
                /sinh((tau0-tau)*sqrt(-pba->K))
                /sinh((tau0-tau_rec)*sqrt(-pba->K));
              break;
            }
            // Note: until 2.4.3 there was a bug here: the curvature effects had been omitted.
          }

          /* copy from input array to output array */
          sources[index_tau-index_tau_min] =
            interpolated_sources[index_tau]
            * rescaling
            * ptr->lcmb_rescale
            * pow(k/ptr->lcmb_pivot,ptr->lcmb_tilt);

          /* store value of (tau0-tau) */
          tau0_minus_tau[index_tau-index_tau_min] = tau0 - tau;

        }

        /* Compute trapezoidal weights for integration over tau */
        class_call(array_trapezoidal_mweights(tau0_minus_tau,
                                              tau_size,
                                              w_trapz,
                                              ptr->error_message),
                   ptr->error_message,
                   ptr->error_message);
      }

      /* Non-integrated contributions to dCl/nCl need selection time sampling*/

      if (_nonintegrated_ncl_) {

        _get_bin_nonintegrated_ncl_(index_tt)

          /* redefine the time sampling */
          class_call(transfer_selection_sampling(ppr,
                                                 pba,
                                                 ppt,
                                                 ptr,
                                                 bin,
                                                 tau0_minus_tau,
                                                 tau_size),
                     ptr->error_message,
                     ptr->error_message);

        class_test(tau0 - tau0_minus_tau[0] > ppt->tau_sampling[ppt->tau_size-1],
                   ptr->error_message,
                   "this should not happen, there was probably a rounding error, if this error occurred, then this must be coded more carefully");

        /* resample the source at those times */
        class_call(transfer_source_resample(ppr,
                                            pba,
                                            ppt,
                                            ptr,
                                            bin,
                                            tau0_minus_tau,
                                            tau_size,
                                            index_md,
                                            tau0,
                                            interpolated_sources,
                                            sources),
                   ptr->error_message,
                   ptr->error_message);

        /* Compute trapezoidal weights for integration over tau */
        class_call(array_trapezoidal_mweights(tau0_minus_tau,
                                              tau_size,
                                              w_trapz,
                                              ptr->error_message),
                   ptr->error_message,
                   ptr->error_message);

        /* loop over time and rescale */
        for (index_tau = 0; index_tau < tau_size; index_tau++) {

          /* matter density source =  [- (dz/dtau) W(z)] * delta_m(k,tau)
             = W(tau) delta_m(k,tau)
             with
             delta_m = total matter perturbation (defined in gauge-independent way, see arXiv 1307.1459)
             W(z) = redshift space selection function = dN/dz
             W(tau) = same wrt conformal time = dN/dtau
             (in tau = tau_0, set source = 0 to avoid division by zero;
             regulated anyway by Bessel).
          */

          rescaling = window[index_tt*tau_size_max+index_tau];

          if (_index_tt_in_range_(ptr->index_tt_d0,      ppt->selection_num, ppt->has_nc_rsd))
            rescaling *= 1./k/k; // Factor from original ClassGAL paper ( arXiv 1307.1459 )

          if (_index_tt_in_range_(ptr->index_tt_d1,      ppt->selection_num, ppt->has_nc_rsd))
            rescaling *= 1./k; // Factor from original ClassGAL paper ( arXiv 1307.1459 )

          sources[index_tau] *= rescaling;
        }
      }
      /* End normal contributions */

      /* Integrated contributions to dCl/nCl/sCl need integrated selection time sampling */

      if (_integrated_ncl_) {

        _get_bin_integrated_ncl_(index_tt)

          /* redefine the time sampling */
          class_call(transfer_lensing_sampling(ppr,
                                               pba,
                                               ppt,
                                               ptr,
                                               bin,
                                               tau0,
                                               tau0_minus_tau,
                                               tau_size),
                     ptr->error_message,
                     ptr->error_message);

        /* resample the source at those times */
        class_call(transfer_source_resample(ppr,
                                            pba,
                                            ppt,
                                            ptr,
                                            bin,
                                            tau0_minus_tau,
                                            tau_size,
                                            index_md,
                                            tau0,
                                            interpolated_sources,
                                            sources),
                   ptr->error_message,
                   ptr->error_message);

        /* Compute trapezoidal weights for integration over tau */
        class_call(array_trapezoidal_mweights(tau0_minus_tau,
                                              tau_size,
                                              w_trapz,
                                              ptr->error_message),
                   ptr->error_message,
                   ptr->error_message);

        /* loop over time and rescale */
        for (index_tau = 0; index_tau < tau_size; index_tau++) {

          /* lensing source =  - W(tau) (phi(k,tau) + psi(k,tau)) Heaviside(tau-tau_rec)
             with
             psi,phi = metric perturbation in newtonian gauge (phi+psi = Phi_A-Phi_H of Bardeen)
             W = (tau-tau_rec)/(tau_0-tau)/(tau_0-tau_rec)
             H(x) = Heaviside
             (in tau = tau_0, set source = 0 to avoid division by zero;
             regulated anyway by Bessel).
          */

          /* copy from input array to output array */
          sources[index_tau] *= window[index_tt*tau_size_max+index_tau];

          if (_index_tt_in_range_(ptr->index_tt_nc_g5, ppt->selection_num, ppt->has_nc_gr))
            sources[index_tau] *= k; // Factor from chi derivative of d/dchi j_ell(k*chi)= d/d(kchi) j_ell(k chi) * k = k * j_ell'(kchi)
        }
      }
      /* End integrated contributions */
    }
  }

  /** - case where we do not need to redefine */

  else {

    /* number of sampled time values */
    tau_size = ppt->tau_size;

    /* plain copy from input array to output array */
    memcpy(sources,
           interpolated_sources,
           ppt->tau_size*sizeof(double));

    /* store values of (tau0-tau) */
    for (index_tau=0; index_tau < ppt->tau_size; index_tau++) {
      tau0_minus_tau[index_tau] = tau0 - ppt->tau_sampling[index_tau];
    }

    /* Compute trapezoidal weights for integration over tau */
    class_call(array_trapezoidal_mweights(tau0_minus_tau,
                                          tau_size,
                                          w_trapz,
                                          ptr->error_message),
               ptr->error_message,
               ptr->error_message);
  }

  /** - return tau_size value that will be stored in the workspace (the
      workspace wants a double) */

  *tau_size_out = tau_size;

  return _SUCCESS_;

}

/**
 * Arbitrarily normalized selection function dN/dz(z,bin)
 *
 * @param ppr                   Input: pointer to precision structure
 * @param ppt                   Input: pointer to perturbation structure
 * @param ptr                   Input: pointer to transfer structure
 * @param bin                   Input: redshift bin number
 * @param z                     Input: one value of redshift
 * @param selection             Output: pointer to selection function
 * @return the error status
 */

int transfer_selection_function(
                                struct precision * ppr,
                                struct perturbations * ppt,
                                struct transfer * ptr,
                                int bin,
                                double z,
                                double * selection) {

  double x;
  double dNdz;
  double dln_dNdz_dz;
  int last_index;

  /* trivial dirac case */
  if (ppt->selection==dirac) {

    *selection=1.;

    return _SUCCESS_;
  }

  /* difference between z and the bin center (we can take the absolute
     value as long as all selection functions are symmetric around
     x=0) */
  x=fabs(z-ppt->selection_mean[bin]);

  /* gaussian case (the function is anyway normalized later
     automatically, but could not resist to normalize it already
     here) */
  if (ppt->selection==gaussian) {

    *selection = exp(-0.5*pow(x/ppt->selection_width[bin],2))
      /ppt->selection_width[bin]/sqrt(2.*_PI_);

    if ((ptr->has_nz_file == _TRUE_) || (ptr->has_nz_analytic == _TRUE_)) {

      if (ptr->has_nz_file == _TRUE_) {

        class_test((z<ptr->nz_z[0]) || (z>ptr->nz_z[ptr->nz_size-1]),
                   ptr->error_message,
                   "Your input file for the selection function only covers the redshift range [%f : %f]. However, your input for the selection function requires z=%f",
                   ptr->nz_z[0],
                   ptr->nz_z[ptr->nz_size-1],
                   z);

        class_call(array_interpolate_spline(
                                            ptr->nz_z,
                                            ptr->nz_size,
                                            ptr->nz_nz,
                                            ptr->nz_ddnz,
                                            1,
                                            z,
                                            &last_index,
                                            &dNdz,
                                            1,
                                            ptr->error_message),
                   ptr->error_message,
                   ptr->error_message);
      }
      else {

        class_call(transfer_dNdz_analytic(ptr,
                                          z,
                                          &dNdz,
                                          &dln_dNdz_dz),
                   ptr->error_message,
                   ptr->error_message);
      }

      *selection *= dNdz;
    }

    return _SUCCESS_;
  }

  /* top-hat case, with smoothed edges. The problem with sharp edges
     is that the final result will be affected by random
     noise. Indeed, the values of k at which the transfer functions
     Delta_l(k) are sampled will never coincide with the actual edges
     of the true transfer function (computed with or even without the
     Limber approximation). Hence the integral Cl=\int dk
     Delta_l(k)**2 (...) will be imprecise and will fluctuate randomly
     with the resolution along k. With smooth edges, the problem is
     solved, and the final Cls become mildly dependent on the
     resolution along k. */

  if (ppt->selection==tophat) {

    /* selection function, centered on z=mean (i.e. on x=0), equal to
       one around x=0, with tanh step centered on x=width, of width
       delta x = 0.1*width
    */
    *selection=(1.-tanh((x-ppt->selection_width[bin])/(ppr->selection_tophat_edge*ppt->selection_width[bin])))/2.;

    if ((ptr->has_nz_file == _TRUE_) || (ptr->has_nz_analytic == _TRUE_)) {

      if (ptr->has_nz_file == _TRUE_) {

        class_call(array_interpolate_spline(
                                            ptr->nz_z,
                                            ptr->nz_size,
                                            ptr->nz_nz,
                                            ptr->nz_ddnz,
                                            1,
                                            z,
                                            &last_index,
                                            &dNdz,
                                            1,
                                            ptr->error_message),
                   ptr->error_message,
                   ptr->error_message);
      }
      else {

        class_call(transfer_dNdz_analytic(ptr,
                                          z,
                                          &dNdz,
                                          &dln_dNdz_dz),
                   ptr->error_message,
                   ptr->error_message);
      }

      *selection *= dNdz;
    }

    return _SUCCESS_;
  }

  /* get here only if selection type was recognized */
  class_stop(ptr->error_message,
             "invalid choice of selection function");

  return _SUCCESS_;
}

/**
 * Analytic form for dNdz distribution, from arXiv:1004.4640
 *
 * @param ptr          Input: pointer to transfer structure
 * @param z            Input: redshift
 * @param dNdz         Output: density per redshift, dN/dZ
 * @param dln_dNdz_dz  Output: dln(dN/dz)/dz, used optionally for the source evolution
 * @return the error status
 */

int transfer_dNdz_analytic(
                           struct transfer * ptr,
                           double z,
                           double * dNdz,
                           double * dln_dNdz_dz) {

  /* Implement here your favorite analytic ansatz for the selection
     function. Typical function for photometric sample: dN/dz =
     (z/z0)^alpha exp[-(z/z0)^beta]. Then: dln(dN/dz)/dz = (alpha -
     beta*(z/z0)^beta)/z. In principle, one is free to use different
     ansatz for the selection function and the evolution
     function. Since the selection function uses only dN/dz, while the
     evolution uses only dln(dN/dz)/dz, it is possible to use
     different functions for dN/dz and dln(dN/dz)/dz */

  double z0,alpha,beta;

  //Euclid IST dNdz, do not change this!
  z0 = 0.9/pow(2.,1./2.);
  alpha = 2.0;
  beta = 1.5;

  *dNdz = pow(z/z0,alpha) * exp(-pow(z/z0,beta));

  *dln_dNdz_dz = (alpha - pow(z/z0,beta)*beta)/z;

  return _SUCCESS_;

}

/**
 * For sources that need to be multiplied by a selection function,
 * redefine a finer time sampling in a small range
 *
 * @param ppr                   Input: pointer to precision structure
 * @param pba                   Input: pointer to background structure
 * @param ppt                   Input: pointer to perturbation structure
 * @param ptr                   Input: pointer to transfer structure
 * @param bin                   Input: redshift bin number
 * @param tau0_minus_tau        Output: values of (tau0-tau) at which source are sample
 * @param tau_size              Output: pointer to size of previous array
 * @return the error status
 */

int transfer_selection_sampling(
                                struct precision * ppr,
                                struct background * pba,
                                struct perturbations * ppt,
                                struct transfer * ptr,
                                int bin,
                                double * tau0_minus_tau,
                                int tau_size) {

  /* running index on time */
  int index_tau;

  /* minimum and maximal value of time in new sampled interval */
  double tau_min,tau_mean,tau_max;

  /* time interval for this bin */
  class_call(transfer_selection_times(ppr,
                                      pba,
                                      ppt,
                                      ptr,
                                      bin,
                                      &tau_min,
                                      &tau_mean,
                                      &tau_max),
             ptr->error_message,
             ptr->error_message);

  class_test(tau_size <= 0,
             ptr->error_message,
             "should be at least one");

  /* case selection == dirac */
  if (tau_min == tau_max) {
    class_test(tau_size !=1,
               ptr->error_message,
               "for Dirac selection function tau_size should be 1, not %d",tau_size);
    tau0_minus_tau[0] = pba->conformal_age - tau_mean;
  }
  /* for other cases (gaussian, tophat...) define new sampled values
     of (tau0-tau) with even spacing */
  else {
    for (index_tau=0; index_tau<tau_size-1; index_tau++) {
      tau0_minus_tau[index_tau]=pba->conformal_age-tau_min-((double)index_tau)/((double)tau_size-1.)*(tau_max-tau_min);
    }
    tau0_minus_tau[tau_size-1]=pba->conformal_age-tau_max;
  }

  return _SUCCESS_;

}

/**
 * For lensing sources that need to be convolved with a selection
 * function, redefine the sampling within the range extending from the
 * tau_min of the selection function up to tau0
 *
 *
 * @param ppr                   Input: pointer to precision structure
 * @param pba                   Input: pointer to background structure
 * @param ppt                   Input: pointer to perturbation structure
 * @param ptr                   Input: pointer to transfer structure
 * @param bin                   Input: redshift bin number
 * @param tau0                  Input: time today
 * @param tau0_minus_tau        Output: values of (tau0-tau) at which source are sample
 * @param tau_size              Output: pointer to size of previous array
 * @return the error status
 */

int transfer_lensing_sampling(
                              struct precision * ppr,
                              struct background * pba,
                              struct perturbations * ppt,
                              struct transfer * ptr,
                              int bin,
                              double tau0,
                              double * tau0_minus_tau,
                              int tau_size) {

  /* running index on time */
  int index_tau;

  /* minimum and maximal value of time in new sampled interval */
  double tau_min,tau_mean,tau_max;

  /* time interval for this bin */
  class_call(transfer_selection_times(ppr,
                                      pba,
                                      ppt,
                                      ptr,
                                      bin,
                                      &tau_min,
                                      &tau_mean,
                                      &tau_max),
             ptr->error_message,
             ptr->error_message);

  for (index_tau=0; index_tau<tau_size; index_tau++) {
    //tau0_minus_tau[index_tau]=pba->conformal_age-tau_min-((double)index_tau)/((double)tau_size-1.)*(tau0-tau_min);
    tau0_minus_tau[index_tau]=((double)(tau_size-1-index_tau))/((double)(tau_size-1))*(tau0-tau_min);
  }

  return _SUCCESS_;

}


/**
 * For sources that need to be multiplied by a selection function,
 * redefine a finer time sampling in a small range, and resample the
 * perturbation sources at the new value by linear interpolation
 *
 * @param ppr                   Input: pointer to precision structure
 * @param pba                   Input: pointer to background structure
 * @param ppt                   Input: pointer to perturbation structure
 * @param ptr                   Input: pointer to transfer structure
 * @param bin                   Input: redshift bin number
 * @param tau0_minus_tau        Output: values of (tau0-tau) at which source are sample
 * @param tau_size              Output: pointer to size of previous array
 * @param index_md              Input: index of mode
 * @param tau0                  Input: time today
 * @param interpolated_sources  Input: interpolated perturbation source
 * @param sources               Output: resampled transfer source
 * @return the error status
 */

int transfer_source_resample(
                             struct precision * ppr,
                             struct background * pba,
                             struct perturbations * ppt,
                             struct transfer * ptr,
                             int bin,
                             double * tau0_minus_tau,
                             int tau_size,
                             int index_md,
                             double tau0,
                             double * interpolated_sources,
                             double * sources) {

  /* running index on time */
  int index_tau;

  /* array of values of source */
  double * source_at_tau;

  /* array of source values for a given time and for all k's */
  class_alloc(source_at_tau,
              sizeof(double),
              ptr->error_message);

  /* interpolate the sources linearly at the new time values */
  for (index_tau=0; index_tau<tau_size; index_tau++) {

    class_call(array_interpolate_two(ppt->tau_sampling,
                                     1,
                                     0,
                                     interpolated_sources,
                                     1,
                                     ppt->tau_size,
                                     tau0-tau0_minus_tau[index_tau],
                                     source_at_tau,
                                     1,
                                     ptr->error_message),
               ptr->error_message,
               ptr->error_message);

    /* copy the new values in the output sources array */
    sources[index_tau] = source_at_tau[0];
  }

  /* deallocate the temporary array */
  free(source_at_tau);

  return _SUCCESS_;

}

/**
 * For each selection function, compute the min, mean and max values
 * of conformal time (associated to the min, mean and max values of
 * redshift specified by the user)
 *
 * @param ppr                   Input: pointer to precision structure
 * @param pba                   Input: pointer to background structure
 * @param ppt                   Input: pointer to perturbation structure
 * @param ptr                   Input: pointer to transfer structure
 * @param bin                   Input: redshift bin number
 * @param tau_min               Output: smallest time in the selection interval
 * @param tau_mean              Output: time corresponding to z_mean
 * @param tau_max               Output: largest time in the selection interval
 * @return the error status
 */

int transfer_selection_times(
                             struct precision * ppr,
                             struct background * pba,
                             struct perturbations * ppt,
                             struct transfer * ptr,
                             int bin,
                             double * tau_min,
                             double * tau_mean,
                             double * tau_max) {

  /* a value of redshift */
  double z=0.;

  /* lower edge of time interval for this bin */
  /* the few lines below should be consistent with their counterpart in input.c */
  if (ppt->selection==gaussian) {
    z = ppt->selection_mean[bin]+ppt->selection_width[bin]*ppr->selection_cut_at_sigma;
  }
  if (ppt->selection==tophat) {
    z = ppt->selection_mean[bin]+(1.+ppr->selection_cut_at_sigma*ppr->selection_tophat_edge)*ppt->selection_width[bin];
  }
  if (ppt->selection==dirac) {
    z = ppt->selection_mean[bin];
  }

  class_call(background_tau_of_z(pba,
                                 z,
                                 tau_min),
             pba->error_message,
             ppt->error_message);

  /* higher edge of time interval for this bin */

  if (ppt->selection==gaussian) {
    z = MAX(ppt->selection_mean[bin]-ppt->selection_width[bin]*ppr->selection_cut_at_sigma,0.);
  }
  if (ppt->selection==tophat) {
    z = MAX(ppt->selection_mean[bin]-(1.+ppr->selection_cut_at_sigma*ppr->selection_tophat_edge)*ppt->selection_width[bin],0.);
  }
  if (ppt->selection==dirac) {
    z = ppt->selection_mean[bin];
  }

  class_call(background_tau_of_z(pba,
                                 z,
                                 tau_max),
             pba->error_message,
             ppt->error_message);

  /* central value of time interval for this bin */

  z = MAX(ppt->selection_mean[bin],0.);

  class_call(background_tau_of_z(pba,
                                 z,
                                 tau_mean),
             pba->error_message,
             ppt->error_message);

  return _SUCCESS_;

}

/**
 * Compute and normalize selection function for a set of time values
 *
 * @param ppr                   Input: pointer to precision structure
 * @param pba                   Input: pointer to background structure
 * @param ppt                   Input: pointer to perturbation structure
 * @param ptr                   Input: pointer to transfer structure
 * @param selection             Output: normalized selection function
 * @param tau0_minus_tau        Input: values of (tau0-tau) at which source are sample
 * @param w_trapz               Input: trapezoidal weights for integration over tau
 * @param tau_size              Input: size of previous two arrays
 * @param pvecback              Input: allocated array of background values
 * @param tau0                  Input: time today
 * @param bin                   Input: redshift bin number
 * @return the error status
 */

int transfer_selection_compute(
                               struct precision * ppr,
                               struct background * pba,
                               struct perturbations * ppt,
                               struct transfer * ptr,
                               double * selection,
                               double * tau0_minus_tau,
                               double * w_trapz,
                               int tau_size,
                               double * pvecback,
                               double tau0,
                               int bin) {

  /* running index over time */
  int index_tau;

  /* running value of time */
  double tau;

  /* used for normalizing the selection to one */
  double norm;

  /* used for calling background_at_tau() */
  int last_index;

  /* running value of redshift */
  double z;

  if (tau_size > 1) {

    /* loop over time */
    for (index_tau = 0; index_tau < tau_size; index_tau++) {

      /* running value of time */
      tau = tau0 - tau0_minus_tau[index_tau];

      /* get background quantities at this time */
      class_call(background_at_tau(pba,
                                   tau,
                                   long_info,
                                   inter_normal,
                                   &last_index,
                                   pvecback),
                 pba->error_message,
                 ptr->error_message);

      /* infer redshift (remember that a in the code is in fact a/a_0) */
      z = 1./pvecback[pba->index_bg_a]-1.;

      /* get corresponding dN/dz(z,bin) */
      class_call(transfer_selection_function(ppr,
                                             ppt,
                                             ptr,
                                             bin,
                                             z,
                                             &(selection[index_tau])),
                 ptr->error_message,
                 ptr->error_message);

      /* get corresponding dN/dtau = dN/dz * dz/dtau = dN/dz * H */
      selection[index_tau] *= pvecback[pba->index_bg_H];

    }

    /* compute norm = \int W(tau) dtau */
    class_call(array_trapezoidal_integral(selection,
                                          tau_size,
                                          w_trapz,
                                          &norm,
                                          ptr->error_message),
               ptr->error_message,
               ptr->error_message);


    /* divide W by norm so that \int W(tau) dtau = 1 */
    for (index_tau = 0; index_tau < tau_size; index_tau++) {
      selection[index_tau]/=norm;
    }

  }

  /* trivial case: dirac distribution */
  else {
    selection[0] = 1.;
  }

  return _SUCCESS_;
}

/**
 * This routine computes the transfer functions \f$ \Delta_l^{X} (k) \f$)
 * as a function of wavenumber k for a given mode, initial condition,
 * type and multipole l passed in input.
 *
 * For a given value of k, the transfer function is inferred from
 * the source function (passed in input in the array interpolated_sources)
 * and from Bessel functions (passed in input in the bessels structure),
 * either by convolving them along tau, or by a Limber approximation.
 * This elementary task is distributed either to transfer_integrate()
 * or to transfer_limber(). The task of this routine is mainly to
 * loop over k values, and to decide at which k_max the calculation can
 * be stopped, according to some approximation scheme designed to find a
 * compromise between execution time and precision. The approximation scheme
 * is defined by parameters in the precision structure.
 *
 * @param ptw                   Input: pointer to transfer_workspace structure (allocated in transfer_init() to avoid numerous reallocation)
 * @param ppr                   Input: pointer to precision structure
 * @param ppt                   Input: pointer to perturbation structure
 * @param ptr                   Input/output: pointer to transfer structure (result stored there)
 * @param index_q               Input: index of wavenumber
 * @param index_md              Input: index of mode
 * @param index_ic              Input: index of initial condition
 * @param index_tt              Input: index of type of transfer
 * @param index_l               Input: index of multipole
 * @param l                     Input: multipole
 * @param q_max_bessel          Input: maximum value of argument q at which Bessel functions are computed
 * @param radial_type           Input: type of radial (Bessel) functions to convolve with
 * @param use_full_limber       Inpt: whether we will try using the full Limber scheme
 * @return the error status
 */

int transfer_compute_for_each_l(
                                struct transfer_workspace * ptw,
                                struct precision * ppr,
                                struct perturbations * ppt,
                                struct transfer * ptr,
                                int index_q,
                                int index_md,
                                int index_ic,
                                int index_tt,
                                int index_l,
                                double l,
                                double q_max_bessel,
                                radial_function_type radial_type,
                                short use_full_limber
                                ){

  /** Summary: */

  /** - define local variables */

  /* current wavenumber value */
  double q,k;

  /* value of transfer function */
  double transfer_function;

  /* whether to use the Limber approximation */
  short use_limber;

  /** - return zero transfer function if l is above l_max */
  if (index_l >= ptr->l_size_tt[index_md][index_tt]) {
     transfer_function = 0.;
  }
  else {

    if (ptr->transfer_verbose > 3)
      printf("Compute transfer for l=%d type=%d\n",(int)l,index_tt);

    if (use_full_limber == _FALSE_) {

      q = ptr->q[index_q];
      k = ptr->k[index_md][index_q];

      class_call(transfer_use_limber(ppr,
                                     ppt,
                                     ptr,
                                     q_max_bessel,
                                     index_md,
                                     index_tt,
                                     q,
                                     l,
                                     &use_limber),
                 ptr->error_message,
                 ptr->error_message);
    }
    else {
      q = ptr->q_limber[index_q];
      k = ptr->k_limber[index_md][index_q];
      use_limber = _TRUE_;
    }

    if (use_limber == _TRUE_) {

      class_call(transfer_limber(ptr,
                                 ptw,
                                 index_md,
                                 index_q,
                                 l,
                                 q,
                                 radial_type,
                                 &transfer_function),
                 ptr->error_message,
                 ptr->error_message);

    }
    else {
      class_call(transfer_integrate(
                                    ppt,
                                    ptr,
                                    ptw,
                                    index_q,
                                    index_md,
                                    index_tt,
                                    l,
                                    index_l,
                                    k,
                                    radial_type,
                                    &transfer_function
                                    ),
                 ptr->error_message,
                 ptr->error_message);
    }
  }

  /** - store transfer function in transfer structure */
  if (use_full_limber == _FALSE_) {
    ptr->transfer[index_md][((index_ic * ptr->tt_size[index_md] + index_tt)
                             * ptr->l_size[index_md] + index_l)
                            * ptr->q_size + index_q]
      = transfer_function;
  }
  else {
    ptr->transfer_limber[index_md][((index_ic * ptr->tt_size[index_md] + index_tt)
                                   * ptr->l_size[index_md] + index_l)
                                  * ptr->q_size_limber + index_q]
      = transfer_function;
  }

  return _SUCCESS_;

}

int transfer_use_limber(
                        struct precision * ppr,
                        struct perturbations * ppt,
                        struct transfer * ptr,
                        double q_max_bessel,
                        int index_md,
                        int index_tt,
                        double q,
                        double l,
                        short * use_limber) {


  /* criteria for choosing between integration and Limber
     must be implemented here */

  *use_limber = _FALSE_;

  if (q>q_max_bessel) {
    *use_limber = _TRUE_;
  }
  else {

    if (_scalars_) {

      //TBC: in principle the Limber condition should be adapted to account for curvature effects

      if ((ppt->has_cl_cmb_lensing_potential == _TRUE_) && (index_tt == ptr->index_tt_lcmb) && (l>ppr->l_switch_limber)) {
        *use_limber = _TRUE_;
      }
      if (_index_tt_in_range_(ptr->index_tt_density, ppt->selection_num, ppt->has_nc_density) && (l>=ppr->l_switch_limber_for_nc_local_over_z*ppt->selection_mean[index_tt-ptr->index_tt_density])) {
        if (ppt->selection != dirac) *use_limber = _TRUE_;
      }
      if (_index_tt_in_range_(ptr->index_tt_rsd,     ppt->selection_num, ppt->has_nc_rsd) && (l>=ppr->l_switch_limber_for_nc_local_over_z*ppt->selection_mean[index_tt-ptr->index_tt_rsd])) {
        if (ppt->selection != dirac) *use_limber = _TRUE_;
      }
      if (_index_tt_in_range_(ptr->index_tt_d0,      ppt->selection_num, ppt->has_nc_rsd) && (l>=ppr->l_switch_limber_for_nc_local_over_z*ppt->selection_mean[index_tt-ptr->index_tt_d0])) {
        if (ppt->selection != dirac) *use_limber = _TRUE_;
      }
      if (_index_tt_in_range_(ptr->index_tt_d1,      ppt->selection_num, ppt->has_nc_rsd) && (l>=ppr->l_switch_limber_for_nc_local_over_z*ppt->selection_mean[index_tt-ptr->index_tt_d1])) {
        if (ppt->selection != dirac) *use_limber = _TRUE_;
      }
      if (_index_tt_in_range_(ptr->index_tt_nc_lens, ppt->selection_num, ppt->has_nc_lens) && (l>=ppr->l_switch_limber_for_nc_los_over_z*ppt->selection_mean[index_tt-ptr->index_tt_nc_lens])) {
        if (ppt->selection != dirac) *use_limber = _TRUE_;
      }
      if (_index_tt_in_range_(ptr->index_tt_nc_g1, ppt->selection_num, ppt->has_nc_gr) && (l>=ppr->l_switch_limber_for_nc_local_over_z*ppt->selection_mean[index_tt-ptr->index_tt_nc_g1])) {
        if (ppt->selection != dirac) *use_limber = _TRUE_;
      }
      if (_index_tt_in_range_(ptr->index_tt_nc_g2, ppt->selection_num, ppt->has_nc_gr) && (l>=ppr->l_switch_limber_for_nc_local_over_z*ppt->selection_mean[index_tt-ptr->index_tt_nc_g2])) {
        if (ppt->selection != dirac) *use_limber = _TRUE_;
      }
      if (_index_tt_in_range_(ptr->index_tt_nc_g3, ppt->selection_num, ppt->has_nc_gr) && (l>=ppr->l_switch_limber_for_nc_local_over_z*ppt->selection_mean[index_tt-ptr->index_tt_nc_g3])) {
        if (ppt->selection != dirac) *use_limber = _TRUE_;
      }
      if (_index_tt_in_range_(ptr->index_tt_nc_g4, ppt->selection_num, ppt->has_nc_gr) && (l>=ppr->l_switch_limber_for_nc_los_over_z*ppt->selection_mean[index_tt-ptr->index_tt_nc_g4])) {
        if (ppt->selection != dirac) *use_limber = _TRUE_;
      }
      if (_index_tt_in_range_(ptr->index_tt_nc_g5, ppt->selection_num, ppt->has_nc_gr) && (l>=ppr->l_switch_limber_for_nc_local_over_z*ppt->selection_mean[index_tt-ptr->index_tt_nc_g5])) {
        if (ppt->selection != dirac) *use_limber = _TRUE_;
      }
      if (_index_tt_in_range_(ptr->index_tt_lensing, ppt->selection_num, ppt->has_cl_lensing_potential) && (l>=ppr->l_switch_limber_for_nc_los_over_z*ppt->selection_mean[index_tt-ptr->index_tt_lensing])) {
        *use_limber = _TRUE_;
      }
    }
  }

  return _SUCCESS_;
}

/**
 * This routine computes the transfer functions \f$ \Delta_l^{X} (k) \f$)
 * for each mode, initial condition, type, multipole l and wavenumber k,
 * by convolving  the source function (passed in input in the array
 * interpolated_sources) with Bessel functions (passed in input in the
 * bessels structure).
 *
 * @param ppt            Input: pointer to perturbation structure
 * @param ptr            Input: pointer to transfer structure
 * @param ptw            Input: pointer to transfer_workspace structure (allocated in transfer_init() to avoid numerous reallocation)
 * @param index_q        Input: index of wavenumber
 * @param index_md       Input: index of mode
 * @param index_tt       Input: index of type
 * @param l              Input: multipole
 * @param index_l        Input: index of multipole
 * @param k              Input: wavenumber
 * @param radial_type    Input: type of radial (Bessel) functions to convolve with
 * @param trsf           Output: transfer function \f$ \Delta_l(k) \f$
 * @return the error status
 */

int transfer_integrate(
                       struct perturbations * ppt,
                       struct transfer * ptr,
                       struct transfer_workspace *ptw,
                       int index_q,
                       int index_md,
                       int index_tt,
                       double l,
                       int index_l,
                       double k,
                       radial_function_type radial_type,
                       double * trsf
                       ) {

  /** Summary: */

  /** - define local variables */

  double * tau0_minus_tau = ptw->tau0_minus_tau;
  double * w_trapz = ptw->w_trapz;
  double * sources = ptw->sources;

  /* minimum value of \f$ (\tau0-\tau) \f$ at which \f$ j_l(k[\tau_0-\tau]) \f$ is known, given that \f$ j_l(x) \f$ is sampled above some finite value \f$ x_{\min} \f$ (below which it can be approximated by zero) */
  double tau0_minus_tau_min_bessel;

  /* index in the source's tau list corresponding to the last point in the overlapping region between sources and bessels. Also the index of possible Bessel truncation. */
  int index_tau_max, index_tau_max_Bessel;

  double bessel, *radial_function;

  double x_turning_point;

  /** - find minimum value of (tau0-tau) at which \f$ j_l(k[\tau_0-\tau]) \f$ is known, given that \f$ j_l(x) \f$ is sampled above some finite value \f$ x_{\min} \f$ (below which it can be approximated by zero) */
  //tau0_minus_tau_min_bessel = x_min_l/k; /* segmentation fault impossible, checked before that k != 0 */
  //printf("index_l=%d\n",index_l);
  if (ptw->sgnK==0){
    tau0_minus_tau_min_bessel = ptw->pBIS->chi_at_phimin[index_l]/k; /* segmentation fault impossible, checked before that k != 0 */
  }
  else{

    if (index_q < ptr->index_q_flat_approximation) {

      tau0_minus_tau_min_bessel = ptw->HIS.chi_at_phimin[index_l]/sqrt(ptw->sgnK*ptw->K);

    }
    else {

      tau0_minus_tau_min_bessel = ptw->pBIS->chi_at_phimin[index_l]/sqrt(ptw->sgnK*ptw->K);

      if (ptw->sgnK == 1) {
        x_turning_point = asin(sqrt(l*(l+1.))/ptr->q[index_q]*sqrt(ptw->sgnK*ptw->K));
        tau0_minus_tau_min_bessel *= x_turning_point/sqrt(l*(l+1.));
      }
      else {
        x_turning_point = asinh(sqrt(l*(l+1.))/ptr->q[index_q]*sqrt(ptw->sgnK*ptw->K));
        tau0_minus_tau_min_bessel *= x_turning_point/sqrt(l*(l+1.));
      }
    }
  }
  /** - if there is no overlap between the region in which bessels and sources are non-zero, return zero */
  if (tau0_minus_tau_min_bessel >= tau0_minus_tau[0]) {
    *trsf = 0.;
    return _SUCCESS_;
  }

  /** - if there is an overlap: */

  /** - --> trivial case: the source is a Dirac function and is sampled in only one point */
  if (ptw->tau_size == 1) {

    class_call(transfer_radial_function(
                                        ptw,
                                        ppt,
                                        ptr,
                                        k,
                                        index_q,
                                        index_l,
                                        1,
                                        &bessel,
                                        radial_type
                                        ),
               ptr->error_message,
               ptr->error_message);

    *trsf = sources[0] * bessel;
    return _SUCCESS_;
  }

  /** - --> other cases */

  /** - ---> (a) find index in the source's tau list corresponding to the last point in the overlapping region. After this step, index_tau_max can be as small as zero, but not negative. */
  index_tau_max = ptw->tau_size-1;
  while (tau0_minus_tau[index_tau_max] < tau0_minus_tau_min_bessel)
    index_tau_max--;
  /* Set index so we know if the truncation of the convolution integral is due to Bessel and not
     due to the source. */
  index_tau_max_Bessel = index_tau_max;

  /** - ---> (b) the source function can vanish at large \f$ \tau \f$. Check if further points can be eliminated. After this step and if we did not return a null transfer function, index_tau_max can be as small as zero, but not negative. */
  while (sources[index_tau_max] == 0.) {
    index_tau_max--;
    if (index_tau_max < 0) {
      *trsf = 0.;
      return _SUCCESS_;
    }
  }

  if (ptw->neglect_late_source == _TRUE_) {

    while (tau0_minus_tau[index_tau_max] < ptw->tau0_minus_tau_cut) {
      index_tau_max--;
      if (index_tau_max < 0) {
        *trsf = 0.;
        return _SUCCESS_;
      }
    }
  }

  /** - Compute the radial function: */
  class_alloc(radial_function,sizeof(double)*(index_tau_max+1),ptr->error_message);

  class_call(transfer_radial_function(
                                      ptw,
                                      ppt,
                                      ptr,
                                      k,
                                      index_q,
                                      index_l,
                                      index_tau_max+1,
                                      radial_function,
                                      radial_type
                                      ),
             ptr->error_message,
             ptr->error_message);

  /** - Now we do most of the convolution integral: */
  class_call(array_trapezoidal_convolution(sources,
                                           radial_function,
                                           index_tau_max+1,
                                           w_trapz,
                                           trsf,
                                           ptr->error_message),
             ptr->error_message,
             ptr->error_message);

  /** - This integral is correct for the case where no truncation has
      occurred. If it has been truncated at some index_tau_max because
      f[index_tau_max+1]==0, it is still correct. The 'mistake' in using
      the wrong weight w_trapz[index_tau_max] is exactly compensated by the
      triangle we miss. However, for the Bessel cut off, we must subtract the
      wrong triangle and add the correct triangle. */
  if ((index_tau_max!=(ptw->tau_size-1))&&(index_tau_max==index_tau_max_Bessel)){
    //Bessel truncation
    *trsf -= 0.5*(tau0_minus_tau[index_tau_max+1]-tau0_minus_tau_min_bessel)*
      radial_function[index_tau_max]*sources[index_tau_max];
  }


  free(radial_function);
  return _SUCCESS_;
}

/**
 * This routine computes the transfer functions \f$ \Delta_l^{X} (k) \f$)
 * for each mode, initial condition, type, multipole l and wavenumber k,
 * by using the Limber approximation, i.e by evaluating the source function
 * (passed in input in the array interpolated_sources) at a single value of
 * tau (the Bessel function being approximated as a Dirac distribution).
 *
 *
 * @param ptr            Input: pointer to transfer structure
 * @param ptw            Input: pointer to transfer workspace structure
 * @param index_md       Input: index of mode
 * @param index_q        Input: index of wavenumber
 * @param l              Input: multipole
 * @param q              Input: wavenumber
 * @param radial_type    Input: type of radial (Bessel) functions to convolve with
 * @param trsf           Output: transfer function \f$ \Delta_l(k) \f$
 * @return the error status
 */

int transfer_limber(
                    struct transfer * ptr,
                    struct transfer_workspace * ptw,
                    int index_md,
                    int index_q,
                    double l,
                    double q,
                    radial_function_type radial_type,
                    double * trsf
                    ){

  /** Summary: */

  /** - define local variables */

  /* interpolated source and its derivatives at this value */
  double S, Sp, Sm;

  double x_limber=0.;
  double tau0_minus_tau_limber=0.;
  double IPhiFlat = 0.;

  if (radial_type == SCALAR_TEMPERATURE_0) {

    /** - get k, l and infer tau such that k(tau0-tau)=l+1/2;
        check that tau is in appropriate range */

    if (ptw->sgnK == 0) {
      tau0_minus_tau_limber = (l+0.5)/q;
    }
    else if (ptw->sgnK == 1) {
      x_limber = asin(sqrt(l*(l+1.))/q*sqrt(ptw->K));
      tau0_minus_tau_limber = x_limber/sqrt(ptw->K);
    }
    else if (ptw->sgnK == -1) {
      x_limber = asinh((l+0.5)/q*sqrt(-ptw->K));
      tau0_minus_tau_limber = x_limber/sqrt(-ptw->K);
    }

    if ((tau0_minus_tau_limber > ptw->tau0_minus_tau[0]) ||
        (tau0_minus_tau_limber < ptw->tau0_minus_tau[ptw->tau_size-1])) {
      *trsf = 0.;
      return _SUCCESS_;
    }

    class_call(transfer_limber_interpolate(ptr,
                                           ptw->tau0_minus_tau,
                                           ptw->sources,
                                           ptw->tau_size,
                                           tau0_minus_tau_limber,
                                           &S),
               ptr->error_message,
               ptr->error_message);

    /** - get transfer = source * \f$ \sqrt{\pi/(2l+1)}/q \f$
        = source*[tau0-tau] * \f$ \sqrt{\pi/(2l+1)}/(l+1/2)\f$
    */

    IPhiFlat = sqrt(_PI_/(2.*l))*(1.-0.25/l+1./32./(l*l));

    *trsf = IPhiFlat*S;

    if (ptw->sgnK == 0) {
      *trsf /= (l+0.5);
    }
    else {
      *trsf *= pow(1.-ptw->K*l*l/q/q,-1./4.)/(tau0_minus_tau_limber*q);
    }

  }

  else if (radial_type == SCALAR_TEMPERATURE_1) {

    if (((l+1.5)/q > ptw->tau0_minus_tau[0]) ||
        ((l-0.5)/q < ptw->tau0_minus_tau[ptw->tau_size-1])) {
      *trsf = 0.;
      return _SUCCESS_;
    }

    class_call(transfer_limber_interpolate(ptr,
                                           ptw->tau0_minus_tau,
                                           ptw->sources,
                                           ptw->tau_size,
                                           (l+1.5)/q,
                                           &Sp),
               ptr->error_message,
               ptr->error_message);

    class_call(transfer_limber_interpolate(ptr,
                                           ptw->tau0_minus_tau,
                                           ptw->sources,
                                           ptw->tau_size,
                                           (l-0.5)/q,
                                           &Sm),
               ptr->error_message,
               ptr->error_message);

    *trsf =
      -sqrt(_PI_/(2.*l+3.))*Sp/(l+1.5) * (l+1.)/(2.*l+1)
      +sqrt(_PI_/(2.*l-1.))*Sm/(l-0.5) * l/(2.*l+1.);

  }

  else if (radial_type == NC_RSD) {

    if (((l+2.5)/q > ptw->tau0_minus_tau[0]) ||
        ((l-1.5)/q < ptw->tau0_minus_tau[ptw->tau_size-1])) {
      *trsf = 0.;
      return _SUCCESS_;
    }

    class_call(transfer_limber_interpolate(ptr,
                                           ptw->tau0_minus_tau,
                                           ptw->sources,
                                           ptw->tau_size,
                                           (l+2.5)/q,
                                           &Sp),
               ptr->error_message,
               ptr->error_message);

    class_call(transfer_limber_interpolate(ptr,
                                           ptw->tau0_minus_tau,
                                           ptw->sources,
                                           ptw->tau_size,
                                           (l-1.5)/q,
                                           &Sm),
               ptr->error_message,
               ptr->error_message);

    class_call(transfer_limber_interpolate(ptr,
                                           ptw->tau0_minus_tau,
                                           ptw->sources,
                                           ptw->tau_size,
                                           (l+0.5)/q,
                                           &S),
               ptr->error_message,
               ptr->error_message);

    *trsf =
      sqrt(_PI_/(2.*l+5.))*Sp/(l+2.5) * l*(l+2.)/(2.*l+1.)/(2.*l+3.)
      -sqrt(_PI_/(2.*l+1.))*S/(l+0.5) * l/(2.*l+1.)*(l/(2.*l-1.)+(l+1.)/(2.*l+3.))
      +sqrt(_PI_/(2.*l-3.))*Sm/(l-1.5) * l*(l-1.)/(2.*l+1.)/(2.*l-1.);

  }

  else {

    class_stop(ptr->error_message,
               "Limber approximation has not been coded for the radial_type of index %d\n",
               radial_type);

  }

  return _SUCCESS_;

}

int transfer_limber_interpolate(
                                struct transfer * ptr,
                                double * tau0_minus_tau,
                                double * sources,
                                int tau_size,
                                double tau0_minus_tau_limber,
                                double * S
                                ){

  int index_tau;
  double dS,ddS;

  /** - find  bracketing indices.
      index_tau must be at least 1 (so that index_tau-1 is at least 0)
      and at most tau_size-2 (so that index_tau+1 is at most tau_size-1).
  */
  index_tau=1;
  while ((tau0_minus_tau[index_tau] > tau0_minus_tau_limber) && (index_tau<tau_size-2))
    index_tau++;

  /** - interpolate by fitting a polynomial of order two; get source
      and its first two derivatives. Note that we are not
      interpolating S, but the product S*(tau0-tau). Indeed this
      product is regular in tau=tau0, while S alone diverges for
      lensing. */

  /* the case where the last of the three point is the edge (tau0=tau) must be treated separately, see below */
  if (index_tau < tau_size-2) {

    class_call(array_interpolate_parabola(tau0_minus_tau[index_tau-1],
                                          tau0_minus_tau[index_tau],
                                          tau0_minus_tau[index_tau+1],
                                          tau0_minus_tau_limber,
                                          sources[index_tau-1]*tau0_minus_tau[index_tau-1],
                                          sources[index_tau]*tau0_minus_tau[index_tau],
                                          sources[index_tau+1]*tau0_minus_tau[index_tau+1],
                                          S,
                                          &dS,
                                          &ddS,
                                          ptr->error_message),
               ptr->error_message,
               ptr->error_message);

  }

  /* in this case, we have stored a zero for sources[index_k*tau_size+index_tau+1]. But we can use in very good approximation the fact that S*(tau0-tau) is constant near tau=tau0 and replace sources[index_k*tau_size+index_tau+1]*tau0_minus_tau[index_tau+1] by sources[index_k*tau_size+index_tau]*tau0_minus_tau[index_tau] */
  else {

    class_call(array_interpolate_parabola(tau0_minus_tau[index_tau-1],
                                          tau0_minus_tau[index_tau],
                                          tau0_minus_tau[index_tau+1],
                                          tau0_minus_tau_limber,
                                          sources[index_tau-1]*tau0_minus_tau[index_tau-1],
                                          sources[index_tau]*tau0_minus_tau[index_tau],
                                          sources[index_tau]*tau0_minus_tau[index_tau],
                                          S,
                                          &dS,
                                          &ddS,
                                          ptr->error_message),
               ptr->error_message,
               ptr->error_message);
  }

  return _SUCCESS_;

}

/**
 * This routine computes the transfer functions \f$ \Delta_l^{X} (k)
 * \f$) for each mode, initial condition, type, multipole l and
 * wavenumber k, by using the Limber approximation at order two, i.e
 * as a function of the source function and its first two derivatives
 * at a single value of tau
 *
 * @param tau_size        Input: size of conformal time array
 * @param ptr             Input: pointer to transfer structure
 * @param index_md        Input: index of mode
 * @param index_k         Input: index of wavenumber
 * @param l               Input: multipole
 * @param k               Input: wavenumber
 * @param tau0_minus_tau  Input: array of values of (tau_today - tau)
 * @param sources         Input: source functions
 * @param radial_type     Input: type of radial (Bessel) functions to convolve with
 * @param trsf            Output: transfer function \f$ \Delta_l(k) \f$
 * @return the error status
 */

int transfer_limber2(
                     int tau_size,
                     struct transfer * ptr,
                     int index_md,
                     int index_k,
                     double l,
                     double k,
                     double * tau0_minus_tau,
                     double * sources,
                     radial_function_type radial_type,
                     double * trsf
                     ){

  /** Summary: */

  /** - define local variables */

  /* conformal time at which source must be computed */
  double tau0_minus_tau_limber;
  int index_tau;

  /* interpolated source and its derivatives */
  double S, dS, ddS;

  /** - get k, l and infer tau such that k(tau0-tau)=l+1/2;
      check that tau is in appropriate range */

  tau0_minus_tau_limber = (l+0.5)/k;  //TBC: to be updated to include curvature effects

  if ((tau0_minus_tau_limber > tau0_minus_tau[0]) ||
      (tau0_minus_tau_limber < tau0_minus_tau[tau_size-1])) {
    *trsf = 0.;
    return _SUCCESS_;
  }

  /** - find  bracketing indices */
  index_tau=0;
  while ((tau0_minus_tau[index_tau] > tau0_minus_tau_limber) && (index_tau<tau_size-2))
    index_tau++;

  /** - interpolate by fitting a polynomial of order two; get source
      and its first two derivatives */
  class_call(array_interpolate_parabola(tau0_minus_tau[index_tau-1],
                                        tau0_minus_tau[index_tau],
                                        tau0_minus_tau[index_tau+1],
                                        tau0_minus_tau_limber,
                                        sources[index_tau-1],
                                        sources[index_tau],
                                        sources[index_tau+1],
                                        &S,
                                        &dS,
                                        &ddS,
                                        ptr->error_message),
             ptr->error_message,
             ptr->error_message);


  /** - get transfer from 2nd order Limber approx (inferred from 0809.5112 [astro-ph]) */

  *trsf = sqrt(_PI_/(2.*l+1.))/k*((1.-3./2./(2.*l+1.)/(2.*l+1.))*S+dS/k/(2.*l+1.)-0.5*ddS/k/k);

  return _SUCCESS_;

}

int transfer_can_be_neglected(
                              struct precision * ppr,
                              struct perturbations * ppt,
                              struct transfer * ptr,
                              int index_md,
                              int index_ic,
                              int index_tt,
                              double ra_rec,
                              double k,
                              double l,
                              short * neglect) {

  *neglect = _FALSE_;

  if (_scalars_) {

    if ((ppt->has_cl_cmb_temperature == _TRUE_) && (index_tt == ptr->index_tt_t0) && (l < (k-ppr->transfer_neglect_delta_k_S_t0)*ra_rec)) *neglect = _TRUE_;

    else if ((ppt->has_cl_cmb_temperature == _TRUE_) && (index_tt == ptr->index_tt_t1) && (l < (k-ppr->transfer_neglect_delta_k_S_t1)*ra_rec)) *neglect = _TRUE_;

    else if ((ppt->has_cl_cmb_temperature == _TRUE_) && (index_tt == ptr->index_tt_t2) && (l < (k-ppr->transfer_neglect_delta_k_S_t2)*ra_rec)) *neglect = _TRUE_;

    else if ((ppt->has_cl_cmb_polarization == _TRUE_) && (index_tt == ptr->index_tt_e) && (l < (k-ppr->transfer_neglect_delta_k_S_e)*ra_rec)) *neglect = _TRUE_;

  }

  else if (_vectors_) {

    if ((ppt->has_cl_cmb_temperature == _TRUE_) && (index_tt == ptr->index_tt_t1) && (l < (k-ppr->transfer_neglect_delta_k_V_t1)*ra_rec)) *neglect = _TRUE_;

    else if ((ppt->has_cl_cmb_temperature == _TRUE_) && (index_tt == ptr->index_tt_t2) && (l < (k-ppr->transfer_neglect_delta_k_V_t2)*ra_rec)) *neglect = _TRUE_;

    else if ((ppt->has_cl_cmb_polarization == _TRUE_) && (index_tt == ptr->index_tt_e) && (l < (k-ppr->transfer_neglect_delta_k_V_e)*ra_rec)) *neglect = _TRUE_;

    else if ((ppt->has_cl_cmb_polarization == _TRUE_) && (index_tt == ptr->index_tt_b) && (l < (k-ppr->transfer_neglect_delta_k_V_b)*ra_rec)) *neglect = _TRUE_;

  }

  else if (_tensors_) {

    if ((ppt->has_cl_cmb_temperature == _TRUE_) && (index_tt == ptr->index_tt_t2) && (l < (k-ppr->transfer_neglect_delta_k_T_t2)*ra_rec)) *neglect = _TRUE_;

    else if ((ppt->has_cl_cmb_polarization == _TRUE_) && (index_tt == ptr->index_tt_e) && (l < (k-ppr->transfer_neglect_delta_k_T_e)*ra_rec)) *neglect = _TRUE_;

    else if ((ppt->has_cl_cmb_polarization == _TRUE_) && (index_tt == ptr->index_tt_b) && (l < (k-ppr->transfer_neglect_delta_k_T_b)*ra_rec)) *neglect = _TRUE_;

  }

  return _SUCCESS_;

}

int transfer_late_source_can_be_neglected(
                                          struct precision * ppr,
                                          struct perturbations * ppt,
                                          struct transfer * ptr,
                                          int index_md,
                                          int index_tt,
                                          double l,
                                          short * neglect) {

  *neglect = _FALSE_;

  if (l > ppr->transfer_neglect_late_source*ptr->angular_rescaling) {

    /* sources at late times can be neglected for CMB, excepted when
       there is a LISW: this means for tt_t1, t2, e */

    if (_scalars_) {
      if (ppt->has_cl_cmb_temperature == _TRUE_) {
        if ((index_tt == ptr->index_tt_t1) ||
            (index_tt == ptr->index_tt_t2))
          *neglect = _TRUE_;
      }
      if (ppt->has_cl_cmb_polarization == _TRUE_) {
        if (index_tt == ptr->index_tt_e)
          *neglect = _TRUE_;
      }
    }
    else if (_vectors_) {
      if (ppt->has_cl_cmb_temperature == _TRUE_) {
        if ((index_tt == ptr->index_tt_t1) ||
            (index_tt == ptr->index_tt_t2))
          *neglect = _TRUE_;
      }
      if (ppt->has_cl_cmb_polarization == _TRUE_) {
        if ((index_tt == ptr->index_tt_e) ||
            (index_tt == ptr->index_tt_b))
          *neglect = _TRUE_;
      }
    }
    else if (_tensors_) {
      if (ppt->has_cl_cmb_polarization == _TRUE_) {
        if ((index_tt == ptr->index_tt_e) ||
            (index_tt == ptr->index_tt_b))
          *neglect = _TRUE_;
      }
    }
  }

  return _SUCCESS_;

}

int transfer_radial_function(
                             struct transfer_workspace * ptw,
                             struct perturbations * ppt,
                             struct transfer * ptr,
                             double k,
                             int index_q,
                             int index_l,
                             int x_size,
                             double * radial_function,
                             radial_function_type radial_type
                             ){

  HyperInterpStruct * pHIS;
  double *chi = ptw->chi;
  double *cscKgen = ptw->cscKgen;
  double *cotKgen = ptw->cotKgen;
  int j;
  double *Phi, *dPhi, *d2Phi, *chireverse;
  double K=0.,k2=1.0;
  double sqrt_absK_over_k;
  double absK_over_k2;
  double nu=0., chi_tp=0.;
  double factor, s0, s2, ssqrt3, si, ssqrt2, ssqrt2i;
  double l = (double)ptr->l[index_l];
  double rescale_argument;
  double rescale_amplitude;
  double* rescale_function;
  int (*interpolate_Phi)(HyperInterpStruct*, int, int, double*, double*, char*);
  int (*interpolate_dPhi)(HyperInterpStruct*, int, int, double*, double*, char*);
  int (*interpolate_Phid2Phi)(HyperInterpStruct*, int, int, double*, double*, double*, char*);
  int (*interpolate_PhidPhi)(HyperInterpStruct*, int, int, double*, double*, double*, char*);
  int (*interpolate_PhidPhid2Phi)(HyperInterpStruct*, int, int, double*, double*, double*, double*, char*);
  enum Hermite_Interpolation_Order HIorder;

  K = ptw->K;
  k2 = k*k;

  if (ptw->sgnK==0){
    /* This is the choice consistent with chi=k*(tau0-tau) and nu=1 */
    sqrt_absK_over_k = 1.0;
  }
  else {
    K=ptw->K;
    sqrt_absK_over_k = sqrt(ptw->sgnK*K)/k;
  }
  absK_over_k2 =sqrt_absK_over_k*sqrt_absK_over_k;

  class_alloc(Phi,sizeof(double)*x_size,ptr->error_message);
  class_alloc(dPhi,sizeof(double)*x_size,ptr->error_message);
  class_alloc(d2Phi,sizeof(double)*x_size,ptr->error_message);
  class_alloc(chireverse,sizeof(double)*x_size,ptr->error_message);
  class_alloc(rescale_function,sizeof(double)*x_size,ptr->error_message);

  if (ptw->sgnK == 0) {
    pHIS = ptw->pBIS;
    rescale_argument = 1.;
    rescale_amplitude = 1.;
    HIorder = HERMITE4;
  }
  else if (index_q < ptr->index_q_flat_approximation) {
    pHIS = &(ptw->HIS);
    rescale_argument = 1.;
    rescale_amplitude = 1.;
    HIorder = HERMITE6;
  }
  else {
    pHIS = ptw->pBIS;
    if (ptw->sgnK == 1){
      nu = ptr->q[index_q]/sqrt(K);
      chi_tp = asin(sqrt(ptr->l[index_l]*(ptr->l[index_l]+1.))/nu);
    }
    else{
      nu = ptr->q[index_q]/sqrt(-K);
      chi_tp = asinh(sqrt(ptr->l[index_l]*(ptr->l[index_l]+1.))/nu);
    }
    rescale_argument = sqrt(ptr->l[index_l]*(ptr->l[index_l]+1.))/chi_tp;
    rescale_amplitude = pow(1.-K*ptr->l[index_l]*(ptr->l[index_l]+1.)/ptr->q[index_q]/ptr->q[index_q],-1./12.);
    HIorder = HERMITE4;
  }

  switch (HIorder){
  case HERMITE3:
    interpolate_Phi = hyperspherical_Hermite3_interpolation_vector_Phi;
    interpolate_dPhi = hyperspherical_Hermite3_interpolation_vector_dPhi;
    interpolate_PhidPhi = hyperspherical_Hermite3_interpolation_vector_PhidPhi;
    interpolate_Phid2Phi = hyperspherical_Hermite3_interpolation_vector_Phid2Phi;
    interpolate_PhidPhid2Phi = hyperspherical_Hermite3_interpolation_vector_PhidPhid2Phi;
    break;
  case HERMITE4:
    interpolate_Phi = hyperspherical_Hermite4_interpolation_vector_Phi;
    interpolate_dPhi = hyperspherical_Hermite4_interpolation_vector_dPhi;
    interpolate_PhidPhi = hyperspherical_Hermite4_interpolation_vector_PhidPhi;
    interpolate_Phid2Phi = hyperspherical_Hermite4_interpolation_vector_Phid2Phi;
    interpolate_PhidPhid2Phi = hyperspherical_Hermite4_interpolation_vector_PhidPhid2Phi;
    break;
  case HERMITE6:
    interpolate_Phi = hyperspherical_Hermite6_interpolation_vector_Phi;
    interpolate_dPhi = hyperspherical_Hermite6_interpolation_vector_dPhi;
    interpolate_PhidPhi = hyperspherical_Hermite6_interpolation_vector_PhidPhi;
    interpolate_Phid2Phi = hyperspherical_Hermite6_interpolation_vector_Phid2Phi;
    interpolate_PhidPhid2Phi = hyperspherical_Hermite6_interpolation_vector_PhidPhid2Phi;
    break;
  }

  //Reverse chi
  for (j=0; j<x_size; j++) {
    chireverse[j] = chi[x_size-1-j]*rescale_argument;
    if (rescale_amplitude == 1.) {
      rescale_function[j] = 1.;
    }
    else {
      if (ptw->sgnK == 1) {
        rescale_function[j] =
          MIN(
              rescale_amplitude
              * (1
                 + 0.34 * atan(ptr->l[index_l]/nu) * (chireverse[j]/rescale_argument-chi_tp)
                 + 2.00 * pow(atan(ptr->l[index_l]/nu) * (chireverse[j]/rescale_argument-chi_tp),2)),
              chireverse[j]/rescale_argument/sin(chireverse[j]/rescale_argument)
              );
      }
      else {
        rescale_function[j] =
          MAX(
              rescale_amplitude
              * (1
                 - 0.38 * atan(ptr->l[index_l]/nu) * (chireverse[j]/rescale_argument-chi_tp)
                 + 0.40 * pow(atan(ptr->l[index_l]/nu) * (chireverse[j]/rescale_argument-chi_tp),2)),
              chireverse[j]/rescale_argument/sinh(chireverse[j]/rescale_argument)
              );
      }
    }
  }

  /*
    class_test(pHIS->x[0] > chireverse[0],
    ptr->error_message,
    "Bessels need to be interpolated at %e, outside the range in which they have been computed (>%e). Decrease their x_min.",
    chireverse[0],
    pHIS->x[0]);
  */

  class_test((pHIS->x[pHIS->x_size-1] < chireverse[x_size-1]) && (ptw->sgnK != 1),
             ptr->error_message,
             "Bessels need to be interpolated at %e, outside the range in which they have been computed (<%e). Increase their x_max.",
             chireverse[x_size-1],
             pHIS->x[pHIS->x_size-1]
             );

  switch (radial_type){
  case SCALAR_TEMPERATURE_0:
    class_call(interpolate_Phi(pHIS, x_size, index_l, chireverse, Phi, ptr->error_message),
               ptr->error_message, ptr->error_message);
    //hyperspherical_Hermite_interpolation_vector(pHIS, x_size, index_l, chireverse, Phi, NULL, NULL);
    for (j=0; j<x_size; j++)
      radial_function[x_size-1-j] = Phi[j]*rescale_function[j];
    break;
  case SCALAR_TEMPERATURE_1:
    class_call(interpolate_dPhi(pHIS, x_size, index_l, chireverse, dPhi, ptr->error_message),
               ptr->error_message, ptr->error_message);
    //hyperspherical_Hermite_interpolation_vector(pHIS, x_size, index_l, chireverse, NULL, dPhi, NULL);
    for (j=0; j<x_size; j++)
      radial_function[x_size-1-j] = sqrt_absK_over_k*dPhi[j]*rescale_argument*rescale_function[j];
    break;
  case SCALAR_TEMPERATURE_2:
    class_call(interpolate_Phid2Phi(pHIS, x_size, index_l, chireverse, Phi, d2Phi, ptr->error_message),
               ptr->error_message, ptr->error_message);
    //hyperspherical_Hermite_interpolation_vector(pHIS, x_size, index_l, chireverse, Phi, NULL, d2Phi);
    s2 = sqrt(1.0-3.0*K/k2);
    factor = 1.0/(2.0*s2);
    for (j=0; j<x_size; j++)
      radial_function[x_size-1-j] = factor*(3*absK_over_k2*d2Phi[j]*rescale_argument*rescale_argument+Phi[j])*rescale_function[j];
    break;
  case SCALAR_POLARISATION_E:
    class_call(interpolate_Phi(pHIS, x_size, index_l, chireverse, Phi, ptr->error_message),
               ptr->error_message, ptr->error_message);
    //hyperspherical_Hermite_interpolation_vector(pHIS, x_size, index_l, chireverse, Phi, NULL, NULL);
    s2 = sqrt(1.0-3.0*K/k2);
    factor = sqrt(3.0/8.0*(l+2.0)*(l+1.0)*l*(l-1.0))/s2;
    for (j=0; j<x_size; j++)
      radial_function[x_size-1-j] = factor*cscKgen[x_size-1-j]*cscKgen[x_size-1-j]*Phi[j]*rescale_function[j];
    break;
  case VECTOR_TEMPERATURE_1:
    class_call(interpolate_Phi(pHIS, x_size, index_l, chireverse, Phi, ptr->error_message),
               ptr->error_message, ptr->error_message);
    //hyperspherical_Hermite_interpolation_vector(pHIS, x_size, index_l, chireverse, Phi, NULL, NULL);
    s0 = sqrt(1.0+K/k2);
    factor = sqrt(0.5*l*(l+1))/s0;
    for (j=0; j<x_size; j++)
      radial_function[x_size-1-j] = factor*cscKgen[x_size-1-j]*Phi[j]*rescale_function[j];
    break;
  case VECTOR_TEMPERATURE_2:
    class_call(interpolate_PhidPhi(pHIS, x_size, index_l, chireverse, Phi, dPhi, ptr->error_message),
               ptr->error_message, ptr->error_message);
    //hyperspherical_Hermite_interpolation_vector(pHIS, x_size, index_l, chireverse, Phi, dPhi, NULL);
    s0 = sqrt(1.0+K/k2);
    ssqrt3 = sqrt(1.0-2.0*K/k2);
    factor = sqrt(1.5*l*(l+1))/s0/ssqrt3;
    for (j=0; j<x_size; j++)
      radial_function[x_size-1-j] = factor*cscKgen[x_size-1-j]*(sqrt_absK_over_k*dPhi[j]*rescale_argument-cotKgen[j]*Phi[j])*rescale_function[j];
    break;
  case VECTOR_POLARISATION_E:
    class_call(interpolate_PhidPhi(pHIS, x_size, index_l, chireverse, Phi, dPhi, ptr->error_message),
               ptr->error_message, ptr->error_message);
    //    hyperspherical_Hermite_interpolation_vector(pHIS, x_size, index_l, chireverse, Phi, dPhi, NULL);
    s0 = sqrt(1.0+K/k2);
    ssqrt3 = sqrt(1.0-2.0*K/k2);
    factor = 0.5*sqrt((l-1.0)*(l+2.0))/s0/ssqrt3;
    for (j=0; j<x_size; j++)
      radial_function[x_size-1-j] = factor*cscKgen[x_size-1-j]*(cotKgen[j]*Phi[j]+sqrt_absK_over_k*dPhi[j]*rescale_argument)*rescale_function[j];
    break;
  case VECTOR_POLARISATION_B:
    class_call(interpolate_Phi(pHIS, x_size, index_l, chireverse, Phi, ptr->error_message),
               ptr->error_message, ptr->error_message);
    //hyperspherical_Hermite_interpolation_vector(pHIS, x_size, index_l, chireverse, Phi, NULL, NULL);
    s0 = sqrt(1.0+K/k2);
    ssqrt3 = sqrt(1.0-2.0*K/k2);
    si = sqrt(1.0+2.0*K/k2);
    factor = 0.5*sqrt((l-1.0)*(l+2.0))*si/s0/ssqrt3;
    for (j=0; j<x_size; j++)
      radial_function[x_size-1-j] = factor*cscKgen[x_size-1-j]*Phi[j]*rescale_function[j];
    break;
  case TENSOR_TEMPERATURE_2:
    class_call(interpolate_Phi(pHIS, x_size, index_l, chireverse, Phi, ptr->error_message),
               ptr->error_message, ptr->error_message);
    //hyperspherical_Hermite_interpolation_vector(pHIS, x_size, index_l, chireverse, Phi, NULL, NULL);
    ssqrt2 = sqrt(1.0-1.0*K/k2);
    si = sqrt(1.0+2.0*K/k2);
    factor = sqrt(3.0/8.0*(l+2.0)*(l+1.0)*l*(l-1.0))/si/ssqrt2;
    for (j=0; j<x_size; j++)
      radial_function[x_size-1-j] = factor*cscKgen[x_size-1-j]*cscKgen[x_size-1-j]*Phi[j]*rescale_function[j];
    break;
  case TENSOR_POLARISATION_E:
    class_call(interpolate_PhidPhid2Phi(pHIS, x_size, index_l, chireverse, Phi, dPhi, d2Phi, ptr->error_message),
               ptr->error_message, ptr->error_message);
    //hyperspherical_Hermite_interpolation_vector(pHIS, x_size, index_l, chireverse, Phi, NULL, NULL);
    ssqrt2 = sqrt(1.0-1.0*K/k2);
    si = sqrt(1.0+2.0*K/k2);
    factor = 0.25/si/ssqrt2;
    for (j=0; j<x_size; j++)
      radial_function[x_size-1-j] = factor*(absK_over_k2*d2Phi[j]*rescale_argument*rescale_argument
                                            +4.0*cotKgen[x_size-1-j]*sqrt_absK_over_k*dPhi[j]*rescale_argument
                                            -(1.0+4*K/k2-2.0*cotKgen[x_size-1-j]*cotKgen[x_size-1-j])*Phi[j])*rescale_function[j];
    break;
  case TENSOR_POLARISATION_B:
    class_call(interpolate_PhidPhi(pHIS, x_size, index_l, chireverse, Phi, dPhi, ptr->error_message),
               ptr->error_message, ptr->error_message);
    //hyperspherical_Hermite_interpolation_vector(pHIS, x_size, index_l, chireverse, Phi, dPhi, NULL);
    ssqrt2i = sqrt(1.0+3.0*K/k2);
    ssqrt2 = sqrt(1.0-1.0*K/k2);
    si = sqrt(1.0+2.0*K/k2);
    factor = 0.5*ssqrt2i/ssqrt2/si;
    for (j=0; j<x_size; j++)
      radial_function[x_size-1-j] = factor*(sqrt_absK_over_k*dPhi[j]*rescale_argument+2.0*cotKgen[x_size-1-j]*Phi[j])*rescale_function[j];
    break;
  case NC_RSD:
    class_call(interpolate_Phid2Phi(pHIS, x_size, index_l, chireverse, Phi, d2Phi, ptr->error_message),
               ptr->error_message, ptr->error_message);
    //hyperspherical_Hermite_interpolation_vector(pHIS, x_size, index_l, chireverse, Phi, NULL, d2Phi);
    //s2 = sqrt(1.0-3.0*K/k2);
    factor = 1.0;
    for (j=0; j<x_size; j++)
      radial_function[x_size-1-j] = factor*absK_over_k2*d2Phi[j]*rescale_argument*rescale_argument*rescale_function[j];
    // Note: in previous line there was a missing factor absK_over_k2 until version 2.4.3. Credits Francesco Montanari.
    break;
  }

  free(Phi);
  free(dPhi);
  free(d2Phi);
  free(chireverse);
  free(rescale_function);

  return _SUCCESS_;
}

int transfer_select_radial_function(
                                    struct perturbations * ppt,
                                    struct transfer * ptr,
                                    int index_md,
                                    int index_tt,
                                    radial_function_type * radial_type
                                    ) {

  /* generic case leading to generic bessel function (it applies also to all nonCMB types: lcmb, density, lensing) */
  *radial_type = SCALAR_TEMPERATURE_0;

  /* other specific cases */
  if (_scalars_) {

    if (ppt->has_cl_cmb_temperature == _TRUE_) {

      if (index_tt == ptr->index_tt_t0) {
        *radial_type = SCALAR_TEMPERATURE_0;
      }
      if (index_tt == ptr->index_tt_t1) {
        *radial_type = SCALAR_TEMPERATURE_1;
      }
      if (index_tt == ptr->index_tt_t2) {
        *radial_type = SCALAR_TEMPERATURE_2;
      }

    }

    if (ppt->has_cl_cmb_polarization == _TRUE_) {

      if (index_tt == ptr->index_tt_e) {
        *radial_type = SCALAR_POLARISATION_E;
      }

    }

    if (_index_tt_in_range_(ptr->index_tt_d1,      ppt->selection_num, ppt->has_nc_rsd))
      *radial_type = SCALAR_TEMPERATURE_1;

    if (_index_tt_in_range_(ptr->index_tt_rsd,     ppt->selection_num, ppt->has_nc_rsd))
      *radial_type = NC_RSD;

    if (_index_tt_in_range_(ptr->index_tt_nc_g5,   ppt->selection_num, ppt->has_nc_gr))
      *radial_type = SCALAR_TEMPERATURE_1;

  }

  if (_vectors_) {

    if (ppt->has_cl_cmb_temperature == _TRUE_) {

      if (index_tt == ptr->index_tt_t1) {
        *radial_type = VECTOR_TEMPERATURE_1;
      }
      if (index_tt == ptr->index_tt_t2) {
        *radial_type = VECTOR_TEMPERATURE_2;
      }
    }

    if (ppt->has_cl_cmb_polarization == _TRUE_) {

      if (index_tt == ptr->index_tt_e) {
        *radial_type = VECTOR_POLARISATION_E;
      }
      if (index_tt == ptr->index_tt_b) {
        *radial_type = VECTOR_POLARISATION_B;
      }

    }
  }

  if (_tensors_) {

    if (ppt->has_cl_cmb_temperature == _TRUE_) {

      if (index_tt == ptr->index_tt_t2) {
        *radial_type = TENSOR_TEMPERATURE_2;
      }
    }

    if (ppt->has_cl_cmb_polarization == _TRUE_) {

      if (index_tt == ptr->index_tt_e) {
        *radial_type = TENSOR_POLARISATION_E;
      }
      if (index_tt == ptr->index_tt_b) {
        *radial_type = TENSOR_POLARISATION_B;
      }

    }
  }

  return _SUCCESS_;

}

/* for reading global selection function (ie the one multiplying the selection function of each bin) */

int transfer_global_selection_read(
                                   struct transfer * ptr
                                   ) {

  /* for reading selection function */
  FILE * input_file;
  int row,status;
  double tmp1,tmp2;

  ptr->nz_size = 0;

  if (ptr->has_nz_file == _TRUE_) {

    input_file = fopen(ptr->nz_file_name,"r");
    class_test(input_file == NULL,
               ptr->error_message,
               "Could not open file %s!",ptr->nz_file_name);

    /* Find size of table */
    for (row=0,status=2; status==2; row++){
      status = fscanf(input_file,"%lf %lf",&tmp1,&tmp2);
    }
    rewind(input_file);
    ptr->nz_size = row-1;

    /* Allocate room for interpolation table */
    class_alloc(ptr->nz_z,sizeof(double)*ptr->nz_size,ptr->error_message);
    class_alloc(ptr->nz_nz,sizeof(double)*ptr->nz_size,ptr->error_message);
    class_alloc(ptr->nz_ddnz,sizeof(double)*ptr->nz_size,ptr->error_message);

    for (row=0; row<ptr->nz_size; row++){
      status = fscanf(input_file,"%lf %lf",
                      &ptr->nz_z[row],&ptr->nz_nz[row]);
      //printf("%d: (z,dNdz) = (%g,%g)\n",row,ptr->nz_z[row],ptr->nz_nz[row]);
    }
    fclose(input_file);

    /* Call spline interpolation: */
    class_call(array_spline_table_lines(ptr->nz_z,
                                        ptr->nz_size,
                                        ptr->nz_nz,
                                        1,
                                        ptr->nz_ddnz,
                                        _SPLINE_EST_DERIV_,
                                        ptr->error_message),
               ptr->error_message,
               ptr->error_message);
  }

  ptr->nz_evo_size = 0;

  if (ptr->has_nz_evo_file == _TRUE_) {

    input_file = fopen(ptr->nz_evo_file_name,"r");
    class_test(input_file == NULL,
               ptr->error_message,
               "Could not open file %s!",ptr->nz_evo_file_name);

    /* Find size of table */
    for (row=0,status=2; status==2; row++){
      status = fscanf(input_file,"%lf %lf",&tmp1,&tmp2);
    }
    rewind(input_file);
    ptr->nz_evo_size = row-1;

    /* Allocate room for interpolation table */
    class_alloc(ptr->nz_evo_z,sizeof(double)*ptr->nz_evo_size,ptr->error_message);
    class_alloc(ptr->nz_evo_nz,sizeof(double)*ptr->nz_evo_size,ptr->error_message);
    class_alloc(ptr->nz_evo_dlog_nz,sizeof(double)*ptr->nz_evo_size,ptr->error_message);
    class_alloc(ptr->nz_evo_dd_dlog_nz,sizeof(double)*ptr->nz_evo_size,ptr->error_message);

    for (row=0; row<ptr->nz_evo_size; row++){
      status = fscanf(input_file,"%lf %lf",
                      &ptr->nz_evo_z[row],&ptr->nz_evo_nz[row]);
    }
    fclose(input_file);

    /* infer dlog(dN/dz)/dz from dN/dz */
    ptr->nz_evo_dlog_nz[0] =
      (log(ptr->nz_evo_nz[1])-log(ptr->nz_evo_nz[0]))
      /(ptr->nz_evo_z[1]-ptr->nz_evo_z[0]);
    for (row=1; row<ptr->nz_evo_size-1; row++){
      ptr->nz_evo_dlog_nz[row] =
        (log(ptr->nz_evo_nz[row+1])-log(ptr->nz_evo_nz[row-1]))
        /(ptr->nz_evo_z[row+1]-ptr->nz_evo_z[row-1]);
    }
    ptr->nz_evo_dlog_nz[ptr->nz_evo_size-1] =
      (log(ptr->nz_evo_nz[ptr->nz_evo_size-1])-log(ptr->nz_evo_nz[ptr->nz_evo_size-2]))
      /(ptr->nz_evo_z[ptr->nz_evo_size-1]-ptr->nz_evo_z[ptr->nz_evo_size-2]);

    /* to test that the file is read:
       for (row=0; row<ptr->nz_evo_size; row++){
       fprintf(stdout,"%d: (z,dNdz,dlndNdzdz) = (%g,%g,%g)\n",row,ptr->nz_evo_z[row],ptr->nz_evo_nz[row],ptr->nz_evo_dlog_nz[row]);
       }
    */

    /* Call spline interpolation: */
    class_call(array_spline_table_lines(ptr->nz_evo_z,
                                        ptr->nz_evo_size,
                                        ptr->nz_evo_dlog_nz,
                                        1,
                                        ptr->nz_evo_dd_dlog_nz,
                                        _SPLINE_EST_DERIV_,
                                        ptr->error_message),
               ptr->error_message,
               ptr->error_message);
  }

  return _SUCCESS_;

};

int transfer_workspace_init(
                            struct transfer * ptr,
                            struct precision * ppr,
                            struct transfer_workspace *ptw,
                            int perturbations_tau_size,
                            int tau_size_max,
                            double K,
                            int sgnK,
                            double tau0_minus_tau_cut,
                            HyperInterpStruct * pBIS){

  ptw->tau_size_max = tau_size_max;
  ptw->l_size = ptr->l_size_max;
  ptw->HIS_allocated=_FALSE_;
  ptw->pBIS = pBIS;
  ptw->K = K;
  ptw->sgnK = sgnK;
  ptw->tau0_minus_tau_cut = tau0_minus_tau_cut;
  ptw->neglect_late_source = _FALSE_;

  class_alloc(ptw->interpolated_sources,perturbations_tau_size*sizeof(double),ptr->error_message);
  class_alloc(ptw->sources,tau_size_max*sizeof(double),ptr->error_message);
  class_alloc(ptw->tau0_minus_tau,tau_size_max*sizeof(double),ptr->error_message);
  class_alloc(ptw->w_trapz,tau_size_max*sizeof(double),ptr->error_message);
  class_alloc(ptw->chi,tau_size_max*sizeof(double),ptr->error_message);
  class_alloc(ptw->cscKgen,tau_size_max*sizeof(double),ptr->error_message);
  class_alloc(ptw->cotKgen,tau_size_max*sizeof(double),ptr->error_message);

  return _SUCCESS_;
}

int transfer_workspace_free(
                            struct transfer * ptr,
                            struct transfer_workspace *ptw
                            ) {

  if (ptw->HIS_allocated==_TRUE_){
    //Free HIS structure:
    class_call(hyperspherical_HIS_free(&(ptw->HIS),ptr->error_message),
               ptr->error_message,
               ptr->error_message);
  }
  free(ptw->interpolated_sources);
  free(ptw->sources);
  free(ptw->tau0_minus_tau);
  free(ptw->w_trapz);
  free(ptw->chi);
  free(ptw->cscKgen);
  free(ptw->cotKgen);

  return _SUCCESS_;
}

int transfer_update_HIS(
                        struct precision * ppr,
                        struct transfer * ptr,
                        struct transfer_workspace * ptw,
                        int index_q,
                        double tau0
                        ) {

  double nu,new_nu;
  int int_nu;
  double xmin, xmax, sampling, phiminabs, xtol;
  double sqrt_absK;
  int l_size_max;
  int index_l_left,index_l_right;

  if (ptw->HIS_allocated == _TRUE_) {
    class_call(hyperspherical_HIS_free(&(ptw->HIS),ptr->error_message),
               ptr->error_message,
               ptr->error_message);
    ptw->HIS_allocated = _FALSE_;
  }

  if ((ptw->sgnK!=0) && (index_q < ptr->index_q_flat_approximation)) {

    xmin = ppr->hyper_x_min;

    sqrt_absK = sqrt(ptw->sgnK*ptw->K);

    xmax = sqrt_absK*tau0;
    nu = ptr->q[index_q]/sqrt_absK;

    if (ptw->sgnK == 1) {
      xmax = MIN(xmax,_PI_/2.0-ppr->hyper_x_min); //We only need solution on [0;pi/2]

      int_nu = (int)(nu+0.2);
      new_nu = (double)int_nu;
      class_test(nu-new_nu > 1.e-6,
                 ptr->error_message,
                 "problem in q list definition in closed case for index_q=%d, nu=%e, nu-int(nu)=%e",index_q,nu,nu-new_nu);
      nu = new_nu;

    }

    if (nu > ppr->hyper_nu_sampling_step)
      sampling = ppr->hyper_sampling_curved_high_nu;
    else
      sampling = ppr->hyper_sampling_curved_low_nu;

    /* find the highest value of l such that x_nonzero < xmax = sqrt(|K|) tau0. That will be l_max. */
    l_size_max = ptr->l_size_max;
    if (ptw->sgnK == 1)
      while ((double)ptr->l[l_size_max-1] >= nu)
        l_size_max--;

    if (ptw->sgnK == -1){
      xtol = ppr->hyper_x_tol;
      phiminabs = ppr->hyper_phi_min_abs;

      /* First try to find lmax using fast approximation: */
      index_l_left=0;
      index_l_right=l_size_max-1;
      class_call(transfer_get_lmax(hyperspherical_get_xmin_from_approx,
                                   ptw->sgnK,
                                   nu,
                                   ptr->l,
                                   l_size_max,
                                   phiminabs,
                                   xmax,
                                   xtol,
                                   &index_l_left,
                                   &index_l_right,
                                   ptr->error_message),
                 ptr->error_message,
                 ptr->error_message);

      /* Now use WKB approximation to eventually modify borders: */
      class_call(transfer_get_lmax(hyperspherical_get_xmin_from_Airy,
                                   ptw->sgnK,
                                   nu,
                                   ptr->l,
                                   l_size_max,
                                   phiminabs,
                                   xmax,
                                   xtol,
                                   &index_l_left,
                                   &index_l_right,
                                   ptr->error_message),
                 ptr->error_message,
                 ptr->error_message);
      l_size_max = index_l_right+1;
    }

    class_test(nu <= 0.,
               ptr->error_message,
               "nu=%e when index_q=%d, q=%e, K=%e, sqrt(|K|)=%e; instead nu should always be strictly positive",
               nu,index_q,ptr->q[index_q],ptw->K,sqrt_absK);

    class_call(hyperspherical_HIS_create(ptw->sgnK,
                                         nu,
                                         l_size_max,
                                         ptr->l,
                                         xmin,
                                         xmax,
                                         sampling,
                                         ptr->l[l_size_max-1]+1,
                                         ppr->hyper_phi_min_abs,
                                         &(ptw->HIS),
                                         ptr->error_message),
               ptr->error_message,
               ptr->error_message);

    ptw->HIS_allocated = _TRUE_;

  }

  return _SUCCESS_;
}

int transfer_get_lmax(int (*get_xmin_generic)(int sgnK,
                                              int l,
                                              double nu,
                                              double xtol,
                                              double phiminabs,
                                              double *x_nonzero,
                                              int *fevals),
                      int sgnK,
                      double nu,
                      int *lvec,
                      int lsize,
                      double phiminabs,
                      double xmax,
                      double xtol,
                      int *index_l_left,
                      int *index_l_right,
                      ErrorMsg error_message){
  double x_nonzero;
  int fevals=0, index_l_mid;
  int multiplier;
  int right_boundary_checked = _FALSE_;
  class_call(get_xmin_generic(sgnK,
                              lvec[0],
                              nu,
                              xtol,
                              phiminabs,
                              &x_nonzero,
                              &fevals),
             error_message,
             error_message);
  if (x_nonzero >= xmax){
    //printf("None relevant\n");
    //x at left boundary is already larger than xmax.
    *index_l_right = MAX(lsize-1,1);
    return _SUCCESS_;
  }
  class_call(get_xmin_generic(sgnK,
                              lvec[lsize-1],
                              nu,
                              xtol,
                              phiminabs,
                              &x_nonzero,
                              &fevals),
             error_message,
             error_message);

  if (x_nonzero < xmax){
    //All Bessels are relevant
    //printf("All relevant\n");
    *index_l_left = MAX(0,(lsize-2));
    return _SUCCESS_;
  }
  /* Hunt for left boundary: */
  for (multiplier=1; ;multiplier *= 5){
    class_call(get_xmin_generic(sgnK,
                                lvec[*index_l_left],
                                nu,
                                xtol,
                                phiminabs,
                                &x_nonzero,
                                &fevals),
               error_message,
               error_message);
    if (x_nonzero <= xmax){
      //Boundary found
      break;
    }
    else{
      //We can use current index_l_left as index_l_right:
      *index_l_right = *index_l_left;
      right_boundary_checked = _TRUE_;
    }
    //Update index_l_left:
    *index_l_left = (*index_l_left)-multiplier;
    if (*index_l_left<=0){
      *index_l_left = 0;
      break;
    }
  }
  /* If not found, hunt for right boundary: */
  if (right_boundary_checked == _FALSE_){
    for (multiplier=1; ;multiplier *= 5){
      class_call(get_xmin_generic(sgnK,
                                  lvec[*index_l_right],
                                  nu,
                                  xtol,
                                  phiminabs,
                                  &x_nonzero,
                                  &fevals),
                 error_message,
                 error_message);
      if (x_nonzero >= xmax){
        //Boundary found
        break;
      }
      else{
        //We can use current index_l_right as index_l_left:
        *index_l_left = *index_l_right;
      }
      //Update index_l_right:
      *index_l_right = (*index_l_right)+multiplier;
      if (*index_l_right>=(lsize-1)){
        *index_l_right = lsize-1;
        break;
      }
    }
  }
  //  int fevalshunt=fevals;
  fevals=0;
  //Do binary search
  //  printf("Do binary search in get_lmax. \n");
  //printf("Region: [%d, %d]\n",*index_l_left,*index_l_right);
  while (((*index_l_right) - (*index_l_left)) > 1) {
    index_l_mid= (int)(0.5*((*index_l_right)+(*index_l_left)));
    //printf("left:%d, mid=%d, right=%d\n",*index_l_left,index_l_mid,*index_l_right);
    class_call(get_xmin_generic(sgnK,
                                lvec[index_l_mid],
                                nu,
                                xtol,
                                phiminabs,
                                &x_nonzero,
                                &fevals),
               error_message,
               error_message);
    if (x_nonzero < xmax)
      *index_l_left=index_l_mid;
    else
      *index_l_right=index_l_mid;
  }
  //printf("Done\n");
  return _SUCCESS_;
}

/**
 * Here we can precompute the window functions for the final integration
 * For each type of nCl/dCl/sCl we combine the selection function
 *  with the corresponding prefactor (e.g. 1/aH), and, if required,
 *  we also integrate for integrated (lensed) contributions
 * (In the original ClassGAL paper these would be labeled g4,g5, and lens)
 *
 * All factors of k have to be added later (at least in the current version)
 *
 * @param ppr                   Input: pointer to precision structure
 * @param pba                   Input: pointer to background structure
 * @param ppt                   Input: pointer to perturbation structure
 * @param ptr                   Input: pointer to transfer structure
 * @param tau_rec               Input: recombination time
 * @param tau_size_max          Input: maximum size that tau array can have
 * @param window                Output: pointer to array of selection functions
 * @return the error status
 */

int transfer_precompute_selection(
                                  struct precision * ppr,
                                  struct background * pba,
                                  struct perturbations * ppt,
                                  struct transfer * ptr,
                                  double tau_rec,
                                  int tau_size_max,
                                  double ** window /* Pass a pointer to the pointer, so the pointer can be allocated inside of the function */
                                  ){
  /** Summary: */

  /** - define local variables */

  double* tau0_minus_tau;
  double* w_trapz;

  /* index running on time */
  int index_tau;

  /* bin for computation of cl_density */
  int bin=0;

  /* number of tau values */
  int tau_size;

  /* for calling background_at_eta */
  int last_index;
  double * pvecback = NULL;

  /* conformal time */
  double tau, tau0;

  /* geometrical quantities */
  double sinKgen_source=0.;
  double sinKgen_source_to_lens=0.;
  double cotKgen_source=0.;
  double cscKgen_lens=0.;

  /* rescaling factor depending on the background at a given time */
  double rescaling=0.;

  /* array of selection function values at different times */
  double * selection;

  /* array of time sampling for lensing source selection function */
  double * tau0_minus_tau_lensing_sources;

  /* trapezoidal weights for lensing source selection function */
  double * w_trapz_lensing_sources;

  /* index running on time in previous two arrays */
  int index_tau_sources;

  /* number of time values in previous two arrays */
  int tau_sources_size;

  /* source evolution factor */
  double f_evo = 0.;


  /* Setup initial variables and arrays*/
  int index_md = ppt->index_md_scalars;
  int index_tt;

  /* allocate temporary arrays for storing selections, weights, times, and output; and for calling background */
  class_alloc(tau0_minus_tau,tau_size_max*sizeof(double),ptr->error_message);
  class_alloc(selection,tau_size_max*sizeof(double),ptr->error_message);
  class_alloc(w_trapz,tau_size_max*sizeof(double),ptr->error_message);
  class_alloc((*window),tau_size_max*ptr->tt_size[index_md]*sizeof(double),ptr->error_message);
  class_alloc(pvecback,pba->bg_size*sizeof(double),ptr->error_message);

  /* conformal time today */
  tau0 = pba->conformal_age;

  /* Loop through different types to be precomputed */
  for (index_tt = 0; index_tt < ptr->tt_size[index_md]; index_tt++) {

    /* First set the corresponding tau size */
    class_call(transfer_source_tau_size(ppr,
                                        pba,
                                        ppt,
                                        ptr,
                                        tau_rec,
                                        tau0,
                                        index_md,
                                        index_tt,
                                        &tau_size),
               ptr->error_message,
               ptr->error_message);

    /* Start with non-integrated contributions */
    if (_nonintegrated_ncl_) {

      _get_bin_nonintegrated_ncl_(index_tt)

        /* redefine the time sampling */
        class_call(transfer_selection_sampling(ppr,
                                               pba,
                                               ppt,
                                               ptr,
                                               bin,
                                               tau0_minus_tau,
                                               tau_size),
                   ptr->error_message,
                   ptr->error_message);

      class_test(tau0 - tau0_minus_tau[0] > ppt->tau_sampling[ppt->tau_size-1],
                 ptr->error_message,
                 "this should not happen, there was probably a rounding error, if this error occurred, then this must be coded more carefully");

      /* Compute trapezoidal weights for integration over tau */
      class_call(array_trapezoidal_mweights(tau0_minus_tau,
                                            tau_size,
                                            w_trapz,
                                            ptr->error_message),
                 ptr->error_message,
                 ptr->error_message);

      /* compute values of selection function at sampled values of tau */
      class_call(transfer_selection_compute(ppr,
                                            pba,
                                            ppt,
                                            ptr,
                                            selection,
                                            tau0_minus_tau,
                                            w_trapz,
                                            tau_size,
                                            pvecback,
                                            tau0,
                                            bin),
                 ptr->error_message,
                 ptr->error_message);

      /* loop over time and rescale */
      for (index_tau = 0; index_tau < tau_size; index_tau++) {

        /* conformal time */
        tau = tau0 - tau0_minus_tau[index_tau];

        /* geometrical quantity */
        switch (pba->sgnK){
        case 1:
          cotKgen_source = sqrt(pba->K)
            *cos(tau0_minus_tau[index_tau]*sqrt(pba->K))
            /sin(tau0_minus_tau[index_tau]*sqrt(pba->K));
          break;
        case 0:
          cotKgen_source = 1./(tau0_minus_tau[index_tau]);
          break;
        case -1:
          cotKgen_source = sqrt(-pba->K)
            *cosh(tau0_minus_tau[index_tau]*sqrt(-pba->K))
            /sinh(tau0_minus_tau[index_tau]*sqrt(-pba->K));
          break;
        }

        /* corresponding background quantities */
        class_call(background_at_tau(pba,
                                     tau,
                                     long_info,
                                     inter_normal,
                                     &last_index,
                                     pvecback),
                   pba->error_message,
                   ptr->error_message);

        /* Source evolution, used by nCl doppler and nCl gravity terms */

        if ((_index_tt_in_range_(ptr->index_tt_d0,      ppt->selection_num, ppt->has_nc_rsd)) ||
            (_index_tt_in_range_(ptr->index_tt_d1,      ppt->selection_num, ppt->has_nc_rsd)) ||
            (_index_tt_in_range_(ptr->index_tt_nc_g2,   ppt->selection_num, ppt->has_nc_gr)))
          {
            class_call(transfer_f_evo(pba,ptr,pvecback,last_index,cotKgen_source,&f_evo),
                       ptr->error_message,
                       ptr->error_message);
            /* Error in old CLASS 2.6.3 : Number count evolution did not respect curvature */
          }

        /* matter density source =  [- (dz/dtau) W(z)] * delta_m(k,tau)
           = W(tau) delta_m(k,tau)
           with
           delta_m = total matter perturbation (defined in gauge-independent way, see arXiv 1307.1459)
           W(z) = redshift space selection function = dN/dz
           W(tau) = same wrt conformal time = dN/dtau
           (in tau = tau_0, set source = 0 to avoid division by zero;
           regulated anyway by Bessel).
        */

        if (_index_tt_in_range_(ptr->index_tt_density, ppt->selection_num, ppt->has_nc_density))
          rescaling = ptr->selection_bias[bin]*selection[index_tau];

        /* redshift space distortion source = - [- (dz/dtau) W(z)] * (k/H) * theta(k,tau) */

        if (_index_tt_in_range_(ptr->index_tt_rsd,     ppt->selection_num, ppt->has_nc_rsd))
          rescaling = selection[index_tau]/pvecback[pba->index_bg_H]/pvecback[pba->index_bg_a];

        if (_index_tt_in_range_(ptr->index_tt_d0,      ppt->selection_num, ppt->has_nc_rsd))
          rescaling = (f_evo-3.)*selection[index_tau]*pvecback[pba->index_bg_H]*pvecback[pba->index_bg_a];

        if (_index_tt_in_range_(ptr->index_tt_d1,      ppt->selection_num, ppt->has_nc_rsd))

          rescaling = selection[index_tau]*(1.
                                            +pvecback[pba->index_bg_H_prime]
                                            /pvecback[pba->index_bg_a]
                                            /pvecback[pba->index_bg_H]
                                            /pvecback[pba->index_bg_H]
                                            +(2.-5.*ptr->selection_magnification_bias[bin])
                                            // /tau0_minus_tau[index_tau] // in flat space
                                            *cotKgen_source  // in general case
                                            /pvecback[pba->index_bg_a]
                                            /pvecback[pba->index_bg_H]
                                            +5.*ptr->selection_magnification_bias[bin]
                                            -f_evo
                                            );

        if (_index_tt_in_range_(ptr->index_tt_nc_g1,   ppt->selection_num, ppt->has_nc_gr))

          rescaling = selection[index_tau];

        if (_index_tt_in_range_(ptr->index_tt_nc_g2,   ppt->selection_num, ppt->has_nc_gr))

          rescaling = -selection[index_tau]*(3.
                                             +pvecback[pba->index_bg_H_prime]
                                             /pvecback[pba->index_bg_a]
                                             /pvecback[pba->index_bg_H]
                                             /pvecback[pba->index_bg_H]
                                             +(2.-5.*ptr->selection_magnification_bias[bin])
                                             // /tau0_minus_tau[index_tau]  // in flat space
                                             *cotKgen_source  // in general case
                                             /pvecback[pba->index_bg_a]
                                             /pvecback[pba->index_bg_H]
                                             -f_evo
                                             );

        if (_index_tt_in_range_(ptr->index_tt_nc_g3,   ppt->selection_num, ppt->has_nc_gr))
          rescaling = selection[index_tau]/pvecback[pba->index_bg_a]/pvecback[pba->index_bg_H];

        /* finally store in array */
        (*window)[index_tt*tau_size_max+index_tau] = rescaling;
      }
    }
    /* End non-integrated contribution */

    /* Now deal with integrated contributions */
    if (_integrated_ncl_) {

      _get_bin_integrated_ncl_(index_tt)

        /* dirac case */
        if (ppt->selection == dirac) {
          tau_sources_size=1;
        }
      /* other cases (gaussian, tophat...) */
        else {
          tau_sources_size=ppr->selection_sampling;
        }

      class_alloc(tau0_minus_tau_lensing_sources,
                  tau_sources_size*sizeof(double),
                  ptr->error_message);

      class_alloc(w_trapz_lensing_sources,
                  tau_sources_size*sizeof(double),
                  ptr->error_message);

      /* time sampling for source selection function */
      class_call(transfer_selection_sampling(ppr,
                                             pba,
                                             ppt,
                                             ptr,
                                             bin,
                                             tau0_minus_tau_lensing_sources,
                                             tau_sources_size),
                 ptr->error_message,
                 ptr->error_message);

      /* Compute trapezoidal weights for integration over tau */
      class_call(array_trapezoidal_mweights(tau0_minus_tau_lensing_sources,
                                            tau_sources_size,
                                            w_trapz_lensing_sources,
                                            ptr->error_message),
                 ptr->error_message,
                 ptr->error_message);

      /* compute values of selection function at sampled values of tau */
      class_call(transfer_selection_compute(ppr,
                                            pba,
                                            ppt,
                                            ptr,
                                            selection,
                                            tau0_minus_tau_lensing_sources,
                                            w_trapz_lensing_sources,
                                            tau_sources_size,
                                            pvecback,
                                            tau0,
                                            bin),
                 ptr->error_message,
                 ptr->error_message);

      /* redefine the time sampling */
      class_call(transfer_lensing_sampling(ppr,
                                           pba,
                                           ppt,
                                           ptr,
                                           bin,
                                           tau0,
                                           tau0_minus_tau,
                                           tau_size),
                 ptr->error_message,
                 ptr->error_message);

      /* Compute trapezoidal weights for integration over tau */
      class_call(array_trapezoidal_mweights(tau0_minus_tau,
                                            tau_size,
                                            w_trapz,
                                            ptr->error_message),
                 ptr->error_message,
                 ptr->error_message);

      /* loop over time and rescale */
      for (index_tau = 0; index_tau < tau_size; index_tau++) {

        /* lensing source =  - W(tau) (phi(k,tau) + psi(k,tau)) Heaviside(tau-tau_rec)
           with
           psi,phi = metric perturbation in newtonian gauge (phi+psi = Phi_A-Phi_H of Bardeen)
           W = (tau-tau_rec)/(tau_0-tau)/(tau_0-tau_rec)
           H(x) = Heaviside
           (in tau = tau_0, set source = 0 to avoid division by zero;
           regulated anyway by Bessel).
        */

        if (index_tau == tau_size-1) {
          rescaling=0.;
        }
        else {

          rescaling = 0.;

          for (index_tau_sources=0;
               index_tau_sources < tau_sources_size;
               index_tau_sources++) {

            switch (pba->sgnK){
            case 1:
              sinKgen_source = sin(tau0_minus_tau_lensing_sources[index_tau_sources]*sqrt(pba->K))/sqrt(pba->K);
              sinKgen_source_to_lens = sin((tau0_minus_tau[index_tau]-tau0_minus_tau_lensing_sources[index_tau_sources])*sqrt(pba->K))/sqrt(pba->K);
              cotKgen_source = cos(tau0_minus_tau_lensing_sources[index_tau_sources]*sqrt(pba->K))/sinKgen_source;
              cscKgen_lens = sqrt(pba->K)/sin(sqrt(pba->K)*tau0_minus_tau[index_tau]);
              break;
            case 0:
              sinKgen_source = tau0_minus_tau_lensing_sources[index_tau_sources];
              sinKgen_source_to_lens = (tau0_minus_tau[index_tau]-tau0_minus_tau_lensing_sources[index_tau_sources]);
              cotKgen_source = 1./(tau0_minus_tau_lensing_sources[index_tau_sources]);
              cscKgen_lens = 1./(tau0_minus_tau[index_tau]);
              break;
            case -1:
              sinKgen_source = sinh(tau0_minus_tau_lensing_sources[index_tau_sources]*sqrt(-pba->K))/sqrt(-pba->K);
              sinKgen_source_to_lens = sinh((tau0_minus_tau[index_tau]-tau0_minus_tau_lensing_sources[index_tau_sources])*sqrt(-pba->K))/sqrt(-pba->K);
              cotKgen_source = cosh(tau0_minus_tau_lensing_sources[index_tau_sources]*sqrt(-pba->K))/sinKgen_source;
              cscKgen_lens = sqrt(-pba->K)/sinh(sqrt(-pba->K)*tau0_minus_tau[index_tau]);
              break;
            }

            /* condition for excluding from the sum the sources located in z=zero */
            if ((tau0_minus_tau_lensing_sources[index_tau_sources] > 0.) && (tau0_minus_tau_lensing_sources[index_tau_sources]-tau0_minus_tau[index_tau] > 0.)) {

              if (_index_tt_in_range_(ptr->index_tt_lensing, ppt->selection_num, ppt->has_cl_lensing_potential)) {

                rescaling +=
                  //  *(tau0_minus_tau[index_tau]-tau0_minus_tau_lensing_sources[index_tau_sources])
                  //  /tau0_minus_tau[index_tau]
                  //  /tau0_minus_tau_lensing_sources[index_tau_sources]
                  sinKgen_source_to_lens
                  *cscKgen_lens
                  /sinKgen_source
                  * selection[index_tau_sources]
                  * w_trapz_lensing_sources[index_tau_sources];
              }

              if (_index_tt_in_range_(ptr->index_tt_nc_lens, ppt->selection_num, ppt->has_nc_lens)) {

                rescaling -=
                  (2.-5.*ptr->selection_magnification_bias[bin])/2.
                  //  *(tau0_minus_tau[index_tau]-tau0_minus_tau_lensing_sources[index_tau_sources])
                  //  /tau0_minus_tau[index_tau]
                  //  /tau0_minus_tau_lensing_sources[index_tau_sources]
                  *sinKgen_source_to_lens
                  *cscKgen_lens
                  /sinKgen_source
                  * selection[index_tau_sources]
                  * w_trapz_lensing_sources[index_tau_sources];
              }

              if (_index_tt_in_range_(ptr->index_tt_nc_g4, ppt->selection_num, ppt->has_nc_gr)) {

                rescaling +=
                  (2.-5.*ptr->selection_magnification_bias[bin])
                  // /tau0_minus_tau_lensing_sources[index_tau_sources]
                  * cotKgen_source
                  * selection[index_tau_sources]
                  * w_trapz_lensing_sources[index_tau_sources];

              }

              if (_index_tt_in_range_(ptr->index_tt_nc_g5, ppt->selection_num, ppt->has_nc_gr)) {

                /* background quantities at time tau_lensing_source */

                class_call(background_at_tau(pba,
                                             tau0-tau0_minus_tau_lensing_sources[index_tau_sources],
                                             long_info,
                                             inter_normal,
                                             &last_index,
                                             pvecback),
                           pba->error_message,
                           ptr->error_message);

                /* Source evolution at time tau_lensing_source */

                class_call(transfer_f_evo(pba,ptr,pvecback,last_index,cotKgen_source,&f_evo),
                           ptr->error_message,
                           ptr->error_message);


                rescaling +=
                  (1.
                   + pvecback[pba->index_bg_H_prime]
                   /pvecback[pba->index_bg_a]
                   /pvecback[pba->index_bg_H]
                   /pvecback[pba->index_bg_H]
                   + (2.-5.*ptr->selection_magnification_bias[bin])
                   //  /tau0_minus_tau_lensing_sources[index_tau_sources]
                   * cotKgen_source
                   /pvecback[pba->index_bg_a]
                   /pvecback[pba->index_bg_H]
                   + 5.*ptr->selection_magnification_bias[bin]
                   - f_evo)
                  * selection[index_tau_sources]
                  * w_trapz_lensing_sources[index_tau_sources];
              }
            }
          }
        }

        /* Finally store integrated result for later use */
        (*window)[index_tt*tau_size_max+index_tau] = rescaling;
      }

      /* deallocate temporary arrays */
      free(tau0_minus_tau_lensing_sources);
      free(w_trapz_lensing_sources);
    }
    /* End integrated contribution */
  }

  /* deallocate temporary arrays */
  free(selection);
  free(tau0_minus_tau);
  free(w_trapz);
  free(pvecback);
  return _SUCCESS_;
}

int transfer_f_evo(
                   struct background* pba,
                   struct transfer * ptr,
                   double* pvecback,
                   int last_index,
                   double cotKgen, /* Should be FILLED with values of corresponding time */
                   double* f_evo
                   ){
  /* Allocate temporary variables for calculation of f_evo */
  double z;
  double dNdz;
  double dln_dNdz_dz;
  double temp_f_evo;

  if ((ptr->has_nz_evo_file == _TRUE_) || (ptr->has_nz_evo_analytic == _TRUE_)){

    temp_f_evo = 2./pvecback[pba->index_bg_H]/pvecback[pba->index_bg_a]*cotKgen
      + pvecback[pba->index_bg_H_prime]/pvecback[pba->index_bg_H]/pvecback[pba->index_bg_H]/pvecback[pba->index_bg_a];

    /* z = a_0/a-1 (remember that a in the code is in fact a/a_0) */
    z = 1./pvecback[pba->index_bg_a]-1.;

    if (ptr->has_nz_evo_file ==_TRUE_) {

      class_test((z<ptr->nz_evo_z[0]) || (z>ptr->nz_evo_z[ptr->nz_evo_size-1]),
                 ptr->error_message,
                 "Your input file for the selection function only covers the redshift range [%f : %f]. However, your input for the selection function requires z=%f",
                 ptr->nz_evo_z[0],
                 ptr->nz_evo_z[ptr->nz_evo_size-1],
                 z);


      class_call(array_interpolate_spline(
                                          ptr->nz_evo_z,
                                          ptr->nz_evo_size,
                                          ptr->nz_evo_dlog_nz,
                                          ptr->nz_evo_dd_dlog_nz,
                                          1,
                                          z,
                                          &last_index,
                                          &dln_dNdz_dz,
                                          1,
                                          ptr->error_message),
                 ptr->error_message,
                 ptr->error_message);

    }
    else {

      class_call(transfer_dNdz_analytic(ptr,
                                        z,
                                        &dNdz,
                                        &dln_dNdz_dz),
                 ptr->error_message,
                 ptr->error_message);
    }

    temp_f_evo -= dln_dNdz_dz/pvecback[pba->index_bg_a];
  }
  else {
    temp_f_evo = 0.;
  }

  /* after obtaining f_evo, store it in output */
  *f_evo = temp_f_evo;

  return _SUCCESS_;
}

```
