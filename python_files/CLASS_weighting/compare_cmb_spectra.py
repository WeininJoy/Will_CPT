#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
CMB Power Spectrum Comparison: Original vs K-dependent Weighting

This script compares CMB power spectra generated by:
1. Original CLASS (nu_spacing=1, without weighting)
2. Modified CLASS with k-dependent weighting, nu_spacing=4

Uses the same cosmological parameters as generate_cmb_spectrum.py
"""

import numpy as np
import matplotlib.pyplot as plt
import os
import sys

try:
    from classy import Class
except ImportError:
    print("Error: Could not import CLASS Python wrapper.")
    print("Make sure CLASS is compiled and installed with Python wrapper enabled.")
    print("Run 'cd class_nu_spacing_weighting/python && python setup.py install --user'")
    sys.exit(1)

def extract_cosmological_parameters():
    """
    Extract cosmological parameters from solve_real_cosmology_vr.py
    Returns a dictionary with CLASS-compatible parameter names
    """
    # Parameters from solve_real_cosmology_vr.py (lines 27-35)
    h = 0.5409
    Omega_gamma_h2 = 2.47e-5
    Neff = 3.046
    OmegaR = (1 + Neff * (7/8) * (4/11)**(4/3)) * Omega_gamma_h2 / h**2
    OmegaM = 0.483
    OmegaK = -0.0438
    OmegaLambda = 1 - OmegaM - OmegaK - OmegaR
    z_rec = 1089.411

    # Other cosmological parameters
    tau_reio = 0.0495  # Reionization optical depth (typical value)
    A_s = 2.0706e-9  # Scalar amplitude (typical value)
    n_s = 0.97235  # Scalar spectral index (typical value)
    k_pivot = 0.05  # Pivot scale in 1/Mpc

    # Derived parameters
    a0 = 1
    s0 = 1/a0
    H0 = np.sqrt(1 / (3 * OmegaLambda))  # in units where c=1
    K = -OmegaK * a0**2 * H0**2
    
    # Convert to CLASS parameters
    # H0 in km/s/Mpc (standard units)
    H0_kmsMpc = h * 100  # Convert from h to actual H0
    
    # Density parameters (CLASS uses Omega_cdm, Omega_b, etc.)
    omega_b = 0.02237  # Baryon density (typical value)
    omega_cdm = OmegaM * h**2 - omega_b  # Cold dark matter density
    omega_g = Omega_gamma_h2  # Photon density
    omega_ur = omega_g * Neff * (7/8) * (4/11)**(4/3) - omega_g  # Ultra-relativistic species
    
    params = {
        'H0': H0_kmsMpc,
        'omega_b': omega_b,
        'omega_cdm': omega_cdm,
        'Omega_k': OmegaK,
        'N_ur': Neff,
        'tau_reio': tau_reio,
        'A_s': A_s,
        'n_s': n_s,
        'k_pivot': k_pivot,

        # Output settings
        'output': 'tCl,pCl,lCl',
        'lensing': 'yes',
        'l_max_scalars': 2500,
        
        # Extended k range for compatibility
        'k_max_tau0_over_l_max': 20.0,
    }
    
    return params, K

def generate_original_cmb_spectrum(params):
    """
    Generate CMB power spectrum using modified CLASS but without weighting (nu_spacing=1)
    """
    print("Generating CMB power spectrum without k-dependent weighting...")
    
    # Add parameters for original CLASS (no weighting parameters)
    params_original = params.copy()
    params_original.update({
        'nu_spacing': 1,
        # No weighting parameters - this should use original CLASS behavior
    })
    
    cosmo = Class()
    
    try:
        cosmo.set(params_original)
        cosmo.compute()
        
        l_max = params_original['l_max_scalars']
        
        # Get CMB power spectra using the bulk method to avoid array issues
        cls = cosmo.lensed_cl(l_max)
        ell = cls['ell'][2:]  # Remove l=0,1
        cl_tt = cls['tt'][2:]
        cl_ee = cls['ee'][2:]
        cl_te = cls['te'][2:]
        
        # Convert to D_l = l(l+1)C_l/(2π) in μK²
        factor = ell * (ell + 1) / (2 * np.pi)
        Dl_tt = cl_tt * factor * (2.7255e6)**2  # Convert to μK²
        Dl_ee = cl_ee * factor * (2.7255e6)**2
        Dl_te = cl_te * factor * (2.7255e6)**2
        
        print(f"Successfully computed CMB power spectra without weighting up to l = {l_max}")
        
        cosmo.struct_cleanup()
        cosmo.empty()
        
        return ell, {'tt': Dl_tt, 'ee': Dl_ee, 'te': Dl_te}
        
    except Exception as e:
        print(f"Error computing CMB spectrum without weighting: {e}")
        try:
            cosmo.struct_cleanup()
            cosmo.empty()
        except:
            pass
        return None, None

def generate_weighted_cmb_spectrum(params, K):
    """
    Generate CMB power spectrum using modified CLASS with k-dependent weighting
    """
    print("Generating CMB power spectrum with k-dependent weighting...")
    
    # Add weighting parameters
    params_weighted = params.copy()
    params_weighted.update({
        'nu_spacing': 4,  # Use nu_spacing=4 for k-dependent weighting
        'weighting_filename': 'mode_weights.dat',
        'max_weight_index': 31,  # 32 weights (0-31)
    })
    
    # Check if weight file exists
    weight_file = 'mode_weights.dat'
    if not os.path.exists(weight_file):
        print(f"Error: Weight file '{weight_file}' not found!")
        print("Make sure you have generated the weights using solve_real_cosmology_weighting.py")
        return None, None
    
    print(f"Using weight file: {weight_file}")
    
    cosmo = Class()
    
    try:
        cosmo.set(params_weighted)
        cosmo.compute()
        
        l_max = params_weighted['l_max_scalars']
        
        # Get CMB power spectra using the bulk method to avoid array issues
        cls = cosmo.lensed_cl(l_max)
        ell = cls['ell'][2:]  # Remove l=0,1
        cl_tt = cls['tt'][2:]
        cl_ee = cls['ee'][2:]
        cl_te = cls['te'][2:]
        
        # Convert to D_l = l(l+1)C_l/(2π) in μK²
        factor = ell * (ell + 1) / (2 * np.pi)
        Dl_tt = cl_tt * factor * (2.7255e6)**2  # Convert to μK²
        Dl_ee = cl_ee * factor * (2.7255e6)**2
        Dl_te = cl_te * factor * (2.7255e6)**2
        
        print(f"Successfully computed weighted CMB power spectra up to l = {l_max}")
        
        cosmo.struct_cleanup()
        cosmo.empty()
        print(Dl_tt)
        return ell, {'tt': Dl_tt, 'ee': Dl_ee, 'te': Dl_te}
        
    except Exception as e:
        print(f"Error computing weighted CMB spectrum: {e}")
        print("This might be due to:")
        print("1. CLASS not compiled with our modifications")
        print("2. Weight file format issues")
        print("3. Parameter compatibility issues")
        
        try:
            cosmo.struct_cleanup()
            cosmo.empty()
        except:
            pass
        return None, None

def plot_cmb_comparison(ell, spectra_original, spectra_weighted):
    """
    Plot comparison between original and weighted CMB power spectra
    """
    print("Plotting CMB power spectra comparison...")
    
    fig, axes = plt.subplots(2, 2, figsize=(16, 12))
    fig.suptitle('CMB Power Spectra: Without vs With K-dependent Weighting', fontsize=16)
    
    # Temperature power spectrum
    ax1 = axes[0, 0]
    ax1.loglog(ell, spectra_original['tt'], 'b-', linewidth=2, label='Without Weighting (nu_spacing=1)')
    ax1.loglog(ell, spectra_weighted['tt'], 'r-', linewidth=2, label='With K-dependent Weighting')
    ax1.set_xlabel(r'Multipole $\ell$')
    ax1.set_ylabel(r'$D_\ell^{TT}$ [$\mu$K$^2$]')
    ax1.set_title('Temperature Power Spectrum')
    ax1.grid(True, alpha=0.3)
    ax1.legend()
    ax1.set_xlim([2, 2500])
    
    # E-mode polarization power spectrum
    ax2 = axes[0, 1]
    ax2.loglog(ell, spectra_original['ee'], 'b-', linewidth=2, label='Without Weighting (nu_spacing=1)')
    ax2.loglog(ell, spectra_weighted['ee'], 'r-', linewidth=2, label='With K-dependent Weighting')
    ax2.set_xlabel(r'Multipole $\ell$')
    ax2.set_ylabel(r'$D_\ell^{EE}$ [$\mu$K$^2$]')
    ax2.set_title('E-mode Polarization Power Spectrum')
    ax2.grid(True, alpha=0.3)
    ax2.legend()
    ax2.set_xlim([2, 2500])
    
    # Temperature-E cross correlation
    ax3 = axes[1, 0]
    # Handle negative values for log plot
    positive_mask_orig = spectra_original['te'] > 0
    negative_mask_orig = spectra_original['te'] < 0
    positive_mask_wght = spectra_weighted['te'] > 0
    negative_mask_wght = spectra_weighted['te'] < 0
    
    if np.any(positive_mask_orig):
        ax3.loglog(ell[positive_mask_orig], spectra_original['te'][positive_mask_orig], 
                   'b-', linewidth=2, label='Without Weighting (positive)')
    if np.any(negative_mask_orig):
        ax3.loglog(ell[negative_mask_orig], -spectra_original['te'][negative_mask_orig], 
                   'b--', linewidth=2, label='Without Weighting (negative)')
    if np.any(positive_mask_wght):
        ax3.loglog(ell[positive_mask_wght], spectra_weighted['te'][positive_mask_wght], 
                   'r-', linewidth=2, label='With K-dependent Weighting (positive)')
    if np.any(negative_mask_wght):
        ax3.loglog(ell[negative_mask_wght], -spectra_weighted['te'][negative_mask_wght], 
                   'r--', linewidth=2, label='With K-dependent Weighting (negative)')
    
    ax3.set_xlabel(r'Multipole $\ell$')
    ax3.set_ylabel(r'$|D_\ell^{TE}|$ [$\mu$K$^2$]')
    ax3.set_title('Temperature-E Cross Correlation')
    ax3.grid(True, alpha=0.3)
    ax3.legend()
    ax3.set_xlim([2, 2500])
    
    # Ratio plot
    ax4 = axes[1, 1]
    ratio_tt = spectra_weighted['tt'] / spectra_original['tt']
    ratio_ee = spectra_weighted['ee'] / spectra_original['ee']
    
    ax4.semilogx(ell, ratio_tt, 'r-', linewidth=2, label='TT Ratio')
    ax4.semilogx(ell, ratio_ee, 'g-', linewidth=2, label='EE Ratio')
    ax4.axhline(y=1, color='k', linestyle='--', alpha=0.5, label='No change')
    ax4.set_xlabel(r'Multipole $\ell$')
    ax4.set_ylabel('Ratio (Weighted/Original)')
    ax4.set_title('Effect of K-dependent Weighting')
    ax4.grid(True, alpha=0.3)
    ax4.legend()
    ax4.set_xlim([2, 2500])
    ax4.set_ylim([0.9, 1.1])
    
    plt.tight_layout()
    plt.savefig('cmb_comparison_original_vs_weighted.pdf', dpi=300, bbox_inches='tight')
    plt.savefig('cmb_comparison_original_vs_weighted.png', dpi=300, bbox_inches='tight')
    plt.show()
    
    return fig

def main():
    """
    Main function to generate and compare CMB power spectra
    """
    print("=" * 70)
    print("CMB Power Spectrum Comparison: Original vs K-dependent Weighting")
    print("=" * 70)
    
    # Extract cosmological parameters
    params, K = extract_cosmological_parameters()
    
    print("Cosmological parameters:")
    for key, value in params.items():
        if key not in ['output', 'lensing']:
            print(f"  {key}: {value}")
    print(f"  K (curvature): {K}")
    
    # # Generate original spectrum
    # ell_orig, spectra_original = generate_original_cmb_spectrum(params)
    
    # if ell_orig is None:
    #     print("Failed to generate original CMB spectrum.")
    #     return
    
    # Generate weighted spectrum
    ell_wght, spectra_weighted = generate_weighted_cmb_spectrum(params, K)
    
    if ell_wght is None:
        print("Failed to generate weighted CMB spectrum.")
        return
    else:
        plt.plot(ell_wght, spectra_weighted['tt'], label='Weighted TT', color='red')
        plt.savefig('cmb_weighted_tt.png', dpi=300)

    # # Ensure both have same ell range
    # if not np.array_equal(ell_orig, ell_wght):
    #     print("Warning: Different ell ranges for original and weighted spectra")
    #     # Use intersection
    #     ell_min = max(ell_orig[0], ell_wght[0])
    #     ell_max = min(ell_orig[-1], ell_wght[-1])
    #     ell_common = np.arange(ell_min, ell_max + 1)
        
    #     # Interpolate both to common range
    #     from scipy import interpolate
        
    #     for key in ['tt', 'ee', 'te']:
    #         f_orig = interpolate.interp1d(ell_orig, spectra_original[key])
    #         f_wght = interpolate.interp1d(ell_wght, spectra_weighted[key])
    #         spectra_original[key] = f_orig(ell_common)
    #         spectra_weighted[key] = f_wght(ell_common)
        
    #     ell_orig = ell_wght = ell_common
    
    # # Plot comparison
    # fig = plot_cmb_comparison(ell_orig, spectra_original, spectra_weighted)
    
    # # Save data
    # print("\nSaving comparison results...")
    # np.savez('cmb_comparison_results.npz',
    #          ell=ell_orig,
    #          Dl_tt_original=spectra_original['tt'],
    #          Dl_ee_original=spectra_original['ee'],
    #          Dl_te_original=spectra_original['te'],
    #          Dl_tt_weighted=spectra_weighted['tt'],
    #          Dl_ee_weighted=spectra_weighted['ee'],
    #          Dl_te_weighted=spectra_weighted['te'])
    
    # print("Results saved to 'cmb_comparison_results.npz'")
    # print("Plots saved as 'cmb_comparison_original_vs_weighted.pdf' and '.png'")
    
    # # Print statistics
    # ratio_tt = spectra_weighted['tt'] / spectra_original['tt']
    # ratio_ee = spectra_weighted['ee'] / spectra_original['ee']
    
    # print(f"\nStatistics for the effect of k-dependent weighting:")
    # print(f"TT power spectrum ratio - Mean: {np.mean(ratio_tt):.6f}, Std: {np.std(ratio_tt):.6f}")
    # print(f"EE power spectrum ratio - Mean: {np.mean(ratio_ee):.6f}, Std: {np.std(ratio_ee):.6f}")
    # print(f"Maximum TT ratio: {np.max(ratio_tt):.6f} at ℓ = {ell_orig[np.argmax(ratio_tt)]}")
    # print(f"Minimum TT ratio: {np.min(ratio_tt):.6f} at ℓ = {ell_orig[np.argmin(ratio_tt)]}")
    # print(f"TT ratio range: {np.max(ratio_tt) - np.min(ratio_tt):.6f}")
    
    # print("\nCMB power spectrum comparison completed successfully!")

if __name__ == "__main__":
    main()